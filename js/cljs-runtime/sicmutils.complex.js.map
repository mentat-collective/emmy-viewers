{"version":3,"sources":["sicmutils/complex.cljc"],"mappings":"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","names":["sicmutils.complex/ZERO","sicmutils.complex.goog$module$goog$object.get","js/module$node_modules$complex_DOT_js$complex","sicmutils.complex/ONE","sicmutils.complex/I","sicmutils.complex/-I","sicmutils.complex/complextype","cljs.core.derive","var_args","G__95613","sicmutils.complex/complex","js/Error","re","sicmutils.util/double","im","sicmutils.complex/complex?","a","sicmutils.complex/real","sicmutils.complex/imaginary","sicmutils.complex/parse-complex","x","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/vector?","vec__95622","cljs.core.nth","sicmutils.util/illegal","cljs.core/PROTOCOL_SENTINEL","this","other","sicmutils.value/real?","and__4251__auto__","sicmutils.value/=","writer","_","cljs.core.write_all","c","sicmutils.value/one?","sicmutils.value/zero?","sicmutils.value/exact?","sicmutils.complex/round","z","sicmutils.complex.complex","Math/round","sicmutils.value/native-integral?","sicmutils.complex/gaussian-integer?","sicmutils.value/almost-integral?","sicmutils.complex/abs-real","sicmutils.generic/negate","Math/abs","sicmutils.complex/gcd","l","r","vec__95640","sicmutils.generic/magnitude","b","sicmutils.generic/sub","sicmutils.generic/mul","sicmutils.generic/div","sicmutils.generic/gcd","sicmutils.generic/make-rectangular","sicmutils.generic/make-polar","radius","angle","js/Number","sicmutils.generic/real-part","sicmutils.generic/imag-part","sicmutils.generic/angle","sicmutils.generic/conjugate","sicmutils.generic/dot-product","n","sicmutils.generic/add","sicmutils.generic/expt","choices","cljs.core._EQ_","G__95665","cljs.core/mod","sicmutils.generic/square","sicmutils.generic/cube","sicmutils.generic/abs","sicmutils.generic/exp","sicmutils.generic/log","sicmutils.generic/sqrt","sicmutils.generic/sin","sicmutils.generic/cos","sicmutils.generic/tan","sicmutils.generic/asin","sicmutils.generic/acos","sicmutils.generic/atan","sicmutils.generic/cosh","sicmutils.generic/sinh","sicmutils.generic/tanh","sicmutils.generic/integer-part","sicmutils.generic/fractional-part","sicmutils.generic/negative?","sicmutils.generic/infinite?","or__4253__auto__","sicmutils.generic/cot","sicmutils.generic/sec","sicmutils.generic/csc","sicmutils.generic/sech","sicmutils.generic/csch","sicmutils.generic/acosh","sicmutils.generic/asinh","sicmutils.generic/atanh","sicmutils.generic/floor","sicmutils.generic/ceiling","sicmutils.generic/invert"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.complex\n  \"This namespace provides a number of functions and constructors for working\n  with [[Complex]] numbers in Clojure and Clojurescript, and\n  installs [[Complex]] into the SICMUtils generic arithmetic system.\n\n  For other numeric extensions, see [[sicmutils.ratio]]\n  and [[sicmutils.numbers]].\"\n  (:require [sicmutils.generic :as g]\n            [sicmutils.util :as u]\n            [sicmutils.value :as v]\n            #?(:cljs [goog.object :as obj])\n            #?(:cljs [\"complex.js\" :as Complex]))\n  #?(:clj\n     (:import (org.apache.commons.math3.complex Complex ComplexFormat))))\n\n(def ^{:doc \"A [[Complex]] value equal to 0 (south pole on the Riemann Sphere).\"}\n  ZERO\n  #?(:clj Complex/ZERO\n     :cljs (obj/get Complex \"ZERO\")))\n\n(def ^{:doc \"A [[Complex]] value equal to 1.\"}\n  ONE #?(:clj Complex/ONE\n         :cljs (obj/get Complex \"ONE\")))\n\n(def ^{:doc \"A [[Complex]] value equal to `i`.\"}\n  I\n  #?(:clj Complex/I\n     :cljs (obj/get Complex \"I\")))\n\n;; NOTE that on the JVM this obnoxiously negates the (zero-valued) real\n;; component too. So `(complex 0 -1)` does not equal `-I`... but `(complex -0.0\n;; -1.0)` does. Once we get a native complex implementation in this issue will\n;; disappear.\n(def ^{:doc \"A [[Complex]] value equal to `-i`.\"}\n  -I\n  #?(:clj (.negate Complex/I)\n     :cljs (.neg ^js (obj/get Complex \"I\"))))\n\n(def ^:no-doc complextype Complex)\n\n(derive ::complex ::v/number)\n\n#?(:clj\n   (def complex-format (ComplexFormat.)))\n\n(defn complex\n  \"Returns a [[Complex]] number with the supplied real part `re` and imaginary\n  part `im`. `im` defaults to 0.\"\n  ([re]\n   #?(:clj (if (string? re)\n             (.parse ^ComplexFormat complex-format re)\n             (Complex. (u/double re)))\n      :cljs (Complex.\n             (if (string? re)\n               re\n               (u/double re)))))\n  ([re im]\n   (Complex. (u/double re)\n             (u/double im))))\n\n(defn complex?\n  \"Returns true if `a` is an instance of [[Complex]], false otherwise.\"\n  [a]\n  (instance? Complex a))\n\n(defn ^:no-doc real [^Complex a]\n  #?(:clj (.getReal a)\n     :cljs (obj/get a \"re\")))\n\n(defn ^:no-doc imaginary [^Complex a]\n  #?(:clj (.getImaginary a)\n     :cljs (obj/get a \"im\")))\n\n(defn ^:no-doc parse-complex\n  \"Parser that converts a string, vector or numeric representation of a complex\n   number, like\n\n  - `1 + 3i`\n  - [1 3]\n  - 1\n\n  into a [[Complex]] number object in clj or cljs.\"\n  [x]\n  (cond (string? x)\n        #?(:clj\n           (let [v (.parse ^ComplexFormat complex-format x)]\n             `(complex ~(real v) ~(imaginary v)))\n           :cljs `(complex ~x))\n\n        (vector? x)\n        (let [[re im] x]\n          (if (nil? im)\n            `(complex ~re)\n            `(complex ~re ~im)))\n\n        (number? x) `(complex ~x)\n\n        :else (u/illegal\n               (str\n                \"#sicm/complex takes a string, 2-vector or a number. Received: \"\n                x))))\n\n;; ## Type Extensions\n\n#?(:cljs\n   (extend-type Complex\n     IEquiv\n     (-equiv [this other]\n       (cond (complex? other)\n             (.equals ^js this other)\n\n             (v/real? other)\n             (and (zero? (imaginary this))\n                  (v/= (real this) other))\n\n             ;; Defer to `v/=` to support quaternion, octonion equality etc.\n             :else (v/= this other)))\n\n     IPrintWithWriter\n     (-pr-writer [x writer _]\n       (write-all\n        writer\n        \"#sicm/complex \"\n        (str [(obj/get x \"re\")\n              (obj/get x \"im\")])))))\n\n#?(:clj\n   (defmethod print-method Complex [^Complex v ^java.io.Writer w]\n     (.write w (str \"#sicm/complex \"\n                    [(.getReal v)\n                     (.getImaginary v)]))))\n\n(extend-type Complex\n  v/Numerical\n  (numerical? [_] true)\n\n  v/Value\n  (zero? [c]\n    #?(:clj (and (zero? (real c))\n                 (zero? (imaginary c)))\n       :cljs (.isZero ^js c)))\n\n  (one? [c]\n    (and (v/one? (real c))\n         (zero? (imaginary c))))\n  (identity? [c] (v/one? c))\n  (zero-like [_] ZERO)\n  (one-like [_] ONE)\n  (identity-like [_] ONE)\n  (freeze [c] (let [re (real c)\n                    im (imaginary c)]\n                (if (v/zero? im)\n                  re\n                  (list 'complex re im))))\n  (exact? [c] (and (v/exact? (real c))\n                   (v/exact? (imaginary c))))\n  (kind [_] ::complex))\n\n;; ## Gaussian Integers\n\n(defn round\n  \"Generates a [Gaussian integer](https://en.wikipedia.org/wiki/Gaussian_integer)\n  from the complex number `z` by rounding the real and imaginary components of\n  `z` to their nearest integral values.\"\n  [z]\n  (cond (complex? z)\n        (complex\n         (Math/round ^Float (real z))\n         (Math/round ^Float (imaginary z)))\n        (v/native-integral? z) z\n        :else (Math/round (double z))))\n\n(defn gaussian-integer?\n  \"Returns true if `z` is a [Gaussian\n  integer](https://en.wikipedia.org/wiki/Gaussian_integer), ie, a complex entry\n  with integral real and imaginary components.\n\n  [[gaussian-integer?]] will return true if the real and imaginary components\n  are within `epsilon` of integral values. See [[value/almost-integral?]] for\n  details.\"\n  [z]\n  (if (complex? z)\n    (and (v/almost-integral? (real z))\n         (v/almost-integral? (imaginary z)))\n    (and (v/real? z)\n         (v/almost-integral? z))))\n\n;; ## Complex GCD\n\n(defn ^:no-doc abs-real\n  \"Returns a complex or real number with a positive real component. (ie, either z\n  or (* -1 z)), whichever number has a positive real component.\"\n  [z]\n  (cond (complex? z)\n        (if (neg? (real z))\n          (g/negate z)\n          z)\n\n        (v/real? z)\n        (Math/abs ^double (u/double z))\n\n        :else (u/illegal \"not supported!\")))\n\n(defn ^:no-doc gcd\n  \"Returns the complex gcd of two complex numbers using the euclidean algorithm.\n\n  For more details on the algorithm, see [this post on Ask Dr\n  Math](https://web.archive.org/web/20190720160400/http://mathforum.org/library/drmath/view/67068.html).\n\n  NOTE that the GCD of two complex numbers is determined up to a factor of \u00b11\n  and \u00b1i.\"\n  [l r]\n  (cond (v/zero? l) r\n        (v/zero? r) l\n        (v/= l r)   (abs-real l)\n        (not (or (gaussian-integer? l)\n                 (gaussian-integer? r)))\n        (u/illegal \"gcd can only be computed for gaussian integers, but\n        both arguments were not.\")\n\n        (not (gaussian-integer? l))\n        (u/illegal \"gcd can only be computed for gaussian integers, but first\n        argument was not.\")\n\n        (not (gaussian-integer? r))\n        (u/illegal \"gcd can only be computed for gaussian integers, but second\n        argument was not.\")\n\n        :else (let [[l r] (if (< (g/magnitude l)\n                                 (g/magnitude r))\n                            [l r] [r l])]\n                (loop [a (round l)\n                       b (round r)]\n                  (if (v/zero? b)\n                    (abs-real a)\n                    (recur b (g/sub a (g/mul (round (g/div a b)) b))))))))\n\n;; ## Generic Method Installation\n\n(defmethod g/gcd [::complex ::complex] [a b] (gcd a b))\n(defmethod g/gcd [::complex ::v/real] [a b] (gcd a b))\n(defmethod g/gcd [::v/real ::complex] [a b] (gcd a b))\n\n(defmethod g/make-rectangular [::v/real ::v/real] [re im]\n  (if (v/zero? im)\n    re\n    (complex re im)))\n\n(defmethod g/make-polar [::v/real ::v/real] [radius angle]\n  (cond (v/zero? radius) radius\n        (v/zero? angle)  radius\n        :else\n        #?(:cljs (Complex. #js {:abs (js/Number radius)\n                                :arg (js/Number angle)})\n           :clj (let [angle (u/double angle)]\n                  (Complex. (* radius (Math/cos angle))\n                            (* radius (Math/sin angle)))))))\n\n(defmethod g/real-part [::complex] [a] (real a))\n(defmethod g/imag-part [::complex] [a] (imaginary a))\n\n(defmethod g/magnitude [::complex] [a]\n  #?(:clj (.abs ^Complex a)\n     :cljs (.abs ^js a)))\n\n(defmethod g/angle [::complex] [a]\n  #?(:clj (.getArgument ^Complex a)\n     :cljs (.arg ^js a)))\n\n(defmethod g/conjugate [::complex] [a]\n  #?(:clj (.conjugate ^Complex a)\n     :cljs (.conjugate ^js a)))\n\n(defmethod g/dot-product [::complex ::complex] [a b]\n  (+ (* (real a) (real b))\n     (* (imaginary a) (imaginary b))))\n(defmethod g/dot-product [::complex ::v/real] [a b] (* (real a) b))\n(defmethod g/dot-product [::v/real ::complex] [a b] (* a (real b)))\n\n(defmethod v/= [::complex ::complex] [a b]\n  #?(:clj (.equals ^Complex a ^Complex b)\n     :cljs (.equals ^js a b)))\n\n(defmethod v/= [::complex ::v/real] [^Complex a n]\n  (and (zero? (imaginary a))\n       (v/= (real a) n)))\n\n(defmethod v/= [::v/real ::complex] [n ^Complex a]\n  (and (zero? (imaginary a))\n       (v/= n (real a))))\n\n(defmethod g/add [::complex ::complex] [a b]\n  #?(:clj (.add ^Complex a ^Complex b)\n     :cljs (.add ^js a b)))\n\n(defmethod g/add [::complex ::v/real] [a n]\n  #?(:clj (.add ^Complex a ^double (u/double n))\n     :cljs (.add ^js a (u/double n))))\n\n(defmethod g/add [::v/real ::complex] [n a]\n  #?(:clj (.add ^Complex a ^double (u/double n))\n     :cljs (.add ^js a (u/double n))))\n\n(defmethod g/expt [::complex ::complex] [a b]\n  #?(:clj (.pow ^Complex a ^Complex b)\n     :cljs (.pow ^js a b)))\n\n(let [choices [1 I -1 -I]]\n  (defmethod g/expt [::complex ::v/real] [a n]\n    (if (= a I)\n      (choices (mod n 4))\n      #?(:clj (.pow ^Complex a ^double (u/double n))\n         :cljs (.pow ^js a ^double (u/double n))))))\n\n(defmethod g/expt [::v/real ::complex] [n a]\n  #?(:clj (.pow ^Complex (complex n) ^Complex a)\n     :cljs (.pow ^js (complex n) a)))\n\n;; Take advantage of the `expt` optimizations above for `I`.\n(defmethod g/square [::complex] [z] (g/expt z 2))\n(defmethod g/cube [::complex] [z] (g/expt z 3))\n\n(defmethod g/abs [::complex] [a]\n  #?(:clj (.abs ^Complex a)\n     :cljs (.abs ^js a)))\n\n(defmethod g/exp [::complex] [a]\n  #?(:clj (.exp ^Complex a)\n     :cljs (.exp ^js a)))\n\n(defmethod g/log [::complex] [a]\n  #?(:clj (.log ^Complex a)\n     :cljs (.log ^js a)))\n\n(defmethod g/sqrt [::complex] [a]\n  #?(:clj (.sqrt ^Complex a)\n     :cljs (.sqrt ^js a)))\n\n(defmethod g/sin [::complex] [a]\n  #?(:clj (.sin ^Complex a)\n     :cljs (.sin ^js a)))\n\n(defmethod g/cos [::complex] [a]\n  #?(:clj (.cos ^Complex a)\n     :cljs (.cos ^js a)))\n\n(defmethod g/tan [::complex] [a]\n  #?(:clj (.tan ^Complex a)\n     :cljs (.tan ^js a)))\n\n(defmethod g/asin [::complex] [a]\n  #?(:clj (.asin ^Complex a)\n     :cljs (.asin ^js a)))\n\n(defmethod g/acos [::complex] [a]\n  #?(:clj (.acos ^Complex a)\n     :cljs (.acos ^js a)))\n\n(defmethod g/atan [::complex] [a]\n  #?(:clj (.atan ^Complex a)\n     :cljs (.atan ^js a)))\n\n(defmethod g/cosh [::complex] [a]\n  #?(:clj (.cosh ^Complex a)\n     :cljs (.cosh ^js a)))\n\n(defmethod g/sinh [::complex] [a]\n  #?(:clj (.sinh ^Complex a)\n     :cljs (.sinh ^js a)))\n\n(defmethod g/tanh [::complex] [a]\n  #?(:clj (.tanh ^Complex a)\n     :cljs (.tanh ^js a)))\n\n(defmethod g/integer-part [::complex] [a]\n  (let [re (g/integer-part (real a))\n        im (g/integer-part (imaginary a))]\n    (if (v/zero? im)\n      re\n      (complex re im))))\n\n(defmethod g/fractional-part [::complex] [a]\n  (let [re (g/fractional-part (real a))\n        im (g/fractional-part (imaginary a))]\n    (if (v/zero? im)\n      re\n      (complex re im))))\n\n(defmethod g/negative? [::complex] [a]\n  (and (v/zero? (imaginary a))\n       (g/negative? (real a))))\n\n(defmethod g/infinite? [::complex] [a]\n  (or (g/infinite? (real a))\n      (g/infinite? (imaginary a))))\n\n#?(:cljs\n   ;; These are all defined explicitly in Complex.js.\n   (do\n     (defmethod g/cot [::complex] [a] (.cot ^js a))\n     (defmethod g/sec [::complex] [a] (.sec ^js a))\n     (defmethod g/csc [::complex] [a] (.csc ^js a))\n     (defmethod g/tanh [::complex] [a] (.tanh ^js a))\n     (defmethod g/sech [::complex] [a] (.sech ^js a))\n     (defmethod g/csch [::complex] [a] (.csch ^js a))\n     (defmethod g/acosh [::complex] [a] (.acosh ^js a))\n     (defmethod g/asinh [::complex] [a] (.asinh ^js a))\n     (defmethod g/atanh [::complex] [a] (.atanh ^js a))))\n\n;;The remaining methods have different names in the Clojure vs JS\n;;implementations.\n#?(:clj\n   (do\n     (defmethod g/floor [::complex] [^Complex a]\n       (let [re (g/floor (.getReal a))\n             im (g/floor (.getImaginary a))]\n         (if (v/zero? im)\n           re\n           (complex re im))))\n\n     (defmethod g/ceiling [::complex] [^Complex a]\n       (let [re (g/ceiling (.getReal a))\n             im (g/ceiling (.getImaginary a))]\n         (if (v/zero? im)\n           re\n           (complex re im))))\n\n     (defmethod g/sub [::complex ::complex] [^Complex a ^Complex b] (.subtract a b))\n     (defmethod g/sub [::complex ::v/real] [^Complex a n] (.subtract a (double n)))\n     (defmethod g/sub [::v/real ::complex] [n ^Complex a] (.add (.negate a) (double n)))\n\n     (defmethod g/mul [::complex ::complex] [^Complex a ^Complex b] (.multiply a b))\n     (defmethod g/mul [::complex ::v/real] [^Complex a n] (.multiply a (double n)))\n     (defmethod g/mul [::v/real ::complex] [n ^Complex a] (.multiply a (double n)))\n\n     (defmethod g/div [::complex ::complex] [^Complex a ^Complex b] (.divide a b))\n     (defmethod g/div [::complex ::v/real] [^Complex a n] (.divide a (double n)))\n     (defmethod g/div [::v/real ::complex] [n ^Complex a] (.multiply (.reciprocal a) (double n)))\n\n     (defmethod g/negate [::complex] [^Complex a] (.negate a))\n     (defmethod g/invert [::complex] [^Complex a] (.reciprocal a)))\n\n   :cljs\n   (do\n     (defmethod g/floor [::complex] [a] (.floor ^js a))\n     (defmethod g/ceiling [::complex] [a] (.ceil ^js a))\n     (defmethod g/sub [::complex ::complex] [a b] (.sub ^js a b))\n     (defmethod g/sub [::complex ::v/real] [a n] (.sub ^js a (u/double n)))\n     (defmethod g/sub [::v/real ::complex] [n a] (.add ^js (.neg ^js a) (u/double n)))\n\n     (defmethod g/mul [::complex ::complex] [a b] (.mul ^js a b))\n     (defmethod g/mul [::complex ::v/real] [a n] (.mul ^js a (u/double n)))\n     (defmethod g/mul [::v/real ::complex] [n a] (.mul ^js a (u/double n)))\n\n     (defmethod g/div [::complex ::complex] [a b] (.div ^js a b))\n     (defmethod g/div [::complex ::v/real] [a n] (.div ^js a (u/double n)))\n     (defmethod g/div [::v/real ::complex] [n a]\n       (.mul ^js (.inverse ^js a) (u/double n)))\n\n     (defmethod g/negate [::complex] [a] (.neg ^js a))\n     (defmethod g/invert [::complex] [a] (.inverse ^js a))))\n"]}