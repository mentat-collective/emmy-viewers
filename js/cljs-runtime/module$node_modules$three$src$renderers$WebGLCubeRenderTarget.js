shadow$provide.module$node_modules$three$src$renderers$WebGLCubeRenderTarget=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLCubeRenderTarget=void 0;var _constants=require("module$node_modules$three$src$constants"),_Mesh=require("module$node_modules$three$src$objects$Mesh"),_BoxGeometry=require("module$node_modules$three$src$geometries$BoxGeometry"),_ShaderMaterial=require("module$node_modules$three$src$materials$ShaderMaterial"),_UniformsUtils=
require("module$node_modules$three$src$renderers$shaders$UniformsUtils");global=require("module$node_modules$three$src$renderers$WebGLRenderTarget");var _CubeCamera=require("module$node_modules$three$src$cameras$CubeCamera"),_CubeTexture=require("module$node_modules$three$src$textures$CubeTexture");class WebGLCubeRenderTarget extends global.WebGLRenderTarget{constructor(size,options,dummy){Number.isInteger(options)&&(console.warn("THREE.WebGLCubeRenderTarget: constructor signature is now WebGLCubeRenderTarget( size, options )"),
options=dummy);super(size,size,options);options=options||{};this.texture=new _CubeTexture.CubeTexture(void 0,options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=!0;this.texture.generateMipmaps=void 0!==options.generateMipmaps?options.generateMipmaps:!1;this.texture.minFilter=void 0!==options.minFilter?options.minFilter:_constants.LinearFilter}fromEquirectangularTexture(renderer,
texture){this.texture.type=texture.type;this.texture.format=_constants.RGBAFormat;this.texture.encoding=texture.encoding;this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;var geometry=new _BoxGeometry.BoxGeometry(5,5,5),material=new _ShaderMaterial.ShaderMaterial({name:"CubemapFromEquirect",uniforms:(0,_UniformsUtils.cloneUniforms)({tEquirect:{value:null}}),vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection \x3d transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include \x3cbegin_vertex\x3e\n\t\t\t\t\t#include \x3cproject_vertex\x3e\n\n\t\t\t\t}\n\t\t\t",
fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include \x3ccommon\x3e\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction \x3d normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV \x3d equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor \x3d texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",side:_constants.BackSide,blending:_constants.NoBlending});material.uniforms.tEquirect.value=texture;geometry=new _Mesh.Mesh(geometry,material);
material=texture.minFilter;texture.minFilter===_constants.LinearMipmapLinearFilter&&(texture.minFilter=_constants.LinearFilter);(new _CubeCamera.CubeCamera(1,10,this)).update(renderer,geometry);texture.minFilter=material;geometry.geometry.dispose();geometry.material.dispose();return this}clear(renderer,color,depth,stencil){const currentRenderTarget=renderer.getRenderTarget();for(let i=0;6>i;i++)renderer.setRenderTarget(this,i),renderer.clear(color,depth,stencil);renderer.setRenderTarget(currentRenderTarget)}}
exports.WebGLCubeRenderTarget=WebGLCubeRenderTarget;WebGLCubeRenderTarget.prototype.isWebGLCubeRenderTarget=!0}
//# sourceMappingURL=module$node_modules$three$src$renderers$WebGLCubeRenderTarget.js.map
