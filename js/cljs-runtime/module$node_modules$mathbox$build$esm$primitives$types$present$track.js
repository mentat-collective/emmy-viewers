shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$present$track=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Track=void 0;var Ease=
function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,
key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$mathbox$build$esm$util$ease"));global=require("module$node_modules$mathbox$build$esm$primitives$primitive");const deepCopy=function(x){const out={};for(const k in x){const v=x[k];out[k]=v instanceof Array?v.slice():null!=v&&"object"===typeof v?deepCopy(v):v}return out};class Track extends global.Primitive{static initClass(){this.traits=
["node","track","seek","bind"]}init(){this.handlers={};this.values=this.script=null;this.playhead=0;return this.expr=this.section=this.velocity=null}make(){let ref;this._helpers.bind.make([{to:"track.target",trait:"node",callback:null}]);const {script}=this.props,{node}=this.bind.target;this.targetNode=node;return[this.script,this.values,this.start,this.end]=Array.from(ref=this._process(node,script)),ref}unmake(){this.unbindExpr();this._helpers.bind.unmake();this.script=this.values=this.start=this.end=
this.section=this.expr=null;return this.playhead=0}bindExpr(expr){this.unbindExpr();this.expr=expr;this.targetNode.bind(expr,!0);const {clock}=this.targetNode,self=this;return this._attributes.bind(this.measure=function(){let playhead=null;return()=>{const {step}=clock.getTime();null!=playhead&&(self.velocity=(self.playhead-playhead)/step);return playhead=self.playhead}}())}unbindExpr(){null!=this.expr&&this.targetNode.unbind(this.expr,!0);null!=this.measure&&this._attributes.unbind(this.measure);
return this.expr=this.measure=null}_process(object,script){let k;let step;if(script instanceof Array){var s={};for(var i=0;i<script.length;i++)step=script[i],s[i]=step;script=s}s=[];for(key in script)step=script[key],null==step&&(step=[]),step instanceof Array?step={key:+key,props:null!=step[0]?deepCopy(step[0]):{},bind:null!=step[1]?deepCopy(step[1]):{}}:(step=null!=step.key||step.props||step.bind?deepCopy(step):{props:deepCopy(step)},step.key=null!=step.key?+step.key:+key,null==step.props&&(step.props=
{}),null==step.bind&&(step.bind={})),s.push(step);script=s;if(!script.length)return[[],{},0,0];script.sort((a,b)=>a.key-b.key);i=script[0].key;const end=script[script.length-1].key;for(key in script){step=script[key];null!=last&&(last.next=step);var last=step}last.next=last;script=s;s={};const values={};for(key in script)for(k in step=script[key],step.props)last=step.props[k],s[k]=!0;for(key in script)for(k in step=script[key],step.bind)last=step.bind[k],s[k]=!0;for(k in s)s[k]=object.get(k);try{for(k in s)values[k]=
[object.attribute(k).T.make(),object.attribute(k).T.make(),object.attribute(k).T.make()]}catch(error){throw console.warn(this.node.toMarkup()),object=`${this.node.toString()} - Target ${object} has no \`${k}\` property`,Error(object);}var key=[];for(step of Array.from(script)){for(k in s)if(last=s[k],last=object.validate(k,null!=step.props[k]?step.props[k]:last),s[k]=step.props[k]=last,null!=step.bind[k]&&"function"!==typeof step.bind[k])throw console.warn(this.node.toMarkup()),object=`${this.node.toString()} - Bind expression \`${step.bind[k]}\` on property \`${k}\` is not a function`,
Error(object);key.push(step)}return[key,values,i,end]}update(){let {playhead}=this;const {script}=this,{ease,seek}=this.props,node=this.targetNode;null!=seek&&(playhead=seek);if(script.length){let k;var find=function(){let last=script[0];for(let i=0;i<script.length;i++){const step=script[i];if(step.key>playhead)break;last=step}return last},{section}=this;if(!section||playhead<section.key||playhead>section.next.key)section=find(script,playhead);if(section!==this.section){var from=this.section=section,
to=section.next,start=from.key,end=to.key,easeMethod=(()=>{switch(ease){case "linear":case 0:return Ease.clamp;case "cosine":case 1:return Ease.cosine;case "binary":case 2:return Ease.binary;case "hold":case 3:return Ease.hold;default:return Ease.cosine}})(),{clock}=node,getPlayhead=time=>{if(null==this.velocity)return this.playhead;const now=clock.getTime();return this.playhead+this.velocity*(time-now.time)},getLerpFactor=function(){const scale=1/Math.max(1E-4,end-start);return time=>easeMethod((getPlayhead(time)-
start)*scale,0,1)}();find=key=>{const fromE=from.bind[key],toE=to.bind[key],fromP=from.props[key],toP=to.props[key],invalid=function(){console.warn(node.toMarkup());throw Error(`${this.node.toString()} - Invalid expression result on track \`${key}\``);},attr=node.attribute(key),values$jscomp$0=this.values[key],animator=this._animator;return fromE&&toE?((values,_from$jscomp$0,_to)=>function(time,delta){let _from;values[0]=_from=attr.T.validate(fromE(time,delta),values[0],invalid);values[1]=delta=attr.T.validate(toE(time,
delta),values[1],invalid);return values[2]=animator.lerp(attr.T,_from,delta,getLerpFactor(time),values[2])})(values$jscomp$0,from,to):fromE?((values,_from,_to)=>function(time,delta){values[0]=delta=attr.T.validate(fromE(time,delta),values[0],invalid);return values[1]=animator.lerp(attr.T,delta,toP,getLerpFactor(time),values[1])})(values$jscomp$0,from,to):toE?((values,_from,_to)=>function(time,delta){values[0]=delta=attr.T.validate(toE(time,delta),values[0],invalid);return values[1]=animator.lerp(attr.T,
fromP,delta,getLerpFactor(time),values[1])})(values$jscomp$0,from,to):((values,_from,_to)=>(time,_delta)=>values[0]=animator.lerp(attr.T,fromP,toP,getLerpFactor(time),values[0]))(values$jscomp$0,from,to)};section={};for(k in from.bind)null==section[k]&&(section[k]=find(k));for(k in to.bind)null==section[k]&&(section[k]=find(k));for(k in from.props)null==section[k]&&(section[k]=find(k));for(k in to.props)null==section[k]&&(section[k]=find(k));return this.bindExpr(section)}}}change(changed,touched,
init){if(changed["track.target"]||changed["track.script"]||changed["track.mode"])return this.rebuild();if(changed["seek.seek"]||init)return this.update()}}exports.Track=Track;Track.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$present$track.js.map
