{
"version":3,
"file":"module$node_modules$mdurl$parse.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/mdurl/parse.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$mdurl$parse\"] = function(global,require,module,exports) {\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n//\n// Changes from joyent/node:\n//\n// 1. No leading slash in paths,\n//    e.g. in `url.parse('http://foo?bar')` pathname is ``, not `/`\n//\n// 2. Backslashes are not replaced with slashes,\n//    so `http:\\\\example.org\\` is treated like a relative path\n//\n// 3. Trailing colon is treated like a part of the path,\n//    i.e. in `http://example.org:foo` pathname is `:foo`\n//\n// 4. Nothing is URL-encoded in the resulting object,\n//    (in joyent/node some chars in auth and paths are encoded)\n//\n// 5. `url.parse()` does not have `parseQueryString` argument\n//\n// 6. Removed extraneous result properties: `host`, `path`, `query`, etc.,\n//    which can be constructed using other parts of the url.\n//\n\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.pathname = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = [ '<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t' ],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = [ '{', '}', '|', '\\\\', '^', '`' ].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = [ '\\'' ].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = [ '%', '/', '?', ';', '#' ].concat(autoEscape),\n    hostEndingChars = [ '/', '?', '#' ],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    /* eslint-disable no-script-url */\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    };\n    /* eslint-enable no-script-url */\n\nfunction urlParse(url, slashesDenoteHost) {\n  if (url && url instanceof Url) { return url; }\n\n  var u = new Url();\n  u.parse(url, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, slashesDenoteHost) {\n  var i, l, lowerProto, hec, slashes,\n      rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    lowerProto = proto.toLowerCase();\n    this.protocol = proto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (i = 0; i < hostEndingChars.length; i++) {\n      hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = auth;\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (i = 0; i < nonHostChars.length; i++) {\n      hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {\n        hostEnd = hec;\n      }\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1) {\n      hostEnd = rest.length;\n    }\n\n    if (rest[hostEnd - 1] === ':') { hostEnd--; }\n    var host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost(host);\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) { continue; }\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    }\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n    }\n  }\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    rest = rest.slice(0, qm);\n  }\n  if (rest) { this.pathname = rest; }\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '';\n  }\n\n  return this;\n};\n\nUrl.prototype.parseHost = function(host) {\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) { this.hostname = host; }\n};\n\nmodule.exports = urlParse;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Url","pathname","search","hash","hostname","port","auth","slashes","protocol","protocolPattern","portPattern","simplePathPattern","unwise","concat","delims","autoEscape","nonHostChars","hostEndingChars","hostnamePartPattern","hostnamePartStart","hostlessProtocol","slashedProtocol","prototype","parse","Url.prototype.parse","url","slashesDenoteHost","l","rest","trim","split","length","simplePath","exec","proto","lowerProto","toLowerCase","substr","match","hostEnd","i","hec","indexOf","atSign","lastIndexOf","slice","host","parseHost","ipv6Hostname","hostparts","part","newpart","j","k","charCodeAt","validParts","notHost","bit","push","unshift","join","hostnameMaxLen","qm","Url.prototype.parseHost","urlParse","u"]
}
