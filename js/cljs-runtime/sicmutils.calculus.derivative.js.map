{"version":3,"sources":["sicmutils/calculus/derivative.cljc"],"mappings":"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","names":["sicmutils.calculus.derivative/extract-tangent-fn","f","tag","args","sicmutils.differential/tag-active?","fresh","sicmutils.differential/fresh-tag","sicmutils.differential/with-active-tag","p1__87243#","cljs.core.map","sicmutils.differential/replace-tag","sicmutils.differential/extract-tangent","sicmutils.function$.with_arity","sicmutils.function/arity","sicmutils.calculus.derivative/replace-tag-fn","old","new","p1__87248#","cljs.core.apply","sicmutils.differential/IPerturbed","sicmutils.differential/perturbed?","cljs.core/PROTOCOL_SENTINEL","_","cljs.core/MetaFn","cljs.core/MultiFn","sicmutils.calculus.derivative/derivative","x","lifted","sicmutils.differential.bundle_element","var_args","G__87298","sicmutils.calculus.derivative/deep-partial","js/Error","structure","path","entry","cljs.core.get_in","sicmutils.calculus.derivative.deep_partial","sicmutils.value/numerical?","G__87303","cljs.core/assoc-in","f-entry","sicmutils.util/illegal","G__87306","sicmutils.calculus.derivative/jacobian","input","sicmutils.calculus.derivative.jacobian","selectors","cljs.core/empty?","cljs.core.into","temp__5751__auto__","piece","frame","sicmutils.structure/transpose","sicmutils.structure/map-chain","prefixed","G__87309","sicmutils.calculus.derivative/euclidean","sicmutils.calculus.derivative.euclidean","cljs.core/vec","sicmutils.structure/structure?","G__87342","sicmutils.calculus.derivative/multivariate","sicmutils.calculus.derivative.multivariate","p1__87317#","d","df","df*","cljs.core/constantly","more","sicmutils.matrix/seq->","cljs.core/cons","seq__87350","cljs.core/seq","chunk__87351","count__87352","i__87353","temp__5753__auto__","cljs.core/chunked-seq?","c__4679__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","t","sicmutils.generic/partial-derivative","sicmutils.value/seqtype","sicmutils.calculus.derivative/D","p1__87360#","sicmutils.operator.make_operator","sicmutils.generic/derivative-symbol","sicmutils.calculus.derivative/D-as-matrix","F","s","sicmutils.matrix.s__GT_m","sicmutils.structure/compatible-shape","fexpr__87362","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.calculus.derivative/partial","seq87364","self__4852__auto__","p1__87363#","cljs.core.sequence","cljs.core.concat","cljs.core/List","G__87370","sicmutils.calculus.derivative/taylor-series","args-arr__4885__auto__","argseq__4886__auto__","seq87368","G__87369","self__4851__auto__","sicmutils.calculus.derivative.taylor_series","xs","sicmutils.series/->function","fexpr__87379","sicmutils.generic/exp","G__87383","sicmutils.calculus.derivative/symbolic-taylor-series","seq87381","G__87382","sicmutils.calculus.derivative.symbolic_taylor_series","syms","sicmutils.structure/typical-object","replace-m","cljs.core/zipmap","cljs.core/flatten","series","term","sicmutils.generic/simplify","sicmutils.structure.mapr","sicmutils.differential/differential?","sicmutils.differential/map-coefficients","rec","sicmutils.expression.substitute","sicmutils.series/fmap","process-term"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.calculus.derivative\n  \"This namespace implements a number of differential operators like [[D]], and\n  the machinery to apply [[D]] to various structures.\"\n  (:refer-clojure :exclude [partial])\n  (:require [sicmutils.differential :as d]\n            [sicmutils.expression :as x]\n            [sicmutils.function :as f]\n            [sicmutils.generic :as g]\n            [sicmutils.matrix :as matrix]\n            [sicmutils.operator :as o]\n            [sicmutils.series :as series]\n            [sicmutils.structure :as s]\n            [sicmutils.util :as u]\n            [sicmutils.value :as v])\n  #?(:clj\n     (:import (clojure.lang Fn MultiFn))))\n\n;; ## IPerturbed Implementation for Functions\n;;\n;; The following section, along with [[sicmutils.collection]]\n;; and [[sicmutils.differential]], rounds out the implementations\n;; of [[d/IPerturbed]] for native Clojure(script) data types. The function\n;; implementation is subtle, as described by [Manzyuk et al.\n;; 2019](https://arxiv.org/pdf/1211.4892.pdf).\n;; ([[sicmutils.derivative.calculus-test]], in the \"Amazing Bug\" sections,\n;; describes the pitfalls at length.)\n;;\n;; [[sicmutils.differential]] describes how each in-progress perturbed variable\n;; in a derivative is assigned a \"tag\" that accumulates the variable's partial\n;; derivative.\n;;\n;; How do we interpret the case where `((D f) x)` produces a _function_?\n;;\n;; [Manzyuk et al. 2019](https://arxiv.org/pdf/1211.4892.pdf) extends `D` to\n;; functions `f` of type $\\mathbb{R}^n \\rightarrow \\alpha$, where\n;;\n;; $$\\alpha::=\\mathbb{R}^m \\mid \\alpha_{1} \\rightarrow \\alpha_{2}$$\n;;\n;; By viewing\n;;\n;; - `f` as a (maybe curried) multivariable function that _eventually_ must\n;;   produce an $\\mathbb{R}^m$\n;; - The derivative `(D f)` as the partial derivative with respect to the first\n;;   argument of `f`\n;;\n;; A 3-level nest of functions will respond to `D` just like the flattened,\n;; non-higher-order version would respond to `(partial 0)`. In other words,\n;; these two forms should evaluate to equivalent results:\n\n(comment\n  (let [f (fn [x]\n            (fn [y]\n              (fn [z]\n                (g/* x y z))))]\n    ((((D f) 'x) 'y) 'z))\n  ;;=> (* y z)\n  )\n\n(comment\n  (((partial 0) g/*) 'x 'y 'z)\n  ;;=> (* y z)\n  )\n\n;; To `extract-tangent` from a function, we need to compose the\n;; `extract-tangent` operation with the returned function.\n;;\n;; The returned function needs to capture an internal reference to the\n;; original [[d/Differential]] input. This is true for any Functor-shaped return\n;; value, like a structure or Map. However! There is a subtlety present with\n;; functions that's not present with vectors or other containers.\n;;\n;; The difference with functions is that they take _inputs_. If you contrive a\n;; situation where you can feed the original captured [[d/Differential]] into\n;; the returned function, this can trigger \"perturbation confusion\", where two\n;; different layers try to extract the tangent corresponding to the SAME tag,\n;; and one is left with nothing.\n;;\n;; If you engineer an\n;; example (see [[sicmutils.calculus.derivative-test/amazing-bug]]) where:\n;;\n;; - this function takes another function, which then receives the closed-over\n;;   `x` as an argument\n;; - you pass this function to itself, so the closed-over `x` instances can both\n;;   be multiplied\n;;\n;; Then your program isn't going to make any distinction between the instances\n;; of `x`. They're both references to the same value.\n;;\n;; HOWEVER! `((D f) x)` returns a function which, when you eventually provide\n;; all arguments, will return the sensitivity of `f` to the first argument `x`.\n;;\n;; If you perform the trick above, pass `((D f) x)` into itself, and the `x`\n;; instances meet (multiply, say) - should final return value treat them as the\n;; /same/ instance?\n;;\n;; Manzyuk et al. says _NO!_. If `((D f) x)` returns a function, that function\n;; closes over:\n;;\n;; - the value of `x`\n;; - an _intention_ to start the derivative-taking process on that isolated copy\n;;   of `x` once the final argument is supplied.\n;;\n;; How does the implementation keep the values separate?\n;;\n;; ### Tag Replacement\n;;\n;; The key to the solution lives in [[extract-tangent-fn]], called on the result\n;; of `((D f) x)` when `((D f) x)` produces a function. We have to armor the\n;; returned function so that:\n;;\n;; - it extracts the originally-injected tag when someone eventually calls the\n;;   function\n;; - if some caller passes a new [[d/Differential]] instance into the function,\n;;   any tags in that [[d/Differential]] will survive on their way back out...\n;;   even if they happen to contain the originally-injected tag.\n;;\n;; We do this by:\n;;\n;; - replacing any instance of the original `tag` in the returned function's\n;;   arguments with a temporary tag (let's call it `fresh`)\n;; - calling the function and extracting the tangent component associated with\n;;   `tag`, as requested (note now that the only instances of `tag` that can\n;;   appear in the result come from variables captured in the function's\n;;   closure)\n;; - remapping `fresh` back to `tag` inside the remaining [[d/Differential]]\n;;   instance.\n;;\n;; This last step ensures that any tangent tagged with `tag` in the input can\n;; make it back out without tangling with closure-captured `tag` instances that\n;; some higher level might want.\n\n(defn- extract-tangent-fn\n  \"Returns a new function that composes a 'tag extraction' step with `f`. The\n  returned fn will\n\n  - call the underlying `f`, producing `result`\n  - return `(extract-tangent result tag)`\n\n  If called within the scope of a function waiting for the same `tag`, the\n  returned function will remap any instance of `tag` that appears in any\n  differential argument passed to it to a private `fresh` tag, to prevent\n  internal perturbation confusion. Any tangent components in the final result\n  tagged with `fresh` will be remapped in the final result back to `tag`.\n\n  If called _outside_ of a function waiting for `tag` no tag remapping will\n  occur.\"\n  [f tag]\n  (-> (fn [& args]\n        (if (d/tag-active? tag)\n          (let [fresh (d/fresh-tag)]\n            (-> (d/with-active-tag tag f (map #(d/replace-tag % tag fresh) args))\n                (d/extract-tangent tag)\n                (d/replace-tag fresh tag)))\n          (-> (d/with-active-tag tag f args)\n              (d/extract-tangent tag))))\n      (f/with-arity (f/arity f))))\n\n;; NOTE: that the tag-remapping that the docstring for `extract-tag-fn`\n;; describes might _also_ have to apply to a functional argument!\n;;\n;; `replace-tag` on a function is meant to be a `replace-tag` call applied to\n;; the function's _output_. To prevent perturbation confusion inside the\n;; function, we perform a similar remapping of any occurrence of `tag` in the\n;; function's arguments.\n\n(defn- replace-tag-fn\n  \"Returns a new function that composes a 'tag replacement' step with `f`.\n\n  If called within the scope of a function waiting for the same `tag`, the\n  returned function will:\n\n  - make a fresh tag, and replace all `old` tags with `fresh` in the inputs\n  - call `f`, producing `result`\n  - return `(replace-tag result old new)`\n  - remap any tangent component in the result tagged with `fresh` back to `old`.\n\n  If called _outside_ of a function waiting for `tag`, the returned function\n  will apply `f` to its arguments and call `(replace-tag result old new)` with\n  no tag-rerouting.\"\n  [f old new]\n  (-> (fn [& args]\n        (if (d/tag-active? old)\n          (let [fresh (d/fresh-tag)\n                args  (map #(d/replace-tag % old fresh) args)]\n            (-> (apply f args)\n                (d/replace-tag old new)\n                (d/replace-tag fresh old)))\n          (-> (apply f args)\n              (d/replace-tag old new))))\n      (f/with-arity (f/arity f))))\n\n;; ## Protocol Implementation\n;;\n;; The implementation for functions handles functions, multimethods, and, in\n;; Clojurescript, [[MetaFn]] instances. Metadata in the original function is\n;; preserved through tag replacement and extraction.\n\n(extend-protocol d/IPerturbed\n  #?(:clj Fn :cljs function)\n  (perturbed? [#?(:cljs _ :clj f)]\n    #?(:clj (:perturbed? (meta f) false)\n       :cljs false))\n  (replace-tag [f old new] (replace-tag-fn f old new))\n  (extract-tangent [f tag] (extract-tangent-fn f tag))\n\n  #?@(:cljs\n      [MetaFn\n       (perturbed? [f] (:perturbed? (.-meta f) false))\n       (replace-tag [f old new]\n                    (replace-tag-fn (.-afn f) old new))\n       (extract-tangent [f tag]\n                        (extract-tangent-fn (.-afn f) tag))])\n\n  MultiFn\n  (perturbed? [_] false)\n  (replace-tag [f old new] (replace-tag-fn f old new))\n  (extract-tangent [f tag] (extract-tangent-fn f tag)))\n\n;; ## Single and Multivariable Calculus\n;;\n;; These functions put together the pieces laid out\n;; in [[sicmutils.differential]] and declare an interface for taking\n;; derivatives.\n\n(defn derivative\n  \"Returns a single-argument function of that, when called with an argument `x`,\n  returns the derivative of `f` at `x` using forward-mode automatic\n  differentiation.\n\n  For numerical differentiation,\n  see [[sicmutils.numerical.derivative/D-numeric]].\n\n  `f` must be built out of generic operations that know how to\n  handle [[d/Differential]] inputs in addition to any types that a normal `(f\n  x)` call would present. This restriction does _not_ apply to operations like\n  putting `x` into a container or destructuring; just primitive function calls.\"\n  [f]\n  (fn [x]\n    (let [tag    (d/fresh-tag)\n          lifted (d/bundle-element x 1 tag)]\n      (-> (d/with-active-tag tag f [lifted])\n          (d/extract-tangent tag)))))\n\n;; The result of applying the derivative `(D f)` of a multivariable function `f`\n;; to a sequence of `args` is a structure of the same shape as `args` with all\n;; orientations flipped. (For a partial derivative like `((partial 0 1) f)` the\n;; result has the same-but-flipped shape as `(get-in args [0 1])`.)\n;;\n;; `args` is coerced into an `up` structure. The only special case where this\n;; does not happen is if `(= 1 (count args))`.\n;;\n;; To generate the result:\n;;\n;; - For a single non-structural argument, return `(derivative f)`\n;; - else, bundle up all arguments into a single [[s/Structure]] instance `xs`\n;; - Generate `xs'` by replacing each entry in `xs` with `((derivative f')\n;;   entry)`, where `f'` is a function of ONLY that entry that\n;;   calls `(f (assoc-in xs path entry))`. In other words, replace each entry\n;;   with the result of the partial derivative of `f` at only that entry.\n;; - Return `(s/transpose xs')` (the same structure with all orientations\n;;   flipped.)\n;;\n;; A multivariable derivative is a multiple-arity function that performs the\n;; above.\n;;\n;; [[jacobian]] handles this main logic. [[jacobian]] can only take a structural\n;; input. [[euclidean]] and [[multivariate]] below widen handle, respectively,\n;; optionally-structural and multivariable arguments.\n\n(defn- deep-partial\n  \"Returns the partial derivative of `f` with respect to the entry in `structure`\n  at the location `path`.\n\n  `entry` defaults to `(get-in structure path)`.\"\n  ([f structure path]\n   (let [entry (get-in structure path)]\n     (deep-partial f structure path entry)))\n  ([f structure path entry]\n   (if (v/numerical? entry)\n     (letfn [(f-entry [x]\n               (f (assoc-in structure path x)))]\n       ((derivative f-entry) entry))\n     (u/illegal\n      (str \"non-numerical entry \" entry\n           \" at path \" path\n           \" in input structure \" structure)))))\n\n(defn- jacobian\n  \"Takes:\n\n  - some function `f` of a single [[sicmutils.structure/structure?]] argument\n  - the unperturbed structural `input`\n  - a `selectors` vector that can be empty or contain a valid path into the\n    `input` structure\n\n  and returns either:\n\n  - The full [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n    of `f` at `input`, if `selectors` is empty\n  - the entry of the Jacobian at `selectors`\n\n  The Jacobian has the same shape as `input` (or the entry at `selectors`) with\n  all orientations flipped. Multiply this by an increment in the shape of\n  `input` to produce an increment in the output of `f`.\"\n  ([f input] (jacobian f input []))\n  ([f input selectors]\n   (letfn [(prefixed [path]\n             (if (empty? selectors)\n               path\n               (into selectors path)))]\n     (if-let [piece (get-in input selectors)]\n       (let [frame (s/transpose piece)]\n         ;; Visit each entry in `frame`, a copy of either the full input or the\n         ;; sub-piece living at `selectors` (with all orientations flipped), and\n         ;; replace the entry with the result of the partial derivative of `f`\n         ;; with that entry perturbed.\n         (s/map-chain\n          (fn [entry path _]\n            (deep-partial f input (prefixed path) entry))\n          frame))\n\n       ;; The call to `get-in` will return nil if the `selectors` don't index\n       ;; correctly into the supplied `input`, triggering this exception.\n       (u/illegal (str \"Bad selectors \" selectors \" for structure \" input))))))\n\n(defn- euclidean\n  \"Slightly more general version of [[jacobian]] that can handle a single\n  non-structural input; dispatches to either [[jacobian]] or [[derivative]]\n  depending on the input type.\n\n  If you pass non-empty `selectors`, the returned function will throw if it\n  receives a non-structural, non-numerical argument.\"\n  ([f] (euclidean f []))\n  ([f selectors]\n   (let [selectors (vec selectors)]\n     (fn [input]\n       (cond (s/structure? input)\n             (jacobian f input selectors)\n\n             ;; non-empty selectors are only allowed for functions that receive\n             ;; a structural argument. This case passes that single,\n             ;; non-structural argument on to `(derivative f)`.\n             (empty? selectors)\n             ((derivative f) input)\n\n             ;; Any attempt to index (via non-empty selectors) into a\n             ;; non-structural argument will throw.\n             ;;\n             ;; NOTE: What about matrices, maps or sequences? The current\n             ;; implementation (as of 0.15.0) pushes the derivative operator\n             ;; into the entries, or values, of those types, so they won't reach\n             ;; this clause. There is a case I (@sritchie) can make for actually\n             ;; allowing the first clause here to work for ANY associative\n             ;; structure; then you're on your own if you want to call this fn\n             ;; directly.\n             :else\n             (u/illegal\n              (str \"Selectors \" selectors\n                   \" not allowed for non-structural input \" input)))))))\n\n(defn- multivariate\n  \"Slightly wider version of [[euclidean]]. Accepts:\n\n  - some function `f` of potentially many arguments\n  - optionally, a sequence of selectors meant to index into the structural\n    argument, or argument vector, of `f`\n\n  And returns a new function that computes either the\n  full [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  or the entry at `selectors`.\n\n  Any multivariable function will have its argument vector coerced into an `up`\n  structure. Any [[matrix/Matrix]] in a multiple-arg function call will be\n  converted into a `down` of `up`s (a row of columns).\n\n  Single-argument functions don't transform their arguments.\"\n  ([f] (multivariate f []))\n  ([f selectors]\n   (let [d #(euclidean % selectors)\n         df (d f)\n         df* (d (fn [args] (apply f args)))]\n     (-> (fn\n           ([] (constantly 0))\n           ([x] (df x))\n           ([x & more]\n            (df* (matrix/seq-> (cons x more)))))\n         (f/with-arity (f/arity f) {:from ::multivariate})))))\n\n;; ## Generic [[g/partial-derivative]] Installation\n;;\n;; [[g/partial-derivative]] is meant to produce either a full Jacobian or some\n;; entry specified by a `selectors` vector.\n;;\n;; When called on a function `f`, [[g/partial-derivative]] returns a function\n;; wrapped in the machinery provided by [[multivariate]]; this allows the same\n;; operator to serve functions of:\n;;\n;; - a single numerical input\n;; - a single structural input\n;; - multiple numerical OR structural inputs\n;;\n;; NOTE: The reason that this implementation is also installed\n;; for [[sicmutils.structure/Structure]] is that structures act as functions\n;; that apply their args to every (functional) entry. Calling `(multivariate\n;; structure selectors)` allows all of the machinery that handles\n;; structure-walking and argument conversion to run a SINGLE time before getting\n;; passed to the structure of functions, instead of separately for every entry\n;; in the structure.\n;;\n;; TODO: I think this is going to cause problems for, say, a Structure of\n;; PowerSeries, where there is actually a cheap `g/partial-derivative`\n;; implementation for the components. I vote to back out this `::s/structure`\n;; installation.\n\n(doseq [t [::v/function ::s/structure]]\n  (defmethod g/partial-derivative [t v/seqtype] [f selectors]\n    (multivariate f selectors))\n\n  (defmethod g/partial-derivative [t nil] [f _]\n    (multivariate f [])))\n\n;; ## Operators\n;;\n;; This section exposes various differential operators as [[o/Operator]]\n;; instances.\n\n(def ^{:doc \"Derivative operator. Takes some function `f` and returns a function\n  whose value at some point can multiply an increment in the arguments, to\n  produce the best linear estimate of the increment in the function value.\n\n  For univariate functions, [[D]] computes a derivative. For vector-valued\n  functions, [[D]] computes\n  the [Jacobian](https://en.wikipedia.org/wiki/Jacobian_matrix_and_determinant)\n  of `f`.\n\n  The related [[Grad]] returns a function that produces a structure of the\n  opposite orientation as [[D]]. Both of these functions use forward-mode\n  automatic differentiation.\"} D\n  (o/make-operator #(g/partial-derivative % [])\n                   g/derivative-symbol))\n\n(defn D-as-matrix [F]\n  (fn [s]\n    (matrix/s->m\n     (s/compatible-shape (F s))\n     ((D F) s)\n     s)))\n\n(defn partial\n  \"Returns an operator that, when applied to a function `f`, produces a function\n  that computes the partial derivative of `f` at the (zero-based) slot index\n  provided via `selectors`.\"\n  [& selectors]\n  (o/make-operator #(g/partial-derivative % selectors)\n                   `(~'partial ~@selectors)))\n\n;; ## Derivative Utilities\n;;\n;; Functions that make use of the differential operators defined above in\n;; standard ways.\n\n(defn taylor-series\n  \"Given a differentiable function `f` and any number of arguments `xs`, returns\n  a [[sicmutils.series/PowerSeries]] representing the [Taylor\n  series](https://en.wikipedia.org/wiki/Taylor_series) of the function `f`\n  expanded at `xs`.\n\n  Calling [[taylor-series]] with no arguments will return the [Maclaurin\n  series](https://en.wikipedia.org/wiki/Taylor_series#List_of_Maclaurin_series_of_some_common_functions)\n  of `f`, ie, the Taylor series expansion at `(= x 0)`.\n\n  Calling the returned power series with incremental argument `dx` will produce\n  a [[sicmutils.series/Series]] representing the terms of the Taylor series of\n  `f` expanded at `x` and evaluated at `x+dx`.\n\n  NOTE: Just like the [[D]] operator, functions `f` of multiple-arguments are\n  treated as a function of a single structural argument. If you pass multiple\n  arguments `xs`, you'll have to manually wrap your multiple-argument `dx` in\n  a [[sicmutils.structure/up]] or a vector before passing it to the returned\n  power series.\n\n  NOTE: The typical definition of a Taylor series of `f` expanded around some\n  point `x` is\n\n  $$T(p) = f(x) + \\\\frac{f'(x)}{1!}(p-x) + \\\\frac{f''(x)}{2!} (p-x)^2 + \\\\ldots,$$\n\n  where `p` is the evaluation point. When `(= p x)`, all derivatives of the\n  Taylor series expansion of `f` will exactly match the derivatives of `f`\n  itself.\n\n  The Taylor series returned here (call it $T'$) is actually a function of `dx`,\n  where\n\n  $$T'(dx) = T(x+dx) = f(x) + \\\\frac{f'(x)}{1!}(dx) + \\\\frac{f''(x)}{2!} (dx)^2 + \\\\ldots.$$\"\n  ([f] (taylor-series f 0))\n  ([f & xs]\n   (series/->function\n    (apply ((g/exp D) f) xs))))\n\n(defn symbolic-taylor-series\n  \"Similar to [[taylor-series]], except `f` is evaluated with symbolic arguments,\n  and these arguments are only replaced with the values `xs` after Taylor series\n  expansion.\n\n  Please see the docs for [[taylor-series]]!\"\n  ([f] (symbolic-taylor-series f 0))\n  ([f & xs]\n   (let [syms      (map s/typical-object xs)\n         replace-m (zipmap (flatten syms)\n                           (flatten xs))\n         series    (apply taylor-series f syms)]\n     (letfn [(process-term [term]\n               (g/simplify\n                (s/mapr (fn rec [x]\n                          (if (d/differential? x)\n                            (d/map-coefficients rec x)\n                            (-> (g/simplify x)\n                                (x/substitute replace-m))))\n                        term)))]\n       (series/fmap process-term series)))))\n"]}