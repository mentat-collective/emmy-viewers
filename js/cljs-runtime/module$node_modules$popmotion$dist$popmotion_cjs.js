shadow$provide.module$node_modules$popmotion$dist$popmotion_cjs=function(global,require,module,exports){function findSpring({duration=800,bounce=.25,velocity=0,mass=1}){let envelope;heyListen.warning(1E4>=duration,"Spring duration must be 10 seconds or less");let dampingRatio=1-bounce;dampingRatio=clamp(.05,1,dampingRatio);duration=clamp(.01,10,duration/1E3);1>dampingRatio?(envelope=undampedFreq=>{const exponentialDecay=undampedFreq*dampingRatio;return.001-(exponentialDecay-velocity)/(undampedFreq*
Math.sqrt(1-dampingRatio*dampingRatio))*Math.exp(-(exponentialDecay*duration))},bounce=undampedFreq=>{var delta=undampedFreq*dampingRatio*duration;const d=delta*velocity+velocity,e=Math.pow(dampingRatio,2)*Math.pow(undampedFreq,2)*duration;delta=Math.exp(-delta);const g=Math.pow(undampedFreq,2)*Math.sqrt(1-dampingRatio*dampingRatio);return(0<-envelope(undampedFreq)+.001?-1:1)*(d-e)*delta/g}):(envelope=undampedFreq=>-.001+Math.exp(-undampedFreq*duration)*((undampedFreq-velocity)*duration+1),bounce=
undampedFreq=>Math.exp(-undampedFreq*duration)*(velocity-undampedFreq)*duration*duration);bounce=approximateRoot(envelope,bounce,5/duration);duration*=1E3;if(isNaN(bounce))return{stiffness:100,damping:10,duration};bounce=Math.pow(bounce,2)*mass;return{stiffness:bounce,damping:2*dampingRatio*Math.sqrt(mass*bounce),duration}}function approximateRoot(envelope,derivative,initialGuess){for(let i=1;12>i;i++)initialGuess-=envelope(initialGuess)/derivative(initialGuess);return initialGuess}function isSpringType(options,
keys){return keys.some(key=>void 0!==options[key])}function getSpringOptions(options){let springOptions=Object.assign({velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1},options);!isSpringType(options,physicsKeys)&&isSpringType(options,durationKeys)&&(options=findSpring(options),springOptions=Object.assign(Object.assign(Object.assign({},springOptions),options),{velocity:0,mass:1}),springOptions.isResolvedFromDuration=!0);return springOptions}function spring(_a){function createSpring(){const initialVelocity=
velocity?-(velocity/1E3):0,initialDelta=to-from,dampingRatio=damping/(2*Math.sqrt(stiffness*mass)),undampedAngularFreq=Math.sqrt(stiffness/mass)/1E3;void 0===restDelta&&(restDelta=Math.min(Math.abs(to-from)/100,.4));if(1>dampingRatio){const angularFreq=undampedAngularFreq*Math.sqrt(1-dampingRatio*dampingRatio);resolveSpring=t=>to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*
t));resolveVelocity=t=>{const envelope=Math.exp(-dampingRatio*undampedAngularFreq*t);return dampingRatio*undampedAngularFreq*envelope*(Math.sin(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq+initialDelta*Math.cos(angularFreq*t))-envelope*(Math.cos(angularFreq*t)*(initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)-angularFreq*initialDelta*Math.sin(angularFreq*t))}}else if(1===dampingRatio)resolveSpring=t=>to-Math.exp(-undampedAngularFreq*t)*(initialDelta+
(initialVelocity+undampedAngularFreq*initialDelta)*t);else{const dampedAngularFreq=undampedAngularFreq*Math.sqrt(dampingRatio*dampingRatio-1);resolveSpring=t=>{const freqForT=Math.min(dampedAngularFreq*t,300);return to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((initialVelocity+dampingRatio*undampedAngularFreq*initialDelta)*Math.sinh(freqForT)+dampedAngularFreq*initialDelta*Math.cosh(freqForT))/dampedAngularFreq}}}var {from=0,to=1,restSpeed=2,restDelta}=_a;_a=tslib.__rest(_a,["from","to","restSpeed",
"restDelta"]);const state={done:!1,value:from};let {stiffness,damping,mass,velocity,duration,isResolvedFromDuration}=getSpringOptions(_a),resolveSpring=zero,resolveVelocity=zero;createSpring();return{next:t=>{const current=resolveSpring(t);if(isResolvedFromDuration)state.done=t>=duration;else{t=1E3*resolveVelocity(t);const isBelowDisplacementThreshold=Math.abs(to-current)<=restDelta;state.done=Math.abs(t)<=restSpeed&&isBelowDisplacementThreshold}state.value=state.done?to:current;return state},flipTarget:()=>
{velocity=-velocity;[from,to]=[to,from];createSpring()}}}function hueToRgb(p,q,t){0>t&&(t+=1);1<t&&--t;return t<1/6?p+6*(q-p)*t:.5>t?q:t<2/3?p+(q-p)*(2/3-t)*6:p}function hslaToRgba({hue,saturation,lightness,alpha}){hue/=360;saturation/=100;lightness/=100;if(saturation){const q=.5>lightness?lightness*(1+saturation):lightness+saturation-lightness*saturation,p=2*lightness-q;lightness=hueToRgb(p,q,hue+1/3);saturation=hueToRgb(p,q,hue);hue=hueToRgb(p,q,hue-1/3)}else lightness=saturation=hue=lightness;
return{red:Math.round(255*lightness),green:Math.round(255*saturation),blue:Math.round(255*hue),alpha}}function getMixer(origin,target){return"number"===typeof origin?v=>-v*origin+v*target+origin:styleValueTypes.color.test(origin)?mixColor(origin,target):mixComplex(origin,target)}function analyse(value){value=styleValueTypes.complex.parse(value);const numValues=value.length;let numNumbers=0,numRGB=0,numHSL=0;for(let i=0;i<numValues;i++)numNumbers||"number"===typeof value[i]?numNumbers++:void 0!==value[i].hue?
numHSL++:numRGB++;return{parsed:value,numNumbers,numRGB,numHSL}}function detectMixerFactory(v){if("number"===typeof v)return mixNumber;if("string"===typeof v)return styleValueTypes.color.test(v)?mixColor:mixComplex;if(Array.isArray(v))return mixArray;if("object"===typeof v)return mixObject}function createMixers(output,ease,customMixer){const mixers=[];customMixer=customMixer||detectMixerFactory(output[0]);const numMixers=output.length-1;for(let i=0;i<numMixers;i++){let mixer=customMixer(output[i],
output[i+1]);ease&&(mixer=[Array.isArray(ease)?ease[i]:ease,mixer].reduce(combineFunctions));mixers.push(mixer)}return mixers}function fastInterpolate([from,to],[mixer]){return v=>mixer(progress(from,to,v))}function slowInterpolate(input,mixers){const inputLength=input.length,lastInputIndex=inputLength-1;return v=>{var mixerIndex=0;let foundMixerIndex=!1;v<=input[0]?foundMixerIndex=!0:v>=input[lastInputIndex]&&(mixerIndex=lastInputIndex-1,foundMixerIndex=!0);if(!foundMixerIndex){for(mixerIndex=1;mixerIndex<
inputLength&&!(input[mixerIndex]>v||mixerIndex===lastInputIndex);mixerIndex++);--mixerIndex}v=progress(input[mixerIndex],input[mixerIndex+1],v);return mixers[mixerIndex](v)}}function interpolate(input,output,{clamp:isClamp=!0,ease,mixer}={}){const inputLength=input.length;heyListen.invariant(inputLength===output.length,"Both input and output ranges must be the same length");heyListen.invariant(!ease||!Array.isArray(ease)||ease.length===inputLength-1,"Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
input[0]>input[inputLength-1]&&(input=[].concat(input),output=[].concat(output),input.reverse(),output.reverse());output=createMixers(output,ease,mixer);const interpolator=2===inputLength?fastInterpolate(input,output):slowInterpolate(input,output);return isClamp?v=>interpolator(clamp(input[0],input[inputLength-1],v)):interpolator}function defaultEasing(values,easing){return values.map(()=>easing||easeInOut).splice(0,values.length-1)}function defaultOffset(values){const numValues=values.length;return values.map((_value,
i)=>0!==i?i/(numValues-1):0)}function convertOffsetToTimes(offset,duration){return offset.map(o=>o*duration)}function keyframes({from=0,to=1,ease,offset,duration=300}){function createInterpolator(){return interpolate(times,values,{ease:Array.isArray(ease)?ease:defaultEasing(values,ease)})}const state={done:!1,value:from},values=Array.isArray(to)?to:[from,to],times=convertOffsetToTimes(offset&&offset.length===values.length?offset:defaultOffset(values),duration);let interpolator=createInterpolator();
return{next:t=>{state.value=interpolator(t);state.done=t>=duration;return state},flipTarget:()=>{values.reverse();interpolator=createInterpolator()}}}function decay({velocity=0,from=0,power=.8,timeConstant=350,restDelta=.5,modifyTarget}){const state={done:!1,value:from};let amplitude=power*velocity;velocity=from+amplitude;const target=void 0===modifyTarget?velocity:modifyTarget(velocity);target!==velocity&&(amplitude=target-from);return{next:t=>{t=-amplitude*Math.exp(-t/timeConstant);state.done=!(t>
restDelta||t<-restDelta);state.value=state.done?target:target+t;return state},flipTarget:()=>{}}}function detectAnimationFromOptions(config){if(Array.isArray(config.to))return keyframes;if(types[config.type])return types[config.type];config=new Set(Object.keys(config));return config.has("ease")||config.has("duration")&&!config.has("dampingRatio")||!(config.has("dampingRatio")||config.has("stiffness")||config.has("mass")||config.has("damping")||config.has("restSpeed")||config.has("restDelta"))?keyframes:
spring}function loopElapsed(elapsed,duration,delay=0){return elapsed-duration-delay}function reverseElapsed(elapsed,duration,delay=0,isForwardPlayback=!0){return isForwardPlayback?loopElapsed(duration+-elapsed,duration,delay):duration-(elapsed-duration)+delay}function animate(_a){function update(delta){isForwardPlayback||(delta=-delta);elapsed+=delta;isComplete||(delta=animation.next(Math.max(0,elapsed)),latest=delta.value,interpolateFromNumber&&(latest=interpolateFromNumber(latest)),isComplete=isForwardPlayback?
delta.done:0>=elapsed);null===onUpdate||void 0===onUpdate?void 0:onUpdate(latest);if(isComplete)if(0===repeatCount&&(null!==computedDuration&&void 0!==computedDuration?computedDuration:computedDuration=elapsed),repeatCount<repeatMax){if(isForwardPlayback?elapsed>=computedDuration+repeatDelay:elapsed<=-repeatDelay)repeatCount++,"reverse"===repeatType?(isForwardPlayback=0===repeatCount%2,elapsed=reverseElapsed(elapsed,computedDuration,repeatDelay,isForwardPlayback)):(elapsed=loopElapsed(elapsed,computedDuration,
repeatDelay),"mirror"===repeatType&&animation.flipTarget()),isComplete=!1,onRepeat&&onRepeat()}else driverControls.stop(),onComplete&&onComplete()}var _c,{from,autoplay=!0,driver=framesync,elapsed=0,repeat:repeatMax=0,repeatType="loop",repeatDelay=0,onPlay,onStop,onComplete,onRepeat,onUpdate}=_a;_a=tslib.__rest(_a,"from autoplay driver elapsed repeat repeatType repeatDelay onPlay onStop onComplete onRepeat onUpdate".split(" "));let {to}=_a,driverControls,repeatCount=0,computedDuration=_a.duration,
latest,isComplete=!1,isForwardPlayback=!0,interpolateFromNumber;const animator=detectAnimationFromOptions(_a);if(null===(_c=animator.needsInterpolation)||void 0===_c?0:_c.call(animator,from,to))interpolateFromNumber=interpolate([0,100],[from,to],{clamp:!1}),from=0,to=100;const animation=animator(Object.assign(Object.assign({},_a),{from,to}));autoplay&&(null===onPlay||void 0===onPlay?void 0:onPlay(),driverControls=driver(update),driverControls.start());return{stop:()=>{null===onStop||void 0===onStop?
void 0:onStop();driverControls.stop()}}}function velocityPerSecond(velocity,frameDuration){return frameDuration?1E3/frameDuration*velocity:0}Object.defineProperty(exports,"__esModule",{value:!0});var tslib=require("module$node_modules$tslib$tslib"),heyListen=require("module$node_modules$hey_listen$dist$index"),styleValueTypes=require("module$node_modules$style_value_types$dist$valueTypes_cjs"),sync=require("module$node_modules$framesync$dist$framesync_cjs"),sync__default=sync&&"object"===typeof sync&&
"default"in sync?sync:{"default":sync};const clamp=(min,max,v)=>Math.min(Math.max(v,min),max),durationKeys=["duration","bounce"],physicsKeys=["stiffness","damping","mass"];spring.needsInterpolation=(a,b)=>"string"===typeof a||"string"===typeof b;const zero=_t=>0,progress=(from,to,value)=>{to-=from;return 0===to?1:(value-from)/to},colorTypes=[styleValueTypes.hex,styleValueTypes.rgba,styleValueTypes.hsla],getColorType=v=>colorTypes.find(type=>type.test(v)),notAnimatable=color=>`'${color}' is not an animatable color. Use the equivalent color code instead.`,
mixColor=(from$jscomp$0,to$jscomp$0)=>{let fromColorType=getColorType(from$jscomp$0),toColorType=getColorType(to$jscomp$0);heyListen.invariant(!!fromColorType,notAnimatable(from$jscomp$0));heyListen.invariant(!!toColorType,notAnimatable(to$jscomp$0));let fromColor=fromColorType.parse(from$jscomp$0),toColor=toColorType.parse(to$jscomp$0);fromColorType===styleValueTypes.hsla&&(fromColor=hslaToRgba(fromColor),fromColorType=styleValueTypes.rgba);toColorType===styleValueTypes.hsla&&(toColor=hslaToRgba(toColor),
toColorType=styleValueTypes.rgba);const blended=Object.assign({},fromColor);return v=>{for(const key in blended)if("alpha"!==key){var from=fromColor[key],to=toColor[key];from*=from;blended[key]=Math.sqrt(Math.max(0,v*(to*to-from)+from))}to=fromColor.alpha;blended.alpha=-v*to+v*toColor.alpha+to;return fromColorType.transform(blended)}},zeroPoint={x:0,y:0,z:0},combineFunctions=(a,b)=>v=>b(a(v)),mixArray=(from,to)=>{const output=[...from],numValues=output.length,blendValue=from.map((fromThis,i)=>getMixer(fromThis,
to[i]));return v=>{for(let i=0;i<numValues;i++)output[i]=blendValue[i](v);return output}},mixObject=(origin,target)=>{const output=Object.assign(Object.assign({},origin),target),blendValue={};for(const key in output)void 0!==origin[key]&&void 0!==target[key]&&(blendValue[key]=getMixer(origin[key],target[key]));return v=>{for(const key in blendValue)output[key]=blendValue[key](v);return output}},mixComplex=(origin,target)=>{const template=styleValueTypes.complex.createTransformer(target),originStats=
analyse(origin),targetStats=analyse(target);if(originStats.numHSL===targetStats.numHSL&&originStats.numRGB===targetStats.numRGB&&originStats.numNumbers>=targetStats.numNumbers)return[mixArray(originStats.parsed,targetStats.parsed),template].reduce(combineFunctions);heyListen.warning(!0,`Complex values '${origin}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);return p=>
`${0<p?target:origin}`},mixNumber=(from,to)=>p=>-p*from+p*to+from;global=easing=>p=>1-easing(1-p);require=easing=>p=>.5>=p?easing(2*p)/2:(2-easing(2*(1-p)))/2;module=power=>p=>Math.pow(p,power);const createBackIn=power=>p=>p*p*((power+1)*p-power),createAnticipate=power=>{const backEasing=createBackIn(power);return p=>1>(p*=2)?.5*backEasing(p):.5*(2-Math.pow(2,-10*(p-1)))},BOUNCE_FIRST_THRESHOLD=4/11,BOUNCE_SECOND_THRESHOLD=8/11,linear=p=>p,easeIn=module(2),easeOut=global(easeIn),easeInOut=require(easeIn),
circIn=p=>1-Math.sin(Math.acos(p)),circOut=global(circIn),circInOut=require(circOut),backIn=createBackIn(1.525),backOut=global(backIn),backInOut=require(backIn),anticipate=createAnticipate(1.525),ca=4356/361,cb=35442/1805,cc=16061/1805,bounceOut=p=>{if(1===p||0===p)return p;const p2=p*p;return p<BOUNCE_FIRST_THRESHOLD?7.5625*p2:p<BOUNCE_SECOND_THRESHOLD?9.075*p2-9.9*p+3.4:.9>p?ca*p2-cb*p+cc:10.8*p*p-20.52*p+10.72},bounceIn=global(bounceOut),types={keyframes,spring,decay},framesync=update=>{const passTimestamp=
({delta})=>update(delta);return{start:()=>sync__default["default"].update(passTimestamp,!0),stop:()=>sync.cancelSync.update(passTimestamp)}},identity=v=>v,createAttractor=(alterDisplacement=identity)=>(constant,origin,v)=>{v=origin-v;constant=-(0-constant+1)*(0-alterDisplacement(Math.abs(v)));return 0>=v?origin+constant:origin-constant},attract=createAttractor(),attractExpo=createAttractor(Math.sqrt),isPoint=point=>point.hasOwnProperty("x")&&point.hasOwnProperty("y"),isPoint3D=point=>isPoint(point)&&
point.hasOwnProperty("z"),toDecimal=(num,precision=2)=>{precision=Math.pow(10,precision);return Math.round(num*precision)/precision},smoothFrame=(prevValue,nextValue,duration,smoothing=0)=>toDecimal(prevValue+duration*(nextValue-prevValue)/Math.max(smoothing,duration)),calcBezier=(t,a1,a2)=>(((1-3*a2+3*a1)*t+(3*a2-6*a1))*t+3*a1)*t;exports.angle=(a,b=zeroPoint)=>180*Math.atan2(b.y-a.y,b.x-a.x)/Math.PI;exports.animate=animate;exports.anticipate=anticipate;exports.applyOffset=(from,to)=>{let hasReceivedFrom=
!0;void 0===to&&(to=from,hasReceivedFrom=!1);return v=>{if(hasReceivedFrom)return v-from+to;from=v;hasReceivedFrom=!0;return to}};exports.attract=attract;exports.attractExpo=attractExpo;exports.backIn=backIn;exports.backInOut=backInOut;exports.backOut=backOut;exports.bounceIn=bounceIn;exports.bounceInOut=p=>.5>p?.5*(1-bounceOut(1-2*p)):.5*bounceOut(2*p-1)+.5;exports.bounceOut=bounceOut;exports.circIn=circIn;exports.circInOut=circInOut;exports.circOut=circOut;exports.clamp=clamp;exports.createAnticipate=
createAnticipate;exports.createAttractor=createAttractor;exports.createBackIn=createBackIn;exports.createExpoIn=module;exports.cubicBezier=function(mX1,mY1,mX2,mY2){if(mX1===mY1&&mX2===mY2)return linear;const sampleValues=new Float32Array(11);for(let i=0;11>i;++i)sampleValues[i]=calcBezier(.1*i,mX1,mX2);return t=>{if(0!==t&&1!==t){for(var intervalStart=0,currentSample=1;10!==currentSample&&sampleValues[currentSample]<=t;++currentSample)intervalStart+=.1;--currentSample;currentSample=intervalStart+
(t-sampleValues[currentSample])/(sampleValues[currentSample+1]-sampleValues[currentSample])*.1;var initialSlope=3*(1-3*mX2+3*mX1)*currentSample*currentSample+2*(3*mX2-6*mX1)*currentSample+3*mX1;if(.001<=initialSlope){for(intervalStart=0;8>intervalStart;++intervalStart){initialSlope=3*(1-3*mX2+3*mX1)*currentSample*currentSample+2*(3*mX2-6*mX1)*currentSample+3*mX1;if(0===initialSlope)break;var currentX=calcBezier(currentSample,mX1,mX2)-t;currentSample-=currentX/initialSlope}t=currentSample}else if(0===
initialSlope)t=currentSample;else{currentSample=intervalStart;intervalStart+=.1;let i=0;do currentX=currentSample+(intervalStart-currentSample)/2,initialSlope=calcBezier(currentX,mX1,mX2)-t,0<initialSlope?intervalStart=currentX:currentSample=currentX;while(1E-7<Math.abs(initialSlope)&&10>++i);t=currentX}t=calcBezier(t,mY1,mY2)}return t}};exports.decay=decay;exports.degreesToRadians=degrees=>degrees*Math.PI/180;exports.distance=function(a,b){if("number"===typeof a&&"number"===typeof b)return Math.abs(a-
b);if(isPoint(a)&&isPoint(b)){const xDelta=Math.abs(a.x-b.x),yDelta=Math.abs(a.y-b.y);a=isPoint3D(a)&&isPoint3D(b)?Math.abs(a.z-b.z):0;return Math.sqrt(Math.pow(xDelta,2)+Math.pow(yDelta,2)+Math.pow(a,2))}};exports.easeIn=easeIn;exports.easeInOut=easeInOut;exports.easeOut=easeOut;exports.inertia=function({from=0,velocity=0,min,max,power=.8,timeConstant=750,bounceStiffness=500,bounceDamping=10,restDelta=1,modifyTarget,driver,onUpdate,onComplete,onStop}){function boundaryNearest(v){return void 0===
min?max:void 0===max?min:Math.abs(min-v)<Math.abs(max-v)?min:max}function startAnimation(options){null===currentAnimation||void 0===currentAnimation?void 0:currentAnimation.stop();currentAnimation=animate(Object.assign(Object.assign({},options),{driver,onUpdate:v=>{var _a;null===onUpdate||void 0===onUpdate?void 0:onUpdate(v);null===(_a=options.onUpdate)||void 0===_a?void 0:_a.call(options,v)},onComplete,onStop}))}function startSpring(options){startAnimation(Object.assign({type:"spring",stiffness:bounceStiffness,
damping:bounceDamping,restDelta},options))}let currentAnimation;if(void 0!==min&&from<min||void 0!==max&&from>max)startSpring({from,velocity,to:boundaryNearest(from)});else{let target=power*velocity+from;"undefined"!==typeof modifyTarget&&(target=modifyTarget(target));const boundary=boundaryNearest(target),heading=boundary===min?-1:1;let prev,current;const checkBoundary=v=>{prev=current;current=v;velocity=velocityPerSecond(v-prev,sync.getFrameData().delta);(1===heading&&v>boundary||-1===heading&&
v<boundary)&&startSpring({from:v,to:boundary,velocity})};startAnimation({type:"decay",from,velocity,timeConstant,power,restDelta,modifyTarget,onUpdate:void 0!==min&&target<min||void 0!==max&&target>max?checkBoundary:void 0})}return{stop:()=>null===currentAnimation||void 0===currentAnimation?void 0:currentAnimation.stop()}};exports.interpolate=interpolate;exports.isPoint=isPoint;exports.isPoint3D=isPoint3D;exports.keyframes=keyframes;exports.linear=linear;exports.mirrorEasing=require;exports.mix=(from,
to,progress)=>-progress*from+progress*to+from;exports.mixColor=mixColor;exports.mixComplex=mixComplex;exports.pipe=(...transformers)=>transformers.reduce(combineFunctions);exports.pointFromVector=(origin,angle,distance)=>{angle=angle*Math.PI/180;return{x:distance*Math.cos(angle)+origin.x,y:distance*Math.sin(angle)+origin.y}};exports.progress=progress;exports.radiansToDegrees=radians=>180*radians/Math.PI;exports.reverseEasing=global;exports.smooth=(strength=50)=>{let previousValue=0,lastUpdated=0;
return v=>{const currentFramestamp=sync.getFrameData().timestamp,timeDelta=currentFramestamp!==lastUpdated?currentFramestamp-lastUpdated:0;v=timeDelta?smoothFrame(previousValue,v,timeDelta,strength):previousValue;lastUpdated=currentFramestamp;return previousValue=v}};exports.smoothFrame=smoothFrame;exports.snap=points=>{if("number"===typeof points)return v=>Math.round(v/points)*points;let i=0;const numPoints=points.length;return v=>{let lastDistance=Math.abs(points[0]-v);for(i=1;i<numPoints;i++){const point=
points[i],distance=Math.abs(point-v);if(0===distance)return point;if(distance>lastDistance)return points[i-1];if(i===numPoints-1)return point;lastDistance=distance}}};exports.spring=spring;exports.steps=(steps,direction="end")=>progress=>{progress="end"===direction?Math.min(progress,.999):Math.max(progress,.001);progress*=steps;return clamp(0,1,("end"===direction?Math.floor(progress):Math.ceil(progress))/steps)};exports.toDecimal=toDecimal;exports.velocityPerFrame=function(xps,frameDuration){return xps/
(1E3/frameDuration)};exports.velocityPerSecond=velocityPerSecond;exports.wrap=(min,max,v)=>{max-=min;return((v-min)%max+max)%max+min}}
//# sourceMappingURL=module$node_modules$popmotion$dist$popmotion_cjs.js.map
