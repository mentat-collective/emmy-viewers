{
"version":3,
"file":"module$node_modules$three$src$renderers$webgl$WebGLMorphtargets.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/three/src/renderers/webgl/WebGLMorphtargets.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$src$renderers$webgl$WebGLMorphtargets\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLMorphtargets = WebGLMorphtargets;\n\nvar _constants = require(\"../../constants.js\");\n\nvar _DataArrayTexture = require(\"../../textures/DataArrayTexture.js\");\n\nvar _Vector = require(\"../../math/Vector4.js\");\n\nvar _Vector2 = require(\"../../math/Vector2.js\");\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const morphTextures = new WeakMap();\n  const morph = new _Vector.Vector4();\n  const workInfluences = [];\n\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n      const morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;\n      const morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;\n      let entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== morphTargetsCount) {\n        if (entry !== undefined) entry.texture.dispose();\n        const hasMorphPosition = geometry.morphAttributes.position !== undefined;\n        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        const hasMorphColors = geometry.morphAttributes.color !== undefined;\n        const morphTargets = geometry.morphAttributes.position || [];\n        const morphNormals = geometry.morphAttributes.normal || [];\n        const morphColors = geometry.morphAttributes.color || [];\n        let vertexDataCount = 0;\n        if (hasMorphPosition === true) vertexDataCount = 1;\n        if (hasMorphNormals === true) vertexDataCount = 2;\n        if (hasMorphColors === true) vertexDataCount = 3;\n        let width = geometry.attributes.position.count * vertexDataCount;\n        let height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        const buffer = new Float32Array(width * height * 4 * morphTargetsCount);\n        const texture = new _DataArrayTexture.DataArrayTexture(buffer, width, height, morphTargetsCount);\n        texture.type = _constants.FloatType;\n        texture.needsUpdate = true; // fill buffer\n\n        const vertexDataStride = vertexDataCount * 4;\n\n        for (let i = 0; i < morphTargetsCount; i++) {\n          const morphTarget = morphTargets[i];\n          const morphNormal = morphNormals[i];\n          const morphColor = morphColors[i];\n          const offset = width * height * 4 * i;\n\n          for (let j = 0; j < morphTarget.count; j++) {\n            const stride = j * vertexDataStride;\n\n            if (hasMorphPosition === true) {\n              morph.fromBufferAttribute(morphTarget, j);\n              buffer[offset + stride + 0] = morph.x;\n              buffer[offset + stride + 1] = morph.y;\n              buffer[offset + stride + 2] = morph.z;\n              buffer[offset + stride + 3] = 0;\n            }\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n\n            if (hasMorphColors === true) {\n              morph.fromBufferAttribute(morphColor, j);\n              buffer[offset + stride + 8] = morph.x;\n              buffer[offset + stride + 9] = morph.y;\n              buffer[offset + stride + 10] = morph.z;\n              buffer[offset + stride + 11] = morphColor.itemSize === 4 ? morph.w : 1;\n            }\n          }\n        }\n\n        entry = {\n          count: morphTargetsCount,\n          texture: texture,\n          size: new _Vector2.Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n\n        function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener('dispose', disposeTexture);\n        }\n\n        geometry.addEventListener('dispose', disposeTexture);\n      } //\n\n\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);\n      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n      const length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      let influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n        influences = [];\n\n        for (let i = 0; i < length; i++) {\n          influences[i] = [i, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      } // Collect influences\n\n\n      for (let i = 0; i < length; i++) {\n        const influence = influences[i];\n        influence[0] = i;\n        influence[1] = objectInfluences[i];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (let i = 0; i < 8; i++) {\n        if (i < length && influences[i][1]) {\n          workInfluences[i][0] = influences[i][0];\n          workInfluences[i][1] = influences[i][1];\n        } else {\n          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[i][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n      const morphTargets = geometry.morphAttributes.position;\n      const morphNormals = geometry.morphAttributes.normal;\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < 8; i++) {\n        const influence = workInfluences[i];\n        const index = influence[0];\n        const value = influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n            geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          }\n\n          if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n            geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          }\n\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n        } else {\n          if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n            geometry.deleteAttribute('morphTarget' + i);\n          }\n\n          if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n            geometry.deleteAttribute('morphNormal' + i);\n          }\n\n          morphInfluences[i] = 0;\n        }\n      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n\n  return {\n    update: update\n  };\n}\n};"],
"names":["shadow$provide","global","require","module","exports","numericalSort","a","b","absNumericalSort","Math","abs","Object","defineProperty","value","WebGLMorphtargets","gl","capabilities","textures","influencesList","morphInfluences","Float32Array","morphTextures","WeakMap","morph","_Vector","Vector4","workInfluences","i","update","object","geometry","material","program","objectInfluences","morphTargetInfluences","isWebGL2","morphAttribute","morphAttributes","position","normal","color","morphTargetsCount","undefined","length","entry","get","count","texture","dispose","hasMorphPosition","hasMorphNormals","hasMorphColors","morphTargets","morphNormals","morphColors","vertexDataCount","width","attributes","height","maxTextureSize","ceil","buffer","_DataArrayTexture","DataArrayTexture","type","_constants","FloatType","needsUpdate","vertexDataStride","morphTarget","morphNormal","morphColor","offset","j","stride","fromBufferAttribute","x","y","z","itemSize","w","size","_Vector2","Vector2","set","disposeTexture","delete","removeEventListener","addEventListener","morphInfluencesSum","morphBaseInfluence","morphTargetsRelative","getUniforms","setValue","influences","id","influence","sort","Number","MAX_SAFE_INTEGER","index","getAttribute","setAttribute","hasAttribute","deleteAttribute"]
}
