{
"version":3,
"file":"module$node_modules$three$src$renderers$webgl$WebGLMorphtargets.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/three/src/renderers/webgl/WebGLMorphtargets.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$src$renderers$webgl$WebGLMorphtargets\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLMorphtargets = WebGLMorphtargets;\n\nvar _constants = require(\"../../constants.js\");\n\nvar _DataTexture2DArray = require(\"../../textures/DataTexture2DArray.js\");\n\nvar _Vector = require(\"../../math/Vector3.js\");\n\nvar _Vector2 = require(\"../../math/Vector2.js\");\n\nfunction numericalSort(a, b) {\n  return a[0] - b[0];\n}\n\nfunction absNumericalSort(a, b) {\n  return Math.abs(b[1]) - Math.abs(a[1]);\n}\n\nfunction denormalize(morph, attribute) {\n  let denominator = 1;\n  const array = attribute.isInterleavedBufferAttribute ? attribute.data.array : attribute.array;\n  if (array instanceof Int8Array) denominator = 127;else if (array instanceof Int16Array) denominator = 32767;else if (array instanceof Int32Array) denominator = 2147483647;else console.error('THREE.WebGLMorphtargets: Unsupported morph attribute data type: ', array);\n  morph.divideScalar(denominator);\n}\n\nfunction WebGLMorphtargets(gl, capabilities, textures) {\n  const influencesList = {};\n  const morphInfluences = new Float32Array(8);\n  const morphTextures = new WeakMap();\n  const morph = new _Vector.Vector3();\n  const workInfluences = [];\n\n  for (let i = 0; i < 8; i++) {\n    workInfluences[i] = [i, 0];\n  }\n\n  function update(object, geometry, material, program) {\n    const objectInfluences = object.morphTargetInfluences;\n\n    if (capabilities.isWebGL2 === true) {\n      // instead of using attributes, the WebGL 2 code path encodes morph targets\n      // into an array of data textures. Each layer represents a single morph target.\n      const numberOfMorphTargets = geometry.morphAttributes.position.length;\n      let entry = morphTextures.get(geometry);\n\n      if (entry === undefined || entry.count !== numberOfMorphTargets) {\n        if (entry !== undefined) entry.texture.dispose();\n        const hasMorphNormals = geometry.morphAttributes.normal !== undefined;\n        const morphTargets = geometry.morphAttributes.position;\n        const morphNormals = geometry.morphAttributes.normal || [];\n        const numberOfVertices = geometry.attributes.position.count;\n        const numberOfVertexData = hasMorphNormals === true ? 2 : 1; // (v,n) vs. (v)\n\n        let width = numberOfVertices * numberOfVertexData;\n        let height = 1;\n\n        if (width > capabilities.maxTextureSize) {\n          height = Math.ceil(width / capabilities.maxTextureSize);\n          width = capabilities.maxTextureSize;\n        }\n\n        const buffer = new Float32Array(width * height * 4 * numberOfMorphTargets);\n        const texture = new _DataTexture2DArray.DataTexture2DArray(buffer, width, height, numberOfMorphTargets);\n        texture.format = _constants.RGBAFormat; // using RGBA since RGB might be emulated (and is thus slower)\n\n        texture.type = _constants.FloatType;\n        texture.needsUpdate = true; // fill buffer\n\n        const vertexDataStride = numberOfVertexData * 4;\n\n        for (let i = 0; i < numberOfMorphTargets; i++) {\n          const morphTarget = morphTargets[i];\n          const morphNormal = morphNormals[i];\n          const offset = width * height * 4 * i;\n\n          for (let j = 0; j < morphTarget.count; j++) {\n            morph.fromBufferAttribute(morphTarget, j);\n            if (morphTarget.normalized === true) denormalize(morph, morphTarget);\n            const stride = j * vertexDataStride;\n            buffer[offset + stride + 0] = morph.x;\n            buffer[offset + stride + 1] = morph.y;\n            buffer[offset + stride + 2] = morph.z;\n            buffer[offset + stride + 3] = 0;\n\n            if (hasMorphNormals === true) {\n              morph.fromBufferAttribute(morphNormal, j);\n              if (morphNormal.normalized === true) denormalize(morph, morphNormal);\n              buffer[offset + stride + 4] = morph.x;\n              buffer[offset + stride + 5] = morph.y;\n              buffer[offset + stride + 6] = morph.z;\n              buffer[offset + stride + 7] = 0;\n            }\n          }\n        }\n\n        entry = {\n          count: numberOfMorphTargets,\n          texture: texture,\n          size: new _Vector2.Vector2(width, height)\n        };\n        morphTextures.set(geometry, entry);\n\n        function disposeTexture() {\n          texture.dispose();\n          morphTextures.delete(geometry);\n          geometry.removeEventListener('dispose', disposeTexture);\n        }\n\n        geometry.addEventListener('dispose', disposeTexture);\n      } //\n\n\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < objectInfluences.length; i++) {\n        morphInfluencesSum += objectInfluences[i];\n      }\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', objectInfluences);\n      program.getUniforms().setValue(gl, 'morphTargetsTexture', entry.texture, textures);\n      program.getUniforms().setValue(gl, 'morphTargetsTextureSize', entry.size);\n    } else {\n      // When object doesn't have morph target influences defined, we treat it as a 0-length array\n      // This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences\n      const length = objectInfluences === undefined ? 0 : objectInfluences.length;\n      let influences = influencesList[geometry.id];\n\n      if (influences === undefined || influences.length !== length) {\n        // initialise list\n        influences = [];\n\n        for (let i = 0; i < length; i++) {\n          influences[i] = [i, 0];\n        }\n\n        influencesList[geometry.id] = influences;\n      } // Collect influences\n\n\n      for (let i = 0; i < length; i++) {\n        const influence = influences[i];\n        influence[0] = i;\n        influence[1] = objectInfluences[i];\n      }\n\n      influences.sort(absNumericalSort);\n\n      for (let i = 0; i < 8; i++) {\n        if (i < length && influences[i][1]) {\n          workInfluences[i][0] = influences[i][0];\n          workInfluences[i][1] = influences[i][1];\n        } else {\n          workInfluences[i][0] = Number.MAX_SAFE_INTEGER;\n          workInfluences[i][1] = 0;\n        }\n      }\n\n      workInfluences.sort(numericalSort);\n      const morphTargets = geometry.morphAttributes.position;\n      const morphNormals = geometry.morphAttributes.normal;\n      let morphInfluencesSum = 0;\n\n      for (let i = 0; i < 8; i++) {\n        const influence = workInfluences[i];\n        const index = influence[0];\n        const value = influence[1];\n\n        if (index !== Number.MAX_SAFE_INTEGER && value) {\n          if (morphTargets && geometry.getAttribute('morphTarget' + i) !== morphTargets[index]) {\n            geometry.setAttribute('morphTarget' + i, morphTargets[index]);\n          }\n\n          if (morphNormals && geometry.getAttribute('morphNormal' + i) !== morphNormals[index]) {\n            geometry.setAttribute('morphNormal' + i, morphNormals[index]);\n          }\n\n          morphInfluences[i] = value;\n          morphInfluencesSum += value;\n        } else {\n          if (morphTargets && geometry.hasAttribute('morphTarget' + i) === true) {\n            geometry.deleteAttribute('morphTarget' + i);\n          }\n\n          if (morphNormals && geometry.hasAttribute('morphNormal' + i) === true) {\n            geometry.deleteAttribute('morphNormal' + i);\n          }\n\n          morphInfluences[i] = 0;\n        }\n      } // GLSL shader uses formula baseinfluence * base + sum(target * influence)\n      // This allows us to switch between absolute morphs and relative morphs without changing shader code\n      // When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)\n\n\n      const morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;\n      program.getUniforms().setValue(gl, 'morphTargetBaseInfluence', morphBaseInfluence);\n      program.getUniforms().setValue(gl, 'morphTargetInfluences', morphInfluences);\n    }\n  }\n\n  return {\n    update: update\n  };\n}\n};"],
"names":["shadow$provide","global","require","module","exports","numericalSort","a","b","absNumericalSort","Math","abs","denormalize","morph","attribute","denominator","array","isInterleavedBufferAttribute","data","Int8Array","Int16Array","Int32Array","console","error","divideScalar","Object","defineProperty","value","WebGLMorphtargets","gl","capabilities","textures","influencesList","morphInfluences","Float32Array","morphTextures","WeakMap","_Vector","Vector3","workInfluences","i","update","object","geometry","material","program","objectInfluences","morphTargetInfluences","isWebGL2","numberOfMorphTargets","morphAttributes","position","length","entry","get","undefined","count","texture","dispose","hasMorphNormals","normal","morphTargets","morphNormals","numberOfVertexData","width","attributes","height","maxTextureSize","ceil","buffer","_DataTexture2DArray","DataTexture2DArray","format","_constants","RGBAFormat","type","FloatType","needsUpdate","vertexDataStride","morphTarget","morphNormal","offset","j","fromBufferAttribute","normalized","stride","x","y","z","size","_Vector2","Vector2","set","disposeTexture","delete","removeEventListener","addEventListener","morphInfluencesSum","morphBaseInfluence","morphTargetsRelative","getUniforms","setValue","influences","id","influence","sort","Number","MAX_SAFE_INTEGER","index","getAttribute","setAttribute","hasAttribute","deleteAttribute"]
}
