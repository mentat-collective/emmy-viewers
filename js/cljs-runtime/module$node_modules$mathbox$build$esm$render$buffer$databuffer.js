shadow$provide.module$node_modules$mathbox$build$esm$render$buffer$databuffer=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;
if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,
desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}Object.defineProperty(exports,"__esModule",{value:!0});exports.DataBuffer=void 0;var UData=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$data")),UGLSL=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$glsl"));global=require("module$node_modules$mathbox$build$esm$render$buffer$buffer");var _datatexture=require("module$node_modules$mathbox$build$esm$render$buffer$texture$datatexture"),
_Vector=require("module$node_modules$three$src$math$Vector2");class DataBuffer extends global.Buffer{constructor(renderer,shaders,options,build){null==build&&(build=!0);const width=options.width||1,height=options.height||1,depth=options.depth||1,samples=width*height*depth;options.samples||(options.samples=samples);super(renderer,shaders,options);this.width=width;this.height=height;this.depth=depth;null==this.samples&&(this.samples=samples);build&&this.build(options)}shader(shader,indices){null==indices&&
(indices=4);1<this.items||1<this.depth?(4!==indices&&shader.pipe(UGLSL.extendVec(indices,4)),shader.pipe("map.xyzw.texture",this.uniforms)):2!==indices&&shader.pipe(UGLSL.truncateVec(indices,2));shader.pipe(`map.2d.data${this.wrap?".wrap":""}`,this.uniforms);shader.pipe("sample.2d",this.uniforms);4>this.channels&&shader.pipe(UGLSL.swizzleVec4(["0000","x000","xw00","xyz0"][this.channels]));return shader}build(options){this.data=new Float32Array(this.samples*this.channels*this.items);this.texture=new _datatexture.DataTexture(this.renderer,
this.items*this.width,this.height*this.depth,this.channels,options);this.used=this.filled=0;this._adopt(this.texture.uniforms);this._adopt({dataPointer:{type:"v2",value:new _Vector.Vector2},textureItems:{type:"f",value:this.items},textureHeight:{type:"f",value:this.height}});this.dataPointer=this.uniforms.dataPointer.value;this.streamer=this.generate(this.data)}dispose(){this.data=null;this.texture.dispose();return super.dispose()}getFilled(){return this.filled}setCallback(callback){this.callback=
callback;return this.filled=0}copy(data){const n=Math.min(data.length,this.samples*this.channels*this.items),d=this.data;for(let i=0,end=n,asc=0<=end;asc?i<end:i>end;asc?i++:i--)d[i]=data[i];this.write(Math.ceil(n/this.channels/this.items))}write(n){null==n&&(n=this.samples);let height=n/this.width;n*=this.items;const width=1>height?n:this.items*this.width;height=Math.ceil(height);this.texture.write(this.data,0,0,width,height);this.dataPointer.set(.5,.5);this.filled=1;this.used=n}through(callback,
target){let dst,src;const {consume,done}=src=this.streamer,{emit}=dst=target.streamer;let i=0,pipe=()=>consume((x,y,z,w)=>callback(emit,x,y,z,w,i));pipe=UData.repeatCall(pipe,this.items);return()=>{src.reset();dst.reset();const limit=this.used;for(i=0;!done()&&i<limit;)pipe(),i++;return src.count()}}}exports.DataBuffer=DataBuffer}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$render$buffer$databuffer.js.map
