{"version":3,"sources":["sicmutils/algebra/fold.cljc"],"mappings":"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","names":["var_args","G__95611","sicmutils.algebra.fold/generic-sum-fold","js/Error","acc","x","sicmutils.generic._PLUS_","G__95626","sicmutils.algebra.fold/fold->sum-fn","fold","sicmutils.algebra.fold.fold__GT_sum_fn","present","init","xs","G__95628","cljs.core.reduce","f","low","high","cljs.core.range","cljs.core.transduce","cljs.core.map","sicmutils.algebra.fold/constant","const","_","G__95633","sicmutils.algebra.fold/count","sicmutils.algebra.fold.count","pred","G__95635","sicmutils.algebra.fold/min","x__4339__auto__","y__4340__auto__","G__95638","sicmutils.algebra.fold/max","x__4336__auto__","y__4337__auto__","G__95654","sicmutils.algebra.fold/join","args-arr__4885__auto__","len__4864__auto__","i__4865__auto__","argseq__4886__auto__","cljs.core/IndexedSeq","seq95652","G__95653","cljs.core/first","cljs.core/next","self__4851__auto__","folds","cljs.core/cons","cljs.core.mapv","accs","p1__95643#","p2__95644#","G__95664","sicmutils.algebra.fold/fold->scan-fn","sicmutils.algebra.fold.fold__GT_scan_fn","cljs.core.reductions","cljs.core/rest","sicmutils$algebra$fold$scan","G__95672","sicmutils.algebra.fold/kahan","p__95676","vec__95677","cljs.core.nth","p__95680","vec__95682","c","y","t","G__95691","sicmutils.algebra.fold/kahan-babushka-neumaier","p__95703","vec__95707","cljs.core/+","acc+x","delta","Math/abs","sicmutils.algebra.fold/kbn","G__95711","sicmutils.algebra.fold/kahan-babushka-klein","p__95714","vec__95715","cs","ccs","cs+delta","cc","cljs.core/vec","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","sicmutils.algebra.fold/klein-term","cljs.core/with-meta","sicmutils.algebra.fold/kbk-n-body","n","syms","cljs.core.into","cljs.core.repeatedly","cljs.core/gensym","prefix","cljs.core/pop","final","cljs.core/peek","cljs.core.gensym","cljs.core.repeat","p1__95726#","cljs.core.mapcat"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.algebra.fold\n  \"Namespace implementing various aggregation functions using the `fold`\n  abstraction and combinators for generating new folds from fold primitives.\n\n  Contains a number of algorithms for [compensated\n  summation](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) of\n  floating-point numbers.\"\n  (:refer-clojure :exclude [min max count])\n  (:require [clojure.core :as core]\n            [sicmutils.generic :as g]\n            [sicmutils.util.def :as ud :include-macros true]))\n\n;; ## Folds and Scans\n;;\n;; A [fold](https://en.wikipedia.org/wiki/Fold_(higher-order_function)) is a\n;; combination of:\n;;\n;; - some initial value into which you want to aggregate\n;; - a combining function of type (accumulator, x) => accumulator, capable\n;;   of \"folding\" each element `x` in some sequence of `xs` into the\n;;   accumulating state\n;; - a \"present\" function that converts the accumulator into a final value.\n;;\n;; NOTE: This also happens to be Clojure's required interface for the reducing\n;; function you pass to [[clojure.core/transduce]]. Any of the folds implemented\n;; in this namespace work well with `transduce` out of the box.\n;;\n;; Here is a simple example of a fold:\n\n(defn generic-sum-fold\n  \"Fold-style function. The 2-arity merge operation adds the value `x` into the\n  accumulating stating using [[sicmutils.generic/+]].\n\n  - given 0 arguments, returns an accumulator of 0.0\n  - given a single argument `acc`, acts as identity.\"\n  ([] 0.0)\n  ([acc] acc)\n  ([acc x]\n   (g/+ acc x)))\n\n;; The accumulator is the floating point 0.0. The `present` function is just...\n;; identity. This might seem pedantic to include, but many interesting folds\n;; need to keep intermediate state around, so please indulge me for now.\n;;\n;; To \"fold\" a new number into the running total, simply add them together.\n;;\n;; Here is how to use this function to add up the integers from 0 to 9:\n\n#_\n(let [xs (range 10)]\n  (= 45 (generic-sum-fold\n         (reduce generic-sum-fold (generic-sum-fold) xs))))\n\n;; To see how this abstraction is useful, let's first capture this ability to\n;; make \"summation\" functions out of folds. (Note the docstring's description of\n;; the other arities of `fold->sum-fn`... these allow you to define each of the\n;; arities of a fold in separate functions if you like.)\n\n(defn fold->sum-fn\n  \"Given\n\n  - a 0-argument fn `init` that returns some \\\"empty\\\" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) => accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator => final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns the result of accumulating all elements in `xs` using the functions\n  above, then `present`ing the result.\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns the result of\n  accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.\"\n  ([fold]\n   (fold->sum-fn fold fold fold))\n  ([fold present]\n   (fold->sum-fn fold fold present))\n  ([init fold present]\n   (fn ([xs]\n       (present\n        (reduce fold (init) xs)))\n     ([f low high]\n      (let [xs (range low high)]\n        (transduce (map f) fold xs))))))\n\n;; Our example again:\n#_\n(let [sum (fold->sum-fn generic-sum-fold)\n      xs  (range 10)]\n  (= 45 (sum xs)))\n\n;; ### Useful Folds\n;;\n;; This pattern is quite general. Here is example of a fold that (inefficiently)\n;; computes the average of a sequence of numbers:\n\n#_\n(defn average\n  ([] [0.0 0])\n  ([[sum n]] (/ sum n))\n  ([[sum n] x]\n   [(+ sum x) (inc n)]))\n\n;; The average of [0,9] is 4.5:\n\n#_\n(let [sum (fold->sum-fn average)]\n  (= 4.5 (sum (range 10))))\n\n;; (I'm not committing this particular implementation because it can overflow\n;; for large numbers. There is a better implementation in Algebird, used\n;; in [`AveragedValue`](https://github.com/twitter/algebird/blob/develop/algebird-core/src/main/scala/com/twitter/algebird/AveragedValue.scala)\n;; that you should port when this becomes important.)\n;;\n;; Here are some more building blocks:\n\n(defn constant\n  \"Given some value `const`, returns a fold that ignores all input and returns\n  `const` for a call to any of its arities.\"\n  [const]\n  (fn [& _] const))\n\n(defn count\n  \"Given some predicate `pred`, returns a fold that counts the number of items it\n  encounters that return true when passed to `pred`, false otherwise.\"\n  ([] (count (fn [_] true)))\n  ([pred]\n   (fn ([] 0)\n     ([acc] acc)\n     ([acc x]\n      (if (pred x)\n        (inc acc)\n        acc)))))\n\n(defn min\n  \"Fold that stores its minimum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.\"\n  ([] nil)\n  ([acc] acc)\n  ([acc x]\n   (if acc\n     (core/min acc x)\n     x)))\n\n(defn max\n  \"Fold that stores its maximum encountered value in its accumulator, and returns\n  it when called on to present.\n\n  Accumulation initializes with `nil`.\"\n  ([] nil)\n  ([acc] acc)\n  ([acc x]\n   (if acc\n     (core/max acc x)\n     x)))\n\n;; NOTE also that any [[sicmutils.util.aggregate/monoid]] instance will work as\n;; a fold out of the box. [[sicmutils.util.aggregate]] has utilities for\n;; generating more explicit folds out of monoids.\n\n;; ## Fold Combinators\n;;\n;; Folds can be \"added\" together in the following sense; if I have a sequence of\n;; folds, I can run them in parallel across some sequence `xs` by combining them\n;; into a single fold with these properties:\n;;\n;; - the accumulator is a vector of the accumulators of each input fold\n;; - each `x` is merged into each accumulator using the appropriate fold\n;; - `present` is called for every entry in the final vector\n;;\n;; This function is called `join`:\n\n(defn join\n  \"Given some number of `folds`, returns a new fold with the following properties:\n\n  - the accumulator is a vector of the accumulators of each input fold\n  - each `x` is merged into each accumulator using the appropriate fold\n  - `present` is called for every entry in the final vector\n\n  Given a single `fold`, acts as identity.\n\n  The no-argument call `(join)` is equivalent to `([[constant]] [])`.\"\n  ([] (constant []))\n  ([fold] fold)\n  ([fold & folds]\n   (let [folds (cons fold folds)]\n     (fn\n       ([]\n        (mapv (fn [f] (f)) folds))\n       ([accs]\n        (mapv #(%1 %2) folds accs))\n       ([accs x]\n        (mapv (fn [f acc]\n                (f acc x))\n              folds accs))))))\n\n;; For example, the following snippet computes the minimum, maximum and sum\n;; of `(range 10)`:\n\n#_\n(let [fold (join min max generic-sum-fold)\n      process (fold->sum-fn fold)]\n  (= [0 9 45]\n     (process (range 10))))\n\n;; ### Scans\n;;\n;; Before moving on, let's pause and implement a similar transformation of a\n;; fold, called `fold->scan-fn`. This is a generic form of Clojure's\n;; `reductions` function; a \"scan\" takes a sequence of `xs` and returns a\n;; sequence of all intermediate results seen by the accumulator, all passed\n;; through `present`.\n\n(defn fold->scan-fn\n  \"Given\n\n  - a 0-argument fn `init` that returns some \\\"empty\\\" accumulating value\n\n  - a 2-argument fn `fold` of `(accumulator, x) => accumulator` responsible for\n    merging some value `x` into the ongoing accumulation\n\n  - a 1-argument fn `present` from `accumulator => final-result`\n\n  Returns a function with two arities. The first arity takes a sequence `xs` and\n  returns a lazy sequence of all intermediate results of the summation. For\n  example, given [0 1 2 3], the return sequence would be equivalent to:\n\n  ```clj\n  (def sum-fn (fold->sum-fn init fold present))\n\n  [(sum-fn [0])\n   (sum-fn [0 1])\n   (sum-fn [0 1 2])\n   (sum-fn [0 1 2 3])]\n  ```\n\n  The second arity takes a transformation function `f`, an inclusive lower bound\n  `low` and an exclusive upper bound `high` and returns a lazy sequence of all\n  intermediate results of accumulating `(map f (range low high))`.\n\n  ## Other Arities\n\n  Given a single argument `fold`, `fold` is passed as each of the 0, 1 and 2\n  arity arguments.\n\n  Given `fold` and `present`, `fold` is used for the 0 and 2 arity arguments,\n  `present` for the 1-arity argument.\"\n  ([fold]\n   (fold->scan-fn fold fold fold))\n  ([fold present]\n   (fold->scan-fn fold fold present))\n  ([init fold present]\n   (fn scan\n     ([xs]\n      (->> (reductions fold (init) xs)\n           (rest)\n           (map present)))\n     ([f low high]\n      (scan\n       (map f (range low high)))))))\n\n;; Here is the previous example, using the fold to scan across `(range 4)`. Each\n;; vector in the returned (lazy) sequence is the minimum, maximum and running\n;; total seen up to that point.\n\n#_\n(let [fold (join min max generic-sum-fold)\n      process (fold->scan-fn fold)]\n  (i [[0 0 0]\n      [0 1 1]\n      [0 2 3]\n      [0 3 6]]\n     (process (range 4))))\n\n;; ## Summing Sequences of Numbers\n;;\n;; This is a fascinating topic, and my explorations have not yet done it\n;; justice. This section implements a number of folds designed to sum up\n;; sequences of numbers in various error-limiting ways.\n;;\n;; Much of the numerical physics simulation code in the library (everything\n;; in [[sicmutils.numerical.quadrature]], for example) depends on the ability to\n;; sum sequences of floating point numbers without the accumulation of error due\n;; to the machine representation of the number.\n;;\n;; Here is the naive way to add up a list of numbers:\n\n(comment\n  (defn naive-sum [xs]\n    (apply g/+ xs)))\n\n;; Simple! But watch it \"break\":\n\n(comment\n  ;; This should be 1.0...\n  (= 0.9999999999999999\n     (naive-sum [1.0 1e-8 -1e-8])))\n\n;; Algorithms called ['compensated\n;; summation'](https://en.wikipedia.org/wiki/Kahan_summation_algorithm)\n;; algorithms are one way around this problem. Instead of simply accumulating\n;; the numbers as they come, compensated summation keeps track of the piece of\n;; the sum that would get erased from the sum due to lack of precision.\n;;\n;; Aggregation algorithms that require intermediate state as they traverse a\n;; sequence are often excellent matches for the \"fold\" abstraction.\n;;\n;; The fold implementing Kahan summation tracks two pieces of state:\n;;\n;; - The running sum\n;; - A running compensation term tracking lost low-order bits\n;;\n;; If you add a very small to a very large number, the small number will lose\n;; bits. If you then SUBTRACT a large number and get back down to the original\n;; small number's range, the compensation term can recover those lost bits for\n;; you.\n;;\n;; See\n;; the ['Accuracy'](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Accuracy)\n;; section of the wiki article for a detailed discussion on the error bounds you\n;; can expect with Kahan summation. I haven't grokked this yet, so please open a\n;; PR with more exposition once you get it.\n\n(defn kahan\n  \"Fold that tracks the summation of a sequence of floating point numbers, using\n  the [Kahan summation\n  algorithm](https://en.wikipedia.org/wiki/Kahan_summation_algorithm) for\n  maintaining stability in the face of accumulating floating point errors.\"\n  ([] [0.0 0.0])\n  ([[acc _]] acc)\n  ([[acc c] x]\n   (let [y (- x c)\n         t (+ acc y)]\n     [t (- (- t acc) y)])))\n\n;; Voila, using [[kahan]], our example from before now correctly sums to 1.0:\n\n#_\n(= 1.0 ((fold->sum-fn kahan) [1.0 1e-8 -1e-8]))\n\n;; From the [wiki\n;; page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements),\n;; \"Neumaier introduced an improved version of Kahan algorithm, which he calls\n;; an 'improved Kahan\u2013Babu\u0161ka algorithm, which also covers the case when the\n;; next term to be added is larger in absolute value than the running sum,\n;; effectively swapping the role of what is large and what is small.\"\n;;\n;; Here is an example of where Kahan fails. The following should be 2.0, but\n;; Kahan returns 0.0:\n\n#_\n(= 0.0 ((fold->sum-fn kahan) [1.0 1e100 1.0 -1e100]))\n\n;; This improved fold is implemented here:\n\n(defn kahan-babushka-neumaier\n  \"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using Neumaier's improvement to [[kahan]].\n\n  This algorithm is more efficient than [[kahan]], handles a wider range of\n  cases (adding in numbers larger than the current running sum, for example) and\n  should be preferred.\"\n  ([] [0.0 0.0])\n  ([acc] (reduce + acc))\n  ([[acc c] x]\n   (let [acc+x (+ acc x)\n         delta (if (>= (Math/abs ^double acc)\n                       (Math/abs ^double x))\n                 ;; If sum is bigger, low-order digits of `x` are lost.\n                 (+ (- acc acc+x) x)\n\n                 ;; else, low-order digits of `sum` are lost.\n                 (+ (- x acc+x) acc))]\n     [acc+x (+ c delta)])))\n\n(def ^{:doc \"Alias for [[kahan-babushka-neumaier]].\"}\n  kbn\n  kahan-babushka-neumaier)\n\n;; [[kbn]] returns the correct result for the example above:\n\n#_\n(= 2.0 ((fold->sum-fn kbn) [1.0 1e100 1.0 -1e100]))\n\n;; The [wiki\n;; page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)\n;; mentions a \"higher-order modification\" of [[kahan-babushka-neumaier]], and I\n;; couldn't help implementing the second-order version here:\n\n(defn kahan-babushka-klein\n  \"Implements a fold that tracks the summation of a sequence of floating point\n  numbers, using a second-order variation of [[kahan-babushka-neumaier]].\n\n  See [this Wikipedia\n  page](https://en.wikipedia.org/wiki/Kahan_summation_algorithm#Further_enhancements)\n  for more information.\n\n  This algorithm was proposed by Klein in ['A Generalized Kahan-Babushka\n  Summation\n  Algorithm'](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.582.288&rep=rep1&type=pdf),\n  along with the higher-order versions implemented by [[kbk-n]].\"\n  ([] [0.0 0.0 0.0])\n  ([acc] (reduce + acc))\n  ([[acc cs ccs] x]\n   (let [acc+x (+ acc x)\n         delta (if (>= (Math/abs ^double acc)\n                       (Math/abs ^double x))\n                 (+ (- acc acc+x) x)\n                 (+ (- x acc+x) acc))\n         cs+delta (+ cs delta)\n         cc (if (>= (Math/abs ^double cs)\n                    (Math/abs ^double delta))\n              (+ (- cs cs+delta) delta)\n              (+ (- delta cs+delta) cs))]\n     [acc+x cs+delta (+ ccs cc)])))\n\n;; ### Higher-Order Kahan-Babushka-Klein\n\n;; Now, the repetition above in the second-order version was too glaring to\n;; ignore. Clearly it is possible to write efficient code for as high an order\n;; as you'd like, as described in [Klein's\n;; paper](https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.582.288&rep=rep1&type=pdf).\n;;\n;; Because this code needs to be very efficient, I chose to implement the\n;; higher-order fold generator using a macro.\n;;\n;; Each new order stacks three entries into the let-binding of the function\n;; above, and adds a new term to the accumulator. Because all of these terms\n;; live inside a single let-binding, we have to be careful with variable names.\n;; It turns out we can get away with\n;;\n;; - one symbol for each term we're accumulating (`sum` and each compensation\n;;   term)\n;;\n;; - a single symbol `delta` that we can reuse for all deltas generated.\n\n(defn- klein-term\n  \"Takes symbolic variables for\n\n  - `acc`, the accumulating term we're compensating for\n  - `delta`, the shared symbol used for deltas\n\n  and generates let-binding entries updating `acc` to `(+ acc delta)` and\n  `delta` to the new compensation amount in `(+ acc delta)`.\"\n  [acc delta]\n  `[sum# (+ ~acc ~delta)\n    ~delta (if (ud/fork\n                :clj (>= (Math/abs ~(with-meta acc {:tag 'double}))\n                         (Math/abs ~(with-meta delta {:tag 'double})))\n                :cljs (>= (.abs js/Math ~acc)\n                          (.abs js/Math ~delta)))\n             (+ (- ~acc sum#) ~delta)\n             (+ (- ~delta sum#) ~acc))\n    ~acc sum#])\n\n(defn ^:no-doc kbk-n-body\n  \"Given some order `n`, generates the function body of a fold implementing `n`-th\n  order Kahan-Babushka-Klein summation.\n\n  See [[kbk-n]] for more detail.\"\n  [n]\n  (let [syms   (into [] (repeatedly (inc n) gensym))\n        prefix (pop syms)\n        final  (peek syms)\n        delta  (gensym)]\n    `[([] [~@(repeat (inc n) 0.0)])\n      ([accs#] (reduce + accs#))\n      ([~syms ~delta]\n       (let [~@(mapcat #(klein-term % delta) prefix)]\n         [~@prefix (+ ~final ~delta)]))]))\n\n(defmacro kbk-n\n  \"Given some order `n`, returns a fold implementing `n`-th order\n  Kahan-Babushka-Klein summation.\n\n  Given `n` == 0, this is identical to a naive sum.\n  Given `n` == 1, identical to [[kahan-babushka-neumaier]].\n  Given `n` == 2, identical to [[kahan-babushka-klein]].\n\n  `n` > 2 represent new compensated summation algorithms.\"\n  [n]\n  `(fn ~@(kbk-n-body n)))\n"]}