{"version":3,"sources":["rewrite_clj/reader.cljc"],"mappings":"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","names":["var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","rewrite-clj.reader/throw-reader","seq74327","G__74328","cljs.core/first","cljs.core/next","G__74329","self__5754__auto__","reader","fmt","data","c","cljs.tools.reader.reader-types/get-column-number","l","cljs.tools.reader.reader-types/get-line-number","cljs.core.ex_info","cljs.core.apply","rewrite-clj.interop/simple-format","rewrite-clj.reader/boundary?","cljs.core/contains?","rewrite-clj.reader/comma?","rewrite-clj.reader/whitespace?","rewrite-clj.interop/clojure-whitespace?","rewrite-clj.reader/linebreak?","rewrite-clj.reader/space?","and__5043__auto__","rewrite-clj.reader/whitespace-or-boundary?","or__5045__auto__","G__74335","rewrite-clj.reader/read-while","js/Error","p?","rewrite_clj.reader.read_while","cljs.core/not","eof?","buf","js/goog.string.StringBuffer","temp__5751__auto__","rewrite-clj.reader/read-until","cljs.core/complement","rewrite-clj.reader/read-include-linebreak","p1__74343#","rewrite-clj.reader/string->edn","s","cljs.tools.reader.edn.read_string","rewrite-clj.reader/ignore","rewrite-clj.reader/next","rewrite-clj.reader/unread","ch","rewrite-clj.reader/peek","rewrite-clj.reader/position","row-k","col-k","rewrite-clj.reader/read-with-meta","read-fn","start-position","temp__5753__auto__","entry","cljs.core.merge","cljs.core/with-meta","rewrite-clj.reader/read-repeatedly","cljs.core.repeatedly","cljs.core.take_while","cljs.core/identity","cljs.core.doall","rewrite-clj.reader/read-n","node-tag","n","vs","v","cljs.core.conj","rewrite_clj.reader.throw_reader","cljs.core._EQ_","rewrite-clj.reader/read-keyword","cljs.tools.reader.reader-types/read-char","cljs.tools.reader.impl.utils/whitespace?","token","fexpr__74504","cljs.tools.reader.edn/read-token","cljs.tools.reader.impl.commons/parse-symbol","ns","name","cljs.core.nth","cljs.tools.reader.impl.errors/throw-invalid","cljs.core.keyword","cljs.tools.reader.impl.errors/throw-single-colon","rewrite-clj.reader/string-reader","cljs.tools.reader.reader_types.string_push_back_reader","cljs.tools.reader.reader_types.indexing_push_back_reader"],"sourcesContent":["(ns ^:no-doc rewrite-clj.reader\n  (:refer-clojure :exclude [peek next])\n  (:require #?@(:clj [[clojure.java.io :as io]])\n            [clojure.tools.reader.edn :as edn]\n            [clojure.tools.reader.impl.commons :as reader-impl-commons]\n            [clojure.tools.reader.impl.errors :as reader-impl-errors]\n            [clojure.tools.reader.impl.utils :as reader-impl-utils]\n            [clojure.tools.reader.reader-types :as r]\n            [rewrite-clj.interop :as interop])\n  #?(:cljs (:import [goog.string StringBuffer])\n     :clj (:import [java.io PushbackReader Closeable]\n                   [clojure.tools.reader.reader_types IndexingPushbackReader])))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## Exception\n\n(defn throw-reader\n  \"Throw reader exception, including line line/column.\"\n  [#?(:cljs ^:not-native reader :default reader) fmt & data]\n  (let [c (r/get-column-number reader)\n        l (r/get-line-number reader)]\n    (throw\n     (ex-info\n      (str (apply interop/simple-format fmt data)\n           \" [at line \" l \", column \" c \"]\") {}))))\n\n;; ## Decisions\n\n(defn boundary?\n  \"Check whether a given char is a token boundary.\"\n  [#?(:clj ^java.lang.Character c :default c)]\n  (contains?\n    #{\\\" \\: \\; \\' \\@ \\^ \\` \\~\n      \\( \\) \\[ \\] \\{ \\} \\\\ nil}\n    c))\n\n(defn comma?\n  [#?(:clj ^java.lang.Character c :default c)]\n  (identical? \\, c))\n\n(defn whitespace?\n  \"Checks whether a given character is whitespace\"\n  #?(:clj ^Boolean [^java.lang.Character c]\n     :default [c])\n  (interop/clojure-whitespace? c))\n\n(defn linebreak?\n  \"Checks whether the character is a newline\"\n  [#?(:clj ^java.lang.Character c :default c)]\n  (contains? #{\\newline \\return} c))\n\n(defn space?\n  \"Checks whether the character is a space\"\n  [#?(:clj ^java.lang.Character c :default c)]\n  (and c\n       (whitespace? c)\n       (not (contains? #{\\newline \\return \\,} c))))\n\n(defn whitespace-or-boundary?\n  #?(:clj ^Boolean [^java.lang.Character c]\n          :default [c])\n  (or (whitespace? c) (boundary? c)))\n\n;; ## Helpers\n\n(defn read-while\n  \"Read while the chars fulfill the given condition. Ignores\n    the unmatching char.\"\n  ([#?(:cljs ^not-native reader :default reader) p?]\n   (read-while reader p? (not (p? nil))))\n\n  ([#?(:cljs ^not-native reader :default reader) p? eof?]\n   (let [buf (StringBuffer.)]\n     (loop []\n       (if-let [c (r/read-char reader)]\n         (if (p? c)\n           (do\n             (.append buf c)\n             (recur))\n           (do\n             (r/unread reader c)\n             (.toString buf)))\n         (if eof?\n           (.toString buf)\n           (throw-reader reader \"unexpected EOF\")))))))\n\n(defn read-until\n  \"Read until a char fulfills the given condition. Ignores the\n   matching char.\"\n  [#?(:cljs ^not-native reader :default reader) p?]\n  (read-while\n    reader\n    (complement p?)\n    (p? nil)))\n\n(defn read-include-linebreak\n  \"Read until linebreak and include it.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (str\n    (read-until\n      reader\n      #(or (nil? %) (linebreak? %)))\n    (r/read-char reader)))\n\n(defn string->edn\n  \"Convert string to EDN value.\"\n  [#?(:clj ^String s :default s)]\n  (edn/read-string s))\n\n(defn ignore\n  \"Ignore the next character.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader)\n  nil)\n\n(defn next\n  \"Read next char.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (r/read-char reader))\n\n(defn unread\n  \"Unreads a char. Puts the char back on the reader.\"\n  [#?(:cljs ^not-native reader :default reader) ch]\n  (r/unread reader ch))\n\n(defn peek\n  \"Peek next char.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (let [ch (r/peek-char reader)]\n    ;; compensate for cljs newline normalization in tools reader v1.3.5\n    ;; see https://clojure.atlassian.net/browse/TRDR-65\n    (if (identical? \\return ch)\n      \\newline\n      ch)))\n\n(defn position\n  \"Create map of `row-k` and `col-k` representing the current reader position.\"\n  [#?(:cljs ^not-native reader :default reader) row-k col-k]\n  {row-k (r/get-line-number reader)\n   col-k (r/get-column-number reader)})\n\n(defn read-with-meta\n  \"Use the given function to read value, then attach row/col metadata.\"\n  [#?(:cljs ^not-native reader :default reader) read-fn]\n  (let [start-position (position reader :row :col)]\n    (when-let [entry (read-fn reader)]\n      (->> (position reader :end-row :end-col)\n           (merge start-position)\n           (with-meta entry)))))\n\n(defn read-repeatedly\n  \"Call the given function on the given reader until it returns\n   a non-truthy value.\"\n  [#?(:cljs ^not-native reader :default reader) read-fn]\n  (->> (repeatedly #(read-fn reader))\n       (take-while identity)\n       (doall)))\n\n(defn read-n\n  \"Call the given function on the given reader until `n` values matching `p?` have been\n   collected.\"\n  [#?(:cljs ^not-native reader :default reader) node-tag read-fn p? n]\n  {:pre [(pos? n)]}\n  (loop [c 0\n         vs []]\n    (if (< c n)\n      (if-let [v (read-fn reader)]\n        (recur\n          (if (p? v) (inc c) c)\n          (conj vs v))\n        (throw-reader\n          reader\n          \"%s node expects %d value%s.\"\n          node-tag\n          n\n          (if (= n 1) \"\" \"s\")))\n      vs)))\n\n;;\n;; ## Customizations\n;;\n(defn read-keyword\n  \"This customized version of clojure.tools.reader.edn's read-keyword allows for\n  an embedded `::` in a keyword to to support [garden-style keywords](https://github.com/noprompt/garden)\n  like `:&::before`. This function was transcribed from clj-kondo.\"\n  [reader]\n  (let [ch (r/read-char reader)]\n    (if-not (reader-impl-utils/whitespace? ch)\n      (let [#?(:clj ^String token :default token) (#'edn/read-token reader :keyword ch)\n            s (reader-impl-commons/parse-symbol token)]\n        (if (and s\n                 ;; (== -1 (.indexOf token \"::\")) becomes:\n                 (not (zero? (.indexOf token \"::\"))))\n          (let [#?(:clj ^String ns :default ns) (s 0)\n                #?(:clj ^String name :default name) (s 1)]\n            (if (identical? \\: (nth token 0))\n              (reader-impl-errors/throw-invalid reader :keyword token) ; No ::kw in edn.\n              (keyword ns name)))\n          (reader-impl-errors/throw-invalid reader :keyword token)))\n      (reader-impl-errors/throw-single-colon reader))))\n\n;; ## Reader Types\n\n;;\n;; clojure.tools.reader (at the time of this writing v1.3.5) does not seem to normalize Windows \\r\\n newlines\n;; properly to \\n for Clojure\n;;\n;; ClojureScript seems to work fine - but note that for peek it will return \\r for \\r\\n and \\r\\f instead of \\n.\n;;\n;; see https://clojure.atlassian.net/browse/TRDR-65\n;;\n;; For now, we introduce a normalizing reader for Clojure.\n;; Once/if this isssue is fixed in in tools reader we can turf our work-around.\n\n#?(:clj\n   (deftype NewlineNormalizingReader\n       [rdr\n        ^:unsynchronized-mutable read-ahead-char\n        ^:unsynchronized-mutable user-peeked-char]\n     r/Reader\n     (read-char [_reader]\n       (if-let [ch user-peeked-char]\n         (do (set! user-peeked-char nil) ch)\n         (let [ch (or read-ahead-char (r/read-char rdr))]\n           (when read-ahead-char (set! read-ahead-char nil))\n           (if (not (identical? \\return ch))\n             ch\n             (let [read-ahead-ch (r/read-char rdr)]\n               (when (not (or (identical? \\newline read-ahead-ch)\n                              (identical? \\formfeed read-ahead-ch)))\n                 (set! read-ahead-char read-ahead-ch))\n               \\newline)))))\n\n     (peek-char [reader]\n       (or user-peeked-char\n           (let [ch (.read-char reader)]\n             (set! user-peeked-char ch)\n             ch)))))\n\n#?(:clj\n   (defn newline-normalizing-reader\n     \"Normalizes the following line endings to LF (line feed - 0x0A):\n      - LF (remains LF)\n      - CRLF (carriage return 0x0D line feed 0x0A)\n      - CRFF (carriage return 0x0D form feed 0x0C)\"\n     ^Closeable [rdr]\n     (NewlineNormalizingReader. (r/to-rdr rdr) nil nil)))\n\n#?(:clj\n   (defn file-reader\n     \"Create reader for files.\"\n     ^IndexingPushbackReader\n     [f]\n     (-> (io/file f)\n         (io/reader)\n         (PushbackReader. 2)\n         newline-normalizing-reader\n         (r/indexing-push-back-reader 2))))\n\n(defn string-reader\n  \"Create reader for strings.\"\n  [s]\n  (-> s\n      r/string-push-back-reader\n      #?@(:clj [newline-normalizing-reader])\n      r/indexing-push-back-reader))\n"]}