{"version":3,"sources":["sicmutils/numerical/quadrature/bulirsch_stoer.cljc"],"mappings":";AAqCA;;;;;;;AAKEA,qEACA,AAACC,mDACA,2DAAA,IAAA,/DAACC,oEACD,2DAAA,IAAA,/DAACA;AA2CJ,4DAAA,5DAAOC,gIAAaC,EAAEC;AAAtB,AACE,IAAMC,QAAM,CAAGD,IAAED;AAAjB,AACE,kBAAKG;AAAL,AAAQ,QAAGD,QAAMC;;;AAErB,AAAA;;;;2DAAA,mEAAAC,9HAAOE;AAAP,AAAA,IAAAD,YAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,uFAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,uFAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,yFAAA,zFAAOD,oGAGHN,EAAEC;AAHN,AAGS,OAACO,uFAAWR,EAAEC,EAAEL;;;AAHzB,CAAA,yFAAA,zFAAOU,oGAIHN,EAAEC,EAAEQ;AAJR,AAKG,OAACC,4CAAI,AAACX,0DAAYC,EAAEC,GAAGQ;;;AAL1B,CAAA,mFAAA,nFAAOH;;AAAP,AAYA;;;;gEAAA,hEAAOK,wIAGJC;AAHH,AAIE,GAAI,6CAAA,7CAACC,8GAAc,AAAA,yGAAkBD;AACnC,8DAAA,vDAACE;;AACD,4EAAA,rEAACC;;;AAML;;;;;;;;;;;;+DAAA,/DAAOC,sIAWJC;AAXH,AAYE;;wFACIC,EAAElB,EAAEC;AADR,AAEG,+GAAA,2CAAA,nJAACkB,kGAAKD,EAAElB,EAAEC,2FAAML;;wFACfsB,EAAElB,EAAEC,EAAEW;AAHV,AAAA,GAIU,GAAK,OAAS,AAAA,4EAAIA;AAJ5B;AAAA,AAAA,MAAA,KAAAL,MAAA;;;AAKG,IAAAa,8MAAmCxB,hMACJ,uGAAA,2CAAA,lJAAC2B,2QAAMX;IADtCQ,kBAAA,AAAAC,4BAAAD;eAAAA,XAAqBR;QAArB,AAAAU,4CAAAF,gBAAA,hEAAcjB;IAERqB,cAAY,AAACb,8DAAgBC;IAC7Ba,SAAY,WAAKC;AAAL,AAAQ,QAAGA,IAAEA;;IACzBC,KAAY,AAACjB,4CAAIe,OAAO,AAACjB,uFAAWR,EAAEC,EAAEE;IACxCyB,KAAY,CAACX,kDAAAA,kEAAAA,lBAAkBC,8CAAAA,5CAAElB,8CAAAA,5CAAEC,8CAAAA,5CAAEW,8CAAAA;AAL3C,AAME,IAAAiB,YACC,AAACnB,4CAAIoB,iBAAOH,GAAGC;AADhB,AAAA,8FAAAC,mCAAAA,zHAACL,4CAAAA,uDAAAA;;+EARFN,EAAElB,EAAEC,EAAEW;;;wFAANM,EAAElB,EAAEC;;wFAAJiB,EAAElB,EAAEC,EAAEW;;;;;;;;;AAWZ;;;;;;;;;;;;;;;;;AAeEmB,8DACA,AAACf,6DAAegB;AAElB;;;;;;;;;;;;;;;;;AAeEC,gEACA,AAACjB,6DAAekB;AAOlB;;;;;;;;;;;;;;;AAAAC,8DAAA,AAAAC,yDAcWC,wDACDN;AAEV;;;;;;;;;;;;;;;AAAAO,gEAAA,AAAAF,yDAcWG,0DACDN","names":["sicmutils.numerical.quadrature.bulirsch-stoer/bulirsch-stoer-steps","cljs.core.interleave","sicmutils.util.stream.powers","sicmutils.numerical.quadrature.bulirsch-stoer/slice-width","a","b","width","n","var_args","G__102646","sicmutils.numerical.quadrature.bulirsch-stoer/h-sequence","js/Error","sicmutils.numerical.quadrature.bulirsch_stoer.h_sequence","n-seq","cljs.core.map","sicmutils.numerical.quadrature.bulirsch-stoer/extrapolator-fn","opts","cljs.core._EQ_","sicmutils.polynomial.interpolate/modified-neville-scan","sicmutils.rational-function.interpolate/modified-bulirsch-stoer-scan","sicmutils.numerical.quadrature.bulirsch-stoer/bs-sequence-fn","integrator-seq-fn","f","sicmutils$numerical$quadrature$bulirsch_stoer$bs_sequence_fn_$_call","map__102660","cljs.core/--destructure-map","cljs.core.get","cljs.core.merge","extrapolate","square","x","xs","ys","G__102661","cljs.core/vector","sicmutils.numerical.quadrature.bulirsch-stoer/open-sequence","sicmutils.numerical.quadrature.midpoint/midpoint-sequence","sicmutils.numerical.quadrature.bulirsch-stoer/closed-sequence","sicmutils.numerical.quadrature.trapezoid/trapezoid-sequence","sicmutils.numerical.quadrature.bulirsch-stoer/open-integral","sicmutils.numerical.quadrature.common/make-integrator-fn","sicmutils.numerical.quadrature.midpoint/single-midpoint","sicmutils.numerical.quadrature.bulirsch-stoer/closed-integral","sicmutils.numerical.quadrature.trapezoid/single-trapezoid"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature.bulirsch-stoer\n  (:require [sicmutils.numerical.quadrature.common :as qc :include-macros true]\n            [sicmutils.numerical.quadrature.midpoint :as mid]\n            [sicmutils.numerical.quadrature.trapezoid :as trap]\n            [sicmutils.polynomial.interpolate :as poly]\n            [sicmutils.rational-function.interpolate :as rat]\n            [sicmutils.util.stream :as us]))\n\n;; ## Bulirsch-Stoer Integration\n;;\n;; This quadrature method comes from\n;; the [scmutils](https://groups.csail.mit.edu/mac/users/gjs/6946/refman.txt)\n;; package that inspired this library.\n;;\n;; The idea is similar to Romberg integration:\n\n;; - use some simpler quadrature method like the Midpoint or Trapezoid method to\n;;   approximate an integral with a successively larger number of integration\n;;   slices\n;;\n;; - Fit a curve to the pairs $(h, f(h))$, where $h$ is the width of an\n;;   integration slice and $f$ is the integral estimator\n;;\n;; - Use the curve to extrapolate forward to $h=0$.\n;;\n;; Romberg integration does this by fitting a polynomial to a geometric series\n;; of slices - $1, 2, 4...$, for example - using Richardson extrapolation.\n;;\n;; The Bulirsch-Stoer algorithm is exactly this, but:\n;;\n;; - using rational function approximation instead of polynomial\n;; - the step sizes increase like $2, 3, 4, 6, 8... 2n_{i-2}$ by default\n;;\n;; Here are the default step sizes:\n\n(def ^{:doc \"Default step sizes used by the Bulirsch-Stoer quadrature algorithm:\n\n  ```\n2, 3, 4, 6, 8, 12, 16, 24, 32, ...\n  ```\"}\n  bulirsch-stoer-steps\n  (interleave\n   (us/powers 2 2)\n   (us/powers 2 3)))\n\n;; The more familiar algorithm named \"Bulirsch-Stoer\" applies the same ideas to\n;; the solution of ODes, as described\n;; on [Wikipedia](https://en.wikipedia.org/wiki/Bulirsch%E2%80%93Stoer_algorithm).\n;; scmutils adapted this into the methods you see here.\n;;\n;; NOTE - The Wikipedia page states that \"Hairer, N\u00f8rsett & Wanner (1993, p.\n;; 228), in their discussion of the method, say that rational extrapolation in\n;; this case is nearly never an improvement over polynomial\n;; interpolation (Deuflhard 1983).\"\n;;\n;; We can do this too! Passing `{:bs-extrapolator :polynomial}` enables\n;; polynomial extrapolation in the sequence and integration functions\n;; implemented below.\n;;\n;; ## Even Power Series\n;;\n;; One more detail is important to understand. You could apply the ideas above\n;; to any function that approximates an integral, but this namespace focuses on\n;; accelerating the midpoint and trapezoid methods.\n;;\n;; As discussed in `midpoint.cljc` and `trapezoid.cljc`, the error series for\n;; these methods has terms that fall off as even powers of the integration slice\n;; width:\n;;\n;; $$1/h^2, 1/h^4, ...$$\n;;\n;; $$1/(h^2) 1/(h^2)^2, ...$$\n;;\n;; This means that the rational function approximation needs to fit the function\n;; to points of the form\n;;\n;; $$(h^2, f(h))$$\n;;\n;; to take advantage of the acceleration. This trick is baked into Richardson\n;; extrapolation through the ability to specify a geometric series.\n;; `richardson_test.cljc` shows that Richardson extrapolation is indeed\n;; equivalent to a polynomial fit using $h^2$... the idea here is the same.\n;;\n;; The following two functions generate a sequence of NON-squared $h$ slice\n;; widths. `bs-sequence-fn` below squares each entry.\n\n(defn- slice-width [a b]\n  (let [width (- b a)]\n    (fn [n] (/ width n))))\n\n(defn- h-sequence\n  \"Defines the sequence of slice widths, given a sequence of `n` (number of\n  slices) in the interval $(a, b)$.\"\n  ([a b] (h-sequence a b bulirsch-stoer-steps))\n  ([a b n-seq]\n   (map (slice-width a b) n-seq)))\n\n;; ## Bulirsch-Stoer Estimate Sequences\n;;\n;; The next group of functions generates `open-sequence` and `closed-sequence`\n;; methods, analagous to all other quadrature methods in the library.\n\n(defn- extrapolator-fn\n  \"Allows the user to specify polynomial or rational function extrapolation via\n  the `:bs-extrapolator` option.\"\n  [opts]\n  (if (= :polynomial (:bs-extrapolator opts))\n    (poly/modified-neville-scan 0)\n    (rat/modified-bulirsch-stoer-scan 0)))\n\n;; This function exists because we wanted to provide an `open-sequence` and\n;; `closed-sequence` option below. The logic for both is the same, other than\n;; the underlying approximation sequence generator.\n\n(defn- bs-sequence-fn\n  \"Accepts some function (like `mid/midpoint-sequence`) that returns a sequence of\n  successively better estimates to the integral, and returns a new function with\n  interface `(f a b opts)` that accelerates the sequence with either\n\n  - polynomial extrapolation\n  - rational function extrapolation\n\n  By default, The `:n` in `opts` (passed on to `integrator-seq-fn`) is set to\n  the sequence of step sizes suggested by Bulirsch-Stoer,\n  `bulirsch-stoer-steps`.\"\n  [integrator-seq-fn]\n  (fn call\n    ([f a b]\n     (call f a b {:n bulirsch-stoer-steps}))\n    ([f a b opts]\n     {:pre [(not (number? (:n opts)))]}\n     (let [{:keys [n] :as opts} (-> {:n bulirsch-stoer-steps}\n                                    (merge opts))\n           extrapolate (extrapolator-fn opts)\n           square      (fn [x] (* x x))\n           xs          (map square (h-sequence a b n))\n           ys          (integrator-seq-fn f a b opts)]\n       (extrapolate\n        (map vector xs ys))))))\n\n(def ^{:doc \"Returns a (lazy) sequence of successively refined estimates of the\n  integral of `f` over the closed interval $[a, b]$ by applying rational\n  polynomial extrapolation to successive integral estimates from the Midpoint\n  rule.\n\n  Returns estimates formed from the same estimates used by the Bulirsch-Stoer\n  ODE solver, stored in `bulirsch-stoer-steps`.\n\n  ### Optional arguments:\n\n  `:n`: If supplied, `n` (sequence) overrides the sequence of steps to use.\n\n  `:bs-extrapolator`: Pass `:polynomial` to override the default rational\n  function extrapolation and enable polynomial extrapolation using the modified\n  Neville's algorithm implemented in `poly/modified-neville`.\"}\n  open-sequence\n  (bs-sequence-fn mid/midpoint-sequence))\n\n(def ^{:doc \"Returns a (lazy) sequence of successively refined estimates of the\n  integral of `f` over the closed interval $[a, b]$ by applying rational\n  polynomial extrapolation to successive integral estimates from the Trapezoid\n  rule.\n\n  Returns estimates formed from the same estimates used by the Bulirsch-Stoer\n  ODE solver, stored in `bulirsch-stoer-steps`.\n\n  ### Optional arguments:\n\n  `:n`: If supplied, `:n` (sequence) overrides the sequence of steps to use.\n\n `:bs-extrapolator`: Pass `:polynomial` to override the default rational\n  function extrapolation and enable polynomial extrapolation using the modified\n  Neville's algorithm implemented in `poly/modified-neville`.\"}\n  closed-sequence\n  (bs-sequence-fn trap/trapezoid-sequence))\n\n;; ## Integration API\n;;\n;; Finally, two separate functions that use the sequence functions above to\n;; converge quadrature estimates.\n\n(qc/defintegrator open-integral\n  \"Returns an estimate of the integral of `f` over the open interval $(a, b)$\n  generated by applying rational polynomial extrapolation to successive integral\n  estimates from the Midpoint rule.\n\n  Considers successive numbers of windows into $(a, b)$ specified by\n  `bulirsch-stoer-steps`.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See [[open-sequence]] for more information about Bulirsch-Stoer quadrature,\n  caveats that might apply when using this integration method and information on\n  the optional args in `opts` that customize this function's behavior.\"\n  :area-fn mid/single-midpoint\n  :seq-fn open-sequence)\n\n(qc/defintegrator closed-integral\n  \"Returns an estimate of the integral of `f` over the closed interval $[a, b]$\n  generated by applying rational polynomial extrapolation to successive integral\n  estimates from the Trapezoid rule.\n\n  Considers successive numbers of windows into $[a, b]$ specified by\n  `bulirsch-stoer-steps`.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See [[closed-sequence]] for more information about Bulirsch-Stoer quadrature,\n  caveats that might apply when using this integration method and information on\n  the optional args in `opts` that customize this function's behavior.\"\n  :area-fn trap/single-trapezoid\n  :seq-fn closed-sequence)\n\n;; ## References:\n;;\n;; - Press, Numerical Recipes, section 16.4: http://phys.uri.edu/nigh/NumRec/bookfpdf/f16-4.pdf\n;; - Wikipedia: https://en.wikipedia.org/wiki/Bulirsch%E2%80%93Stoer_algorithm\n"]}