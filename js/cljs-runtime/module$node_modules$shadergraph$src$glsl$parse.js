shadow$provide.module$node_modules$shadergraph$src$glsl$parse=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.walk=exports.parse=void 0;var _string=_interopRequireDefault(require("module$node_modules$glsl_tokenizer$string")),_direct=_interopRequireDefault(require("module$node_modules$$sicmutils$glsl_parser$direct")),_decl=require("module$node_modules$shadergraph$src$glsl$decl"),
_constants=require("module$node_modules$shadergraph$src$glsl$constants");let debug=!1;exports.parse=function(name,code){name=parseGLSL(name,code);let tock;debug&&(tock=tick());var symbols=[];walk(mapSymbols,collect$jscomp$0(symbols),name,"");const [main,internals,externals]=Array.from(sortSymbols(symbols));symbols=extractSignatures(main,internals,externals);debug&&tock("GLSL AST");return{ast:name,code,signatures:symbols}};const parseGLSL=function(name,code$jscomp$0){let ast;var tock;let errors=[];
debug&&(tock=tick());try{const tokens=(0,_string.default)(code$jscomp$0);ast=(0,_direct.default)(tokens)}catch(e){errors=[{message:e}]}debug&&tock("GLSL Tokenize \x26 Parse");tock=function(code){code=code.split("\n");const max=(""+code.length).length;return code.map((line,i)=>{var v=i+1;i=(v=""+v).length<max?("       "+v).slice(-max):v;return`${i}: ${line}`}).join("\n")};if(!ast||errors.length){name||(name="(inline code)");console.warn(tock(code$jscomp$0));for(const error of errors)console.error(`${name} -`,
error.message);throw Error("GLSL parse error");}return ast},mapSymbols=function(node,collect){switch(node.type){case "decl":return collect(_decl.decl.node(node)),!1}return!0},collect$jscomp$0=out=>function(value){null!=value&&Array.from(value).map(obj=>out.push(obj))},sortSymbols=function(symbols){let main=null;const internals=[];let externals=[];const maybe={};let found=!1;for(const s of Array.from(symbols))s.body?(maybe[s.ident]&&(externals=Array.from(externals).filter(e=>e.ident!==s.ident),delete maybe[s.ident]),
internals.push(s),"main"===s.ident?(main=s,found=!0):found||(main=s)):"global"===s.storage?internals.push(s):(externals.push(s),maybe[s.ident]=!0);return[main,internals,externals]},extractSignatures=function(main,internals,externals){let symbol$jscomp$0;const sigs={uniform:[],attribute:[],varying:[],external:[],internal:[],global:[],main:null},func=function(symbol,inout){let d;const signature=Array.from(symbol.args).map(arg=>_decl.decl.type(arg.ident,arg.type,arg.quant,arg.count,arg.inout,arg.storage));
for(d of Array.from(signature))if(d.inout===_decl.decl.inout){var a=d,b=d.copy();a.inout=_decl.decl.in;b.inout=_decl.decl.out;b.meta={shadow:a.name};b.name+=_constants.SHADOW_ARG;a.meta={shadowed:b.name};signature.push(b)}"void"!==symbol.type&&signature.unshift(_decl.decl.type(_constants.RETURN_ARG,symbol.type,!1,"","out"));a=(()=>{const result=[];for(d of Array.from(signature))d.inout===_decl.decl.in&&result.push(d.type);return result})().join(",");b=(()=>{const result1=[];for(d of Array.from(signature))d.inout===
_decl.decl.out&&result1.push(d.type);return result1})().join(",");return{name:symbol.ident,type:`(${a})(${b})`,signature,inout,spec:symbol.type}};sigs.main=func(main,_decl.decl.out);for(symbol$jscomp$0 of Array.from(internals))sigs.internal.push({name:symbol$jscomp$0.ident});for(symbol$jscomp$0 of Array.from(externals))switch(symbol$jscomp$0.decl){case "external":main=_decl.decl.type(symbol$jscomp$0.ident,symbol$jscomp$0.type,symbol$jscomp$0.quant,symbol$jscomp$0.count,symbol$jscomp$0.inout,symbol$jscomp$0.storage);
sigs[symbol$jscomp$0.storage].push(main);break;case "function":main=func(symbol$jscomp$0,_decl.decl.in),sigs.external.push(main)}return sigs};debug=!1;const walk=function(map,collect,node,indent){debug&&console.log(indent,node.type,null!=node.token?node.token.data:void 0,null!=node.token?node.token.type:void 0);if(map(node,collect))for(let i=0;i<node.children.length;i++)walk(map,collect,node.children[i],indent+"  ",debug);return null};exports.walk=walk;const tick=function(){const now=+new Date;return function(label){const delta=
+new Date-now;console.log(label,delta+" ms");return delta}}}
//# sourceMappingURL=module$node_modules$shadergraph$src$glsl$parse.js.map
