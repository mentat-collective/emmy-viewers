shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$element$composition=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _jxg=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg")),_math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),_geometry=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$geometry")),
_numerics=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$numerics")),_coords=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coords")),_type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type")),_constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants")),_point=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$point")),
_line=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$line")),_circle=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$circle")),_transformation=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$transformation")),_composition=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$composition")),_curve=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$curve")),
_polygon=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$polygon"));_jxg.default.createOrthogonalProjection=function(board,parents,attributes){parents[0]=board.select(parents[0]);parents[1]=board.select(parents[1]);if(_type.default.isPointType(board,parents[0])&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE){var p=_type.default.providePoints(board,[parents[0]],attributes,"point")[0];var l=parents[1]}else if(_type.default.isPointType(board,parents[1])&&
parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE)p=_type.default.providePoints(board,[parents[1]],attributes,"point")[0],l=parents[0];else throw Error("JSXGraph: Can't create perpendicular point with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,line]");parents=_type.default.copyAttributes(attributes,board.options,"orthogonalprojection");var t=board.create("point",[function(){return _geometry.default.projectPointToLine(p,l,board)}],
parents);_type.default.exists(p._is_new)?(t.addChild(p),delete p._is_new):p.addChild(t);l.addChild(t);t.elType="orthogonalprojection";t.setParents([p.id,t.id]);t.update();t.generatePolynomial=function(){var a1=l.point1.symbolic.x,a2=l.point1.symbolic.y,b1=l.point2.symbolic.x,b2=l.point2.symbolic.y,p1=p.symbolic.x,p2=p.symbolic.y,t1=t.symbolic.x,t2=t.symbolic.y;return["("+a2+")*("+t1+")-("+a2+")*("+b1+")+("+t2+")*("+b1+")-("+a1+")*("+t2+")+("+a1+")*("+b2+")-("+t1+")*("+b2+")","("+p2+")*("+a2+")-("+
p2+")*("+b2+")-("+t2+")*("+a2+")+("+t2+")*("+b2+")+("+p1+")*("+a1+")-("+p1+")*("+b1+")-("+t1+")*("+a1+")+("+t1+")*("+b1+")"]};return t};_jxg.default.createPerpendicular=function(board,parents,attributes){parents[0]=board.select(parents[0]);parents[1]=board.select(parents[1]);if(_type.default.isPointType(board,parents[0])&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE){var l=parents[1];var p=_type.default.providePoints(board,[parents[0]],attributes,"point")[0]}else if(_type.default.isPointType(board,
parents[1])&&parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE)l=parents[0],p=_type.default.providePoints(board,[parents[1]],attributes,"point")[0];else throw Error("JSXGraph: Can't create perpendicular with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [line,point]");parents=_type.default.copyAttributes(attributes,board.options,"perpendicular");board=_line.default.createLine(board,[function(){return l.stdform[2]*p.X()-l.stdform[1]*p.Y()},function(){return-l.stdform[2]*
p.Z()},function(){return l.stdform[1]*p.Z()}],parents);board.elType="perpendicular";board.setParents([l.id,p.id]);_type.default.exists(p._is_new)?(board.addChild(p),delete p._is_new):p.addChild(board);l.addChild(board);return board};_jxg.default.createPerpendicularPoint=function(board,parents,attributes){parents[0]=board.select(parents[0]);parents[1]=board.select(parents[1]);if(_type.default.isPointType(board,parents[0])&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE){var p=_type.default.providePoints(board,
[parents[0]],attributes,"point")[0];var l=parents[1]}else if(_type.default.isPointType(board,parents[1])&&parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE)p=_type.default.providePoints(board,[parents[1]],attributes,"point")[0],l=parents[0];else throw Error("JSXGraph: Can't create perpendicular point with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,line]");var t=board.create("point",[function(){return _geometry.default.perpendicular(l,
p,board)[0]}],attributes);_type.default.exists(p._is_new)?(t.addChild(p),delete p._is_new):p.addChild(t);l.addChild(t);t.elType="perpendicularpoint";t.setParents([p.id,l.id]);t.update();t.generatePolynomial=function(){var a1=l.point1.symbolic.x,a2=l.point1.symbolic.y,b1=l.point2.symbolic.x,b2=l.point2.symbolic.y,p1=p.symbolic.x,p2=p.symbolic.y,t1=t.symbolic.x,t2=t.symbolic.y;return["("+a2+")*("+t1+")-("+a2+")*("+b1+")+("+t2+")*("+b1+")-("+a1+")*("+t2+")+("+a1+")*("+b2+")-("+t1+")*("+b2+")","("+p2+
")*("+a2+")-("+p2+")*("+b2+")-("+t2+")*("+a2+")+("+t2+")*("+b2+")+("+p1+")*("+a1+")-("+p1+")*("+b1+")-("+t1+")*("+a1+")+("+t1+")*("+b1+")"]};return t};_jxg.default.createPerpendicularSegment=function(board,parents,attributes){parents[0]=board.select(parents[0]);parents[1]=board.select(parents[1]);if(_type.default.isPointType(board,parents[0])&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE){var l=parents[1];var p=_type.default.providePoints(board,[parents[0]],attributes,"point")[0]}else if(_type.default.isPointType(board,
parents[1])&&parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE)l=parents[0],p=_type.default.providePoints(board,[parents[1]],attributes,"point")[0];else throw Error("JSXGraph: Can't create perpendicular with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [line,point]");parents=_type.default.copyAttributes(attributes,board.options,"perpendicularsegment","point");var t=_jxg.default.createPerpendicularPoint(board,[l,p],parents);t.dump=!1;_type.default.exists(attributes.layer)||
(attributes.layer=board.options.layer.line);parents=_type.default.copyAttributes(attributes,board.options,"perpendicularsegment");attributes=_line.default.createLine(board,[function(){return _geometry.default.perpendicular(l,p,board)[1]?[t,p]:[p,t]}],parents);attributes.point=t;_type.default.exists(p._is_new)?(attributes.addChild(p),delete p._is_new):p.addChild(attributes);l.addChild(attributes);attributes.elType="perpendicularsegment";attributes.setParents([p.id,l.id]);attributes.subs={point:t};
attributes.inherits.push(t);return attributes};_jxg.default.createMidpoint=function(board,parents,attributes){var i;for(i=0;i<parents.length;++i)parents[i]=board.select(parents[i]);if(2===parents.length&&_type.default.isPointType(board,parents[0])&&_type.default.isPointType(board,parents[1])){parents=_type.default.providePoints(board,parents,attributes,"point");var a=parents[0];var b=parents[1]}else if(1===parents.length&&parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE)a=parents[0].point1,
b=parents[0].point2;else throw Error("JSXGraph: Can't create midpoint.\nPossible parent types: [point,point], [line]");parents=_type.default.copyAttributes(attributes,board.options,"midpoint");var t=board.create("point",[function(){var x=a.coords.usrCoords[1]+b.coords.usrCoords[1];return isNaN(x)||Math.abs(a.coords.usrCoords[0])<_math.default.eps||Math.abs(b.coords.usrCoords[0])<_math.default.eps?NaN:.5*x},function(){var y=a.coords.usrCoords[2]+b.coords.usrCoords[2];return isNaN(y)||Math.abs(a.coords.usrCoords[0])<
_math.default.eps||Math.abs(b.coords.usrCoords[0])<_math.default.eps?NaN:.5*y}],parents);_type.default.exists(a._is_new)?(t.addChild(a),delete a._is_new):a.addChild(t);_type.default.exists(b._is_new)?(t.addChild(b),delete b._is_new):b.addChild(t);t.elType="midpoint";t.setParents([a.id,b.id]);t.prepareUpdate().update();t.generatePolynomial=function(){var a1=a.symbolic.x,a2=a.symbolic.y,b1=b.symbolic.x,b2=b.symbolic.y,t1=t.symbolic.x,t2=t.symbolic.y;return["("+a2+")*("+t1+")-("+a2+")*("+b1+")+("+t2+
")*("+b1+")-("+a1+")*("+t2+")+("+a1+")*("+b2+")-("+t1+")*("+b2+")","("+a1+")^2 - 2*("+a1+")*("+t1+")+("+a2+")^2-2*("+a2+")*("+t2+")-("+b1+")^2+2*("+b1+")*("+t1+")-("+b2+")^2+2*("+b2+")*("+t2+")"]};return t};_jxg.default.createParallelPoint=function(board,parents,attributes){var i;for(i=0;i<parents.length;++i)parents[i]=board.select(parents[i]);if(3===parents.length&&_type.default.isPointType(board,parents[0])&&_type.default.isPointType(board,parents[1])&&_type.default.isPointType(board,parents[2])){parents=
_type.default.providePoints(board,parents,attributes,"point");var a=parents[0];var b=parents[1];var c=parents[2]}else if(_type.default.isPointType(board,parents[0])&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE)c=_type.default.providePoints(board,[parents[0]],attributes,"point")[0],a=parents[1].point1,b=parents[1].point2;else if(_type.default.isPointType(board,parents[1])&&parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE)c=_type.default.providePoints(board,[parents[1]],
attributes,"point")[0],a=parents[0].point1,b=parents[0].point2;else throw Error("JSXGraph: Can't create parallel point with parent types '"+typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [line,point], [point,point,point]");var p=board.create("point",[function(){return c.coords.usrCoords[1]+b.coords.usrCoords[1]-a.coords.usrCoords[1]},function(){return c.coords.usrCoords[2]+b.coords.usrCoords[2]-a.coords.usrCoords[2]}],attributes);_type.default.exists(a._is_new)?
(p.addChild(a),delete a._is_new):a.addChild(p);_type.default.exists(b._is_new)?(p.addChild(b),delete b._is_new):b.addChild(p);_type.default.exists(c._is_new)?(p.addChild(c),delete c._is_new):c.addChild(p);p.elType="parallelpoint";p.setParents([a.id,b.id,c.id]);p.prepareUpdate().update();p.generatePolynomial=function(){var a1=a.symbolic.x,a2=a.symbolic.y,b1=b.symbolic.x,b2=b.symbolic.y,c1=c.symbolic.x,c2=c.symbolic.y,t1=p.symbolic.x,t2=p.symbolic.y;return["("+b2+")*("+t1+")-("+b2+")*("+c1+")-("+a2+
")*("+t1+")+("+a2+")*("+c1+")-("+t2+")*("+b1+")+("+t2+")*("+a1+")+("+c2+")*("+b1+")-("+c2+")*("+a1+")","("+t2+")*("+a1+")-("+t2+")*("+c1+")-("+b2+")*("+a1+")+("+b2+")*("+c1+")-("+t1+")*("+a2+")+("+t1+")*("+c2+")+("+b1+")*("+a2+")-("+b1+")*("+c2+")"]};return p};_jxg.default.createParallel=function(board,parents,attributes){var p;var pp=1;for(p=0;p<parents.length;++p)parents[p]=board.select(parents[p]);p=null;if(3===parents.length)parents=_type.default.providePoints(board,parents,attributes,"point"),
p=parents[2],pp=0;else if(_type.default.isPointType(board,parents[0])){p=_type.default.providePoints(board,[parents[0]],attributes,"point")[0];var li=function(){return parents[1].stdform}}else _type.default.isPointType(board,parents[1])&&(p=_type.default.providePoints(board,[parents[1]],attributes,"point")[0],li=function(){return parents[0].stdform});_type.default.exists(attributes.layer)||(attributes.layer=board.options.layer.line);var attr=_type.default.copyAttributes(attributes,board.options,"parallel",
"point");pp=1===pp?board.create("point",[function(){return _math.default.crossProduct([1,0,0],li())}],attr):board.create("parallelpoint",parents,attr);pp.isDraggable=!0;attr=_type.default.copyAttributes(attributes,board.options,"parallel");board=board.create("line",[p,pp],attr);board.elType="parallel";board.subs={point:pp};board.inherits.push(pp);board.setParents([parents[0].id,parents[1].id]);3===parents.length&&board.addParents(parents[2].id);board.point=pp;return board};_jxg.default.createArrowParallel=
function(board,parents,attributes){try{attributes.firstArrow=!1;attributes.lastArrow=!0;var p=_jxg.default.createParallel(board,parents,attributes).setAttribute({straightFirst:!1,straightLast:!1});p.elType="arrowparallel";return p}catch(e){throw Error("JSXGraph: Can't create arrowparallel with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [line,point], [point,point,point]");}};_jxg.default.createNormal=function(board,parents,attributes){var i$jscomp$0;for(i$jscomp$0=
0;i$jscomp$0<parents.length;++i$jscomp$0)parents[i$jscomp$0]=board.select(parents[i$jscomp$0]);if(1===parents.length){var p$jscomp$0=parents[0];var c=p$jscomp$0.slideObject}else if(2===parents.length)if(_type.default.isPointType(board,parents[0]))p$jscomp$0=_type.default.providePoints(board,[parents[0]],attributes,"point")[0],c=parents[1];else if(_type.default.isPointType(board,parents[1]))c=parents[0],p$jscomp$0=_type.default.providePoints(board,[parents[1]],attributes,"point")[0];else throw Error("JSXGraph: Can't create normal with parent types '"+
typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,line], [point,circle], [glider]");else throw Error("JSXGraph: Can't create normal with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,line], [point,circle], [glider]");i$jscomp$0=_type.default.copyAttributes(attributes,board.options,"normal");if(c.elementClass===_constants.default.OBJECT_CLASS_LINE)attributes=_type.default.copyAttributes(attributes,board.options,"normal",
"point"),attributes=board.create("point",[function(){var p=_math.default.crossProduct([1,0,0],c.stdform);return[p[0],-p[2],p[1]]}],attributes),attributes.isDraggable=!0,board=board.create("line",[p$jscomp$0,attributes],i$jscomp$0),board.point=attributes,board.subs={point:attributes},board.inherits.push(attributes);else if(c.elementClass===_constants.default.OBJECT_CLASS_CIRCLE)board=board.create("line",[c.midpoint,p$jscomp$0],i$jscomp$0);else if(c.elementClass===_constants.default.OBJECT_CLASS_CURVE)if("plot"!==
_type.default.evaluate(c.visProp.curvetype)){var g=c.X;var f=c.Y;board=board.create("line",[function(){return-p$jscomp$0.X()*_numerics.default.D(g)(p$jscomp$0.position)-p$jscomp$0.Y()*_numerics.default.D(f)(p$jscomp$0.position)},function(){return _numerics.default.D(g)(p$jscomp$0.position)},function(){return _numerics.default.D(f)(p$jscomp$0.position)}],i$jscomp$0)}else board=board.create("line",[function(){var i=Math.floor(p$jscomp$0.position),lbda=p$jscomp$0.position-i;if(1===c.bezierdegree)i===
c.numberPoints-1&&(--i,lbda=1);else if(3===c.bezierDegree){i=3*Math.floor(p$jscomp$0.position*(c.numberPoints-1)/3);var p1=(p$jscomp$0.position*(c.numberPoints-1)-i)/3;i>=c.numberPoints-1&&(i=c.numberPoints-4,p1=1)}else return 0;if(0>i)return 1;if(1===c.bezierDegree)return(c.Y(i)+lbda*(c.Y(i+1)-c.Y(i)))*(c.Y(i)-c.Y(i+1))-(c.X(i)+lbda*(c.X(i+1)-c.X(i)))*(c.X(i+1)-c.X(i));lbda=c.points[i].usrCoords;var B=c.points[i+1].usrCoords;var C=c.points[i+2].usrCoords;var D=c.points[i+3].usrCoords;i=(1-p1)*(1-
p1)*(B[1]-lbda[1])+2*(1-p1)*p1*(C[1]-B[1])+p1*p1*(D[1]-C[1]);lbda=(1-p1)*(1-p1)*(B[2]-lbda[2])+2*(1-p1)*p1*(C[2]-B[2])+p1*p1*(D[2]-C[2]);B=Math.sqrt(i*i+lbda*lbda);p1=p$jscomp$0.coords.usrCoords;i=[1,p1[1]-lbda/B,p1[2]+i/B];return p1[2]*i[1]-p1[1]*i[2]},function(){var i=Math.floor(p$jscomp$0.position);if(1===c.bezierdegree)i===c.numberPoints-1&&--i;else if(3===c.bezierDegree){i=3*Math.floor(p$jscomp$0.position*(c.numberPoints-1)/3);var p1=(p$jscomp$0.position*(c.numberPoints-1)-i)/3;i>=c.numberPoints-
1&&(i=c.numberPoints-4,p1=1)}else return 0;if(0>i)return 0;if(1===c.bezierDegree)return c.X(i+1)-c.X(i);var A=c.points[i].usrCoords;var B=c.points[i+1].usrCoords;var C=c.points[i+2].usrCoords;var D=c.points[i+3].usrCoords;i=(1-p1)*(1-p1)*(B[1]-A[1])+2*(1-p1)*p1*(C[1]-B[1])+p1*p1*(D[1]-C[1]);p1=(1-p1)*(1-p1)*(B[2]-A[2])+2*(1-p1)*p1*(C[2]-B[2])+p1*p1*(D[2]-C[2]);A=Math.sqrt(i*i+p1*p1);p1=p$jscomp$0.coords.usrCoords;return p1[2]+i/A-p1[2]},function(){var i=Math.floor(p$jscomp$0.position);if(1===c.bezierdegree)i===
c.numberPoints-1&&--i;else if(3===c.bezierDegree){i=3*Math.floor(p$jscomp$0.position*(c.numberPoints-1)/3);var t=(p$jscomp$0.position*(c.numberPoints-1)-i)/3;i>=c.numberPoints-1&&(i=c.numberPoints-4,t=1)}else return 0;if(0>i)return 0;if(1===c.bezierDegree)return c.Y(i+1)-c.Y(i);var p1=c.points[i].usrCoords;var B=c.points[i+1].usrCoords;var C=c.points[i+2].usrCoords;var D=c.points[i+3].usrCoords;i=(1-t)*(1-t)*(B[1]-p1[1])+2*(1-t)*t*(C[1]-B[1])+t*t*(D[1]-C[1]);t=(1-t)*(1-t)*(B[2]-p1[2])+2*(1-t)*t*(C[2]-
B[2])+t*t*(D[2]-C[2]);B=Math.sqrt(i*i+t*t);p1=p$jscomp$0.coords.usrCoords;return p1[1]-(p1[1]-t/B)}],i$jscomp$0);else if(c.type===_constants.default.OBJECT_TYPE_TURTLE)board=board.create("line",[function(){var j,i=Math.floor(p$jscomp$0.position),lbda=p$jscomp$0.position-i;for(j=0;j<c.objects.length;j++){var el=c.objects[j];if(el.type===_constants.default.OBJECT_TYPE_CURVE){if(i<el.numberPoints)break;i-=el.numberPoints}}i===el.numberPoints-1&&(--i,lbda=1);return 0>i?1:(el.Y(i)+lbda*(el.Y(i+1)-el.Y(i)))*
(el.Y(i)-el.Y(i+1))-(el.X(i)+lbda*(el.X(i+1)-el.X(i)))*(el.X(i+1)-el.X(i))},function(){var j,i=Math.floor(p$jscomp$0.position);for(j=0;j<c.objects.length;j++){var el=c.objects[j];if(el.type===_constants.default.OBJECT_TYPE_CURVE){if(i<el.numberPoints)break;i-=el.numberPoints}}i===el.numberPoints-1&&--i;return 0>i?0:el.X(i+1)-el.X(i)},function(){var j,i=Math.floor(p$jscomp$0.position);for(j=0;j<c.objects.length;j++){var el=c.objects[j];if(el.type===_constants.default.OBJECT_TYPE_CURVE){if(i<el.numberPoints)break;
i-=el.numberPoints}}i===el.numberPoints-1&&--i;return 0>i?0:el.Y(i+1)-el.Y(i)}],i$jscomp$0);else throw Error("JSXGraph: Can't create normal with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,line], [point,circle], [glider]");board.elType="normal";board.setParents(parents);_type.default.exists(p$jscomp$0._is_new)?(board.addChild(p$jscomp$0),delete p$jscomp$0._is_new):p$jscomp$0.addChild(board);c.addChild(board);return board};_jxg.default.createBisector=
function(board,parents,attributes){parents=_type.default.providePoints(board,parents,attributes,"point");if(_type.default.isPoint(parents[0])&&_type.default.isPoint(parents[1])&&_type.default.isPoint(parents[2])){var i=_type.default.copyAttributes(attributes,board.options,"bisector","point");i.snapToGrid=!1;var p=board.create("point",[function(){return _geometry.default.angleBisector(parents[0],parents[1],parents[2],board)}],i);p.dump=!1;for(i=0;3>i;i++)_type.default.exists(parents[i]._is_new)?(p.addChild(parents[i]),
delete parents[i]._is_new):parents[i].addChild(p);_type.default.exists(attributes.layer)||(attributes.layer=board.options.layer.line);i=_type.default.copyAttributes(attributes,board.options,"bisector");attributes=_line.default.createLine(board,[parents[1],p],i);attributes.point=p;attributes.elType="bisector";attributes.setParents(parents);attributes.subs={point:p};attributes.inherits.push(p);return attributes}throw Error("JSXGraph: Can't create angle bisector with parent types '"+typeof parents[0]+
"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,point,point]");};_jxg.default.createAngularBisectorsOfTwoLines=function(board,parents,attributes){var l1=board.select(parents[0]),l2=board.select(parents[1]);if(l1.elementClass!==_constants.default.OBJECT_CLASS_LINE||l2.elementClass!==_constants.default.OBJECT_CLASS_LINE)throw Error("JSXGraph: Can't create angle bisectors of two lines with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [line,line]");
_type.default.exists(attributes.layer)||(attributes.layer=board.options.layer.line);var attr=_type.default.copyAttributes(attributes,board.options,"bisectorlines","line1");parents=board.create("line",[function(){return l1.stdform[0]/Math.sqrt(l1.stdform[1]*l1.stdform[1]+l1.stdform[2]*l1.stdform[2])-l2.stdform[0]/Math.sqrt(l2.stdform[1]*l2.stdform[1]+l2.stdform[2]*l2.stdform[2])},function(){return l1.stdform[1]/Math.sqrt(l1.stdform[1]*l1.stdform[1]+l1.stdform[2]*l1.stdform[2])-l2.stdform[1]/Math.sqrt(l2.stdform[1]*
l2.stdform[1]+l2.stdform[2]*l2.stdform[2])},function(){return l1.stdform[2]/Math.sqrt(l1.stdform[1]*l1.stdform[1]+l1.stdform[2]*l1.stdform[2])-l2.stdform[2]/Math.sqrt(l2.stdform[1]*l2.stdform[1]+l2.stdform[2]*l2.stdform[2])}],attr);_type.default.exists(attributes.layer)||(attributes.layer=board.options.layer.line);attr=_type.default.copyAttributes(attributes,board.options,"bisectorlines","line2");board=board.create("line",[function(){return l1.stdform[0]/Math.sqrt(l1.stdform[1]*l1.stdform[1]+l1.stdform[2]*
l1.stdform[2])+l2.stdform[0]/Math.sqrt(l2.stdform[1]*l2.stdform[1]+l2.stdform[2]*l2.stdform[2])},function(){return l1.stdform[1]/Math.sqrt(l1.stdform[1]*l1.stdform[1]+l1.stdform[2]*l1.stdform[2])+l2.stdform[1]/Math.sqrt(l2.stdform[1]*l2.stdform[1]+l2.stdform[2]*l2.stdform[2])},function(){return l1.stdform[2]/Math.sqrt(l1.stdform[1]*l1.stdform[1]+l1.stdform[2]*l1.stdform[2])+l2.stdform[2]/Math.sqrt(l2.stdform[1]*l2.stdform[1]+l2.stdform[2]*l2.stdform[2])}],attr);attributes=new _composition.default({line1:parents,
line2:board});parents.dump=!1;board.dump=!1;attributes.elType="bisectorlines";attributes.setParents([l1.id,l2.id]);attributes.subs={line1:parents,line2:board};return attributes};_jxg.default.createCircumcenter=function(board,parents,attributes){parents=_type.default.providePoints(board,parents,attributes,"point");if(_type.default.isPoint(parents[0])&&_type.default.isPoint(parents[1])&&_type.default.isPoint(parents[2])){var a=parents[0];var b=parents[1];var c=parents[2];var p=_point.default.createPoint(board,
[function(){return _geometry.default.circumcenter(a,b,c,board)}],attributes);for(attributes=0;3>attributes;attributes++)_type.default.exists(parents[attributes]._is_new)?(p.addChild(parents[attributes]),delete parents[attributes]._is_new):parents[attributes].addChild(p);p.elType="circumcenter";p.setParents(parents);p.generatePolynomial=function(){var a1=a.symbolic.x,a2=a.symbolic.y,c1=c.symbolic.x,c2=c.symbolic.y,t1=p.symbolic.x,t2=p.symbolic.y,poly1=["((",t1,")-(",a1,"))^2+((",t2,")-(",a2,"))^2-((",
t1,")-(",b.symbolic.x,"))^2-((",t2,")-(",b.symbolic.y,"))^2"].join("");a1=["((",t1,")-(",a1,"))^2+((",t2,")-(",a2,"))^2-((",t1,")-(",c1,"))^2-((",t2,")-(",c2,"))^2"].join("");return[poly1,a1]};return p}throw Error("JSXGraph: Can't create circumcircle midpoint with parent types '"+typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point]");};_jxg.default.createIncenter=function(board,parents,attributes){var i;parents=_type.default.providePoints(board,
parents,attributes,"point");if(3<=parents.length&&_type.default.isPoint(parents[0])&&_type.default.isPoint(parents[1])&&_type.default.isPoint(parents[2])){var A=parents[0];var B=parents[1];var C=parents[2];attributes=board.create("point",[function(){var a=Math.sqrt((B.X()-C.X())*(B.X()-C.X())+(B.Y()-C.Y())*(B.Y()-C.Y()));var b=Math.sqrt((A.X()-C.X())*(A.X()-C.X())+(A.Y()-C.Y())*(A.Y()-C.Y()));var c=Math.sqrt((B.X()-A.X())*(B.X()-A.X())+(B.Y()-A.Y())*(B.Y()-A.Y()));return new _coords.default(_constants.default.COORDS_BY_USER,
[(a*A.X()+b*B.X()+c*C.X())/(a+b+c),(a*A.Y()+b*B.Y()+c*C.Y())/(a+b+c)],board)}],attributes);for(i=0;3>i;i++)_type.default.exists(parents[i]._is_new)?(attributes.addChild(parents[i]),delete parents[i]._is_new):parents[i].addChild(attributes);attributes.elType="incenter";attributes.setParents(parents)}else throw Error("JSXGraph: Can't create incenter with parent types '"+typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point]");return attributes};
_jxg.default.createCircumcircle=function(board,parents,attributes){var i;parents=_type.default.providePoints(board,parents,attributes,"point");if(!1===parents)throw Error("JSXGraph: Can't create circumcircle with parent types '"+typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point]");try{var attr=_type.default.copyAttributes(attributes,board.options,"circumcircle","center");var p=_jxg.default.createCircumcenter(board,parents,attr);p.dump=
!1;_type.default.exists(attributes.layer)||(attributes.layer=board.options.layer.circle);attr=_type.default.copyAttributes(attributes,board.options,"circumcircle");var c=_circle.default.createCircle(board,[p,parents[0]],attr);c.elType="circumcircle";c.setParents(parents);c.subs={center:p};c.inherits.push(c);for(i=0;3>i;i++)_type.default.exists(parents[i]._is_new)?(c.addChild(parents[i]),delete parents[i]._is_new):parents[i].addChild(c)}catch(e){throw Error("JSXGraph: Can't create circumcircle with parent types '"+
typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point]");}return c};_jxg.default.createIncircle=function(board,parents,attributes){var i;parents=_type.default.providePoints(board,parents,attributes,"point");if(!1===parents)throw Error("JSXGraph: Can't create circumcircle with parent types '"+typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point]");try{var attr=_type.default.copyAttributes(attributes,
board.options,"incircle","center");var p=_jxg.default.createIncenter(board,parents,attr);p.dump=!1;_type.default.exists(attributes.layer)||(attributes.layer=board.options.layer.circle);attr=_type.default.copyAttributes(attributes,board.options,"incircle");var c$jscomp$0=_circle.default.createCircle(board,[p,function(){var a=Math.sqrt((parents[1].X()-parents[2].X())*(parents[1].X()-parents[2].X())+(parents[1].Y()-parents[2].Y())*(parents[1].Y()-parents[2].Y())),b=Math.sqrt((parents[0].X()-parents[2].X())*
(parents[0].X()-parents[2].X())+(parents[0].Y()-parents[2].Y())*(parents[0].Y()-parents[2].Y())),c=Math.sqrt((parents[1].X()-parents[0].X())*(parents[1].X()-parents[0].X())+(parents[1].Y()-parents[0].Y())*(parents[1].Y()-parents[0].Y())),s=(a+b+c)/2;return Math.sqrt((s-a)*(s-b)*(s-c)/s)}],attr);c$jscomp$0.elType="incircle";c$jscomp$0.setParents(parents);for(i=0;3>i;i++)_type.default.exists(parents[i]._is_new)?(c$jscomp$0.addChild(parents[i]),delete parents[i]._is_new):parents[i].addChild(c$jscomp$0);
c$jscomp$0.center=p;c$jscomp$0.subs={center:c$jscomp$0.center};c$jscomp$0.inherits.push(p)}catch(e){throw Error("JSXGraph: Can't create circumcircle with parent types '"+typeof parents[0]+"', '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point]");}return c$jscomp$0};_jxg.default.createReflection=function(board,parents,attributes){var i;for(i=0;i<parents.length;++i)parents[i]=board.select(parents[i]);i=_type.default.copyAttributes(attributes,board.options,
"reflection");if(_type.default.isPoint(parents[0]))var org=_type.default.providePoints(board,[parents[0]],attr2)[0];else if(parents[0].elementClass===_constants.default.OBJECT_CLASS_CURVE||parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE||parents[0].type===_constants.default.OBJECT_TYPE_POLYGON||parents[0].elementClass===_constants.default.OBJECT_CLASS_CIRCLE)org=parents[0];else throw Error("JSXGraph: Can't create reflection element with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+
"'.\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]");if(parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE)var l=parents[1];else throw Error("JSXGraph: Can't create reflected element with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]");var t=_transformation.default.createTransform(board,[l],{type:"reflect"});if(_type.default.isPoint(org))var r=_point.default.createPoint(board,
[org,t],i);else if(org.elementClass===_constants.default.OBJECT_CLASS_CURVE)r=_curve.default.createCurve(board,[org,t],i);else if(org.elementClass===_constants.default.OBJECT_CLASS_LINE)r=_line.default.createLine(board,[org,t],i);else if(org.type===_constants.default.OBJECT_TYPE_POLYGON)r=_polygon.default.createPolygon(board,[org,t],i);else if(org.elementClass===_constants.default.OBJECT_CLASS_CIRCLE)if("euclidean"===i.type.toLowerCase()){var attr2=_type.default.copyAttributes(attributes,board.options,
"reflection","center");parents=_point.default.createPoint(board,[org.center,t],attr2);parents.prepareUpdate().update().updateVisibility(_type.default.evaluate(parents.visProp.visible)).updateRenderer();r=_circle.default.createCircle(board,[parents,function(){return org.Radius()}],i)}else r=_circle.default.createCircle(board,[org,t],i);else throw Error("JSXGraph: Can't create reflected element with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, line]");
_type.default.exists(org._is_new)&&(r.addChild(org),delete org._is_new);l.addChild(r);r.elType="reflection";r.addParents(l);r.prepareUpdate().update();_type.default.isPoint(r)&&(r.generatePolynomial=function(){var a1=l.point1.symbolic.x,a2=l.point1.symbolic.y,p1=org.symbolic.x,p2=org.symbolic.y,r1=r.symbolic.x,r2=r.symbolic.y,poly1=["((",r2,")-(",p2,"))*((",a2,")-(",l.point2.symbolic.y,"))+((",a1,")-(",l.point2.symbolic.x,"))*((",r1,")-(",p1,"))"].join("");a1=["((",r1,")-(",a1,"))^2+((",r2,")-(",
a2,"))^2-((",p1,")-(",a1,"))^2-((",p2,")-(",a2,"))^2"].join("");return[poly1,a1]});return r};_jxg.default.createMirrorElement=function(board,parents,attributes){var i;for(i=0;i<parents.length;++i)parents[i]=board.select(parents[i]);var attr=_type.default.copyAttributes(attributes,board.options,"mirrorelement");if(_type.default.isPoint(parents[0]))var org=_type.default.providePoints(board,[parents[0]],attr)[0];else if(parents[0].elementClass===_constants.default.OBJECT_CLASS_CURVE||parents[0].elementClass===
_constants.default.OBJECT_CLASS_LINE||parents[0].type===_constants.default.OBJECT_TYPE_POLYGON||parents[0].elementClass===_constants.default.OBJECT_CLASS_CIRCLE)org=parents[0];else throw Error("JSXGraph: Can't create mirror element with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]");if(_type.default.isPoint(parents[1])){var attr2=_type.default.copyAttributes(attributes,board.options,"mirrorelement","point");
i=_type.default.providePoints(board,[parents[1]],attr2)[0]}else throw Error("JSXGraph: Can't create mirror element with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]");var t=_transformation.default.createTransform(board,[Math.PI,i],{type:"rotate"});if(_type.default.isPoint(org))board=_point.default.createPoint(board,[org,t],attr);else if(org.elementClass===_constants.default.OBJECT_CLASS_CURVE)board=_curve.default.createCurve(board,
[org,t],attr);else if(org.elementClass===_constants.default.OBJECT_CLASS_LINE)board=_line.default.createLine(board,[org,t],attr);else if(org.type===_constants.default.OBJECT_TYPE_POLYGON)board=_polygon.default.createPolygon(board,[org,t],attr);else if(org.elementClass===_constants.default.OBJECT_CLASS_CIRCLE)"euclidean"===attr.type.toLowerCase()?(attr2=_type.default.copyAttributes(attributes,board.options,"mirrorelement","center"),parents=_point.default.createPoint(board,[org.center,t],attr2),parents.prepareUpdate().update().updateVisibility(_type.default.evaluate(parents.visProp.visible)).updateRenderer(),
board=_circle.default.createCircle(board,[parents,function(){return org.Radius()}],attr)):board=_circle.default.createCircle(board,[org,t],attr);else throw Error("JSXGraph: Can't create mirror element with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point|line|curve|polygon|circle|arc|sector, point]");_type.default.exists(org._is_new)&&(board.addChild(org),delete org._is_new);i.addChild(board);board.elType="mirrorelement";board.addParents(i);board.prepareUpdate().update();
return board};_jxg.default.createMirrorPoint=function(board,parents,attributes){board=_jxg.default.createMirrorElement(board,parents,attributes);board.elType="mirrorpoint";return board};_jxg.default.createIntegral=function(board,parents,attributes){var t=null;if(_type.default.isArray(parents[0])&&parents[1].elementClass===_constants.default.OBJECT_CLASS_CURVE){var interval=parents[0];var curve=parents[1]}else if(_type.default.isArray(parents[1])&&parents[0].elementClass===_constants.default.OBJECT_CLASS_CURVE)interval=
parents[1],curve=parents[0];else throw Error("JSXGraph: Can't create integral with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [[number|function,number|function],curve]");var attr=_type.default.copyAttributes(attributes,board.options,"integral");attr.withLabel=!1;var p=board.create("curve",[[0],[0]],attr);var start=interval[0];attr=interval[1];if(_type.default.isFunction(start)){var startx=start;parents=function(){return curve.Y(startx())};start=startx()}else startx=
start,parents=curve.Y(start);if(_type.default.isFunction(attr)){var endx=attr;start=function(){return curve.Y(endx())};attr=endx()}else endx=attr,start=curve.Y(attr);attr=_type.default.copyAttributes(attributes,board.options,"integral","curveLeft");var pa_on_curve=board.create("glider",[startx,parents,curve],attr);_type.default.isFunction(startx)&&pa_on_curve.hideElement();attr=_type.default.copyAttributes(attributes,board.options,"integral","baseLeft");var pa_on_axis=board.create("point",[function(){return"y"===
_type.default.evaluate(p.visProp.axis)?0:pa_on_curve.X()},function(){return"y"===_type.default.evaluate(p.visProp.axis)?pa_on_curve.Y():0}],attr);attr=_type.default.copyAttributes(attributes,board.options,"integral","curveRight");var pb_on_curve=board.create("glider",[endx,start,curve],attr);_type.default.isFunction(endx)&&pb_on_curve.hideElement();attr=_type.default.copyAttributes(attributes,board.options,"integral","baseRight");var pb_on_axis=board.create("point",[function(){return"y"===_type.default.evaluate(p.visProp.axis)?
0:pb_on_curve.X()},function(){return"y"===_type.default.evaluate(p.visProp.axis)?pb_on_curve.Y():0}],attr);attr=_type.default.copyAttributes(attributes,board.options,"integral");!1!==attr.withlabel&&"y"!==attr.axis&&(attr=_type.default.copyAttributes(attributes,board.options,"integral","label"),attr=_type.default.copyAttributes(attr,board.options,"label"),t=board.create("text",[function(){var off=new _coords.default(_constants.default.COORDS_BY_SCREEN,[_type.default.evaluate(this.visProp.offset[0])+
this.board.origin.scrCoords[1],0],this.board,!1),bb=this.board.getBoundingBox(),dx=.1*(bb[2]-bb[0]),x=pb_on_curve.X();x<bb[0]?x=bb[0]+dx:x>bb[2]&&(x=bb[2]-dx);return x+off.usrCoords[1]},function(){var off=new _coords.default(_constants.default.COORDS_BY_SCREEN,[0,_type.default.evaluate(this.visProp.offset[1])+this.board.origin.scrCoords[2]],this.board,!1),bb=this.board.getBoundingBox(),dy=.1*(bb[1]-bb[3]),y=pb_on_curve.Y();y>bb[1]?y=bb[1]-dy:y<bb[3]&&(y=bb[3]+dy);return y+off.usrCoords[2]},function(){var Int=
_numerics.default.NewtonCotes([pa_on_axis.X(),pb_on_axis.X()],curve.Y);return"\x26int; \x3d "+_type.default.toFixed(Int,4)}],attr),t.dump=!1,pa_on_curve.addChild(t),pb_on_curve.addChild(t));pa_on_curve.dump=!1;pa_on_axis.dump=!1;pb_on_curve.dump=!1;pb_on_axis.dump=!1;p.elType="integral";p.setParents([curve.id,interval]);p.subs={curveLeft:pa_on_curve,baseLeft:pa_on_axis,curveRight:pb_on_curve,baseRight:pb_on_axis};p.inherits.push(pa_on_curve,pa_on_axis,pb_on_curve,pb_on_axis);attr.withLabel&&(p.subs.label=
t,p.inherits.push(t));p.Value=function(){return _numerics.default.I([pa_on_axis.X(),pb_on_axis.X()],curve.Y)};p.updateDataArray=function(){var i;if("y"===_type.default.evaluate(this.visProp.axis)){if(pa_on_curve.Y()<pb_on_curve.Y()){var x=pa_on_curve.X();var lowy=pa_on_curve.Y();var upx=pb_on_curve.X();var upy=pb_on_curve.Y()}else x=pb_on_curve.X(),lowy=pb_on_curve.Y(),upx=pa_on_curve.X(),upy=pa_on_curve.Y();var left=Math.min(x,upx);var right=Math.max(x,upx);x=[0,x];var y=[lowy,lowy];for(i=0;i<curve.numberPoints;i++)lowy<=
curve.points[i].usrCoords[2]&&left<=curve.points[i].usrCoords[1]&&curve.points[i].usrCoords[2]<=upy&&curve.points[i].usrCoords[1]<=right&&(x.push(curve.points[i].usrCoords[1]),y.push(curve.points[i].usrCoords[2]));x.push(upx);y.push(upy);x.push(0);y.push(upy);x.push(0);y.push(lowy)}else{pa_on_axis.X()<pb_on_axis.X()?(left=pa_on_axis.X(),right=pb_on_axis.X()):(left=pb_on_axis.X(),right=pa_on_axis.X());x=[left,left];y=[0,curve.Y(left)];for(i=0;i<curve.numberPoints;i++)left<=curve.points[i].usrCoords[1]&&
curve.points[i].usrCoords[1]<=right&&(x.push(curve.points[i].usrCoords[1]),y.push(curve.points[i].usrCoords[2]));x.push(right);y.push(curve.Y(right));x.push(right);y.push(0);x.push(left);y.push(0)}this.dataX=x;this.dataY=y};pa_on_curve.addChild(p);pb_on_curve.addChild(p);pa_on_axis.addChild(p);pb_on_axis.addChild(p);p.baseLeft=pa_on_axis;p.baseRight=pb_on_axis;p.curveLeft=pa_on_curve;p.curveRight=pb_on_curve;p.methodMap=_jxg.default.deepCopy(p.methodMap,{curveLeft:"curveLeft",baseLeft:"baseLeft",
curveRight:"curveRight",baseRight:"baseRight",Value:"Value"});p.label=t;return p};_jxg.default.createGrid=function(board,parents,attributes){parents=_type.default.copyAttributes(attributes,board.options,"grid");var c=board.create("curve",[[null],[null]],parents);c.elType="grid";c.type=_constants.default.OBJECT_TYPE_GRID;c.updateDataArray=function(){var gridX=_type.default.evaluate(this.visProp.gridx),gridY=_type.default.evaluate(this.visProp.gridy);var topLeft=_type.default.isArray(this.visProp.topleft)?
new _coords.default(_type.default.evaluate(this.visProp.tltype)||_constants.default.COORDS_BY_USER,this.visProp.topleft,board):new _coords.default(_constants.default.COORDS_BY_SCREEN,[0,0],board);var bottomRight=_type.default.isArray(this.visProp.bottomright)?new _coords.default(_type.default.evaluate(this.visProp.brtype)||_constants.default.COORDS_BY_USER,this.visProp.bottomright,board):new _coords.default(_constants.default.COORDS_BY_SCREEN,[board.canvasWidth,board.canvasHeight],board);board.options.grid.hasGrid=
!0;c.dataX=[];c.dataY=[];var start=Math.floor(topLeft.usrCoords[2]/gridY)*gridY;var end=Math.ceil(bottomRight.usrCoords[2]/gridY)*gridY;topLeft.usrCoords[2]<bottomRight.usrCoords[2]&&(start=Math.ceil(bottomRight.usrCoords[2]/gridY)*gridY,end=Math.floor(topLeft.usrCoords[2]/gridY)*gridY);for(;start>end-gridY;start-=gridY)c.dataX.push(topLeft.usrCoords[1],bottomRight.usrCoords[1],NaN),c.dataY.push(start,start,NaN);start=Math.ceil(topLeft.usrCoords[1]/gridX)*gridX;end=Math.floor(bottomRight.usrCoords[1]/
gridX)*gridX;topLeft.usrCoords[1]>bottomRight.usrCoords[1]&&(start=Math.floor(bottomRight.usrCoords[1]/gridX)*gridX,end=Math.ceil(topLeft.usrCoords[1]/gridX)*gridX);for(;start<end+gridX;start+=gridX)c.dataX.push(start,start,NaN),c.dataY.push(topLeft.usrCoords[2],bottomRight.usrCoords[2],NaN)};c.hasPoint=function(){return!1};board.grids.push(c);return c};_jxg.default.createInequality=function(board,parents,attributes){var attr=_type.default.copyAttributes(attributes,board.options,"inequality");if(parents[0].elementClass===
_constants.default.OBJECT_CLASS_LINE){var a=board.create("curve",[[],[]],attr);a.hasPoint=function(){return!1};a.updateDataArray=function(){var i1=board.getBoundingBox();var factor=attr.inverse?-1:1;var i2=1.5*Math.max(i1[2]-i1[0],i1[1]-i1[3]);var dp={coords:{usrCoords:[1,(i1[0]+i1[2])/2,attr.inverse?i1[1]:i1[3]]}},slope1=parents[0].stdform.slice(1);var h=1.5*Math.max(_geometry.default.perpendicular(parents[0],dp,board)[0].distance(_constants.default.COORDS_BY_USER,dp.coords),i2);h*=factor;dp={coords:{usrCoords:[1,
(i1[0]+i1[2])/2,(i1[1]+i1[3])/2]}};dp=Math.abs(_math.default.innerProduct(dp.coords.usrCoords,parents[0].stdform,3))>=_math.default.eps?_geometry.default.perpendicular(parents[0],dp,board)[0].usrCoords:dp.coords.usrCoords;i1=[1,dp[1]+slope1[1]*i2,dp[2]-slope1[0]*i2];i2=[1,dp[1]-slope1[1]*i2,dp[2]+slope1[0]*i2];this.dataX=[i1[1],i1[1]+slope1[0]*h,i2[1]+slope1[0]*h,i2[1],i1[1]];this.dataY=[i1[2],i1[2]+slope1[1]*h,i2[2]+slope1[1]*h,i2[2],i1[2]]}}else if(parents[0].elementClass===_constants.default.OBJECT_CLASS_CURVE&&
"functiongraph"===parents[0].visProp.curvetype)a=board.create("curve",[[],[]],attr),a.updateDataArray=function(){var bbox=this.board.getBoundingBox(),last,mi=parents[0].minX(),ma=parents[0].maxX();var first=.3*(bbox[1]-bbox[3]);var infty=_type.default.evaluate(this.visProp.inverse)?1:3;this.dataX=[];this.dataY=[];var len=parents[0].points.length;if(0!==len)for(bbox[1]+=first,bbox[3]-=first,last=-1;last<len-1;){var i=last+1;for(first=len;i<len;i++)if(parents[0].points[i].isReal()){first=i;break}if(first>=
len)break;i=first;for(last=len-1;i<len-1;i++)if(!parents[0].points[i+1].isReal()){last=i;break}i=parents[0].points[first].usrCoords[1];var points=parents[0].points[last].usrCoords[1];i=0===first?mi:i;var curve_ma=last===len-1?ma:points;points=[];points.push([1,i,bbox[infty]]);points.push([1,i,parents[0].points[first].usrCoords[2]]);for(i=first;i<=last;i++)points.push(parents[0].points[i].usrCoords);points.push([1,curve_ma,parents[0].points[last].usrCoords[2]]);points.push([1,curve_ma,bbox[infty]]);
points.push(points[0]);for(i=0;i<points.length;i++)this.dataX.push(points[i][1]),this.dataY.push(points[i][2]);last<len-1&&(this.dataX.push(NaN),this.dataY.push(NaN))}},a.hasPoint=function(){return!1};else if(attributes=_type.default.createFunction(parents[0]),!_type.default.exists(attributes))throw Error("JSXGraph: Can't create area with the given parents.\nPossible parent types: [line], [function]");a.addParents(parents[0]);return a};_jxg.default.registerElement("arrowparallel",_jxg.default.createArrowParallel);
_jxg.default.registerElement("bisector",_jxg.default.createBisector);_jxg.default.registerElement("bisectorlines",_jxg.default.createAngularBisectorsOfTwoLines);_jxg.default.registerElement("msector",_jxg.default.createMsector);_jxg.default.registerElement("circumcircle",_jxg.default.createCircumcircle);_jxg.default.registerElement("circumcirclemidpoint",_jxg.default.createCircumcenter);_jxg.default.registerElement("circumcenter",_jxg.default.createCircumcenter);_jxg.default.registerElement("incenter",
_jxg.default.createIncenter);_jxg.default.registerElement("incircle",_jxg.default.createIncircle);_jxg.default.registerElement("integral",_jxg.default.createIntegral);_jxg.default.registerElement("midpoint",_jxg.default.createMidpoint);_jxg.default.registerElement("mirrorelement",_jxg.default.createMirrorElement);_jxg.default.registerElement("mirrorpoint",_jxg.default.createMirrorPoint);_jxg.default.registerElement("normal",_jxg.default.createNormal);_jxg.default.registerElement("orthogonalprojection",
_jxg.default.createOrthogonalProjection);_jxg.default.registerElement("parallel",_jxg.default.createParallel);_jxg.default.registerElement("parallelpoint",_jxg.default.createParallelPoint);_jxg.default.registerElement("perpendicular",_jxg.default.createPerpendicular);_jxg.default.registerElement("perpendicularpoint",_jxg.default.createPerpendicularPoint);_jxg.default.registerElement("perpendicularsegment",_jxg.default.createPerpendicularSegment);_jxg.default.registerElement("reflection",_jxg.default.createReflection);
_jxg.default.registerElement("grid",_jxg.default.createGrid);_jxg.default.registerElement("inequality",_jxg.default.createInequality);exports.default={createArrowParallel:_jxg.default.createArrowParallel,createBisector:_jxg.default.createBisector,createAngularBisectorOfTwoLines:_jxg.default.createAngularBisectorsOfTwoLines,createCircumcircle:_jxg.default.createCircumcircle,createCircumcenter:_jxg.default.createCircumcenter,createIncenter:_jxg.default.createIncenter,createIncircle:_jxg.default.createIncircle,
createIntegral:_jxg.default.createIntegral,createMidpoint:_jxg.default.createMidpoint,createMirrorElement:_jxg.default.createMirrorElement,createMirrorPoint:_jxg.default.createMirrorPoint,createNormal:_jxg.default.createNormal,createOrthogonalProjection:_jxg.default.createOrthogonalProjection,createParallel:_jxg.default.createParallel,createParallelPoint:_jxg.default.createParallelPoint,createPerpendicular:_jxg.default.createPerpendicular,createPerpendicularPoint:_jxg.default.createPerpendicularPoint,
createPerpendicularSegmen:_jxg.default.createPerpendicularSegment,createReflection:_jxg.default.createReflection,createGrid:_jxg.default.createGrid,createInequality:_jxg.default.createInequality}}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$element$composition.js.map
