{
"version":3,
"file":"module$node_modules$three$src$renderers$WebGLCubeRenderTarget.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/three/src/renderers/WebGLCubeRenderTarget.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$src$renderers$WebGLCubeRenderTarget\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLCubeRenderTarget = void 0;\n\nvar _constants = require(\"../constants.js\");\n\nvar _Mesh = require(\"../objects/Mesh.js\");\n\nvar _BoxGeometry = require(\"../geometries/BoxGeometry.js\");\n\nvar _ShaderMaterial = require(\"../materials/ShaderMaterial.js\");\n\nvar _UniformsUtils = require(\"./shaders/UniformsUtils.js\");\n\nvar _WebGLRenderTarget = require(\"./WebGLRenderTarget.js\");\n\nvar _CubeCamera = require(\"../cameras/CubeCamera.js\");\n\nvar _CubeTexture = require(\"../textures/CubeTexture.js\");\n\nclass WebGLCubeRenderTarget extends _WebGLRenderTarget.WebGLRenderTarget {\n  constructor(size = 1, options = {}) {\n    super(size, size, options);\n    this.isWebGLCubeRenderTarget = true;\n    const image = {\n      width: size,\n      height: size,\n      depth: 1\n    };\n    const images = [image, image, image, image, image, image];\n    this.texture = new _CubeTexture.CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding); // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)\n    // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,\n    // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.\n    // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped\n    // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture\n    // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).\n\n    this.texture.isRenderTargetTexture = true;\n    this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;\n    this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : _constants.LinearFilter;\n  }\n\n  fromEquirectangularTexture(renderer, texture) {\n    this.texture.type = texture.type;\n    this.texture.encoding = texture.encoding;\n    this.texture.generateMipmaps = texture.generateMipmaps;\n    this.texture.minFilter = texture.minFilter;\n    this.texture.magFilter = texture.magFilter;\n    const shader = {\n      uniforms: {\n        tEquirect: {\n          value: null\n        }\n      },\n      vertexShader:\n      /* glsl */\n      `\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t`,\n      fragmentShader:\n      /* glsl */\n      `\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t`\n    };\n    const geometry = new _BoxGeometry.BoxGeometry(5, 5, 5);\n    const material = new _ShaderMaterial.ShaderMaterial({\n      name: 'CubemapFromEquirect',\n      uniforms: (0, _UniformsUtils.cloneUniforms)(shader.uniforms),\n      vertexShader: shader.vertexShader,\n      fragmentShader: shader.fragmentShader,\n      side: _constants.BackSide,\n      blending: _constants.NoBlending\n    });\n    material.uniforms.tEquirect.value = texture;\n    const mesh = new _Mesh.Mesh(geometry, material);\n    const currentMinFilter = texture.minFilter; // Avoid blurred poles\n\n    if (texture.minFilter === _constants.LinearMipmapLinearFilter) texture.minFilter = _constants.LinearFilter;\n    const camera = new _CubeCamera.CubeCamera(1, 10, this);\n    camera.update(renderer, mesh);\n    texture.minFilter = currentMinFilter;\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    return this;\n  }\n\n  clear(renderer, color, depth, stencil) {\n    const currentRenderTarget = renderer.getRenderTarget();\n\n    for (let i = 0; i < 6; i++) {\n      renderer.setRenderTarget(this, i);\n      renderer.clear(color, depth, stencil);\n    }\n\n    renderer.setRenderTarget(currentRenderTarget);\n  }\n\n}\n\nexports.WebGLCubeRenderTarget = WebGLCubeRenderTarget;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","WebGLCubeRenderTarget","_constants","_Mesh","_BoxGeometry","_ShaderMaterial","_UniformsUtils","_WebGLRenderTarget","_CubeCamera","_CubeTexture","WebGLRenderTarget","constructor","size","options","isWebGLCubeRenderTarget","image","width","height","depth","texture","CubeTexture","images","mapping","wrapS","wrapT","magFilter","minFilter","format","type","anisotropy","encoding","isRenderTargetTexture","generateMipmaps","undefined","LinearFilter","fromEquirectangularTexture","renderer","geometry","BoxGeometry","material","ShaderMaterial","name","uniforms","cloneUniforms","tEquirect","vertexShader","fragmentShader","side","BackSide","blending","NoBlending","mesh","Mesh","currentMinFilter","LinearMipmapLinearFilter","update","camera","CubeCamera","dispose","clear","color","stencil","currentRenderTarget","getRenderTarget","i","setRenderTarget"]
}
