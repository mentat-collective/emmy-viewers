{
"version":3,
"file":"module$node_modules$$motionone$easing$dist$cubic_bezier_cjs.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,2DAAA,CAAgF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGxHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIC,MAAQN,OAAA,CAAQ,qDAAR,CAoDZE,QAAQK,CAAAA,WAAR,CATAA,QAAoB,CAACC,GAAD,CAAMC,GAAN,CAAWC,GAAX,CAAgBC,GAAhB,CAAqB,CAErC,MAAIH,IAAJ,GAAYC,GAAZ,EAAmBC,GAAnB,GAA2BC,GAA3B,CACWL,KAAMM,CAAAA,UADjB,CAIQC,CAAD,EAAO,CAAA,GAAM,CAAN,GAAAA,CAAA,EAAiB,CAAjB,GAAWA,CAAX,CAAA,CAAyB,IAAA,WAAA,CAAA,CAAA,WAAA,CAtBvC,KAAIC,QAAJ,CACIC,QADJ,CAEIC,EAAI,CACR,GACID,SAEA,CAFWE,UAEX,EAFyBC,UAEzB,CAFsCD,UAEtC,EAFoD,CAEpD,CADAH,QACA,IAV6B,CAU7B,CAVmC,CAUnC,CAgBmCJ,GAhBnC,CAV8C,CAU9C,CAgBmCF,GAhBnC,EADsBO,QACtB,EAV+D,CAU/D,CAgBmCL,GAhBnC;AAV0E,CAU1E,CAgBmCF,GAhBnC,GADsBO,QACtB,CAV2F,CAU3F,CAgBmCP,GAhBnC,EADsBO,QACtB,CAgBmCI,CAhBnC,CAAe,CAAf,CAAIL,QAAJ,CACII,UADJ,CACiBH,QADjB,CAIIE,UAJJ,CAIiBF,QAPrB,OANyBK,IAMzB,CASSC,IAAKC,CAAAA,GAAL,CAASR,QAAT,CATT,EAL6BS,EAK7B,CAUI,EAAEP,CAVN,CAWA,EAAA,CAAOD,QAQgC,EAAA,IA1BN,CA0BM,CA1BA,CA0BA,CAAAS,GAAA,CA1BW,CA0BX,CAAAC,GAAA,EAAAZ,CAAA,EA1B4B,CA0B5B,CAAAW,GAAA,CA1BuC,CA0BvC,CAAAC,GAAA,GAAAZ,CAAA,CA1BwD,CA0BxD,CAAAY,GAAzB,CAAA,MAAA,EAAA,CANuB,CAhD+E;",
"sources":["node_modules/@motionone/easing/dist/cubic-bezier.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$motionone$easing$dist$cubic_bezier_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\n\n/*\n  Bezier function generator\n\n  This has been modified from Ga\u00ebtan Renaudeau's BezierEasing\n  https://github.com/gre/bezier-easing/blob/master/src/index.js\n  https://github.com/gre/bezier-easing/blob/master/LICENSE\n  \n  I've removed the newtonRaphsonIterate algo because in benchmarking it\n  wasn't noticiably faster than binarySubdivision, indeed removing it\n  usually improved times, depending on the curve.\n\n  I also removed the lookup table, as for the added bundle size and loop we're\n  only cutting ~4 or so subdivision iterations. I bumped the max iterations up\n  to 12 to compensate and this still tended to be faster for no perceivable\n  loss in accuracy.\n\n  Usage\n    const easeOut = cubicBezier(.17,.67,.83,.67);\n    const x = easeOut(0.5); // returns 0.627...\n*/\n// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\nconst calcBezier = (t, a1, a2) => (((1.0 - 3.0 * a2 + 3.0 * a1) * t + (3.0 * a2 - 6.0 * a1)) * t + 3.0 * a1) * t;\nconst subdivisionPrecision = 0.0000001;\nconst subdivisionMaxIterations = 12;\nfunction binarySubdivide(x, lowerBound, upperBound, mX1, mX2) {\n    let currentX;\n    let currentT;\n    let i = 0;\n    do {\n        currentT = lowerBound + (upperBound - lowerBound) / 2.0;\n        currentX = calcBezier(currentT, mX1, mX2) - x;\n        if (currentX > 0.0) {\n            upperBound = currentT;\n        }\n        else {\n            lowerBound = currentT;\n        }\n    } while (Math.abs(currentX) > subdivisionPrecision &&\n        ++i < subdivisionMaxIterations);\n    return currentT;\n}\nfunction cubicBezier(mX1, mY1, mX2, mY2) {\n    // If this is a linear gradient, return linear easing\n    if (mX1 === mY1 && mX2 === mY2)\n        return utils.noopReturn;\n    const getTForX = (aX) => binarySubdivide(aX, 0, 1, mX1, mX2);\n    // If animation is at start/end, return t without easing\n    return (t) => t === 0 || t === 1 ? t : calcBezier(getTForX(t), mY1, mY2);\n}\n\nexports.cubicBezier = cubicBezier;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","utils","cubicBezier","mX1","mY1","mX2","mY2","noopReturn","t","currentX","currentT","i","lowerBound","upperBound","x","subdivisionPrecision","Math","abs","subdivisionMaxIterations","a2","a1"]
}
