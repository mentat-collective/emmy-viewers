{"version":3,"sources":["sicmutils/polynomial/interpolate.cljc"],"mappings":"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","names":["sicmutils.polynomial.interpolate/lagrange","points","x","cljs.core/vec","n","cljs.core/count","build-term","p__85480","vec__85482","cljs.core.nth","i","a","fa","others","iter__4652__auto__","s__85489","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","b__85491","cljs.core/chunk-buffer","i__85490","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__85488","cljs.core/chunk-rest","cljs.core/first","cljs.core/cons","cljs.core/rest","j","cljs.core.range","cljs.core.not_EQ_","cljs.core.get_in","p","cljs.core.apply","sicmutils.generic/*","p1__85476#","cljs.core.map","sicmutils.generic._","q","p1__85477#","sicmutils.generic._STAR_","sicmutils.generic/invert","cljs.core.transduce","cljs.core.map_indexed","sicmutils.generic/+","sicmutils.polynomial.interpolate/neville-recursive","cljs.core._EQ_","vec__85542","vec__85545","_","y","vec__85550","vec__85553","l-branch","cljs.core/pop","r-branch","cljs.core.subvec","xl","xr","cljs.core/peek","sicmutils.generic._SLASH_","sicmutils.generic._PLUS_","evaluate","p__85566","vec__85568","sicmutils.polynomial.interpolate/neville-prepare","fx","sicmutils.polynomial.interpolate/neville-combine-fn","p__85574","p__85575","vec__85576","vec__85579","pl","pr","plr","sicmutils.polynomial.interpolate/neville-next-column","prev-column","sicmutils.polynomial.interpolate/neville-tableau","cljs.core/iterate","cljs.core.take_while","sicmutils.polynomial.interpolate/first-terms","tableau","sicmutils.polynomial.interpolate/neville-present","row","sicmutils.polynomial.interpolate/neville-incremental","sicmutils.polynomial.interpolate/tableau-fn","prepare","merge","next-col","previous-col","sicmutils.polynomial.interpolate/neville-merge","p__85598","p__85599","vec__85600","vec__85603","var_args","G__85607","sicmutils.polynomial.interpolate/neville","js/Error","column","p__85608","vec__85609","sicmutils.polynomial.interpolate/mn-prepare","sicmutils.polynomial.interpolate/mn-merge","p__85615","p__85616","vec__85617","vec__85620","dl","cr","diff","den","factor","c","d","sicmutils.polynomial.interpolate/mn-present","sicmutils.util.aggregate.scan","p__85628","vec__85629","sicmutils.polynomial.interpolate/modified-neville","sicmutils.polynomial.interpolate/tableau-fold-fn","present","prev-row","point","cljs.core.reductions","sicmutils.polynomial.interpolate/neville-fold","cljs.core/last","sicmutils.polynomial.interpolate/mn-present-final","p__85644","vec__85645","sicmutils.util.aggregate/*fold*","sicmutils.polynomial.interpolate/modified-neville-fold","sicmutils.polynomial.interpolate/neville-sum","sicmutils.algebra.fold.fold__GT_sum_fn","sicmutils.polynomial.interpolate/neville-scan","sicmutils.algebra.fold.fold__GT_scan_fn","sicmutils.polynomial.interpolate/modified-neville-sum","sicmutils.polynomial.interpolate/modified-neville-scan","cljs.core/chunk-first"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.polynomial.interpolate\n  \"This namespace contains a discussion of polynomial interpolation, and different\n  methods for fitting a polynomial of degree `N-1` to `N` points and evaluating\n  that polynomial at some different `x`.\"\n  (:require [sicmutils.algebra.fold :as af]\n            [sicmutils.generic :as g]\n            [sicmutils.util.aggregate :as ua]))\n\n(defn lagrange\n  \"Generates a lagrange interpolating polynomial that fits every point in the\n  supplied sequence `points` (of form `[x (f x)]`) and returns the value of the\n  polynomial evaluated at `x`.\n\n  The Lagrange polynomial has this form:\n\n  ```\n  g(x) =  (f(a) * [(x-b)(x-c)...] / [(a-b)(a-c)...])\n        + (f(b) * [(x-a)(x-c)...] / [(b-a)(b-c)...])\n        + ...\n  ```\n\n  for points `[a f(a)], [b f(b)], [c f(c)]` etc.\n\n  This particular method of interpolating `x` into the polynomial is\n  inefficient; any new calculation requires fully recomputing. Takes `O(n^2)`\n  operations in the number of points.\n  \"\n  [points x]\n  (let [points     (vec points)\n        n          (count points)\n        build-term (fn [i [a fa]]\n                     (let [others (for [j (range n) :when (not= i j)]\n                                    (get-in points [j 0]))\n                           p (apply g/* (map #(g/- x %) others))\n                           q (apply g/* (map #(g/- a %) others))]\n                       (g/* (g/invert q) fa p)))]\n    (transduce (map-indexed build-term)\n               g/+\n               points)))\n\n;; Lagrange's interpolating polynomial is straightforward, but not terribly\n;; efficient; every time we change `points` or `x` we have to redo the entire\n;; calculation. Ideally we'd like to be able to perform:\n;;\n;; 1. Some computation on `points` that would let us efficiently evaluate the\n;;    fitted polynomial for different values of `x` in O(n) time, or\n;;\n;; 2. A computation on a particular `x` that would let us efficiently add new\n;;    points to the set we use to generate the interpolating polynomial.\n;;\n;; \"Neville's algorithm\" lets us generate the same interpolating polynomial\n;; recursively. By flipping the recursion around and generating values from the\n;; bottom up, we can achieve goal #2 and add new points incrementally.\n;;\n;; ## Neville's Algorithm\n;;\n;; Start the recursion with a single point. Any point $(x, f(x))$ has a unique\n;; 0th order polynomial passing through it - the constant function $P(x) = f(x)$.\n;; For points $x_a$, $x_b$, let's call this $P_a$, $P_b$, etc.\n;;\n;; $P_{ab}$ is the unique FIRST order polynomial (ie, a line) going through\n;; points $x_a$ and $x_b$.\n;;\n;; this first recursive step gives us this rule:\n;;\n;; $$P_{ab}(x) = [(x - x_b) P_a(x) - (x - x_a) P_b(x)] / [x_a - x_b]$$\n;;\n;; For higher order terms like $P_{abcd}$, let's call $P_{abc}$ 'P_l', and\n;; $P_{bcd}$ 'P_r' (the polynomial fitted through the left and right set of\n;; points).\n;;\n;; Similarly, the left and rightmost inputs - $x_a$ and $x_b$ - will be $x_l$\n;; and $x_r$.\n;;\n;; Neville's algorithm states that:\n;;\n;; $$P(x) = [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n;;\n;; This recurrence works because the two parents $P_l$ and $P_r$ already agree\n;; at all points except $x_l$ and $x_r$.\n\n(defn neville-recursive\n  \"Top-down implementation of [Neville's\n  algorithm]((https://en.wikipedia.org/wiki/Neville%27s_algorithm))\n\n  Returns the value of `P(x)`, where `P` is a polynomial fit (using Neville's\n  algorithm) to every point in the supplied sequence `points` (of form `[x (f\n  x)]`)\n\n  The efficiency and results should be identical to\n  [[sicmutils.numerical.interpolate/lagrange]]. This function represents a step\n  on the journey toward more incremental methods of polynomial interpolation.\n\n  References:\n\n  - Press's Numerical Recipes (p103), [chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)\"\n  [points x]\n  (letfn [(evaluate [points]\n            (if (= 1 (count points))\n              (let [[[_ y]] points]\n                y)\n              (let [l-branch (pop points)\n                    r-branch (subvec points 1)\n                    [xl]     (first points)\n                    [xr]     (peek points)]\n                (g// (g/+ (g/* (g/- x xr) (evaluate l-branch))\n                          (g/* (g/- xl x) (evaluate r-branch)))\n                     (g/- xl xr)))))]\n    (evaluate (vec points))))\n\n;; ## Tableau-based Methods\n\n;; Neville's algorithm generates each new polynomial from $P_l$ and $P_r$, using\n;; this recursion to incorporate the full set of points.\n;;\n;; You can write these out these relationships in a \"tableau\" that grows to the\n;; right from an initial left column:\n;;\n;;```\n;; p0\n;;  \\\n;;  p01\n;;  /  \\\n;; p1  p012\n;;  \\  /  \\\n;; p12   p0123\n;;  /  \\  /  \\\n;; p2  p123   p01234\n;;  \\  /  \\  /\n;; p23   p1234\n;;  /  \\  /\n;; p3  p234\n;;  \\  /\n;;  p34\n;;  /\n;; p4\n;;```\n\n;; The next few functions will discuss \"rows\" and \"columns\" of the tableau. That\n;; refers to the rows and columns of this representation;\n;;\n;; p0 p01 p012 p0123 p01234\n;; p1 p12 p123 p1234 .\n;; p2 p23 p234 .     .\n;; p3 p34 .    .     .\n;; p4 .   .    .     .\n;; .  .   .    .     .\n;; .  .   .    .     .\n;; .  .   .    .     .\n;;\n;; The first column here is the initial set of points. Each entry in each\n;; successive column is generated through some operation between the entry to\n;; its left, and the entry one left and one down.\n;;\n;; Look again at Neville's algorithm:\n;;\n;; $$P(x) = [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n;;\n;; $l$ refers to the entry in the same row, previous column, while $r$ is one\n;; row lower, previous column.\n;;\n;; If each cell in the above tableau tracked:\n;;\n;; - the value of P(x) for the cell\n;; - $x_l$, the x value of the leftmost point incorporated so far\n;; - $x_r$, the right point\n;;\n;; we could build up Neville's rule incrementally. Let's attempt to build a\n;; function of this signature:\n\n(comment\n  (defn _neville-incremental\n    \"Takes a potentially lazy sequence of `points` and a point `x` and generates a\n  lazy sequence of approximations of P(x).\n\n  entry `N` in the returned sequence is the estimate using a polynomial\n  generated from the first `N` points of the input sequence.\"\n    [_points _x]\n    ,,,))\n;;\n;; First, write a function to process each initial point into a vector that\n;; contains each of those required elements:\n\n(defn- neville-prepare\n  \"Processes each point of the form `[x, (f x)]` into:\n\n  ```\n  $$[x_l, x_r, p]$$\n  ```\n\n  where $p$ is the polynomial that spans all points from $l$ to $r$. The\n  recursion starts with $p = f(x)$.\n  \"\n  [[x fx]]\n  [x x fx])\n\n;; Next, a function that generates the next entry, given l and r:\n\n(defn- neville-combine-fn\n  \"Given some value $x$, returns a function that combines $l$ and $r$ entries in\n  the tableau, arranged like this:\n\n  ```\n  l -- return\n     /\n    /\n   /\n  r\n  ```\n\n  generates the `return` entry of the form\n\n  $$[x_l, x_r, p]$$.\"\n  [x]\n  (fn [[xl _ pl] [_ xr pr]]\n    (let [plr (g// (g/+ (g/* (g/- x xr) pl)\n                        (g/* (g/- xl x) pr))\n                   (g/- xl xr))]\n      [xl xr plr])))\n\n;; We can use higher-order functions to turn this function into a NEW function\n;; that can transform an entire column:\n\n(defn- neville-next-column\n  \"This function takes some point $x$, and returns a new function that takes some\n  column in the tableau and generates the next column.\"\n  [x]\n  (fn [prev-column]\n    (map (neville-combine-fn x)\n         prev-column\n         (rest prev-column))))\n\n;; `neville-tableau` will generate the entire tableau:\n\n(defn- neville-tableau [points x]\n  (->> (map neville-prepare points)\n       (iterate (neville-next-column x))\n       (take-while seq)))\n\n;; Really, we're only interested in the first row:\n;;\n;; p0 p01 p012 p0123 p01234\n;;\n;; So define a function to grab that:\n\n(defn ^:no-doc first-terms [tableau]\n  (map first tableau))\n\n;; the final piece we need is a function that will extract the estimate from our\n;; row of $[x_l, x_r, p]$ vectors:\n\n(defn- neville-present [row]\n  (map peek row))\n\n;; Putting it all together:\n\n(defn neville-incremental\n  \"Takes a potentially lazy sequence of `points` and a point `x` and generates a\n  lazy sequence of approximations of P(x).\n\n  entry N in the returned sequence is the estimate using a polynomial generated\n  from the first N points of the input sequence.\"\n  [points x]\n  (neville-present\n   (first-terms\n    (neville-tableau points x))))\n\n;; How do we know this works? We can prove it by using generic arithmetic to\n;; compare the full symbolic lagrange polynomial to each entry in the successive\n;; approximation.\n\n(comment\n  (defn lagrange-incremental\n    \"Generates a sequence of estimates of `x` to polynomials fitted to `points`;\n  each entry uses one more point, just like [[neville-incremental]].\"\n    [points x]\n    (let [n (count points)]\n      (map (fn [i]\n             (lagrange (take i points) x))\n           (range 1 (inc n)))))\n\n  ;; Every point is the same!\n  (let [points [['x_1 'y_1] ['x_2 'y_2] ['x_3 'y_3] ['x_4 'y_4]]\n        diffs  (map (fn [neville lagrange]\n                      (g/simplify\n                       (g/- neville lagrange)))\n                    (neville-incremental points 'x)\n                    (lagrange-incremental points 'x))]\n    (every? zero? diffs))\n  ;; => true\n  )\n\n;; ## Generic Tableau Processing\n;;\n;; The above pattern, of processing tableau entries, is general enough that we\n;; can abstract it out into a higher order function that takes a `prepare` and\n;; `merge` function and generates a tableau. Any method generating a tableau can\n;; use a `present` function to extract the first row, OR to process the tableau\n;; in any other way that they like.\n;;\n;; This is necessarily more abstract! But we'll specialize it shortly, and\n;; rebuild `neville-incremental` into its final form.\n;;\n;; I'm keeping `points` in the argument vector for now, vs returning a new\n;; function; if you want to do this yourself, curry the function with `(partial\n;; tableau-fn prepare merge present)`.\n\n(defn tableau-fn\n  \"Returns a Newton-style approximation tableau, given:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  ```\n  l -- return\n     /\n    /\n   /\n  r\n  ```\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `points`: the (potentially lazy) sequence of points used to generate the\n  first column of the tableau.\n  \"\n  [prepare merge points]\n  (let [next-col (fn [previous-col]\n                   (map merge\n                        previous-col\n                        (rest previous-col)))]\n    (->> (map prepare points)\n         (iterate next-col)\n         (take-while seq))))\n\n;; Redefine `neville-merge` to make it slightly more efficient, with baked-in\n;; native operations:\n\n(defn- neville-merge\n  \"Returns a tableau merge function. Identical to [[neville-combine-fn]] but uses\n  native operations instead of generic operations.\"\n  [x]\n  (fn [[xl _ pl] [_ xr pr]]\n    (let [p (/ (+ (* (- x xr) pl)\n                  (* (- xl x) pr))\n               (- xl xr))]\n      [xl xr p])))\n\n;; And now, [[neville]], identical to [[neville-incremental]] except using the\n;; generic tableau generator.\n;;\n;; The form of the tableau also makes it easy to select a particular /column/\n;; instead of just the first row. Columns are powerful because they allow you to\n;; successively interpolate between pairs, triplets etc of points, instead of\n;; moving onto very high order polynomials.\n;;\n;; I'm not sure it's the best interface, but we'll add that arity here.\n\n(defn neville\n  \"Takes:\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  Said another way: the Nth in the returned sequence is the estimate using a\n  polynomial generated from the first `N` points of the input sequence:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  ```\n\n  This function generates each estimate using Neville's algorithm:\n\n  ```\n  $$P(x) = [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n  ```\n\n  ### Column\n\n  If you supply an integer for the third `column` argument, `neville` will\n  return that /column/ of the interpolation tableau instead of the first row.\n  This will give you a sequence of nth-order polynomial approximations taken\n  between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n   p0 p01 p012 p0123 p01234\n   p1 p12 p123 p1234 .\n   p2 p23 p234 .     .\n   p3 p34 .    .     .\n   p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of linear approximations\n  between pairs of points; `2` gives quadratic approximations between successive\n  triplets, etc.\n\n  References:\n\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\n  - Wikipedia, [Neville's Algorithm](https://en.wikipedia.org/wiki/Neville%27s_algorithm)\"\n  ([points x]\n   (neville-present\n    (first-terms\n     (tableau-fn neville-prepare\n                 (neville-merge x)\n                 points))))\n  ([points x column]\n   (-> (tableau-fn neville-prepare\n                   (neville-merge x)\n                   points)\n       (nth column)\n       (neville-present))))\n\n;; ## Modified Neville\n;;\n;; Press's Numerical Recipes, chapter 3 (p103) (\n;; http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf ) describes a modified\n;; version of Neville's algorithm that is slightly more efficient than the\n;; version above.\n;;\n;; Allan Macleod, in \"A comparison of algorithms for polynomial interpolation\",\n;; discusses this variation under the name \"Modified Neville\".\n\n;; By generating the /delta/ from each previous estimate in the tableau,\n;; Modified Neville is able to swap one of the multiplications above for an\n;; addition.\n;;\n;; To make this work, instead of tracking the previous $p$ estimate, we track\n;; two quantities:\n;;\n;; - $C_{abc}$ is the delta between $P_{abc}$ and $P_{ab}$, ie, $P_l$.\n;; - $D_{abc}$ is the delta between $P_{abc}$ and $P_{bc}$, ie, $P_r$.\n;;\n;; We can recover the estimates generated by the original Neville's algorithm by\n;; summing C values across the first tableau row.\n;;\n;; Equation 3.1.5 in Numerical recipes gives us the equations we need:\n;;\n;; $$\n;;   C_{abc} = [(x_a - x)(C_{bc} - D_{ab})] / [x_a - x_c] &\\\n;;           = [(x_l - x)(C_r - D_l)] / [x_l - x_r]\n;; $$\n;;\n;; $$\n;;   D_{abc} = [(x_c - x)(C_{bc} - D_{ab})] / [x_a - x_c] &\\\n;;           = [(x_r - x)(C_r - D_l)] / [x_l - x_r]\n;; $$\n;;\n;; These equations describe a `merge` function for a tableau processing scheme,\n;; with state == `[x_l, x_r, C, D]`.\n;;\n;; Let's implement each method, and then combine them into final form. The\n;; following methods use the prefix `mn` for \"Modified Neville\".\n\n(defn- mn-prepare\n  \"Processes an initial point [x (f x)] into the required state:\n\n  [x_l, x_r, C, D]\n\n  The recursion starts with $C = D = f(x)$.\"\n  [[x fx]]\n  [x x fx fx])\n\n(defn- mn-merge\n  \"Implements the recursion rules described above to generate x_l, x_r, C and D\n  for a tableau node, given the usual left and left-up tableau entries.\"\n  [x]\n  (fn [[xl _ _ dl] [_ xr cr _]]\n    (let [diff   (- cr dl)\n          den    (- xl xr)\n          factor (/ diff den)\n          c      (* factor (- xl x))\n          d      (* factor (- xr x))]\n      [xl xr c d])))\n\n(defn ^:no-doc mn-present\n  \"Returns a (lazy) sequence of estimates by successively adding C values from the\n  first entry of each tableau column. Each C value is the delta from the\n  previous estimate.\"\n  [row]\n  (ua/scan\n   (map (fn [[_ _ c _]] c) row)))\n\n;; `tableau-fn` allows us to assemble these pieces into a final function that\n;; has an interface identical to `neville` above. The implementation is more\n;; obfuscated but slightly more efficient.\n\n(defn modified-neville\n  \"Similar to [[neville]] (the interface is identical) but slightly more efficient.\n  Internally this builds up its estimates by tracking the delta from the\n  previous estimate.\n\n  This non-obvious change lets us swap an addition in for a multiplication,\n  making the algorithm slightly more efficient.\n\n  See [[neville]] for usage information, and info about the required structure\n  of the arguments.\n\n  The structure of the [[modified-neville]] algorithm makes it difficult to\n  select a particular column. See [[neville]] if you'd like to generate\n  polynomial approximations between successive sequences of points.\n\n  References:\n\n  - [\\\"A comparison of algorithms for polynomial interpolation\\\"](https://www.sciencedirect.com/science/article/pii/0771050X82900511), A. Macleod\n  - [Press's Numerical Recipes (p103), chapter 3](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-1.pdf)\"\n  [points x]\n  (mn-present\n   (first-terms\n    (tableau-fn mn-prepare\n                (mn-merge x)\n                points))))\n\n;; ## Folds and Tableaus by Row\n;;\n;; NOTE: These folds and scans seem to be higher performance than the functions\n;; above. Prefer `*-sum` functions when you want to consume a full sequence of\n;; points and get the full input, and `*-scan` functions when you want to\n;; observe all intermediate estimates. If you want a /column/ of the tableau,\n;; stick with the versions above.\n;;\n;; The advantage of the method described above, where we generate an entire\n;; tableau and lazily pull the first entry off of each column, is that we can\n;; pass a lazy sequence in as `points` and get a lazy sequence of successive\n;; estimates back. If we don't pull from the result sequence, no computation\n;; will occur.\n;;\n;; One problem with that structure is that we have to have our full sequence of\n;; points available when we call a function like `neville`. As you pull an\n;; element off of the returned sequence, it just-in-time generates a new\n;; diagonal of the tableau required to realize that number.\n;;\n;; Even if the sequence is lazy, this is limiting. What if we want to pause,\n;; save the current estimate and pick up later where we left off?\n;;\n;; Look at the tableau again:\n;;\n;; p0 p01 p012 p0123 p01234\n;; p1 p12 p123 p1234 .\n;; p2 p23 p234 .     .\n;; p3 p34 .    .     .\n;; p4 .   .    .     .\n;; .  .   .    .     .\n;; .  .   .    .     .\n;; .  .   .    .     .\n;;\n;; If you stare at this for a while, you might notice that it should be possible\n;; to use the `merge` and `present` functions we already have to build the\n;; tableau one /row/ at a time, given ONLY the previous row:\n;;\n;; (f [p1 p12 p123 p1234] [x0 fx0]) => [p0 p01 p012 p0123 p01234]\n;;\n;; This method reverses the order of the points, since rows are built from the\n;; bottom up:\n;;\n;; p4 p43 p432 p4321 p43210\n;; p3 p32 p321 p3210 .\n;; p2 p21 p210 .     .\n;; p1 p10 .    .     .\n;; p0 .   .    .     .\n;;\n;; The order of the points is reversed, but this is fine; polynomial\n;; interpolation doesn't care about the order of points. (NOTE that this WILL be\n;; something we have to consider in the fold version of Richardson\n;; extrapolation, in `sicmutils.polynomial.richardson`!)\n;;\n;; Notice that the /diagonal/ of this tableau is identical to the top row of the\n;; tableau before the points were reversed.\n;;\n;; Here's something close, using our previous `merge` and `prepare` definitions:\n\n(comment\n  (defn generate-new-row* [prepare merge]\n    (fn [prev-row point]\n      ;; the new point, once it's prepared, is the first entry in the new row.\n      ;; From there, we can treat the previous row as a sequence of \"r\" values.\n      (reduce merge (prepare point) prev-row))))\n\n;; There's a problem here. `reduce` only returns the FINAL value of the\n;; aggregation:\n;;\n;;   (let [f (generate-new-row* prepare present)]\n;;     (f [p1 p12 p123 p1234] [x0 fx0]))\n;;   ;; => p01234\n;;\n;; If we want to continue building rows, we need the entire new row! Lucky for\n;; us, Clojure has a version of `reduce`, called `reductions`, that returns each\n;; intermediate aggregation result:\n\n(comment\n  (defn generate-new-row [prepare merge]\n    (fn [prev-row point]\n      (reductions merge (prepare point) prev-row))))\n\n;;   (let [f (generate-new-row prepare present)]\n;;     (f [p1 p12 p123 p1234] [x0 fx0]))\n;;   ;; => [p0 p01 p012 p0123 p01234]\n;;\n;; Quick aside here, as we've stumbled across a familiar pattern. The discussion\n;; above suggests the idea of a \"fold\" from functional programming:\n;; https://en.wikipedia.org/wiki/Fold_(higher-order_function)\n;;\n;; Folds are explored (and implemented!) in detail in\n;; the [[sicmutils.algebra.fold]] namespace. See that namespace for an\n;; introduction, but I'll add a reminder here.\n;;\n;; A fold consists of:\n;;\n;; - `init`, an function that returns an initial piece of state called\n;;   an \"accumulator\"\n;;\n;; - a binary `merge` function that combines (\"folds\") a new element `x` into\n;;   the accumulator, and returns a value of the same shape / type as the\n;;   accumulator returned by `init`.\n;;\n;; - a `present` function that transforms the accumulator into a final value.\n;;\n;; In Clojure, you perform a fold on a sequence with the `reduce` function:\n;;\n;;     (reduce merge (init) xs)\n;;\n;; For example:\n;;\n;;     (reduce + 0.0 (range 10))\n;;     ;; => 45.0\n;;\n;; Our `generate-new-row` function from above is exactly the `merge` function of\n;; a fold. The accumulator is the latest tableau row:\n\n;; `init`    == a function that returns [], the initial empty row.\n;;\n;; `present` == a function similar to `neville-present` or `mn-present` that\n;;              simply sums up the estimate deltas for the entire row, instead\n;;              of returning the running tally.\n;;\n;; `present` only needs to return the final value in each row because that is\n;; the best current estimate given all points supplied so far.\n;;\n;; If you want to recover the previous behavior of a lazy sequence of all\n;; estimates, the lazy \"scan\" pattern of `sicmutils.util.aggregate/scan` allows\n;; you to observe each element of the diagonal of the tableau as it's generated.\n;; This is identical to the \"first row\" of the non-fold tableau.\n;;\n;; Now that we've identified this new pattern, we can rewrite `generate-new-row`\n;; to return a new function matching the fold interface described\n;; in [[sicmutils.algebra.fold]]. The new function is\n;; called [[tableau-fold-fn]]:\n\n(defn tableau-fold-fn\n  \"Given `prepare` and `merge` and `present` functions, returns a fold capable of\n  aggregating a point of the form [x, f(x)] into an accumulating tableau\n  row (generating the next tableau row).\n\n  The 0-arity of the returned function returns an empty row, `[]`.\n\n  The 1-arity calls the supplied `present` on the accumulated tableau row.\n\n  The 2-arity scans the supplied `merge` across all entries in the accumulating\n  row, producing a new row.\n\n  ### More detail on the arguments:\n\n  - `prepare`: a fn that processes each element of the supplied `points` into\n  the state necessary to calculate future tableau entries.\n\n  - `merge`: a fn of `l`and `r` the tableau entries:\n\n  l -- return\n     /\n    /\n   /\n  r\n\n  the inputs are of the same form returned by `prepare`. `merge` should return a\n  new structure of the same form.\n\n  - `present`: Transforms a `tableau` row into an estimate at some value `x` of\n  the polynomial interpolated to hit all supplied points.\"\n  [prepare merge present]\n  (fn\n    ([] [])\n    ([row] (present row))\n    ([prev-row point]\n     (reductions merge (prepare point) prev-row))))\n\n;; Next, we can use this to generate specialized fold functions for our two\n;; incremental algorithms above - `neville` and `modified-neville`.\n;;\n;; Instead of using `neville-present` as above, `neville-fold` returns only the\n;; final estimate. This is because folds are meant to consume their entire input\n;; sequence. If you want to observe intermediate values as they're generated,\n;; you can use the \"scan\" pattern, implemented in `neville-scan`.\n\n(defn neville-fold\n  \"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n    and returns the next row of the tableau using the algorithm described in\n  [[neville]].\"\n  [x]\n  (tableau-fold-fn neville-prepare\n                   (neville-merge x)\n                   (fn [row]\n                     (peek (last row)))))\n\n;; Instead of using `mn-present` as above, `modified-neville-fold` uses the\n;; dynamically bound `sicmutils.util.aggregate/*fold*` to sum all deltas and\n;; return the current best estimate taking all points into account.\n;;\n;; If you want to observe intermediate values as they're generated, you can use\n;; the \"scan\" pattern, implemented in `neville-scan`.\n\n(defn ^:no-doc mn-present-final\n  \"Aggregates intermediate deltas to produce an estimate for the final value in\n  the supplied row.\"\n  [row]\n  (transduce (map (fn [[_ _ c _]] c))\n             ua/*fold*\n             row))\n\n(defn modified-neville-fold\n  \"Given some point `x`, returns a fold that accumulates rows of an interpolation\n  tableau providing successively better estimates (at the value `x`) of a\n  polynomial interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-neville]].\"\n  [x]\n  (tableau-fold-fn mn-prepare\n                   (mn-merge x)\n                   mn-present-final))\n\n;; ## Fold Utilities\n;;\n;; `af/fold->scan` will return a function that acts identically to the non-fold,\n;; column-wise version of the interpolators. It does this by folding in one\n;; point at a time, but processing EVERY intermediate value through the\n;; presentation function.\n\n;; Using this function, we specialize to our two incremental methods.\n\n(defn neville-sum\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described in [[neville]].\n\n  Faster than, but equivalent to, `(last ([[neville]] xs x))`\"\n  [x]\n  (af/fold->sum-fn\n   (neville-fold x)))\n\n(defn neville-scan\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[neville]].\n\n  Equivalent to `([[neville]] xs x)`.\"\n  [x]\n  (af/fold->scan-fn\n   (neville-fold x)))\n\n(defn modified-neville-sum\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a polynomial\n  fitted to all points in `xs` using the algorithm described\n  in [[modified-neville]].\n\n  Faster than, but equivalent to, `(last ([[modified-neville]] xs x))`\"\n  [x]\n  (af/fold->sum-fn\n   (modified-neville-fold x)))\n\n(defn modified-neville-scan\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using polynomials fitted to the first point, then the first and second\n  points, etc. using the algorithm described in [[modified-neville]].\n\n  Equivalent to `([[modified-neville]] xs x)`.\"\n  [x]\n  (af/fold->scan-fn\n   (modified-neville-fold x)))\n\n;; Next, check out:\n;;\n;; - `rational.cljc` to learn how to interpolate rational functions\n;; - `richardson.cljc` for a specialized implementation of polynomial\n;;   interpolation, when you know something about the ratios between successive\n;;   `x` elements in the point sequence.\n"]}