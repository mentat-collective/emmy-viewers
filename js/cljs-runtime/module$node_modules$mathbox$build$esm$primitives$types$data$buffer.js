shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$data$buffer=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Buffer=void 0;global=require("module$node_modules$mathbox$build$esm$primitives$types$data$data");class Buffer extends global.Data{static initClass(){this.traits="node buffer active data source index texture".split(" ")}init(){this.bufferStep=this.bufferClock=this.bufferDelta=this.bufferTime=this.bufferFrames=this.bufferSlack=
0;super.init()}make(){super.make();this.clockParent=this._inherit("clock");this.latchParent=this._inherit("latch")}unmake(){return super.unmake()}rawBuffer(){return this.buffer}emitter(){const {channels,items}=this.props;return super.emitter(channels,items)}change(changed,touched,init){if(changed["buffer.fps"]||init)return{fps:changed}=this.props,this.bufferSlack=changed?.5/changed:0}syncBuffer(callback){let delta,step;if(this.buffer){var {live,fps,hurry,limit,realtime,observe}=this.props,filled=
this.buffer.getFilled();if(!filled||live)if(!this.latchParent||this.latchParent.isDirty){var time=this.clockParent.getTime();if(null!=fps){const slack=this.bufferSlack,speed=time.step/time.delta;delta=realtime?time.delta:time.step;const frame=1/fps;step=realtime&&observe?speed*frame:frame;Math.abs(time.time-this.bufferTime)>time.step*limit&&(this.bufferTime=time.time,this.bufferClock=time.clock);this.bufferSlack=Math.min(limit/fps,slack+delta);this.bufferDelta=delta;this.bufferStep=step;let frames=
Math.min(hurry,Math.floor(slack*fps));filled||(frames=Math.max(1,frames));let stop=!1;const abort=()=>stop=!0;return(()=>{const result=[];for(let i=0,end=frames,asc=0<=end;asc?i<end:i>end;asc?i++:i--){this.bufferTime+=delta;this.bufferClock+=step;if(stop)break;callback(abort,this.bufferFrames++,i,frames);result.push(this.bufferSlack-=frame)}return result})()}this.bufferTime=time.time;this.bufferDelta=time.delta;this.bufferClock=time.clock;this.bufferStep=time.step;return callback(function(){},this.bufferFrames++,
0,1)}}}alignShader(dims,shader){const {minFilter,magFilter,aligned}=this.props;dims=1<dims.items&&1<dims.width||1<dims.height&&1<dims.depth;if(!aligned&&dims)return minFilter===this.node.attributes["texture.minFilter"].enum.nearest&&magFilter===this.node.attributes["texture.magFilter"].enum.nearest||console.warn(`${this.node.toString()} - Cannot use linear min/magFilter with 3D/4D sampling`),shader.pipe("map.xyzw.align")}}exports.Buffer=Buffer;Buffer.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$data$buffer.js.map
