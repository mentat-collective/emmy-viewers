{
"version":3,
"file":"module$node_modules$domutils$lib$helpers.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/domutils/lib/helpers.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$domutils$lib$helpers\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.uniqueSort = exports.compareDocumentPosition = exports.removeSubsets = void 0;\nvar domhandler_1 = require(\"domhandler\");\n/**\n * Given an array of nodes, remove any member that is contained by another.\n *\n * @param nodes Nodes to filter.\n * @returns Remaining nodes that aren't subtrees of each other.\n */\nfunction removeSubsets(nodes) {\n    var idx = nodes.length;\n    /*\n     * Check if each node (or one of its ancestors) is already contained in the\n     * array.\n     */\n    while (--idx >= 0) {\n        var node = nodes[idx];\n        /*\n         * Remove the node if it is not unique.\n         * We are going through the array from the end, so we only\n         * have to check nodes that preceed the node under consideration in the array.\n         */\n        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {\n            nodes.splice(idx, 1);\n            continue;\n        }\n        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {\n            if (nodes.includes(ancestor)) {\n                nodes.splice(idx, 1);\n                break;\n            }\n        }\n    }\n    return nodes;\n}\nexports.removeSubsets = removeSubsets;\n/**\n * Compare the position of one node against another node in any other document.\n * The return value is a bitmask with the following values:\n *\n * Document order:\n * > There is an ordering, document order, defined on all the nodes in the\n * > document corresponding to the order in which the first character of the\n * > XML representation of each node occurs in the XML representation of the\n * > document after expansion of general entities. Thus, the document element\n * > node will be the first node. Element nodes occur before their children.\n * > Thus, document order orders element nodes in order of the occurrence of\n * > their start-tag in the XML (after expansion of entities). The attribute\n * > nodes of an element occur after the element and before its children. The\n * > relative order of attribute nodes is implementation-dependent./\n *\n * Source:\n * http://www.w3.org/TR/DOM-Level-3-Core/glossary.html#dt-document-order\n *\n * @param nodeA The first node to use in the comparison\n * @param nodeB The second node to use in the comparison\n * @returns A bitmask describing the input nodes' relative position.\n *\n * See http://dom.spec.whatwg.org/#dom-node-comparedocumentposition for\n * a description of these values.\n */\nfunction compareDocumentPosition(nodeA, nodeB) {\n    var aParents = [];\n    var bParents = [];\n    if (nodeA === nodeB) {\n        return 0;\n    }\n    var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;\n    while (current) {\n        aParents.unshift(current);\n        current = current.parent;\n    }\n    current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;\n    while (current) {\n        bParents.unshift(current);\n        current = current.parent;\n    }\n    var maxIdx = Math.min(aParents.length, bParents.length);\n    var idx = 0;\n    while (idx < maxIdx && aParents[idx] === bParents[idx]) {\n        idx++;\n    }\n    if (idx === 0) {\n        return 1 /* DISCONNECTED */;\n    }\n    var sharedParent = aParents[idx - 1];\n    var siblings = sharedParent.children;\n    var aSibling = aParents[idx];\n    var bSibling = bParents[idx];\n    if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {\n        if (sharedParent === nodeB) {\n            return 4 /* FOLLOWING */ | 16 /* CONTAINED_BY */;\n        }\n        return 4 /* FOLLOWING */;\n    }\n    if (sharedParent === nodeA) {\n        return 2 /* PRECEDING */ | 8 /* CONTAINS */;\n    }\n    return 2 /* PRECEDING */;\n}\nexports.compareDocumentPosition = compareDocumentPosition;\n/**\n * Sort an array of nodes based on their relative position in the document and\n * remove any duplicate nodes. If the array contains nodes that do not belong\n * to the same document, sort order is unspecified.\n *\n * @param nodes Array of DOM nodes.\n * @returns Collection of unique nodes, sorted in document order.\n */\nfunction uniqueSort(nodes) {\n    nodes = nodes.filter(function (node, i, arr) { return !arr.includes(node, i + 1); });\n    nodes.sort(function (a, b) {\n        var relative = compareDocumentPosition(a, b);\n        if (relative & 2 /* PRECEDING */) {\n            return -1;\n        }\n        else if (relative & 4 /* FOLLOWING */) {\n            return 1;\n        }\n        return 0;\n    });\n    return nodes;\n}\nexports.uniqueSort = uniqueSort;\n\n};"],
"names":["shadow$provide","global","require","module","exports","compareDocumentPosition","nodeA","nodeB","aParents","bParents","current","domhandler_1","hasChildren","parent","unshift","maxIdx","Math","min","length","idx","sharedParent","siblings","children","bSibling","indexOf","aSibling","Object","defineProperty","value","uniqueSort","removeSubsets","nodes","node","lastIndexOf","splice","ancestor","includes","filter","i","arr","sort","a","b","relative"]
}
