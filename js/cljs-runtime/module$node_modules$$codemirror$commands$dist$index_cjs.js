shadow$provide.module$node_modules$$codemirror$commands$dist$index_cjs=function(global,require,module,exports){function command$jscomp$0(f,option){return({state,dispatch})=>{if(state.readOnly)return!1;let tr=f(option,state);if(!tr)return!1;dispatch(state.update(tr));return!0}}function getConfig(state,pos=state.selection.main.head){state=state.languageDataAt("commentTokens",pos);return state.length?state[0]:{}}function findBlockComment(state,{open,close},from,to){var textBefore=state.sliceDoc(from-
50,from),textAfter=state.sliceDoc(to,to+50),spaceBefore=/\s*$/.exec(textBefore)[0].length,spaceAfter=/^\s*/.exec(textAfter)[0].length;let beforeOff=textBefore.length-spaceBefore;if(textBefore.slice(beforeOff-open.length,beforeOff)==open&&textAfter.slice(spaceAfter,spaceAfter+close.length)==close)return{open:{pos:from-spaceBefore,margin:spaceBefore&&1},close:{pos:to+spaceAfter,margin:spaceAfter&&1}};100>=to-from?textBefore=state=state.sliceDoc(from,to):(textBefore=state.sliceDoc(from,from+50),state=
state.sliceDoc(to-50,to));textAfter=/^\s*/.exec(textBefore)[0].length;spaceBefore=/\s*$/.exec(state)[0].length;spaceAfter=state.length-spaceBefore-close.length;return textBefore.slice(textAfter,textAfter+open.length)==open&&state.slice(spaceAfter,spaceAfter+close.length)==close?{open:{pos:from+textAfter+open.length,margin:/\s/.test(textBefore.charAt(textAfter+open.length))?1:0},close:{pos:to-spaceBefore-close.length,margin:/\s/.test(state.charAt(spaceAfter-1))?1:0}}:null}function changeBlockComment(option,
state,ranges=state.selection.ranges){let tokens=ranges.map(r=>getConfig(state,r.from).block);if(!tokens.every(c=>c))return null;let comments=ranges.map((r,i)=>findBlockComment(state,tokens[i],r.from,r.to));if(2!=option&&!comments.every(c=>c))return{changes:state.changes(ranges.map((range,i)=>comments[i]?[]:[{from:range.from,insert:tokens[i].open+" "},{from:range.to,insert:" "+tokens[i].close}]))};if(1!=option&&comments.some(c=>c)){option=[];for(let i=0,comment;i<comments.length;i++)if(comment=comments[i]){ranges=
tokens[i];let {open,close}=comment;option.push({from:open.pos-ranges.open.length,to:open.pos+open.margin},{from:close.pos-close.margin,to:close.pos+ranges.close.length})}return{changes:option}}return null}function changeLineComment(option,state,ranges=state.selection.ranges){var lines=[];let prevLine=-1;for(let {from,to}of ranges){ranges=lines.length;let minIndent=1E9;for(var pos=from;pos<=to;){var line$jscomp$0=state.doc.lineAt(pos);if(line$jscomp$0.from>prevLine&&(from==to||to>line$jscomp$0.from)){prevLine=
line$jscomp$0.from;let token=getConfig(state,pos).line;if(!token)continue;pos=/^\s*/.exec(line$jscomp$0.text)[0].length;let empty=pos==line$jscomp$0.length,comment=line$jscomp$0.text.slice(pos,pos+token.length)==token?pos:-1;pos<line$jscomp$0.text.length&&pos<minIndent&&(minIndent=pos);lines.push({line:line$jscomp$0,comment,token,indent:pos,empty,single:!1})}pos=line$jscomp$0.to+1}if(1E9>minIndent)for(line$jscomp$0=ranges;line$jscomp$0<lines.length;line$jscomp$0++)lines[line$jscomp$0].indent<lines[line$jscomp$0].line.text.length&&
(lines[line$jscomp$0].indent=minIndent);lines.length==ranges+1&&(lines[ranges].single=!0)}if(2!=option&&lines.some(l=>0>l.comment&&(!l.empty||l.single))){option=[];for(let {line,token,indent,empty,single}of lines)!single&&empty||option.push({from:line.from+indent,insert:token+" "});lines=state.changes(option);return{changes:lines,selection:state.selection.map(lines,1)}}if(1!=option&&lines.some(l=>0<=l.comment)){state=[];for(let {line,comment,token}of lines)0<=comment&&(lines=line.from+comment,option=
lines+token.length," "==line.text[option-line.from]&&option++,state.push({from:lines,to:option}));return{changes:state}}return null}function changeEnd(changes){let end=0;changes.iterChangedRanges((_,to)=>end=to);return end}function cmd(side,selection){return function({state,dispatch}){if(!selection&&state.readOnly)return!1;let historyState=state.field(historyField_,!1);if(!historyState)return!1;state=historyState.pop(side,state,selection);if(!state)return!1;dispatch(state);return!0}}function depth(side){return function(state){state=
state.field(historyField_,!1);if(!state)return 0;state=0==side?state.done:state.undone;return state.length-(state.length&&!state[0].changes?1:0)}}function updateBranch(branch,to,maxLen,newEvent){branch=branch.slice(to+1>maxLen+20?to-maxLen-1:0,to);branch.push(newEvent);return branch}function isAdjacent(a,b){let ranges=[],isAdjacent=!1;a.iterChangedRanges((f,t)=>ranges.push(f,t));b.iterChangedRanges((_f,_t,f,t)=>{for(_f=0;_f<ranges.length;){_t=ranges[_f++];let to=ranges[_f++];t>=_t&&f<=to&&(isAdjacent=
!0)}});return isAdjacent}function eqSelectionShape(a,b){return a.ranges.length==b.ranges.length&&0===a.ranges.filter((r,i)=>r.empty!=b.ranges[i].empty).length}function conc(a,b){return a.length?b.length?a.concat(b):a:b}function addSelection(branch,selection){if(branch.length){let lastEvent=branch[branch.length-1],sels=lastEvent.selectionsAfter.slice(Math.max(0,lastEvent.selectionsAfter.length-200));if(sels.length&&sels[sels.length-1].eq(selection))return branch;sels.push(selection);return updateBranch(branch,
branch.length-1,1E9,lastEvent.setSelAfter(sels))}return[HistEvent.selection([selection])]}function addMappingToBranch(branch,mapping){if(!branch.length)return branch;let length=branch.length;for(var selections=none;length;){selections=mapEvent(branch[length-1],mapping,selections);if(selections.changes&&!selections.changes.empty||selections.effects.length)return branch=branch.slice(0,length),branch[length-1]=selections,branch;mapping=selections.mapped;length--;selections=selections.selectionsAfter}return selections.length?
[HistEvent.selection(selections)]:none}function mapEvent(event,mapping,extraSelections){extraSelections=conc(event.selectionsAfter.length?event.selectionsAfter.map(s=>s.map(mapping)):none,extraSelections);if(!event.changes)return HistEvent.selection(extraSelections);let mappedChanges=event.changes.map(mapping),before=mapping.mapDesc(event.changes,!0),fullMapping=event.mapped?event.mapped.composeDesc(before):before;return new HistEvent(mappedChanges,state$jscomp$0.StateEffect.mapEffects(event.effects,
mapping),fullMapping,event.startSelection.map(before),extraSelections)}function updateSel(sel,by){return state$jscomp$0.EditorSelection.create(sel.ranges.map(by),sel.mainIndex)}function setSel(state,selection){return state.update({selection,scrollIntoView:!0,userEvent:"select"})}function moveSel({state,dispatch},how){how=updateSel(state.selection,how);if(how.eq(state.selection))return!1;dispatch(setSel(state,how));return!0}function rangeEnd(range,forward){return state$jscomp$0.EditorSelection.cursor(forward?
range.to:range.from)}function cursorByChar(view,forward){return moveSel(view,range=>range.empty?view.moveByChar(range,forward):rangeEnd(range,forward))}function ltrAtCursor(view$1){return view$1.textDirectionAt(view$1.state.selection.main.head)==view$jscomp$0.Direction.LTR}function cursorByGroup(view,forward){return moveSel(view,range=>range.empty?view.moveByGroup(range,forward):rangeEnd(range,forward))}function moveBySubword(view,range,forward){let categorize=view.state.charCategorizer(range.from);
return view.moveByChar(range,forward,start=>{let cat=state$jscomp$0.CharCategory.Space,pos=range.from,done=!1,sawUpper=!1,sawLower=!1,step=next=>{if(done)return!1;pos+=forward?next.length:-next.length;let nextCat=categorize(next),ahead;cat==state$jscomp$0.CharCategory.Space&&(cat=nextCat);if(cat!=nextCat)return!1;if(cat==state$jscomp$0.CharCategory.Word)if(next.toLowerCase()==next){if(!forward&&sawUpper)return!1;sawLower=!0}else if(sawLower){if(forward)return!1;done=!0}else{if(sawUpper&&forward&&
categorize(ahead=view.state.sliceDoc(pos,pos+1))==state$jscomp$0.CharCategory.Word&&ahead.toLowerCase()==ahead)return!1;sawUpper=!0}return!0};step(start);return step})}function cursorBySubword(view,forward){return moveSel(view,range=>range.empty?moveBySubword(view,range,forward):rangeEnd(range,forward))}function moveBySyntax(state$1,start,forward){let pos=language.syntaxTree(state$1).resolveInner(start.head),bracketProp=forward?common.NodeProp.closedBy:common.NodeProp.openedBy;for(start=start.head;;){let next=
forward?pos.childAfter(start):pos.childBefore(start);if(!next)break;a:{var JSCompiler_inline_result=state$1;var node=next;if(node.type.prop(bracketProp)){JSCompiler_inline_result=!0;break a}let len=node.to-node.from;JSCompiler_inline_result=len&&(2<len||/[^\s,.;:]/.test(JSCompiler_inline_result.sliceDoc(node.from,node.to)))||node.firstChild}JSCompiler_inline_result?pos=next:start=forward?next.to:next.from}let match;state$1=pos.type.prop(bracketProp)&&(match=forward?language.matchBrackets(state$1,
pos.from,1):language.matchBrackets(state$1,pos.to,-1))&&match.matched?forward?match.end.to:match.end.from:forward?pos.to:pos.from;return state$jscomp$0.EditorSelection.cursor(state$1,forward?-1:1)}function cursorByLine(view,forward){return moveSel(view,range=>{if(!range.empty)return rangeEnd(range,forward);let moved=view.moveVertically(range,forward);return moved.head!=range.head?moved:view.moveToLineBoundary(range,forward)})}function cursorByPage(view$1,forward){let {state}=view$1,selection=updateSel(state.selection,
range=>range.empty?view$1.moveVertically(range,forward,Math.max(view$1.defaultLineHeight,Math.min(view$1.dom.clientHeight,innerHeight)-5)):rangeEnd(range,forward));if(selection.eq(state.selection))return!1;let startPos=view$1.coordsAtPos(state.selection.main.head),scrollRect=view$1.scrollDOM.getBoundingClientRect(),effect;startPos&&startPos.top>scrollRect.top&&startPos.bottom<scrollRect.bottom&&startPos.top-scrollRect.top<=view$1.scrollDOM.scrollHeight-view$1.scrollDOM.scrollTop-view$1.scrollDOM.clientHeight&&
(effect=view$jscomp$0.EditorView.scrollIntoView(selection.main.head,{y:"start",yMargin:startPos.top-scrollRect.top}));view$1.dispatch(setSel(state,selection),{effects:effect});return!0}function moveByLineBoundary(view,start,forward){let line=view.lineBlockAt(start.head),moved=view.moveToLineBoundary(start,forward);moved.head==start.head&&moved.head!=(forward?line.to:line.from)&&(moved=view.moveToLineBoundary(start,forward,!1));!forward&&moved.head==line.from&&line.length&&(view=/^\s*/.exec(view.state.sliceDoc(line.from,
Math.min(line.from+100,line.to)))[0].length)&&start.head!=line.from+view&&(moved=state$jscomp$0.EditorSelection.cursor(line.from+view));return moved}function toMatchingBracket(state$1,dispatch,extend){let found=!1,selection=updateSel(state$1.selection,range=>{var matching=language.matchBrackets(state$1,range.head,-1)||language.matchBrackets(state$1,range.head,1)||0<range.head&&language.matchBrackets(state$1,range.head-1,1)||range.head<state$1.doc.length&&language.matchBrackets(state$1,range.head+
1,-1);if(!matching||!matching.end)return range;found=!0;matching=matching.start.from==range.head?matching.end.to:matching.end.from;return extend?state$jscomp$0.EditorSelection.range(range.anchor,matching):state$jscomp$0.EditorSelection.cursor(matching)});if(!found)return!1;dispatch(setSel(state$1,selection));return!0}function extendSel(view,how){let selection=updateSel(view.state.selection,range=>{let head=how(range);return state$jscomp$0.EditorSelection.range(range.anchor,head.head,head.goalColumn)});
if(selection.eq(view.state.selection))return!1;view.dispatch(setSel(view.state,selection));return!0}function selectByChar(view,forward){return extendSel(view,range=>view.moveByChar(range,forward))}function selectByGroup(view,forward){return extendSel(view,range=>view.moveByGroup(range,forward))}function selectBySubword(view,forward){return extendSel(view,range=>moveBySubword(view,range,forward))}function selectByLine(view,forward){return extendSel(view,range=>view.moveVertically(range,forward))}function selectByPage(view,
forward){return extendSel(view,range=>view.moveVertically(range,forward,Math.max(view.defaultLineHeight,Math.min(view.dom.clientHeight,innerHeight)-5)))}function deleteBy(target,by){if(target.state.readOnly)return!1;let event="delete.selection",{state:state$1}=target,changes=state$1.changeByRange(range=>{let {from,to}=range;if(from==to){let towards=by(from);towards<from?(event="delete.backward",towards=skipAtomic(target,towards,!1)):towards>from&&(event="delete.forward",towards=skipAtomic(target,
towards,!0));from=Math.min(from,towards);to=Math.max(to,towards)}else from=skipAtomic(target,from,!1),to=skipAtomic(target,to,!0);return from==to?{range}:{changes:{from,to},range:state$jscomp$0.EditorSelection.cursor(from)}});if(changes.changes.empty)return!1;target.dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:event,effects:"delete.selection"==event?view$jscomp$0.EditorView.announce.of(state$1.phrase("Selection deleted")):void 0}));return!0}function skipAtomic(target,pos,forward){if(target instanceof
view$jscomp$0.EditorView)for(let ranges of target.state.facet(view$jscomp$0.EditorView.atomicRanges).map(f=>f(target)))ranges.between(pos,pos,(from,to)=>{from<pos&&to>pos&&(pos=forward?to:from)});return pos}function selectedLineBlocks(state){let blocks=[];var upto=-1;for(let range of state.selection.ranges){let startLine=state.doc.lineAt(range.from),endLine=state.doc.lineAt(range.to);range.empty||range.to!=endLine.from||(endLine=state.doc.lineAt(range.to-1));upto>=startLine.number?(upto=blocks[blocks.length-
1],upto.to=endLine.to,upto.ranges.push(range)):blocks.push({from:startLine.from,to:endLine.to,ranges:[range]});upto=endLine.number+1}return blocks}function moveLine(state$1,dispatch,forward){if(state$1.readOnly)return!1;let changes=[],ranges=[];for(let block of selectedLineBlocks(state$1)){if(forward?block.to==state$1.doc.length:0==block.from)continue;let nextLine=state$1.doc.lineAt(forward?block.to+1:block.from-1),size=nextLine.length+1;if(forward){changes.push({from:block.to,to:nextLine.to},{from:block.from,
insert:nextLine.text+state$1.lineBreak});for(let r of block.ranges)ranges.push(state$jscomp$0.EditorSelection.range(Math.min(state$1.doc.length,r.anchor+size),Math.min(state$1.doc.length,r.head+size)))}else{changes.push({from:nextLine.from,to:block.from},{from:block.to,insert:state$1.lineBreak+nextLine.text});for(let r of block.ranges)ranges.push(state$jscomp$0.EditorSelection.range(r.anchor-size,r.head-size))}}if(!changes.length)return!1;dispatch(state$1.update({changes,scrollIntoView:!0,selection:state$jscomp$0.EditorSelection.create(ranges,
state$1.selection.mainIndex),userEvent:"move.line"}));return!0}function copyLine(state,dispatch,forward){if(state.readOnly)return!1;let changes=[];for(let block of selectedLineBlocks(state))forward?changes.push({from:block.from,insert:state.doc.slice(block.from,block.to)+state.lineBreak}):changes.push({from:block.to,insert:state.lineBreak+state.doc.slice(block.from,block.to)});dispatch(state.update({changes,scrollIntoView:!0,userEvent:"input.copyline"}));return!0}function newlineAndIndent(atEof){return({state:state$1,
dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange(range=>{let {from,to}=range;range=state$1.doc.lineAt(from);var JSCompiler_temp;if(JSCompiler_temp=!atEof&&from==to)if(JSCompiler_temp=from,/\(\)|\[\]|\{\}/.test(state$1.sliceDoc(JSCompiler_temp-1,JSCompiler_temp+1)))JSCompiler_temp={from:JSCompiler_temp,to:JSCompiler_temp};else{var context=language.syntaxTree(state$1).resolveInner(JSCompiler_temp),before=context.childBefore(JSCompiler_temp);context=context.childAfter(JSCompiler_temp);
var closedBy;JSCompiler_temp=before&&context&&before.to<=JSCompiler_temp&&context.from>=JSCompiler_temp&&(closedBy=before.type.prop(common.NodeProp.closedBy))&&-1<closedBy.indexOf(context.name)&&state$1.doc.lineAt(before.to).from==state$1.doc.lineAt(context.from).from?{from:before.to,to:context.from}:null}closedBy=JSCompiler_temp;atEof&&(from=to=(to<=range.to?range:state$1.doc.lineAt(to)).to);before=new language.IndentContext(state$1,{simulateBreak:from,simulateDoubleBreak:!!closedBy});JSCompiler_temp=
language.getIndentation(before,from);null==JSCompiler_temp&&(JSCompiler_temp=/^\s*/.exec(state$1.doc.lineAt(from).text)[0].length);for(;to<range.to&&/\s/.test(range.text[to-range.from]);)to++;closedBy?{from,to}=closedBy:from>range.from&&from<range.from+100&&!/\S/.test(range.text.slice(0,from))&&(from=range.from);JSCompiler_temp=["",language.indentString(state$1,JSCompiler_temp)];closedBy&&JSCompiler_temp.push(language.indentString(state$1,before.lineIndent(range.from,-1)));return{changes:{from,to,
insert:state$jscomp$0.Text.of(JSCompiler_temp)},range:state$jscomp$0.EditorSelection.cursor(from+1+JSCompiler_temp[1].length)}});dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"}));return!0}}function changeBySelectedLine(state$1,f){let atLine=-1;return state$1.changeByRange(range=>{let changes=[];for(var pos=range.from;pos<=range.to;)pos=state$1.doc.lineAt(pos),pos.number>atLine&&(range.empty||range.to>pos.from)&&(f(pos,changes,range),atLine=pos.number),pos=pos.to+1;pos=state$1.changes(changes);
return{changes,range:state$jscomp$0.EditorSelection.range(pos.mapPos(range.anchor,1),pos.mapPos(range.head,1))}})}Object.defineProperty(exports,"__esModule",{value:!0});var state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs"),language=require("module$node_modules$$codemirror$language$dist$index_cjs"),common=require("module$node_modules$$lezer$common$dist$index_cjs");const toggleComment=target=>{let config=
getConfig(target.state);return config.line?toggleLineComment(target):config.block?toggleBlockCommentByLine(target):!1},toggleLineComment=command$jscomp$0(changeLineComment,0),lineComment=command$jscomp$0(changeLineComment,1),lineUncomment=command$jscomp$0(changeLineComment,2),toggleBlockComment=command$jscomp$0(changeBlockComment,0),blockComment=command$jscomp$0(changeBlockComment,1),blockUncomment=command$jscomp$0(changeBlockComment,2),toggleBlockCommentByLine=command$jscomp$0((o,s)=>{let ranges=
[];for(let r of s.selection.ranges){let fromLine=s.doc.lineAt(r.from),toLine=r.to<=fromLine.to?fromLine:s.doc.lineAt(r.to),last=ranges.length-1;0<=last&&ranges[last].to>fromLine.from?ranges[last].to=toLine.to:ranges.push({from:fromLine.from,to:toLine.to})}return changeBlockComment(o,s,ranges)},0),fromHistory=state$jscomp$0.Annotation.define(),isolateHistory=state$jscomp$0.Annotation.define(),invertedEffects=state$jscomp$0.Facet.define(),historyConfig=state$jscomp$0.Facet.define({combine(configs){return state$jscomp$0.combineConfig(configs,
{minDepth:100,newGroupDelay:500},{minDepth:Math.max,newGroupDelay:Math.min})}}),historyField_=state$jscomp$0.StateField.define({create(){return HistoryState.empty},update(state$1,tr){let config=tr.state.facet(historyConfig);var fromHist=tr.annotation(fromHistory);if(fromHist){var selection=tr.docChanged?state$jscomp$0.EditorSelection.single(changeEnd(tr.changes)):void 0;selection=HistEvent.fromTransaction(tr,selection);var from=fromHist.side;state$1=0==from?state$1.undone:state$1.done;state$1=selection?
updateBranch(state$1,state$1.length,config.minDepth,selection):addSelection(state$1,tr.startState.selection);return new HistoryState(0==from?fromHist.rest:state$1,0==from?state$1:fromHist.rest)}fromHist=tr.annotation(isolateHistory);if("full"==fromHist||"before"==fromHist)state$1=state$1.isolate();if(!1===tr.annotation(state$jscomp$0.Transaction.addToHistory))return tr.changes.empty?state$1:state$1.addMapping(tr.changes.desc);selection=HistEvent.fromTransaction(tr);from=tr.annotation(state$jscomp$0.Transaction.time);
let userEvent=tr.annotation(state$jscomp$0.Transaction.userEvent);selection?state$1=state$1.addChanges(selection,from,userEvent,config.newGroupDelay,config.minDepth):tr.selection&&(state$1=state$1.addSelection(tr.startState.selection,from,userEvent,config.newGroupDelay));if("full"==fromHist||"after"==fromHist)state$1=state$1.isolate();return state$1},toJSON(value){return{done:value.done.map(e=>e.toJSON()),undone:value.undone.map(e=>e.toJSON())}},fromJSON(json){return new HistoryState(json.done.map(HistEvent.fromJSON),
json.undone.map(HistEvent.fromJSON))}}),historyField=historyField_,undo=cmd(0,!1),redo=cmd(1,!1),undoSelection=cmd(0,!0),redoSelection=cmd(1,!0),undoDepth=depth(0),redoDepth=depth(1);class HistEvent{constructor(changes,effects,mapped,startSelection,selectionsAfter){this.changes=changes;this.effects=effects;this.mapped=mapped;this.startSelection=startSelection;this.selectionsAfter=selectionsAfter}setSelAfter(after){return new HistEvent(this.changes,this.effects,this.mapped,this.startSelection,after)}toJSON(){var _a,
_b,_c;return{changes:null===(_a=this.changes)||void 0===_a?void 0:_a.toJSON(),mapped:null===(_b=this.mapped)||void 0===_b?void 0:_b.toJSON(),startSelection:null===(_c=this.startSelection)||void 0===_c?void 0:_c.toJSON(),selectionsAfter:this.selectionsAfter.map(s=>s.toJSON())}}static fromJSON(json){return new HistEvent(json.changes&&state$jscomp$0.ChangeSet.fromJSON(json.changes),[],json.mapped&&state$jscomp$0.ChangeDesc.fromJSON(json.mapped),json.startSelection&&state$jscomp$0.EditorSelection.fromJSON(json.startSelection),
json.selectionsAfter.map(state$jscomp$0.EditorSelection.fromJSON))}static fromTransaction(tr,selection){let effects=none;for(let invert of tr.startState.facet(invertedEffects)){let result=invert(tr);result.length&&(effects=effects.concat(result))}return!effects.length&&tr.changes.empty?null:new HistEvent(tr.changes.invert(tr.startState.doc),effects,void 0,selection||tr.startState.selection,none)}static selection(selections){return new HistEvent(void 0,none,void 0,void 0,selections)}}const none=[],
joinableUserEvent=/^(input\.type|delete)($|\.)/;class HistoryState{constructor(done,undone,prevTime=0,prevUserEvent){this.done=done;this.undone=undone;this.prevTime=prevTime;this.prevUserEvent=prevUserEvent}isolate(){return this.prevTime?new HistoryState(this.done,this.undone):this}addChanges(event,time,userEvent,newGroupDelay,maxLen){let done=this.done,lastEvent=done[done.length-1];done=lastEvent&&lastEvent.changes&&!lastEvent.changes.empty&&event.changes&&(!userEvent||joinableUserEvent.test(userEvent))&&
(!lastEvent.selectionsAfter.length&&time-this.prevTime<newGroupDelay&&isAdjacent(lastEvent.changes,event.changes)||"input.type.compose"==userEvent)?updateBranch(done,done.length-1,maxLen,new HistEvent(event.changes.compose(lastEvent.changes),conc(event.effects,lastEvent.effects),lastEvent.mapped,lastEvent.startSelection,none)):updateBranch(done,done.length,maxLen,event);return new HistoryState(done,none,time,userEvent)}addSelection(selection,time,userEvent,newGroupDelay){let last=this.done.length?
this.done[this.done.length-1].selectionsAfter:none;return 0<last.length&&time-this.prevTime<newGroupDelay&&userEvent==this.prevUserEvent&&userEvent&&/^select($|\.)/.test(userEvent)&&eqSelectionShape(last[last.length-1],selection)?this:new HistoryState(addSelection(this.done,selection),this.undone,time,userEvent)}addMapping(mapping){return new HistoryState(addMappingToBranch(this.done,mapping),addMappingToBranch(this.undone,mapping),this.prevTime,this.prevUserEvent)}pop(side,state,selection){var branch=
0==side?this.done:this.undone;if(0==branch.length)return null;var event=branch[branch.length-1];if(selection&&event.selectionsAfter.length){selection=state.update;event=event.selectionsAfter[event.selectionsAfter.length-1];var JSCompiler_temp_const=fromHistory.of;let last=branch[branch.length-1],newBranch=branch.slice();newBranch[branch.length-1]=last.setSelAfter(last.selectionsAfter.slice(0,last.selectionsAfter.length-1));return selection.call(state,{selection:event,annotations:JSCompiler_temp_const.call(fromHistory,
{side,rest:newBranch}),userEvent:0==side?"select.undo":"select.redo",scrollIntoView:!0})}return event.changes?(branch=1==branch.length?none:branch.slice(0,branch.length-1),event.mapped&&(branch=addMappingToBranch(branch,event.mapped)),state.update({changes:event.changes,selection:event.startSelection,effects:event.effects,annotations:fromHistory.of({side,rest:branch}),filter:!1,userEvent:0==side?"undo":"redo",scrollIntoView:!0})):null}}HistoryState.empty=new HistoryState(none,none);const historyKeymap=
[{key:"Mod-z",run:undo,preventDefault:!0},{key:"Mod-y",mac:"Mod-Shift-z",run:redo,preventDefault:!0},{linux:"Ctrl-Shift-z",run:redo,preventDefault:!0},{key:"Mod-u",run:undoSelection,preventDefault:!0},{key:"Alt-u",mac:"Mod-Shift-u",run:redoSelection,preventDefault:!0}],cursorCharLeft=view=>cursorByChar(view,!ltrAtCursor(view)),cursorCharRight=view=>cursorByChar(view,ltrAtCursor(view)),cursorGroupLeft=view=>cursorByGroup(view,!ltrAtCursor(view)),cursorGroupRight=view=>cursorByGroup(view,ltrAtCursor(view)),
cursorSyntaxLeft=view=>moveSel(view,range=>moveBySyntax(view.state,range,!ltrAtCursor(view))),cursorSyntaxRight=view=>moveSel(view,range=>moveBySyntax(view.state,range,ltrAtCursor(view))),cursorLineUp=view=>cursorByLine(view,!1),cursorLineDown=view=>cursorByLine(view,!0),cursorPageUp=view=>cursorByPage(view,!1),cursorPageDown=view=>cursorByPage(view,!0),cursorLineBoundaryForward=view=>moveSel(view,range=>moveByLineBoundary(view,range,!0)),cursorLineBoundaryBackward=view=>moveSel(view,range=>moveByLineBoundary(view,
range,!1)),cursorLineBoundaryLeft=view=>moveSel(view,range=>moveByLineBoundary(view,range,!ltrAtCursor(view))),cursorLineBoundaryRight=view=>moveSel(view,range=>moveByLineBoundary(view,range,ltrAtCursor(view))),cursorLineStart=view=>moveSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).from,1)),cursorLineEnd=view=>moveSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).to,-1)),cursorMatchingBracket=({state,dispatch})=>toMatchingBracket(state,
dispatch,!1),selectCharLeft=view=>selectByChar(view,!ltrAtCursor(view)),selectCharRight=view=>selectByChar(view,ltrAtCursor(view)),selectGroupLeft=view=>selectByGroup(view,!ltrAtCursor(view)),selectGroupRight=view=>selectByGroup(view,ltrAtCursor(view)),selectSyntaxLeft=view=>extendSel(view,range=>moveBySyntax(view.state,range,!ltrAtCursor(view))),selectSyntaxRight=view=>extendSel(view,range=>moveBySyntax(view.state,range,ltrAtCursor(view))),selectLineUp=view=>selectByLine(view,!1),selectLineDown=
view=>selectByLine(view,!0),selectPageUp=view=>selectByPage(view,!1),selectPageDown=view=>selectByPage(view,!0),selectLineBoundaryForward=view=>extendSel(view,range=>moveByLineBoundary(view,range,!0)),selectLineBoundaryBackward=view=>extendSel(view,range=>moveByLineBoundary(view,range,!1)),selectLineBoundaryLeft=view=>extendSel(view,range=>moveByLineBoundary(view,range,!ltrAtCursor(view))),selectLineBoundaryRight=view=>extendSel(view,range=>moveByLineBoundary(view,range,ltrAtCursor(view))),selectLineStart=
view=>extendSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).from)),selectLineEnd=view=>extendSel(view,range=>state$jscomp$0.EditorSelection.cursor(view.lineBlockAt(range.head).to)),cursorDocStart=({state,dispatch})=>{dispatch(setSel(state,{anchor:0}));return!0},cursorDocEnd=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.doc.length}));return!0},selectDocStart=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.selection.main.anchor,head:0}));return!0},
selectDocEnd=({state,dispatch})=>{dispatch(setSel(state,{anchor:state.selection.main.anchor,head:state.doc.length}));return!0},selectAll=({state,dispatch})=>{dispatch(state.update({selection:{anchor:0,head:state.doc.length},userEvent:"select"}));return!0},selectLine=({state:state$1,dispatch})=>{let ranges=selectedLineBlocks(state$1).map(({from,to})=>state$jscomp$0.EditorSelection.range(from,Math.min(to+1,state$1.doc.length)));dispatch(state$1.update({selection:state$jscomp$0.EditorSelection.create(ranges),
userEvent:"select"}));return!0},selectParentSyntax=({state:state$1,dispatch})=>{let selection=updateSel(state$1.selection,range=>{var _a;let context=language.syntaxTree(state$1).resolveInner(range.head,1);for(;!(context.from<range.from&&context.to>=range.to||context.to>range.to&&context.from<=range.from)&&(null===(_a=context.parent)||void 0===_a?0:_a.parent);)context=context.parent;return state$jscomp$0.EditorSelection.range(context.to,context.from)});dispatch(setSel(state$1,selection));return!0},
simplifySelection=({state:state$1,dispatch})=>{let cur=state$1.selection,selection=null;1<cur.ranges.length?selection=state$jscomp$0.EditorSelection.create([cur.main]):cur.main.empty||(selection=state$jscomp$0.EditorSelection.create([state$jscomp$0.EditorSelection.cursor(cur.main.head)]));if(!selection)return!1;dispatch(setSel(state$1,selection));return!0},deleteByChar=(target,forward)=>deleteBy(target,pos=>{var {state:state$1}=target,line=state$1.doc.lineAt(pos),before;if(!forward&&pos>line.from&&
pos<line.from+200&&!/[^ \t]/.test(before=line.text.slice(0,pos-line.from))){if("\t"==before[before.length-1])return pos-1;state$1=state$jscomp$0.countColumn(before,state$1.tabSize)%language.getIndentUnit(state$1)||language.getIndentUnit(state$1);for(line=0;line<state$1&&" "==before[before.length-1-line];line++)pos--;before=pos}else before=state$jscomp$0.findClusterBreak(line.text,pos-line.from,forward,forward)+line.from,before==pos&&line.number!=(forward?state$1.doc.lines:1)&&(before+=forward?1:-1);
return before}),deleteCharBackward=view=>deleteByChar(view,!1),deleteCharForward=view=>deleteByChar(view,!0),deleteByGroup=(target,forward)=>deleteBy(target,start=>{let pos=start,{state:state$1}=target,line=state$1.doc.lineAt(pos),categorize=state$1.charCategorizer(pos);for(let cat=null;;){if(pos==(forward?line.to:line.from)){pos==start&&line.number!=(forward?state$1.doc.lines:1)&&(pos+=forward?1:-1);break}let next=state$jscomp$0.findClusterBreak(line.text,pos-line.from,forward)+line.from,nextChar=
line.text.slice(Math.min(pos,next)-line.from,Math.max(pos,next)-line.from),nextCat=categorize(nextChar);if(null!=cat&&nextCat!=cat)break;if(" "!=nextChar||pos!=start)cat=nextCat;pos=next}return pos}),deleteGroupBackward=target=>deleteByGroup(target,!1),deleteGroupForward=target=>deleteByGroup(target,!0),deleteToLineEnd=view=>deleteBy(view,pos=>{let lineEnd=view.lineBlockAt(pos).to;return pos<lineEnd?lineEnd:Math.min(view.state.doc.length,pos+1)}),deleteToLineStart=view=>deleteBy(view,pos=>{let lineStart=
view.lineBlockAt(pos).from;return pos>lineStart?lineStart:Math.max(0,pos-1)}),splitLine=({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange(range=>({changes:{from:range.from,to:range.to,insert:state$jscomp$0.Text.of(["",""])},range:state$jscomp$0.EditorSelection.cursor(range.from)}));dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"input"}));return!0},transposeChars=({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;let changes=state$1.changeByRange(range=>
{if(!range.empty||0==range.from||range.from==state$1.doc.length)return{range};range=range.from;var line=state$1.doc.lineAt(range);let from=range==line.from?range-1:state$jscomp$0.findClusterBreak(line.text,range-line.from,!1)+line.from;line=range==line.to?range+1:state$jscomp$0.findClusterBreak(line.text,range-line.from,!0)+line.from;return{changes:{from,to:line,insert:state$1.doc.slice(range,line).append(state$1.doc.slice(from,range))},range:state$jscomp$0.EditorSelection.cursor(line)}});if(changes.changes.empty)return!1;
dispatch(state$1.update(changes,{scrollIntoView:!0,userEvent:"move.character"}));return!0},moveLineUp=({state,dispatch})=>moveLine(state,dispatch,!1),moveLineDown=({state,dispatch})=>moveLine(state,dispatch,!0),copyLineUp=({state,dispatch})=>copyLine(state,dispatch,!1),copyLineDown=({state,dispatch})=>copyLine(state,dispatch,!0),deleteLine=view=>{if(view.state.readOnly)return!1;let {state}=view,changes=state.changes(selectedLineBlocks(state).map(({from,to})=>{0<from?from--:to<state.doc.length&&to++;
return{from,to}})),selection=updateSel(state.selection,range=>view.moveVertically(range,!0)).map(changes);view.dispatch({changes,selection,scrollIntoView:!0,userEvent:"delete.line"});return!0},insertNewlineAndIndent=newlineAndIndent(!1),insertBlankLine=newlineAndIndent(!0),indentSelection=({state,dispatch})=>{if(state.readOnly)return!1;let updated=Object.create(null),context=new language.IndentContext(state,{overrideIndentation:start=>{start=updated[start];return null==start?-1:start}}),changes$jscomp$0=
changeBySelectedLine(state,(line,changes,range)=>{let indent=language.getIndentation(context,line.from);if(null!=indent){/\S/.test(line.text)||(indent=0);var cur=/^\s*/.exec(line.text)[0],norm=language.indentString(state,indent);if(cur!=norm||range.from<line.from+cur.length)updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm})}});changes$jscomp$0.changes.empty||dispatch(state.update(changes$jscomp$0,{userEvent:"indent"}));return!0},indentMore=({state,dispatch})=>
{if(state.readOnly)return!1;dispatch(state.update(changeBySelectedLine(state,(line,changes)=>{changes.push({from:line.from,insert:state.facet(language.indentUnit)})}),{userEvent:"input.indent"}));return!0},indentLess=({state:state$1,dispatch})=>{if(state$1.readOnly)return!1;dispatch(state$1.update(changeBySelectedLine(state$1,(line,changes)=>{let space=/^\s*/.exec(line.text)[0];if(space){var col=state$jscomp$0.countColumn(space,state$1.tabSize),keep=0;for(col=language.indentString(state$1,Math.max(0,
col-language.getIndentUnit(state$1)));keep<space.length&&keep<col.length&&space.charCodeAt(keep)==col.charCodeAt(keep);)keep++;changes.push({from:line.from+keep,to:line.from+space.length,insert:col.slice(keep)})}}),{userEvent:"delete.dedent"}));return!0},emacsStyleKeymap=[{key:"Ctrl-b",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Ctrl-f",run:cursorCharRight,shift:selectCharRight},{key:"Ctrl-p",run:cursorLineUp,shift:selectLineUp},{key:"Ctrl-n",run:cursorLineDown,shift:selectLineDown},
{key:"Ctrl-a",run:cursorLineStart,shift:selectLineStart},{key:"Ctrl-e",run:cursorLineEnd,shift:selectLineEnd},{key:"Ctrl-d",run:deleteCharForward},{key:"Ctrl-h",run:deleteCharBackward},{key:"Ctrl-k",run:deleteToLineEnd},{key:"Ctrl-Alt-h",run:deleteGroupBackward},{key:"Ctrl-o",run:splitLine},{key:"Ctrl-t",run:transposeChars},{key:"Ctrl-v",run:cursorPageDown}],standardKeymap=[{key:"ArrowLeft",run:cursorCharLeft,shift:selectCharLeft,preventDefault:!0},{key:"Mod-ArrowLeft",mac:"Alt-ArrowLeft",run:cursorGroupLeft,
shift:selectGroupLeft,preventDefault:!0},{mac:"Cmd-ArrowLeft",run:cursorLineBoundaryLeft,shift:selectLineBoundaryLeft,preventDefault:!0},{key:"ArrowRight",run:cursorCharRight,shift:selectCharRight,preventDefault:!0},{key:"Mod-ArrowRight",mac:"Alt-ArrowRight",run:cursorGroupRight,shift:selectGroupRight,preventDefault:!0},{mac:"Cmd-ArrowRight",run:cursorLineBoundaryRight,shift:selectLineBoundaryRight,preventDefault:!0},{key:"ArrowUp",run:cursorLineUp,shift:selectLineUp,preventDefault:!0},{mac:"Cmd-ArrowUp",
run:cursorDocStart,shift:selectDocStart},{mac:"Ctrl-ArrowUp",run:cursorPageUp,shift:selectPageUp},{key:"ArrowDown",run:cursorLineDown,shift:selectLineDown,preventDefault:!0},{mac:"Cmd-ArrowDown",run:cursorDocEnd,shift:selectDocEnd},{mac:"Ctrl-ArrowDown",run:cursorPageDown,shift:selectPageDown},{key:"PageUp",run:cursorPageUp,shift:selectPageUp},{key:"PageDown",run:cursorPageDown,shift:selectPageDown},{key:"Home",run:cursorLineBoundaryBackward,shift:selectLineBoundaryBackward,preventDefault:!0},{key:"Mod-Home",
run:cursorDocStart,shift:selectDocStart},{key:"End",run:cursorLineBoundaryForward,shift:selectLineBoundaryForward,preventDefault:!0},{key:"Mod-End",run:cursorDocEnd,shift:selectDocEnd},{key:"Enter",run:insertNewlineAndIndent},{key:"Mod-a",run:selectAll},{key:"Backspace",run:deleteCharBackward,shift:deleteCharBackward},{key:"Delete",run:deleteCharForward},{key:"Mod-Backspace",mac:"Alt-Backspace",run:deleteGroupBackward},{key:"Mod-Delete",mac:"Alt-Delete",run:deleteGroupForward},{mac:"Mod-Backspace",
run:deleteToLineStart},{mac:"Mod-Delete",run:deleteToLineEnd}].concat(emacsStyleKeymap.map(b=>({mac:b.key,run:b.run,shift:b.shift}))),defaultKeymap=[{key:"Alt-ArrowLeft",mac:"Ctrl-ArrowLeft",run:cursorSyntaxLeft,shift:selectSyntaxLeft},{key:"Alt-ArrowRight",mac:"Ctrl-ArrowRight",run:cursorSyntaxRight,shift:selectSyntaxRight},{key:"Alt-ArrowUp",run:moveLineUp},{key:"Shift-Alt-ArrowUp",run:copyLineUp},{key:"Alt-ArrowDown",run:moveLineDown},{key:"Shift-Alt-ArrowDown",run:copyLineDown},{key:"Escape",
run:simplifySelection},{key:"Mod-Enter",run:insertBlankLine},{key:"Alt-l",mac:"Ctrl-l",run:selectLine},{key:"Mod-i",run:selectParentSyntax,preventDefault:!0},{key:"Mod-[",run:indentLess},{key:"Mod-]",run:indentMore},{key:"Mod-Alt-\\",run:indentSelection},{key:"Shift-Mod-k",run:deleteLine},{key:"Shift-Mod-\\",run:cursorMatchingBracket},{key:"Mod-/",run:toggleComment},{key:"Alt-A",run:toggleBlockComment}].concat(standardKeymap),indentWithTab={key:"Tab",run:indentMore,shift:indentLess};exports.blockComment=
blockComment;exports.blockUncomment=blockUncomment;exports.copyLineDown=copyLineDown;exports.copyLineUp=copyLineUp;exports.cursorCharBackward=view=>cursorByChar(view,!1);exports.cursorCharForward=view=>cursorByChar(view,!0);exports.cursorCharLeft=cursorCharLeft;exports.cursorCharRight=cursorCharRight;exports.cursorDocEnd=cursorDocEnd;exports.cursorDocStart=cursorDocStart;exports.cursorGroupBackward=view=>cursorByGroup(view,!1);exports.cursorGroupForward=view=>cursorByGroup(view,!0);exports.cursorGroupLeft=
cursorGroupLeft;exports.cursorGroupRight=cursorGroupRight;exports.cursorLineBoundaryBackward=cursorLineBoundaryBackward;exports.cursorLineBoundaryForward=cursorLineBoundaryForward;exports.cursorLineBoundaryLeft=cursorLineBoundaryLeft;exports.cursorLineBoundaryRight=cursorLineBoundaryRight;exports.cursorLineDown=cursorLineDown;exports.cursorLineEnd=cursorLineEnd;exports.cursorLineStart=cursorLineStart;exports.cursorLineUp=cursorLineUp;exports.cursorMatchingBracket=cursorMatchingBracket;exports.cursorPageDown=
cursorPageDown;exports.cursorPageUp=cursorPageUp;exports.cursorSubwordBackward=view=>cursorBySubword(view,!1);exports.cursorSubwordForward=view=>cursorBySubword(view,!0);exports.cursorSyntaxLeft=cursorSyntaxLeft;exports.cursorSyntaxRight=cursorSyntaxRight;exports.defaultKeymap=defaultKeymap;exports.deleteCharBackward=deleteCharBackward;exports.deleteCharForward=deleteCharForward;exports.deleteGroupBackward=deleteGroupBackward;exports.deleteGroupForward=deleteGroupForward;exports.deleteLine=deleteLine;
exports.deleteToLineEnd=deleteToLineEnd;exports.deleteToLineStart=deleteToLineStart;exports.deleteTrailingWhitespace=({state,dispatch})=>{if(state.readOnly)return!1;let changes=[];for(let pos=0,prev="",iter=state.doc.iter();;){iter.next();if(iter.lineBreak||iter.done){let trailing=prev.search(/\s+$/);-1<trailing&&changes.push({from:pos-(prev.length-trailing),to:pos});if(iter.done)break;prev=""}else prev=iter.value;pos+=iter.value.length}if(!changes.length)return!1;dispatch(state.update({changes,userEvent:"delete"}));
return!0};exports.emacsStyleKeymap=emacsStyleKeymap;exports.history=function(config={}){return[historyField_,historyConfig.of(config),view$jscomp$0.EditorView.domEventHandlers({beforeinput(e,view){let command="historyUndo"==e.inputType?undo:"historyRedo"==e.inputType?redo:null;if(!command)return!1;e.preventDefault();return command(view)}})]};exports.historyField=historyField;exports.historyKeymap=historyKeymap;exports.indentLess=indentLess;exports.indentMore=indentMore;exports.indentSelection=indentSelection;
exports.indentWithTab=indentWithTab;exports.insertBlankLine=insertBlankLine;exports.insertNewline=({state,dispatch})=>{dispatch(state.update(state.replaceSelection(state.lineBreak),{scrollIntoView:!0,userEvent:"input"}));return!0};exports.insertNewlineAndIndent=insertNewlineAndIndent;exports.insertTab=({state,dispatch})=>{if(state.selection.ranges.some(r=>!r.empty))return indentMore({state,dispatch});dispatch(state.update(state.replaceSelection("\t"),{scrollIntoView:!0,userEvent:"input"}));return!0};
exports.invertedEffects=invertedEffects;exports.isolateHistory=isolateHistory;exports.lineComment=lineComment;exports.lineUncomment=lineUncomment;exports.moveLineDown=moveLineDown;exports.moveLineUp=moveLineUp;exports.redo=redo;exports.redoDepth=redoDepth;exports.redoSelection=redoSelection;exports.selectAll=selectAll;exports.selectCharBackward=view=>selectByChar(view,!1);exports.selectCharForward=view=>selectByChar(view,!0);exports.selectCharLeft=selectCharLeft;exports.selectCharRight=selectCharRight;
exports.selectDocEnd=selectDocEnd;exports.selectDocStart=selectDocStart;exports.selectGroupBackward=view=>selectByGroup(view,!1);exports.selectGroupForward=view=>selectByGroup(view,!0);exports.selectGroupLeft=selectGroupLeft;exports.selectGroupRight=selectGroupRight;exports.selectLine=selectLine;exports.selectLineBoundaryBackward=selectLineBoundaryBackward;exports.selectLineBoundaryForward=selectLineBoundaryForward;exports.selectLineBoundaryLeft=selectLineBoundaryLeft;exports.selectLineBoundaryRight=
selectLineBoundaryRight;exports.selectLineDown=selectLineDown;exports.selectLineEnd=selectLineEnd;exports.selectLineStart=selectLineStart;exports.selectLineUp=selectLineUp;exports.selectMatchingBracket=({state,dispatch})=>toMatchingBracket(state,dispatch,!0);exports.selectPageDown=selectPageDown;exports.selectPageUp=selectPageUp;exports.selectParentSyntax=selectParentSyntax;exports.selectSubwordBackward=view=>selectBySubword(view,!1);exports.selectSubwordForward=view=>selectBySubword(view,!0);exports.selectSyntaxLeft=
selectSyntaxLeft;exports.selectSyntaxRight=selectSyntaxRight;exports.simplifySelection=simplifySelection;exports.splitLine=splitLine;exports.standardKeymap=standardKeymap;exports.toggleBlockComment=toggleBlockComment;exports.toggleBlockCommentByLine=toggleBlockCommentByLine;exports.toggleComment=toggleComment;exports.toggleLineComment=toggleLineComment;exports.transposeChars=transposeChars;exports.undo=undo;exports.undoDepth=undoDepth;exports.undoSelection=undoSelection}
//# sourceMappingURL=module$node_modules$$codemirror$commands$dist$index_cjs.js.map
