{"version":3,"sources":["pattern/consequence.cljc"],"mappings":"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","names":["pattern.consequence/succeed","x","pattern.consequence/unwrap","cljs.core/map?","pattern.consequence/apply-form","f","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/simple-symbol?","pattern.syntax/unquote?","pattern.syntax/unquoted-form","pattern.consequence/compile-skeleton","frame-sym","skel","xs","acc","pattern.syntax/splice-reduce","cljs.core.some_fn","pattern.syntax/segment?","pattern.syntax/reverse-segment?","pattern.syntax/unquote-splice?","compile","cljs.core/empty?","cljs.core._EQ_","cljs.core/count","cljs.core/first","form","or__4253__auto__","pattern.syntax/binding?","v","pattern.syntax/variable-name","pattern.syntax/reverse-segment-name","cljs.core/Symbol","cljs.core.into","sicmutils.util/map-vals","cljs.core/vector?","compile-sequential","cljs.core/sequential?","cljs.core/vec"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns pattern.consequence\n  \"Code for defining and compiling 'consequence' functions, ie, functions from a\n  binding map generated by a [[[pattern.match]]] to some successful\n  transformation (or a failure!).\n\n  See [[pattern.rule]] for a detailed treatment.\"\n  (:require [pattern.syntax :as ps]\n            [sicmutils.util :as u]))\n\n;; ## Consequence Functions\n;;\n;; A consequence is a function from a binding dictionary (produced by a matcher)\n;; to a successful result or a failure. A \"rule\" (see `pattern.rule`) is built\n;; out of a matcher (from `pattern.match`) and a consequence function.\n;;\n;; The contract for a \"consequence\" function is that it can return `false`,\n;; `nil` or [[pattern.match/failure]] to signal failure. But what if the\n;; function wants to succeed with `false` or `nil`?\n;;\n;; Wrapping a return value with [[succeed]] will allow a successful return of\n;; `false` or `nil`; a rule using a consequence function uses [[unwrap]] to\n;; retrieve the value before returning it.\n\n(defn succeed\n  \"Wraps the argument `x` in a form that will always successfully return from a\n  consequence function, whatever its value.\n\n  Use [[succeed]] to return `nil` or `false` from a consequence function. For\n  all other return values, returning `(succeed x)` is identical to returning\n  `x`\"\n  [x]\n  {::succeed x})\n\n(defn unwrap\n  \"Given a form returned by a consequence function, unwraps the top level\n  `succeed` wrapper if present to return the final value.\"\n  [x]\n  (if (map? x)\n    (::succeed x x)\n    x))\n\n;; ### Consequence Skeletons\n;;\n;; A Skeleton is a template of the form that we'd like to return from a\n;; consequence function, with pattern-matching variables like `?x` and `??x` in\n;; place of binding map lookups.\n;;\n;; [[compile-skeleton]] transforms an expression like\n\n(comment\n  (let [cake 10]\n    (+ ?x ?y ~cake (? (fn [m] (m '?z))))))\n\n;; Into a form like the following, meant to be evaluated in an environment where\n;; `m` is bound to some map of bindings (the user provides this symbol):\n\n(comment\n  (let [cake 10]\n    (list '+ (m '?x) (m '?y) cake ((fn [m] (m '?z)) m))))\n\n;; See [[compile-skeleton]] for the full set of transformation rules.\n\n(defn- apply-form\n  \"Given symbols `f` representing a function and `x` representing its argument,\n  returns a form that represents function application.\n\n  - Symbols are quoted\n  - [[unquote?]] forms are included without quote\n  - all other forms are left untouched.\"\n  [f x]\n  (let [f (cond (simple-symbol? f) `(quote ~f)\n                (ps/unquote? f) (ps/unquoted-form f)\n                :else f)]\n    (list f x)))\n\n(defn compile-skeleton\n  \"Takes:\n\n  - a symbol `frame-sym` meant to reference a map of bindings\n  - a skeleton expression `skel`\n\n  and returns an unevaluated body that, when evaluated, will produce a form\n  structure of identical shape to `skel`, with:\n\n  - all variable binding forms replaced by forms that look up the binding in a\n    map bound to `frame-sym`\n  - same with any segment binding form, with the added note that these should\n    be spliced in\n  - any `unquote` or `unquote-splicing` forms respected.\"\n  [frame-sym skel]\n  (letfn [(compile-sequential [xs]\n            (let [acc (ps/splice-reduce (some-fn ps/segment?\n                                                 ps/reverse-segment?\n                                                 ps/unquote-splice?)\n                                        compile xs)]\n              (cond (empty? acc) ()\n                    (= 1 (count acc)) (first acc)\n                    :else `(concat ~@acc))))\n\n          (compile [form]\n            (cond (or (ps/binding? form)\n                      (ps/segment? form))\n                  (let [v (ps/variable-name form)]\n                    (apply-form v frame-sym))\n\n                  (ps/reverse-segment? form)\n                  (let [v (ps/reverse-segment-name form)]\n                    (list `rseq (apply-form v frame-sym)))\n\n                  (symbol? form) (list 'quote form)\n\n                  (ps/unquote? form)\n                  (ps/unquoted-form form)\n\n                  (ps/unquote-splice? form)\n                  (into [] (ps/unquoted-form form))\n\n                  (map? form)\n                  (u/map-vals compile form)\n\n                  (vector? form)\n                  `(vec ~(compile-sequential form))\n\n                  (sequential? form)\n                  (if (empty? form)\n                    form\n                    `(seq ~(compile-sequential form)))\n\n                  :else form))]\n    (if skel\n      `(let [r# ~(compile skel)]\n         (or r# (succeed r#)))\n      `(succeed ~skel))))\n"]}