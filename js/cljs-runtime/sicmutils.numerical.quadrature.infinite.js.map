{"version":3,"sources":["sicmutils/numerical/quadrature/infinite.cljc"],"mappings":"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","names":["sicmutils.numerical.quadrature.infinite/fill-defaults","opts","cljs.core.merge","sicmutils.numerical.quadrature.infinite/improper","integrator","f","a","b","sicmutils$numerical$quadrature$infinite$improper_$_rec","map__90383","cljs.core/--destructure-map","cljs.core.get","infinite-breakpoint","call","integrate","l","r","interval","m","sicmutils.numerical.quadrature.common/with-interval","result","ab-interval","sicmutils.numerical.quadrature.common/interval","cljs.core.partial","inf-integrate","sicmutils.numerical.quadrature.substitute/infinitize","r-break","Math/abs","l-break","ocr-90387","cljs.core/vector?","cljs.core/count","ocr-90387_0__90394","cljs.core.nth","ocr-90387_1__90395","cljs.core.match/backtrack","e90411","js/Error","e__79159__auto__","e90397","e90409","e90398","e90407","e90399","e90405","e90400","e90403","e90401","e90402","e90396","cljs.core.update","cljs.core/-","-inf->l","sicmutils.numerical.quadrature.common/open-closed","l->r","sicmutils.numerical.quadrature.common/closed","r->+inf","sicmutils.numerical.quadrature.common/closed-open","l->b","sicmutils.numerical.quadrature.common/close-l","a->r","sicmutils.numerical.quadrature.common/close-r"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature.infinite\n  (:require [clojure.core.match :refer [match]]\n            [sicmutils.numerical.quadrature.common :as qc]\n            [sicmutils.numerical.quadrature.substitute :as qs]))\n\n;; ## Improper (infinite) Integrals\n;;\n;; This namespace holds an implementation of an \"improper\" integral\n;; combinator (for infinite endpoints) usable with any quadrature method in the\n;; library.\n;;\n;; The implementation was inspired by `evaluate-improper-integral` in\n;; `numerics/quadrature/quadrature.scm` file in\n;; the [scmutils](https://groups.csail.mit.edu/mac/users/gjs/6946/refman.txt)\n;; package.\n;;\n;; ## Overview\n;;\n;; To evaluate an [improper\n;; integral](https://en.wikipedia.org/wiki/Improper_integral) with an infinite\n;; endpoint, the `improper` combinator applies an internal change of variables.\n;;\n;; $$u(t) = {1 \\over t}$$ $$du = {-1 \\over t^2}$$\n;;\n;; This has the effect of mapping the endpoints from $a, b$ to ${1 \\over b}, {1\n;; \\over a}$. Here's the identity we implement:\n;;\n;; $$\\int_{a}^{b} f(x) d x=\\int_{1 / b}^{1 / a} \\frac{1}{t^{2}} f\\left(\\frac{1}{t}\\right) dt$$\n;;\n;; This is implemented by `substitute/infinitize`.\n;;\n;; The variable change only works as written when both endpoints are of the same\n;; sign; so, internally, `improper` only applies the variable change to the\n;; segment of $a, b$ from `##-Inf => (- :infinite-breakpoint)` and\n;; `:infinite-breakpoint -> ##Inf`, where `:infinite-breakpoint` is an argument\n;; the user can specify in the returned integrator's options map.\n;;\n;; Any segment of $a, b$ /not/ in those regions is evaluated normally.\n;;\n;; NOTE: The ideas in this namespace could be implemented for other variable\n;; substitutions (see `substitute.cljc`) that only need to apply to certain\n;; integration intervals. The code below automatically cuts the range $(a, b)$\n;; to accomodate this for the particular variable change we've baked in, but\n;; there is a more general abstraction lurking.\n;;\n;; If you find it, please submit an issue!\n;;\n;; ## Implementation\n\n(defn- fill-defaults\n  \"Populates the supplied `opts` dictionary with defaults required by\n  `evaluate-infinite-integral`.\"\n  [opts]\n  (merge {:infinite-breakpoint 1} opts))\n\n(defn improper\n  \"Accepts:\n\n  - An `integrator` (function of `f`, `a`, `b` and `opts`)\n  - `a` and `b`, the endpoints of an integration interval, and\n  - (optionally) `opts`, a dict of integrator-configuring options\n\n  And returns a new integrator that's able to handle infinite endpoints. (If you\n  don't specify `##-Inf` or `##Inf`, the returned integrator will fall through\n  to the original `integrator` implementation.)\n\n  All `opts` will be passed through to the supplied `integrator`.\n\n  ## Optional arguments relevant to `improper`:\n\n  `:infinite-breakpoint`: If either `a` or `b` is equal to `##Inf` or `##-Inf`,\n  this function will internally perform a change of variables on the regions\n  from:\n\n  ```\n  (:infinite-breakpoint opts) => ##Inf\n  ```\n\n  or\n\n  ```\n  ##-Inf => (- (:infinite-breakpoint opts))\n  ```\n\n  using $u(t) = {1 \\\\over t}$, as described in the `infinitize` method of\n  `substitute.cljc`. This has the effect of mapping the infinite endpoint to an\n  open interval endpoint of 0.\n\n  Where should you choose the breakpoint? According to Press in Numerical\n  Recipes, section 4.4: \\\"At a sufficiently large positive value so that the\n  function funk is at least beginning to approach its asymptotic decrease to\n  zero value at infinity.\\\"\n\n  References:\n\n  - Press, Numerical Recipes (p138), [Section 4.4](http://phys.uri.edu/nigh/NumRec/bookfpdf/f4-4.pdf)\"\n  [integrator]\n  (fn rec\n    ([f a b] (rec f a b {}))\n    ([f a b opts]\n     (let [{:keys [infinite-breakpoint] :as opts} (fill-defaults opts)\n           call (fn [integrate l r interval]\n                  (let [m      (qc/with-interval opts interval)\n                        result (integrate f l r m)]\n                    (:result result)))\n           ab-interval   (qc/interval opts)\n           integrate     (partial call integrator)\n           inf-integrate (partial call (qs/infinitize integrator))\n           r-break       (Math/abs ^double infinite-breakpoint)\n           l-break       (- r-break)]\n       (match [[a b]]\n              [(:or [##-Inf ##-Inf] [##Inf ##Inf])]\n              {:converged? true\n               :terms-checked 0\n               :result 0.0}\n\n              [(:or [_ ##-Inf] [##Inf _])]\n              (-> (rec f b a opts)\n                  (update :result -))\n\n              ;; Break the region up into three pieces: a central closed core\n              ;; and two open endpoints where we create a change of variables,\n              ;; letting the boundary go to infinity. We use an OPEN interval on\n              ;; the infinite side.\n              [[##-Inf ##Inf]]\n              (let [-inf->l (inf-integrate a l-break qc/open-closed)\n                    l->r    (integrate     l-break r-break qc/closed)\n                    r->+inf (inf-integrate r-break b qc/closed-open)]\n                {:converged? true\n                 :result (+ -inf->l l->r r->+inf)})\n\n              ;; If `b` lies to the left of the negative breakpoint, don't cut.\n              ;; Else, cut the integral into two pieces at the negative\n              ;; breakpoint and variable-change the left piece.\n              [[##-Inf _]]\n              (if (<= b l-break)\n                (inf-integrate a b ab-interval)\n                (let [-inf->l (inf-integrate a l-break qc/open-closed)\n                      l->b    (integrate     l-break b (qc/close-l ab-interval))]\n                  {:converged? true\n                   :result (+ -inf->l l->b)}))\n\n              ;; If `a` lies to the right of the positive breakpoint, don't cut.\n              ;; Else, cut the integral into two pieces at the positive breakpoint\n              ;; and variable-change the right piece.\n              [[_ ##Inf]]\n              (if (>= a r-break)\n                (inf-integrate a b ab-interval)\n                (let [a->r    (integrate     a r-break (qc/close-r ab-interval))\n                      r->+inf (inf-integrate r-break b qc/closed-open)]\n                  {:converged? true\n                   :result (+ a->r r->+inf)}))\n\n              ;; This is a lot of machinery to use with NON-infinite endpoints;\n              ;; but for completeness, if you reach this level the fn will attempt\n              ;; to integrate the full range directly using the original\n              ;; integrator.\n              :else (integrator f a b opts))))))\n\n;; ## Suggestions for Improvement\n;;\n;; The current implementation does not pass convergence information back up the\n;; line! Ideally we would merge results by:\n;;\n;; - Adding results\n;; - combining `:converged?` entries with `and`\n;; - retaining all other keys\n"]}