shadow$provide.module$node_modules$mathbox$build$esm$stage$api=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===
obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=
obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}function __range__(left,right,inclusive){const range=[],ascending=left<right;for(right=inclusive?ascending?right+1:right-1:right;ascending?left<right:left>right;ascending?left++:left--)range.push(left);return range}Object.defineProperty(exports,"__esModule",{value:!0});exports.API=void 0;var Pretty=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$pretty")),ShaderGraph=_interopRequireWildcard(require("module$node_modules$shadergraph$src$index"));
class API{v2(){return this}constructor(_context,_up,_targets){this._context=_context;this._up=_up;this._targets=_targets;_context=this._context.controller.getRoot();null==this._targets&&(this._targets=[_context]);this.isRoot=1===this._targets.length&&this._targets[0]===_context;this.isLeaf=1===this._targets.length&&null==this._targets[0].children;for(_context=0;_context<this._targets.length;_context++)this[_context]=this._targets[_context];this.length=this._targets.length;for(const type of Array.from(this._context.controller.getTypes()))["root"].includes(type)||
(this[type]=(options,binds)=>this.add(type,options,binds))}select(selector){selector=this._context.model.select(selector,this.isRoot?null:this._targets);return this._push(selector)}eq(index){return this._targets.length>index?this._push([this._targets[index]]):this._push([])}filter(callback){if("string"===typeof callback){const matcher=this._context.model._matcher(callback);callback=x=>matcher(x)}return this._push(this._targets.filter(callback))}map(callback){return __range__(0,this.length,!1).map(i=>
callback(this[i],i,this))}each(callback){for(let i=0,end=this.length,asc=0<=end;asc?i<end:i>end;asc?i++:i--)callback(this[i],i,this);return this}add(type,options,binds){const {controller}=this._context;if(this.isLeaf)return this._pop().add(type,options,binds);const nodes=[];for(const target of this._targets){const node=controller.make(type,options,binds);controller.add(node,target);nodes.push(node)}return this._push(nodes)}remove(selector){if(selector)return this.select(selector).remove();for(const target of Array.from(this._targets.slice().reverse()))this._context.controller.remove(target);
return this._pop()}set(key,value){for(const target of Array.from(this._targets))this._context.controller.set(target,key,value);return this}getAll(key){return Array.from(this._targets).map(target=>this._context.controller.get(target,key))}get(key){return null!=this._targets[0]?this._targets[0].get(key):void 0}evaluate(key,time){return null!=this._targets[0]?this._targets[0].evaluate(key,time):void 0}bind(key,value){for(const target of Array.from(this._targets))this._context.controller.bind(target,
key,value);return this}unbind(key){for(const target of Array.from(this._targets))this._context.controller.unbind(target,key);return this}end(){return(this.isLeaf?this._pop():this)._pop()}_push(targets){return new API(this._context,this,targets)}_pop(){return null!=this._up?this._up:this}_reset(){let left;return null!=(left=null!=this._up?this._up.reset():void 0)?left:this}map(callback){return this._targets.map(callback)}on(){const args=arguments;this._targets.map(x=>x.on.apply(x,args));return this}off(){const args=
arguments;this._targets.map(x=>x.off.apply(x,args));return this}toString(){const tags=this._targets.map(x=>x.toString());return 1<this._targets.length?`[${tags.join(", ")}]`:tags[0]}toMarkup(){return this._targets.map(x=>x.toMarkup()).join("\n\n")}print(){Pretty.print(this._targets.map(x=>x.toMarkup()).join("\n\n"));return this}debug(){var info=this.inspect();console.log("Renderables: ",info.renderables);console.log("Renders: ",info.renders);console.log("Shaders: ",info.shaders);const shaders=[];
for(const shader of Array.from(info.shaders))info=shader.owner.constructor.toString().match("function +([^(]*)")[1],shaders.push(`${info} - Vertex`),shaders.push(shader.vertex),shaders.push(`${info} - Fragment`),shaders.push(shader.fragment);return ShaderGraph.inspect(shaders)}inspect(selector,trait,print){let self;"boolean"===typeof trait&&(print=trait,trait=null);null==print&&(print=!0);const recurse=self=function(node,list){null==list&&(list=[]);trait&&!node.traits.hash[trait]||list.push(null!=
(null!=node.controller?node.controller.objects:void 0)?null!=node.controller?node.controller.objects:void 0:[]);if(null!=node.children)for(const child of Array.from(node.children))self(child,list);return list},flatten=function(list){list=list.reduce((a,b)=>a.concat(b),[]);return list=list.filter((x,i)=>null!=x&&list.indexOf(x)===i)},info={nodes:this._targets.slice(),renderables:[],renders:[],shaders:[]};for(const target of Array.from(this._targets)){let renderables;print&&target.print(selector,"info");
const _info={renderables:renderables=flatten(recurse(target)),renders:flatten(renderables.map(x=>x.renders)),shaders:flatten(renderables.map(x=>null!=x.renders?x.renders.map(r=>{const d={};d.owner=x;d.geometry=r.geometry;d.material=r.material;d.vertex=r.userData.vertexGraph;d.fragment=r.userData.fragmentGraph;return d}):void 0))};for(const k in _info)info[k]=info[k].concat(_info[k])}return info}}exports.API=API}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$stage$api.js.map
