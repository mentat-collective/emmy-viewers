shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$base$curve=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _jxg=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg")),_constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants")),_coords=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coords"));
global=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$element"));var _math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),_numerics=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$numerics")),_plot=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$plot")),_geometry=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$geometry")),
_geonext=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$parser$geonext")),_type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type")),_qdt=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$qdt"));_jxg.default.Curve=function(board,parents,attributes){this.constructor(board,attributes,_constants.default.OBJECT_TYPE_CURVE,_constants.default.OBJECT_CLASS_CURVE);this.points=[];this.numberPoints=
_type.default.evaluate(this.visProp.numberpointshigh);this.bezierDegree=1;this.dataY=this.dataX=null;this.ticks=[];this.qdt=null;_type.default.exists(parents[0])?this.varname=parents[0]:this.varname="x";this.xterm=parents[1];this.yterm=parents[2];this.generateTerm(this.varname,this.xterm,this.yterm,parents[3],parents[4]);this.updateCurve();this.id=this.board.setId(this,"G");this.board.renderer.drawCurve(this);this.board.finalizeAdding(this);this.createGradient();this.elType="curve";this.createLabel();
_type.default.isString(this.xterm)&&this.notifyParents(this.xterm);_type.default.isString(this.yterm)&&this.notifyParents(this.yterm);this.methodMap=_type.default.deepCopy(this.methodMap,{generateTerm:"generateTerm",setTerm:"generateTerm",move:"moveTo",moveTo:"moveTo"})};_jxg.default.Curve.prototype=new global.default;_jxg.default.extend(_jxg.default.Curve.prototype,{minX:function(){return"polar"===_type.default.evaluate(this.visProp.curvetype)?0:(new _coords.default(_constants.default.COORDS_BY_SCREEN,
[.1*-this.board.canvasWidth,0],this.board,!1)).usrCoords[1]},maxX:function(){return"polar"===_type.default.evaluate(this.visProp.curvetype)?2*Math.PI:(new _coords.default(_constants.default.COORDS_BY_SCREEN,[1.1*this.board.canvasWidth,0],this.board,!1)).usrCoords[1]},X:function(t){return NaN},Y:function(t){return NaN},Z:function(t){return 1},hasPoint:function(x,y,start){var t=[];var len=_type.default.evaluate(this.visProp.numberpointslow);var points=(this.maxX()-this.minX())/len;var tX=Infinity;if(_type.default.isObject(_type.default.evaluate(this.visProp.precision))){var prec=
this.board._inputDevice;prec=_type.default.evaluate(this.visProp.precision[prec])}else prec=this.board.options.precision.hasPoint;y=new _coords.default(_constants.default.COORDS_BY_SCREEN,[x,y],this.board,!1);x=y.usrCoords[1];y=y.usrCoords[2];if(1===this.bezierDegree&&_type.default.evaluate(this.visProp.hasinnerpoints)){var isIn=_geometry.default.windingNumber([1,x,y],this.points,!0);if(0!==isIn)return!0}prec+=.5*_type.default.evaluate(this.visProp.strokewidth);prec*=prec;isIn=this.board.unitX*this.board.unitX;
var uy2=this.board.unitY*this.board.unitY;var mi=this.minX();this.maxX();_type.default.exists(this._visibleArea)&&(mi=this._visibleArea[0],points=this._visibleArea[1],points=(points-mi)/len);var ev_ct=_type.default.evaluate(this.visProp.curvetype);if("parameter"===ev_ct||"polar"===ev_ct)for(0<this.transformations.length&&(this.updateTransformMatrix(),t=_math.default.inverse(this.transformMat),y=_math.default.matVecMult(t,[1,x,y]),x=y[1],y=y[2]),start=0,t=mi;start<len;start++){tX=this.X(t,!0);var tY=
this.Y(t,!0);tX=(x-tX)*(x-tX)*isIn+(y-tY)*(y-tY)*uy2;if(tX<=prec)return!0;t+=points}else if("plot"===ev_ct||"functiongraph"===ev_ct){if(!_type.default.exists(start)||0>start)start=0;_type.default.exists(this.qdt)&&_type.default.evaluate(this.visProp.useqdt)&&3!==this.bezierDegree?(tY=this.qdt.query(new _coords.default(_constants.default.COORDS_BY_USER,[x,y],this.board)),points=tY.points,len=points.length):(points=this.points,len=this.numberPoints-1);for(;start<len;start++)if(3===this.bezierDegree?
t.push(_geometry.default.projectCoordsToBeziersegment([1,x,y],this,start)):tY?(points[start].prev&&(t=_geometry.default.projectCoordsToSegment([1,x,y],points[start].prev.usrCoords,points[start].usrCoords)),points[start].next&&points[start+1]!==points[start].next&&(t=_geometry.default.projectCoordsToSegment([1,x,y],points[start].usrCoords,points[start].next.usrCoords))):t=_geometry.default.projectCoordsToSegment([1,x,y],points[start].usrCoords,points[start+1].usrCoords),0<=t[1]&&1>=t[1]&&(x-t[0][1])*
(x-t[0][1])*isIn+(y-t[0][2])*(y-t[0][2])*uy2<=prec)return!0;return!1}return tX<prec},allocatePoints:function(){var i;var len=this.numberPoints;if(this.points.length<this.numberPoints)for(i=this.points.length;i<len;i++)this.points[i]=new _coords.default(_constants.default.COORDS_BY_USER,[0,0],this.board,!1)},update:function(){this.needsUpdate&&(_type.default.evaluate(this.visProp.trace)&&this.cloneToBackground(!0),this.updateCurve());return this},updateRenderer:function(){if(!this.needsUpdate)return this;
this.visPropCalc.visible&&((this.isReal=_plot.default.checkReal(this.points))||this.updateVisibility(!1));this.visPropCalc.visible&&this.board.renderer.updateCurve(this);this.hasLabel&&this.visPropCalc.visible&&this.label&&this.label.visPropCalc.visible&&this.isReal&&(this.label.update(),this.board.renderer.updateText(this.label));this.setDisplayRendNode();this.needsUpdate=!1;return this},updateDataArray:function(){},updateCurve:function(){var x=this.visProp.plotversion;var suspendUpdate=!1;this.updateTransformMatrix();
this.updateDataArray();var len=this.minX();var ma=this.maxX();if(_type.default.exists(this.dataX))for(len=this.numberPoints=this.dataX.length,this.allocatePoints(),ma=0;ma<len;ma++)x=ma,_type.default.exists(this.dataY)?this.points[ma].setCoordinates(_constants.default.COORDS_BY_USER,[this.dataX[ma],this.dataY[ma]],!1):(x=this.X(x),this.points[ma].setCoordinates(_constants.default.COORDS_BY_USER,[this.dataX[ma],this.Y(x,suspendUpdate)],!1)),this.points[ma]._t=ma,suspendUpdate=!0;else if(_type.default.evaluate(this.visProp.doadvancedplot)?
1===x||_type.default.evaluate(this.visProp.doadvancedplotold)?_plot.default.updateParametricCurveOld(this,len,ma):2===x?_plot.default.updateParametricCurve_v2(this,len,ma):3===x?_plot.default.updateParametricCurve_v3(this,len,ma):4===x?_plot.default.updateParametricCurve_v4(this,len,ma):_plot.default.updateParametricCurve_v2(this,len,ma):(this.numberPoints=this.board.updateQuality===this.board.BOARD_QUALITY_HIGH?_type.default.evaluate(this.visProp.numberpointshigh):_type.default.evaluate(this.visProp.numberpointslow),
this.allocatePoints(),_plot.default.updateParametricCurveNaive(this,len,ma,this.numberPoints)),len=this.numberPoints,_type.default.evaluate(this.visProp.useqdt)&&this.board.updateQuality===this.board.BOARD_QUALITY_HIGH)for(this.qdt=new _qdt.default(this.board.getBoundingBox()),ma=0;ma<this.points.length;ma++)this.qdt.insert(this.points[ma]),0<ma&&(this.points[ma].prev=this.points[ma-1]),ma<len-1&&(this.points[ma].next=this.points[ma+1]);"plot"!==_type.default.evaluate(this.visProp.curvetype)&&_type.default.evaluate(this.visProp.rdpsmoothing)&&
(this.points=_numerics.default.RamerDouglasPeucker(this.points,.2),this.numberPoints=this.points.length);len=this.numberPoints;for(ma=0;ma<len;ma++)this.updateTransform(this.points[ma]);return this},updateTransformMatrix:function(){var i,len=this.transformations.length;this.transformMat=[[1,0,0],[0,1,0],[0,0,1]];for(i=0;i<len;i++){var t=this.transformations[i];t.update();this.transformMat=_math.default.matMatMult(t.matrix,this.transformMat)}return this},updateTransform:function(p){if(0<this.transformations.length){var c=
_math.default.matVecMult(this.transformMat,p.usrCoords);p.setCoordinates(_constants.default.COORDS_BY_USER,c,!1,!0)}return p},addTransform:function(transform){var list=_type.default.isArray(transform)?transform:[transform],len=list.length;for(transform=0;transform<len;transform++)this.transformations.push(list[transform]);return this},interpolationFunctionFromArray:function(which){var data="data"+which,that=this;return function(t,suspendedUpdate){var j;suspendedUpdate=that[data];var i=suspendedUpdate.length;
var f=[];if(isNaN(t))return NaN;if(0>t)return _type.default.isFunction(suspendedUpdate[0])?suspendedUpdate[0]():suspendedUpdate[0];if(3===that.bezierDegree){if(t>=(i-1)/3)return _type.default.isFunction(suspendedUpdate[suspendedUpdate.length-1])?suspendedUpdate[suspendedUpdate.length-1]():suspendedUpdate[suspendedUpdate.length-1];i=3*Math.floor(t);t%=1;var t1=1-t;for(j=0;4>j;j++)_type.default.isFunction(suspendedUpdate[i+j])?f[j]=suspendedUpdate[i+j]():f[j]=suspendedUpdate[i+j];return t1*t1*(t1*f[0]+
3*t*f[1])+(3*t1*f[2]+t*f[3])*t*t}i=t>i-2?i-2:parseInt(Math.floor(t),10);if(i===t)return _type.default.isFunction(suspendedUpdate[i])?suspendedUpdate[i]():suspendedUpdate[i];for(j=0;2>j;j++)_type.default.isFunction(suspendedUpdate[i+j])?f[j]=suspendedUpdate[i+j]():f[j]=suspendedUpdate[i+j];return f[0]+(f[1]-f[0])*(t-i)}},generateTerm:function(varname,xterm,yterm,mi,ma){if(_type.default.isArray(xterm))this.dataX=xterm,this.numberPoints=this.dataX.length,this.X=this.interpolationFunctionFromArray.apply(this,
["X"]),this.visProp.curvetype="plot";else if(this.X=_type.default.createFunction(xterm,this.board,varname),_type.default.isString(xterm))this.visProp.curvetype="functiongraph";else if(_type.default.isFunction(xterm)||_type.default.isNumber(xterm))this.visProp.curvetype="parameter";this.isDraggable=!0;_type.default.isArray(yterm)?(this.dataY=yterm,this.Y=this.interpolationFunctionFromArray.apply(this,["Y"])):this.Y=_type.default.createFunction(yterm,this.board,varname);if(_type.default.isFunction(xterm)&&
_type.default.isArray(yterm)){var fx=_type.default.createFunction(yterm[0],this.board,"");var fy=_type.default.createFunction(yterm[1],this.board,"");this.X=function(phi){return xterm(phi)*Math.cos(phi)+fx()};this.Y=function(phi){return xterm(phi)*Math.sin(phi)+fy()};this.visProp.curvetype="polar"}_type.default.exists(mi)&&(this.minX=_type.default.createFunction(mi,this.board,""));_type.default.exists(ma)&&(this.maxX=_type.default.createFunction(ma,this.board,""))},notifyParents:function(contentStr){var fstr,
dep,isJessieCode=!1;var obj={xterm:1,yterm:1};for(fstr in obj)if(obj.hasOwnProperty(fstr)&&this.hasOwnProperty(fstr)&&this[fstr].origin)for(dep in isJessieCode=!0,this[fstr].origin.deps)this[fstr].origin.deps.hasOwnProperty(dep)&&this[fstr].origin.deps[dep].addChild(this);isJessieCode||_geonext.default.findDependencies(this,contentStr,this.board)},getLabelAnchor:function(){var x=.05*this.board.canvasWidth;var c=.05*this.board.canvasHeight;var bx=.95*this.board.canvasWidth,by=.95*this.board.canvasHeight;
switch(_type.default.evaluate(this.visProp.label.position)){case "ulft":break;case "llft":c=by;break;case "rt":x=bx;c=.5*by;break;case "lrt":x=bx;c=by;break;case "urt":x=bx;break;case "top":x=.5*bx;break;case "bot":x=.5*bx;c=by;break;default:c=.5*by}c=new _coords.default(_constants.default.COORDS_BY_SCREEN,[x,c],this.board,!1);return _geometry.default.projectCoordsToCurve(c.usrCoords[1],c.usrCoords[2],0,this,this.board)[0]},cloneToBackground:function(){var copy={id:this.id+"T"+this.numTraces,elementClass:_constants.default.OBJECT_CLASS_CURVE,
points:this.points.slice(0),bezierDegree:this.bezierDegree,numberPoints:this.numberPoints,board:this.board,visProp:_type.default.deepCopy(this.visProp,this.visProp.traceattributes,!0)};copy.visProp.layer=this.board.options.layer.trace;copy.visProp.curvetype=this.visProp.curvetype;this.numTraces++;_type.default.clearVisPropOld(copy);copy.visPropCalc={visible:_type.default.evaluate(copy.visProp.visible)};var er=this.board.renderer.enhancedRendering;this.board.renderer.enhancedRendering=!0;this.board.renderer.drawCurve(copy);
this.board.renderer.enhancedRendering=er;this.traces[copy.id]=copy.rendNode;return this},bounds:function(){var minX=Infinity,maxX=-Infinity,minY=Infinity,maxY=-Infinity,l=this.points.length,i;if(3===this.bezierDegree){for(i=0;i<l;i++)this.points[i].X=_type.default.bind(function(){return this.usrCoords[1]},this.points[i]),this.points[i].Y=_type.default.bind(function(){return this.usrCoords[2]},this.points[i]);var bezier=_numerics.default.bezier(this.points);maxY=bezier[3]();minX=_numerics.default.fminbr(function(t){return bezier[0](t)},
[0,maxY]);maxX=_numerics.default.fminbr(function(t){return-bezier[0](t)},[0,maxY]);minY=_numerics.default.fminbr(function(t){return bezier[1](t)},[0,maxY]);maxY=_numerics.default.fminbr(function(t){return-bezier[1](t)},[0,maxY]);minX=bezier[0](minX);maxX=bezier[0](maxX);minY=bezier[1](minY);maxY=bezier[1](maxY);return[minX,maxY,maxX,minY]}for(i=0;i<l;i++)minX>this.points[i].usrCoords[1]&&(minX=this.points[i].usrCoords[1]),maxX<this.points[i].usrCoords[1]&&(maxX=this.points[i].usrCoords[1]),minY>this.points[i].usrCoords[2]&&
(minY=this.points[i].usrCoords[2]),maxY<this.points[i].usrCoords[2]&&(maxY=this.points[i].usrCoords[2]);return[minX,maxY,maxX,minY]},getParents:function(){var p=[this.xterm,this.yterm,this.minX(),this.maxX()];0!==this.parents.length&&(p=this.parents);return p},moveTo:function(where){if(0<this.points.length&&!_type.default.evaluate(this.visProp.fixed)){var p=this.points[0];where=3===where.length?[where[0]-p.usrCoords[0],where[1]-p.usrCoords[1],where[2]-p.usrCoords[2]]:[where[0]-p.usrCoords[1],where[1]-
p.usrCoords[2]];this.setPosition(_constants.default.COORDS_BY_USER,where)}return this},getTransformationSource:function(){var isTransformed;if(_type.default.exists(this._transformationSource)){var curve_org=this._transformationSource;curve_org.elementClass===_constants.default.OBJECT_CLASS_CURVE&&(isTransformed=!0)}return[isTransformed,curve_org]},pnpoly:function(x_in,y_in,coord_type){var v=this.points,isIn=!1;if(coord_type===_constants.default.COORDS_BY_USER){y_in=new _coords.default(_constants.default.COORDS_BY_USER,
[x_in,y_in],this.board);x_in=y_in.scrCoords[1];var y=y_in.scrCoords[2]}else y=y_in;var len=this.points.length;y_in=0;for(coord_type=len-2;y_in<len-1;coord_type=y_in++)v[y_in].scrCoords[2]>y!==v[coord_type].scrCoords[2]>y&&x_in<(v[coord_type].scrCoords[1]-v[y_in].scrCoords[1])*(y-v[y_in].scrCoords[2])/(v[coord_type].scrCoords[2]-v[y_in].scrCoords[2])+v[y_in].scrCoords[1]&&(isIn=!isIn);return isIn}});_jxg.default.createCurve=function(board,parents,attributes){var attr=_type.default.copyAttributes(attributes,
board.options,"curve");var obj=board.select(parents[0],!0);if(_type.default.isTransformationOrArray(parents[1])&&_type.default.isObject(obj)&&(obj.type===_constants.default.OBJECT_TYPE_CURVE||obj.type===_constants.default.OBJECT_TYPE_ANGLE||obj.type===_constants.default.OBJECT_TYPE_ARC||obj.type===_constants.default.OBJECT_TYPE_CONIC||obj.type===_constants.default.OBJECT_TYPE_SECTOR))return obj.type===_constants.default.OBJECT_TYPE_SECTOR?attr=_type.default.copyAttributes(attributes,board.options,
"sector"):obj.type===_constants.default.OBJECT_TYPE_ARC?attr=_type.default.copyAttributes(attributes,board.options,"arc"):obj.type===_constants.default.OBJECT_TYPE_ANGLE?(_type.default.exists(attributes.withLabel)||(attributes.withLabel=!1),attr=_type.default.copyAttributes(attributes,board.options,"angle")):attr=_type.default.copyAttributes(attributes,board.options,"curve"),attr=_type.default.copyAttributes(attr,board.options,"curve"),board=new _jxg.default.Curve(board,["x",[],[]],attr),board.updateDataArray=
function(){var i,le=obj.numberPoints;this.bezierDegree=obj.bezierDegree;this.dataX=[];this.dataY=[];for(i=0;i<le;i++)this.dataX.push(obj.points[i].usrCoords[1]),this.dataY.push(obj.points[i].usrCoords[2]);return this},board.addTransform(parents[1]),obj.addChild(board),board.setParents([obj]),board._transformationSource=obj,board;attr=_type.default.copyAttributes(attributes,board.options,"curve");return new _jxg.default.Curve(board,["x"].concat(parents),attr)};_jxg.default.registerElement("curve",
_jxg.default.createCurve);_jxg.default.createFunctiongraph=function(board,parents,attributes){parents=["x","x"].concat(parents);attributes=_type.default.copyAttributes(attributes,board.options,"curve");attributes.curvetype="functiongraph";return new _jxg.default.Curve(board,parents,attributes)};_jxg.default.registerElement("functiongraph",_jxg.default.createFunctiongraph);_jxg.default.registerElement("plot",_jxg.default.createFunctiongraph);_jxg.default.createSpline=function(board,parents,attributes){attributes=
_type.default.copyAttributes(attributes,board.options,"curve");attributes.curvetype="functiongraph";var ret=function(){var D,x=[],y=[];return[function(t,suspended){var j;if(!suspended){x=[];y=[];if(2===parents.length&&_type.default.isArray(parents[0])&&_type.default.isArray(parents[1])&&parents[0].length===parents[1].length)for(suspended=0;suspended<parents[0].length;suspended++)_type.default.isFunction(parents[0][suspended])?x.push(parents[0][suspended]()):x.push(parents[0][suspended]),_type.default.isFunction(parents[1][suspended])?
y.push(parents[1][suspended]()):y.push(parents[1][suspended]);else for(suspended=0;suspended<parents.length;suspended++)if(_type.default.isPoint(parents[suspended]))x.push(parents[suspended].X()),y.push(parents[suspended].Y());else if(_type.default.isArray(parents[suspended])&&2===parents[suspended].length)for(j=0;j<parents.length;j++)_type.default.isFunction(parents[j][0])?x.push(parents[j][0]()):x.push(parents[j][0]),_type.default.isFunction(parents[j][1])?y.push(parents[j][1]()):y.push(parents[j][1]);
else _type.default.isFunction(parents[suspended])&&2===parents[suspended]().length&&(j=parents[suspended](),x.push(j[0]),y.push(j[1]));D=_numerics.default.splineDef(x,y)}return _numerics.default.splineEval(t,x,y,D)},function(){return x[0]},function(){return x[x.length-1]}]}();board=new _jxg.default.Curve(board,["x","x",ret[0],ret[1],ret[2]],attributes);board.setParents(parents);board.elType="spline";return board};_jxg.default.registerElement("spline",_jxg.default.createSpline);_jxg.default.createCardinalSpline=
function(board,parents,attributes){var i;if(!_type.default.exists(parents[0])||!_type.default.isArray(parents[0]))throw Error("JSXGraph: JXG.createCardinalSpline: argument 1 'points' has to be array of points or coordinate pairs\nPossible parent types: [points:array, tau:number|function, type:string]");if(!_type.default.exists(parents[1])||!_type.default.isNumber(parents[1])&&!_type.default.isFunction(parents[1]))throw Error("JSXGraph: JXG.createCardinalSpline: argument 2 'tau' has to be number between [0,1] or function'\nPossible parent types: [points:array, tau:number|function, type:string]");
if(!_type.default.exists(parents[2])||!_type.default.isString(parents[2]))throw Error("JSXGraph: JXG.createCardinalSpline: argument 3 'type' has to be string 'uniform' or 'centripetal'\nPossible parent types: [points:array, tau:number|function, type:string]");attributes=_type.default.copyAttributes(attributes,board.options,"curve");attributes=_type.default.copyAttributes(attributes,board.options,"cardinalspline");attributes.curvetype="parameter";var getPointLike=parents[0];var q=[];if(!attributes.isarrayofcoordinates&&
2===getPointLike.length&&_type.default.isArray(getPointLike[0])&&_type.default.isArray(getPointLike[1])&&getPointLike[0].length===getPointLike[1].length)for(i=0;i<getPointLike[0].length;i++)q[i]=[],_type.default.isFunction(getPointLike[0][i])?q[i].push(getPointLike[0][i]()):q[i].push(getPointLike[0][i]),_type.default.isFunction(getPointLike[1][i])?q[i].push(getPointLike[1][i]()):q[i].push(getPointLike[1][i]);else for(i=0;i<getPointLike.length;i++)_type.default.isString(getPointLike[i])?q.push(board.select(getPointLike[i])):
_type.default.isPoint(getPointLike[i])?q.push(getPointLike[i]):_type.default.isArray(getPointLike[i])&&2===getPointLike[i].length?(q[i]=[],_type.default.isFunction(getPointLike[i][0])?q[i].push(getPointLike[i][0]()):q[i].push(getPointLike[i][0]),_type.default.isFunction(getPointLike[i][1])?q[i].push(getPointLike[i][1]()):q[i].push(getPointLike[i][1])):_type.default.isFunction(getPointLike[i])&&2===getPointLike[i]().length&&q.push(parents[i]());if(!0===attributes.createpoints)var points=_type.default.providePoints(board,
q,attributes,"cardinalspline",["points"]);else for(points=[],getPointLike=function(ii){return{X:function(){return q[ii][0]},Y:function(){return q[ii][1]},Dist:function(p){var dx=this.X()-p.X();p=this.Y()-p.Y();return Math.sqrt(dx*dx+p*p)}}},i=0;i<q.length;i++)_type.default.isPoint(q[i])?points.push(q[i]):points.push(getPointLike(i));i=["x"].concat(_numerics.default.CardinalSpline(points,parents[1],parents[2]));board=new _jxg.default.Curve(board,i,attributes);attributes=points.length;board.setParents(points);
for(i=0;i<attributes;i++)getPointLike=points[i],_type.default.isPoint(getPointLike)&&(_type.default.exists(getPointLike._is_new)?(board.addChild(getPointLike),delete getPointLike._is_new):getPointLike.addChild(board));board.elType="cardinalspline";return board};_jxg.default.registerElement("cardinalspline",_jxg.default.createCardinalSpline);_jxg.default.createMetapostSpline=function(board,parents,attributes){var i;if(!_type.default.exists(parents[0])||!_type.default.isArray(parents[0]))throw Error("JSXGraph: JXG.createMetapostSpline: argument 1 'points' has to be array of points or coordinate pairs\nPossible parent types: [points:array, controls:object");
if(!_type.default.exists(parents[1])||!_type.default.isObject(parents[1]))throw Error("JSXGraph: JXG.createMetapostSpline: argument 2 'controls' has to be a JavaScript object'\nPossible parent types: [points:array, controls:object");attributes=_type.default.copyAttributes(attributes,board.options,"curve");attributes=_type.default.copyAttributes(attributes,board.options,"metapostspline");attributes.curvetype="parameter";var p$jscomp$0=parents[0];var q=[];if(!attributes.isarrayofcoordinates&&2===p$jscomp$0.length&&
_type.default.isArray(p$jscomp$0[0])&&_type.default.isArray(p$jscomp$0[1])&&p$jscomp$0[0].length===p$jscomp$0[1].length)for(i=0;i<p$jscomp$0[0].length;i++)q[i]=[],_type.default.isFunction(p$jscomp$0[0][i])?q[i].push(p$jscomp$0[0][i]()):q[i].push(p$jscomp$0[0][i]),_type.default.isFunction(p$jscomp$0[1][i])?q[i].push(p$jscomp$0[1][i]()):q[i].push(p$jscomp$0[1][i]);else for(i=0;i<p$jscomp$0.length;i++)_type.default.isString(p$jscomp$0[i])?q.push(board.select(p$jscomp$0[i])):_type.default.isPoint(p$jscomp$0[i])?
q.push(p$jscomp$0[i]):_type.default.isArray(p$jscomp$0[i])&&2===p$jscomp$0[i].length?(q[i]=[],_type.default.isFunction(p$jscomp$0[i][0])?q[i].push(p$jscomp$0[i][0]()):q[i].push(p$jscomp$0[i][0]),_type.default.isFunction(p$jscomp$0[i][1])?q[i].push(p$jscomp$0[i][1]()):q[i].push(p$jscomp$0[i][1])):_type.default.isFunction(p$jscomp$0[i])&&2===p$jscomp$0[i]().length&&q.push(parents[i]());if(!0===attributes.createpoints)var points=_type.default.providePoints(board,q,attributes,"metapostspline",["points"]);
else{points=[];var getPointLike=function(ii){return{X:function(){return q[ii][0]},Y:function(){return q[ii][1]}}};for(i=0;i<q.length;i++)_type.default.isPoint(q[i])?points.push(q[i]):points.push(getPointLike)}var controls=parents[1];board=new _jxg.default.Curve(board,["t",[],[],0,p$jscomp$0.length-1],attributes);board.updateDataArray=function(){var res,len=points.length,p=[];for(res=0;res<len;res++)p.push([points[res].X(),points[res].Y()]);res=_jxg.default.Math.Metapost.curve(p,controls);this.dataX=
res[0];this.dataY=res[1]};board.bezierDegree=3;parents=points.length;board.setParents(points);for(i=0;i<parents;i++)_type.default.isPoint(points[i])&&points[i].addChild(board);board.elType="metapostspline";return board};_jxg.default.registerElement("metapostspline",_jxg.default.createMetapostSpline);_jxg.default.createRiemannsum=function(board,parents,attributes){attributes=_type.default.copyAttributes(attributes,board.options,"riemannsum");attributes.curvetype="plot";var f=parents[0];var n=_type.default.createFunction(parents[1],
board,"");if(!_type.default.exists(n))throw Error("JSXGraph: JXG.createRiemannsum: argument '2' n has to be number or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]");var type=_type.default.createFunction(parents[2],board,"",!1);if(!_type.default.exists(type))throw Error("JSXGraph: JXG.createRiemannsum: argument 3 'type' has to be string or function.\nPossible parent types: [function,n:number|function,type,start:number|function,end:number|function]");
parents=[[0],[0]].concat(parents.slice(3));board=board.create("curve",parents,attributes);board.sum=0;board.Value=function(){return this.sum};board.updateDataArray=function(){var u=_numerics.default.riemann(f,n(),type(),this.minX(),this.maxX());this.dataX=u[0];this.dataY=u[1];this.sum=u[2]};return board};_jxg.default.registerElement("riemannsum",_jxg.default.createRiemannsum);_jxg.default.createTracecurve=function(board,parents,attributes){if(2!==parents.length)throw Error("JSXGraph: Can't create trace curve with given parent'\nPossible parent types: [glider, point]");
var glider=board.select(parents[0]);var tracepoint=board.select(parents[1]);if(glider.type!==_constants.default.OBJECT_TYPE_GLIDER||!_type.default.isPoint(tracepoint))throw Error("JSXGraph: Can't create trace curve with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [glider, point]");var attr=_type.default.copyAttributes(attributes,board.options,"tracecurve");attr.curvetype="plot";board=board.create("curve",[[0],[0]],attr);board.updateDataArray=function(){var i,
el,le=attr.numberpoints,savePos=glider.position,slideObj=glider.slideObject,mi=slideObj.minX();var step=(slideObj.maxX()-mi)/le;this.dataX=[];this.dataY=[];slideObj.elementClass!==_constants.default.OBJECT_CLASS_CURVE&&le++;for(i=0;i<le;i++){var t=mi+i*step;var pEl=slideObj.X(t)/slideObj.Z(t);t=slideObj.Y(t)/slideObj.Z(t);glider.setPositionDirectly(_constants.default.COORDS_BY_USER,[pEl,t]);t=!1;for(el in this.board.objects)if(this.board.objects.hasOwnProperty(el)&&(pEl=this.board.objects[el],pEl===
glider&&(t=!0),t&&pEl.needsRegularUpdate)){var savetrace=pEl.visProp.trace;pEl.visProp.trace=!1;pEl.needsUpdate=!0;pEl.update(!0);pEl.visProp.trace=savetrace;if(pEl===tracepoint)break}this.dataX[i]=tracepoint.X();this.dataY[i]=tracepoint.Y()}glider.position=savePos;t=!1;for(el in this.board.objects)if(this.board.objects.hasOwnProperty(el)&&(pEl=this.board.objects[el],pEl===glider&&(t=!0),t&&pEl.needsRegularUpdate&&(savetrace=pEl.visProp.trace,pEl.visProp.trace=!1,pEl.needsUpdate=!0,pEl.update(!0),
pEl.visProp.trace=savetrace,pEl===tracepoint)))break};return board};_jxg.default.registerElement("tracecurve",_jxg.default.createTracecurve);_jxg.default.createStepfunction=function(board,parents,attributes){if(2!==parents.length)throw Error("JSXGraph: Can't create step function with given parent'\nPossible parent types: [array, array|function]");attributes=_type.default.copyAttributes(attributes,board.options,"stepfunction");board=board.create("curve",parents,attributes);board.updateDataArray=function(){var i,
j=0,len=this.xterm.length;this.dataX=[];this.dataY=[];if(0!==len)for(this.dataX[j]=this.xterm[0],this.dataY[j]=this.yterm[0],++j,i=1;i<len;++i)this.dataX[j]=this.xterm[i],this.dataY[j]=this.dataY[j-1],++j,this.dataX[j]=this.xterm[i],this.dataY[j]=this.yterm[i],++j};return board};_jxg.default.registerElement("stepfunction",_jxg.default.createStepfunction);_jxg.default.createDerivative=function(board,parents,attributes){if(1!==parents.length&&parents[0].class!==_constants.default.OBJECT_CLASS_CURVE)throw Error("JSXGraph: Can't create derivative curve with given parent'\nPossible parent types: [curve]");
attributes=_type.default.copyAttributes(attributes,board.options,"curve");var curve=parents[0];var dx=_numerics.default.D(curve.X);var dy=_numerics.default.D(curve.Y);board=board.create("curve",[function(t){return curve.X(t)},function(t){return dy(t)/dx(t)},curve.minX(),curve.maxX()],attributes);board.setParents(curve);return board};_jxg.default.registerElement("derivative",_jxg.default.createDerivative);_jxg.default.createCurveIntersection=function(board,parents,attributes){if(2!==parents.length)throw Error("JSXGraph: Can't create curve intersection with given parent'\nPossible parent types: [array, array|function]");
board=board.create("curve",[[],[]],attributes);board.updateDataArray=function(){var a=_jxg.default.Math.Clip.intersection(parents[0],parents[1],this.board);this.dataX=a[0];this.dataY=a[1]};return board};_jxg.default.createCurveUnion=function(board,parents,attributes){if(2!==parents.length)throw Error("JSXGraph: Can't create curve union with given parent'\nPossible parent types: [array, array|function]");board=board.create("curve",[[],[]],attributes);board.updateDataArray=function(){var a=_jxg.default.Math.Clip.union(parents[0],
parents[1],this.board);this.dataX=a[0];this.dataY=a[1]};return board};_jxg.default.createCurveDifference=function(board,parents,attributes){if(2!==parents.length)throw Error("JSXGraph: Can't create curve difference with given parent'\nPossible parent types: [array, array|function]");board=board.create("curve",[[],[]],attributes);board.updateDataArray=function(){var a=_jxg.default.Math.Clip.difference(parents[0],parents[1],this.board);this.dataX=a[0];this.dataY=a[1]};return board};_jxg.default.registerElement("curvedifference",
_jxg.default.createCurveDifference);_jxg.default.registerElement("curveintersection",_jxg.default.createCurveIntersection);_jxg.default.registerElement("curveunion",_jxg.default.createCurveUnion);_jxg.default.createBoxPlot=function(board,parents,attributes){var i;attributes=_type.default.copyAttributes(attributes,board.options,"boxplot");if(3!==parents.length)throw Error("JSXGraph: Can't create box plot with given parent'\nPossible parent types: [array, number|function, number|function] containing quantiles, axis, width");
if(5>parents[0].length)throw Error("JSXGraph: Can't create box plot with given parent[0]'\nparent[0] has to conatin at least 5 quantiles.");attributes=board.create("curve",[[],[]],attributes);var len=parents[0].length;attributes.Q=[];for(i=0;i<len;i++)attributes.Q[i]=_type.default.createFunction(parents[0][i],board,null,!0);attributes.x=_type.default.createFunction(parents[1],board,null,!0);attributes.w=_type.default.createFunction(parents[2],board,null,!0);attributes.updateDataArray=function(){var r2=
_type.default.evaluate(this.visProp.smallwidth);var dir=_type.default.evaluate(this.visProp.dir);var x=this.x();var v1=x-.5*this.w();var v2=x-.5*this.w()*r2;var r1=x+.5*this.w();r2=x+.5*this.w()*r2;v1=[x,v2,r2,x,x,v1,v1,r1,r1,x,NaN,v1,r1,NaN,x,x,v2,r2,x];v2=[this.Q[0](),this.Q[0](),this.Q[0](),this.Q[0](),this.Q[1](),this.Q[1](),this.Q[3](),this.Q[3](),this.Q[1](),this.Q[1](),NaN,this.Q[2](),this.Q[2](),NaN,this.Q[3](),this.Q[4](),this.Q[4](),this.Q[4](),this.Q[4]()];"vertical"===dir?(this.dataX=
v1,this.dataY=v2):(this.dataX=v2,this.dataY=v1)};return attributes};_jxg.default.registerElement("boxplot",_jxg.default.createBoxPlot);exports.default={Curve:_jxg.default.Curve,createCardinalSpline:_jxg.default.createCardinalSpline,createCurve:_jxg.default.createCurve,createCurveDifference:_jxg.default.createCurveDifference,createCurveIntersection:_jxg.default.createCurveIntersection,createCurveUnion:_jxg.default.createCurveUnion,createDerivative:_jxg.default.createDerivative,createFunctiongraph:_jxg.default.createFunctiongraph,
createMetapostSpline:_jxg.default.createMetapostSpline,createPlot:_jxg.default.createFunctiongraph,createSpline:_jxg.default.createSpline,createRiemannsum:_jxg.default.createRiemannsum,createStepfunction:_jxg.default.createStepfunction,createTracecurve:_jxg.default.createTracecurve}}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$base$curve.js.map
