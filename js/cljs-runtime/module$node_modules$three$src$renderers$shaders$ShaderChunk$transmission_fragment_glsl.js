shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$transmission_fragment_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\n#ifdef USE_TRANSMISSION\n\n\tmaterial.transmission \x3d transmission;\n\tmaterial.transmissionAlpha \x3d 1.0;\n\tmaterial.thickness \x3d thickness;\n\tmaterial.attenuationDistance \x3d attenuationDistance;\n\tmaterial.attenuationColor \x3d attenuationColor;\n\n\t#ifdef USE_TRANSMISSIONMAP\n\n\t\tmaterial.transmission *\x3d texture2D( transmissionMap, vUv ).r;\n\n\t#endif\n\n\t#ifdef USE_THICKNESSMAP\n\n\t\tmaterial.thickness *\x3d texture2D( thicknessMap, vUv ).g;\n\n\t#endif\n\n\tvec3 pos \x3d vWorldPosition;\n\tvec3 v \x3d normalize( cameraPosition - pos );\n\tvec3 n \x3d inverseTransformDirection( normal, viewMatrix );\n\n\tvec4 transmission \x3d getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\n\tmaterial.transmissionAlpha \x3d mix( material.transmissionAlpha, transmission.a, material.transmission );\n\n\ttotalDiffuse \x3d mix( totalDiffuse, transmission.rgb, material.transmission );\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$transmission_fragment_glsl.js.map
