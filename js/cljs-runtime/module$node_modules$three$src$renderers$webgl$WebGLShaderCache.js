shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLShaderCache=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLShaderCache=void 0;let _id=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map;this.materialCache=new Map}update(material){var fragmentShader=material.fragmentShader;const vertexShaderStage=this._getShaderStage(material.vertexShader);fragmentShader=this._getShaderStage(fragmentShader);material=this._getShaderCacheForMaterial(material);
!1===material.has(vertexShaderStage)&&(material.add(vertexShaderStage),vertexShaderStage.usedTimes++);!1===material.has(fragmentShader)&&(material.add(fragmentShader),fragmentShader.usedTimes++);return this}remove(material){const materialShaders=this.materialCache.get(material);for(const shaderStage of materialShaders)shaderStage.usedTimes--,0===shaderStage.usedTimes&&this.shaderCache.delete(shaderStage.code);this.materialCache.delete(material);return this}getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id}getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id}dispose(){this.shaderCache.clear();
this.materialCache.clear()}_getShaderCacheForMaterial(material){const cache=this.materialCache;let set=cache.get(material);void 0===set&&(set=new Set,cache.set(material,set));return set}_getShaderStage(code){const cache=this.shaderCache;let stage=cache.get(code);void 0===stage&&(stage=new WebGLShaderStage(code),cache.set(code,stage));return stage}}exports.WebGLShaderCache=WebGLShaderCache;class WebGLShaderStage{constructor(code){this.id=_id++;this.code=code;this.usedTimes=0}}}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLShaderCache.js.map
