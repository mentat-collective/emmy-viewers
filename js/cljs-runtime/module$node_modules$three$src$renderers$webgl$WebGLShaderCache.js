shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLShaderCache=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLShaderCache=void 0;let _id=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map;this.materialCache=new Map}update(material){var fragmentShader=material.fragmentShader;const vertexShaderStage=this._getShaderStage(material.vertexShader);fragmentShader=this._getShaderStage(fragmentShader);material=this._getShaderCacheForMaterial(material);
!1===material.has(vertexShaderStage)&&(material.add(vertexShaderStage),vertexShaderStage.usedTimes++);!1===material.has(fragmentShader)&&(material.add(fragmentShader),fragmentShader.usedTimes++);return this}remove(material){const materialShaders=this.materialCache.get(material);for(const shaderStage of materialShaders)shaderStage.usedTimes--,0===shaderStage.usedTimes&&this.shaderCache.delete(shaderStage);this.materialCache.delete(material);return this}getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id}getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id}dispose(){this.shaderCache.clear();
this.materialCache.clear()}_getShaderCacheForMaterial(material){const cache=this.materialCache;!1===cache.has(material)&&cache.set(material,new Set);return cache.get(material)}_getShaderStage(code){const cache=this.shaderCache;if(!1===cache.has(code)){const stage=new WebGLShaderStage;cache.set(code,stage)}return cache.get(code)}}exports.WebGLShaderCache=WebGLShaderCache;class WebGLShaderStage{constructor(){this.id=_id++;this.usedTimes=0}}}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLShaderCache.js.map
