{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$escape.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,uDAAA,CAA4E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAKpH,IAAIC,QAAUH,OAAA,CAAQ,kDAAR,CAA2BG,CAAAA,OAAzC,CAEIC,QAAU,EAEd,KAASC,MAAT,CAAa,CAAb,CAAoB,GAApB,CAAgBA,MAAhB,CAAyBA,MAAA,EAAzB,CAAgCD,OAAQE,CAAAA,IAAR,CAAa,CAAb,CAEhC,iDAAA,CAAA,KAAA,CAAA,EAAA,CACaC,CAAAA,OADb,CACqB,QAAS,CAACC,EAAD,CAAK,CAAEJ,OAAA,CAAQI,EAAGC,CAAAA,UAAH,CAAc,CAAd,CAAR,CAAA,CAA4B,CAA9B,CADnC,CAIAR,OAAOC,CAAAA,OAAP,CAAiBQ,QAAe,CAACC,KAAD,CAAQC,MAAR,CAAgB,CAAA,IACtCC,IAAMF,KAAME,CAAAA,GAD0B,CACrBC,IAAMH,KAAMI,CAAAA,MAErC,IAAkC,EAAlC,GAAIJ,KAAMK,CAAAA,GAAIP,CAAAA,UAAV,CAAqBI,GAArB,CAAJ,CAAiD,MAAO,CAAA,CAExDA,IAAA,EAEA,IAAIA,GAAJ,CAAUC,GAAV,CAAe,CACb,IAAAN;AAAKG,KAAMK,CAAAA,GAAIP,CAAAA,UAAV,CAAqBI,GAArB,CAEL,IAAS,GAAT,CAAIL,EAAJ,EAAgC,CAAhC,GAAgBJ,OAAA,CAAQI,EAAR,CAAhB,CAGE,MAFKI,OAEE,GAFQD,KAAMM,CAAAA,OAEd,EAFyBN,KAAMK,CAAAA,GAAN,CAAUH,GAAV,CAEzB,EADPF,KAAME,CAAAA,GACC,EADM,CACN,CAAA,CAAA,CAGT,IAAW,EAAX,GAAIL,EAAJ,CAAiB,CACVI,MAAL,EACED,KAAML,CAAAA,IAAN,CAAW,WAAX,CAAwB,IAAxB,CAA8B,CAA9B,CAKF,KAFAO,GAAA,EAEA,CAAOA,GAAP,CAAaC,GAAb,CAAA,CAAkB,CAChBN,EAAA,CAAKG,KAAMK,CAAAA,GAAIP,CAAAA,UAAV,CAAqBI,GAArB,CACL,IAAI,CAACV,OAAA,CAAQK,EAAR,CAAL,CAAoB,KACpBK,IAAA,EAHgB,CAMlBF,KAAME,CAAAA,GAAN,CAAYA,GACZ,OAAO,CAAA,CAdQ,CATJ,CA2BVD,MAAL,GAAeD,KAAMM,CAAAA,OAArB,EAAgC,IAAhC,CACAN,MAAME,CAAAA,GAAN,EACA,OAAO,CAAA,CApCuC,CAfoE;",
"sources":["node_modules/markdown-it/lib/rules_inline/escape.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$escape\"] = function(global,require,module,exports) {\n// Process escaped chars and hardbreaks\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) { ESCAPED.push(0); }\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'\n  .split('').forEach(function (ch) { ESCAPED[ch.charCodeAt(0)] = 1; });\n\n\nmodule.exports = function escape(state, silent) {\n  var ch, pos = state.pos, max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C/* \\ */) { return false; }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) { state.pending += state.src[pos]; }\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push('hardbreak', 'br', 0);\n      }\n\n      pos++;\n      // skip leading whitespaces from next line\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n        if (!isSpace(ch)) { break; }\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) { state.pending += '\\\\'; }\n  state.pos++;\n  return true;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","isSpace","ESCAPED","i","push","forEach","ch","charCodeAt","module.exports","state","silent","pos","max","posMax","src","pending"]
}
