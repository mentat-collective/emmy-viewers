{"version":3,"sources":["sicmutils/expression/compile.cljc"],"mappings":"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","names":["sicmutils.expression.compile/->vec","arr","t","theta","thetadot","Math/sin","p__101783","vec__101784","cljs.core.nth","sicmutils.expression.compile/vec->vec","sicmutils.expression.compile/->array","G__101787","sicmutils.expression.compile/->input-array","out","G__101788","sicmutils.expression.compile/->input-array-param","g","G__101789","sicmutils.expression.compile/vec-checker","result","cljs.core._EQ_","sicmutils.expression.compile/array-checker","sicmutils.expression.compile/input-array-checker","sicmutils.expression.compile/fn-cache","cljs.core.atom","p1__101803#","p1__101797#","p1__101798#","p1__101796#","cljs.core//","p1__101793#","p1__101794#","p1__101802#","p1__101790#","p2__101791#","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","cljs.core/vec","p1__101801#","p1__101799#","p1__101805#","p1__101808#","p1__101806#","p1__101792#","p1__101800#","p1__101795#","p1__101807#","p1__101809#","p1__101804#","p1__101810#","sicmutils.expression.compile/compiled-fn-whitelist","cljs.core/vector","sicmutils.structure/down","cljs.core/+","cljs.core/-","cljs.core/*","Math/pow","Math/sqrt","Math/abs","Math/log","Math/exp","Math/cos","Math/tan","Math/acos","Math/asin","Math/atan","Math/cosh","Math/sinh","Math/tanh","Math/floor","Math/ceil","cljs.core/mod","cljs.core/rem","cljs.core/quot","Math/trunc","x","Math/acosh","Math/asinh","Math/atanh","sicmutils.expression.compile/sym->resolved-form","sicmutils.util/map-vals","sicmutils.expression.compile/expr-frequencies","expr","skip?","children","cljs.core.partial","cljs.core/filter","cljs.core/seq?","cljs.core/rest","cljs.core/tree-seq","cljs.core.remove","cljs.core/frequencies","sicmutils.expression.compile/discard-unreferenced-syms","sym->expr","syms","sicmutils.util/keyset","lookup-syms","cljs.core.mapcat","cljs.core.comp","sicmutils.expression/variables-in","referenced","sym-batch","clojure.set.intersection","cljs.core/empty?","cljs.core/select-keys","referenced'","clojure.set.union","syms-in-exprs","cljs.core.into","clojure.set.difference","sicmutils.expression.compile/sortable-gensym","sicmutils.expression.analyze/monotonic-symbol-generator","var_args","G__101812","sicmutils.expression.compile/extract-common-subexpressions","js/Error","p__101813","map__101814","cljs.core/--destructure-map","cljs.core.get","continue","sicmutils.expression.compile.extract_common_subexpressions","symbol-generator","deterministic?","sort","cljs.core/sort-by","cljs.core/str","cljs.core/first","cljs.core/identity","expr->sym","expr->count","new-syms","iter__4652__auto__","s__101828","cljs.core/LazySeq","temp__5753__auto__","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","cljs.core/count","b__101830","cljs.core/chunk-buffer","i__101829","vec__101831","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__101827","cljs.core/chunk-rest","vec__101843","cljs.core/cons","k","v","clojure.set/map-invert","G__101848","G__101849","cljs.core.sort_by","cljs.core/key","expr->sym'","cljs.core.merge","clojure.walk/postwalk-replace","G__101856","sicmutils.expression.compile/cse-form","sicmutils.expression.compile.cse_form","opts","new-expression","bindings","n-bindings","binding-vec","cljs.core/cat","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","goog.string/format","callback","sicmutils.expression.compile/numeric-whitelist","cljs.core.dissoc","G__101961","sicmutils.expression.compile/struct->array","xs","sicmutils.expression.compile.struct__GT_array","js/Array","G__101965","cljs.core/unquote","output","cljs.core.map_indexed","i","sicmutils.expression.compile/apply-numeric-ops","body","clojure.walk/postwalk","sicmutils.value/real?","sicmutils.util/double","cljs.core/sequential?","vec__101995","seq__101996","first__101997","cljs.core/next","f","temp__5751__auto__","m","and__4251__auto__","cljs.core/every?","cljs.core/number?","cljs.core.apply","sicmutils.expression.compile/*mode*","sicmutils.expression.compile/valid-modes","sicmutils.expression.compile/validate-mode!","mode","or__4253__auto__","cljs.core.ex_info","sicmutils.expression.compile/compiler-mode","sicmutils.expression.compile/set-compiler-mode!","sicmutils.expression.compile/state-argv","params","state-model","state","cljs.core/flatten","sicmutils.expression.compile/sci-context","sci.core/init","js/Math","sicmutils.structure/up","sicmutils.expression.compile/sci-eval","f-form","sci.core/eval-form","sci.core/fork","sicmutils.expression.compile/array-bindings","vs","inputs","sicmutils.expression.compile/compile-state->source","_opts","state-sym","cljs.core/with-meta","cljs.core.gensym","param-sym","sicmutils.expression.compile/compile-state-native","cljs.core/eval","sicmutils.expression.compile/compile-state-sci","sicmutils.expression.compile/state->argv","gensym-fn","s","sicmutils.structure/structure?","cljs.core.mapv","rec","G__102020","sicmutils.expression.compile/flatten-structs","G__102022","sicmutils.structure/symbol-set","cljs.core.filter","cljs.core/complement","sym-struct?","sicmutils.expression.compile/->output","cljs.core.take","G__102023","G__102024","sicmutils.expression.compile/->js-output","G__102026","sicmutils.expression.compile/compile-state-fn*","p__102027","map__102028","prototype","sicmutils.expression.compile.compile_state_fn_STAR_","parameters","cljs.core/gensym","vec__102029","sw","sicmutils.util.stopwatch/stopwatch","generic-state","ps","s__102033","b__102035","i__102034","iter__102032","_","G__102036","G__102037","sicmutils.generic/simplify","sicmutils.value/freeze","compiler","G__102038","cljs.core/Keyword","compiled-fn","G__102040","sicmutils.expression.compile/compile-state-fn","sicmutils.expression.compile.compile_state_fn","cached","fexpr__102041","cljs.core/deref","compiled","cljs.core.swap_BANG_","cljs.core/assoc","sicmutils.expression.compile/make-symbol-generator","p","cljs.core.symbol","suffix","cljs.core/inc","sicmutils.expression.compile/infix-set","sicmutils.expression.compile/js-renames","p__102042","vec__102043","sicmutils.expression.compile/render-infix-ratio","num","denom","n","sicmutils.value/integral?","sicmutils.expression.compile/js-handlers","p1__102046#","p1__102047#","->parens","->js-vector","clojure.string.join","p__102077","vec__102079","a","b","p__102049","vec__102053","p__102065","vec__102066","p__102098","vec__102119","p__102090","vec__102091","p1__102134#","sicmutils.expression.compile/->js","cljs.core/Symbol","vec__102195","seq__102196","first__102197","f'","sym","f-name","sicmutils.util/illegal","G__102199","sicmutils.expression.compile/compile-js","p__102200","map__102201","sicmutils.expression.compile.compile_js","vec__102202","new-vars","s__102221","b__102223","i__102222","vec__102233","iter__102220","vec__102244","var","val","s__102249","b__102251","i__102250","iter__102248","G__102254","G__102256","output-sym","s-bindings","cljs.core.transduce","p-bindings","body-str","js/Function","sicmutils.expression.compile/compile->source","args","sicmutils.expression.compile/compile-native","sicmutils.expression.compile/compile-sci","sicmutils.expression.compile/retrieve-arity","vec__102277","kwd","arity","sicmutils.function/arity","G__102281","sicmutils.expression.compile/compile-fn*","sicmutils.expression.compile.compile_fn_STAR_","cljs.core.repeatedly","G__102282","G__102302","sicmutils.expression.compile/compile-fn","vec__102312","sicmutils.expression.compile.compile_fn","G__102316","fexpr__102315","*mode*-orig-val__102327","*mode*-temp-val__102328","cljs.core/chunk-first"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.expression.compile\n  \"This namespace contains tools for compiling functions implemented with the\n  numeric operations defined in [[sicmutils.generic]] down to fast, native\n  functions.\"\n  (:require #?(:cljs [goog.string :refer [format]])\n            [clojure.set :as set]\n            [clojure.string :as cs]\n            [clojure.walk :as w]\n            [sci.core :as sci]\n            [sicmutils.expression :as x]\n            [sicmutils.expression.analyze :as a]\n            [sicmutils.function :as f]\n            [sicmutils.generic :as g]\n            [sicmutils.structure :as struct]\n            [sicmutils.util :as u]\n            [sicmutils.util.stopwatch :as us]\n            [sicmutils.value :as v]\n            [taoensso.timbre :as log]))\n\n;; GOAL:\n;;\n;; Try to get function compilation really freaking fast.\n;;\n;; go through and figure out in which cases we need to SUPPLY an array and in\n;; which cases we need to return an array. The derivative function here\n;; definitely needed to return an array!! So we are going to need both.\n\n(defn ->vec [^doubles arr]\n  (let [t        (aget arr 0)\n        theta    (aget arr 1)\n        thetadot (aget arr 2)]\n    [1.0 thetadot (* -9.8 (Math/sin theta))]))\n\n(defn vec->vec [[t theta thetadot]]\n  [1.0 thetadot (* -9.8 (Math/sin theta))])\n\n(defn ->array [^doubles arr]\n  (let [t        (aget arr 0)\n        theta    (aget arr 1)\n        thetadot (aget arr 2)]\n    (doto ^doubles (make-array Double/TYPE  3)\n      (aset 0 1.0)\n      (aset 1 thetadot)\n      (aset 2 (* -9.8 (Math/sin theta))))))\n\n(defn ->input-array [^doubles arr ^doubles out]\n  (let [t        (aget arr 0)\n        theta    (aget arr 1)\n        thetadot (aget arr 2)]\n    (doto out\n      (aset 0 1.0)\n      (aset 1 thetadot)\n      (aset 2 (* -9.8 (Math/sin theta))))))\n\n(defn ->input-array-param [g ^doubles arr ^doubles out]\n  (let [t        (aget arr 0)\n        theta    (aget arr 1)\n        thetadot (aget arr 2)]\n    (doto out\n      (aset 0 1.0)\n      (aset 1 thetadot)\n      (aset 2 (* g (Math/sin theta))))))\n\n(comment\n  ;; SO what I've learned here is that I need to both change the inputs to take\n  ;; arrays, and the outputs to produce vectors if that occurs.\n  (let [v [0 1 2]\n        xs (double-array [0 1 2])]\n    (time (dotimes [_ 100000000]\n            (vec->vec v)))\n\n    (time (dotimes [_ 100000000]\n            (->vec xs)))\n\n    (time (dotimes [_ 100000000]\n            (->array xs)))\n\n    (let [out ^doubles (make-array Double/TYPE  3)]\n      (time (dotimes [_ 100000000]\n              (->input-array xs out))))\n\n    (let [out ^doubles (make-array Double/TYPE  3)\n          params [-9.8]]\n      (time (dotimes [_ 100000000]\n              (->input-array-param params xs out))))))\n\n(defn vec-checker [arr]\n  (let [result (->vec arr)]\n    (= (result 1)\n       (result 2))))\n\n(defn array-checker [arr]\n  (let [result ^doubles (->array arr)]\n    (= (aget result 1)\n       (aget result 2))))\n\n(defn input-array-checker [^doubles arr ^doubles result]\n  (->input-array arr result)\n  (= (aget result 1)\n     (aget result 2)))\n\n(comment\n  ;; SO what I've learned here is that I need to both change the inputs to take\n  ;; arrays, and the outputs to produce vectors if that occurs.\n  (let [xs (double-array [0 1 2])]\n    (time (dotimes [_ 100000000]\n            (vec-checker xs)))\n\n    (time (dotimes [_ 100000000]\n            (array-checker xs)))\n\n    (let [out ^doubles (make-array Double/TYPE  3)]\n      (time (dotimes [_ 100000000]\n              (input-array-checker xs out))))))\n\n;; # Function Compilation\n;;\n;; Functions built out of generic operations can be compiled down into fast,\n;; efficient functions that operate on doubles. The process is:\n;;\n;; 1. Pass symbols like `'x` in for all arguments. This will cause the function\n;;    to return a \"numerical expression\", a syntax tree representing the\n;;    function's body:\n#_\n(let [f (fn [x] (g/sqrt\n                (g/+ (g/square (g/sin x))\n                     (g/square (g/cos x)))))]\n  (= '(sqrt (+ (expt (sin x) 2) (expt (cos x) 2)))\n     (x/expression-of (f 'x))))\n\n;; 2. `g/simplify` the new function body. Sometimes this results in large\n;;    simplifications:\n\n#_\n(let [f (fn [x] (g/sqrt\n                (g/+ (g/square (g/sin x))\n                     (g/square (g/cos x)))))]\n  (v/= 1 (g/simplify (f 'x))))\n\n;; 3. Apply \"common subexpression elimination\". Any subexpression inside the\n;;    new, simplified body that appears more than once gets extracted out into a\n;;    let-bound variable and calculated just once, then subbed in to the\n;;    computation using the generated variable.\n;;\n;; 4. Wrap the new, efficient body up in `(fn [x] ,,,)` with the proper number\n;;    of arguments and pass it to `eval`.\n;;\n;; Amazing!\n;;\n;; ## Implementation\n;;\n;; Function compilation is potentially expensive, so allocate a cache of\n;; function `f` to compiled function for use below:\n\n(def ^:private fn-cache (atom {}))\n\n;; The next two forms allow us to walk an expression tree, and either:\n;;\n;; - namespace-resolve whitelisted symbols, or\n;; - apply operations at compile time if all arguments are available (and\n;;   non-symbolic).\n;;\n;; If we were only dealing with Clojure here, we could get both of these pieces\n;; from a var. But forms like `Math/pow` make this tricky, so we go with the map\n;; described below.\n\n(def ^{:private true\n       :doc \"Dict of `<symbol> -> {:sym <symbolic-fn>, :f <evaluated-fn>}`. The\n       keys constitute the set of operations allowed to appear within the body\n       of the compiled function.\n\n       If you're compiling a function for use with the numerical routines, the\n       library assumes that your function operates only on doubles (even though\n       you wrote it with generic routines).\"}\n  compiled-fn-whitelist\n  {'up {:sym `vector :f vector}\n   'down {:sym `struct/down\n          :f struct/down}\n   '+ {:sym `+ :f +}\n   '- {:sym `- :f -}\n   '* {:sym `* :f *}\n   '/ {:sym `/ :f /}\n   'expt {:sym 'Math/pow :f #(Math/pow %1 %2)}\n   'sqrt {:sym 'Math/sqrt :f #(Math/sqrt %)}\n   'abs {:sym 'Math/abs :f #(Math/abs ^double %)}\n   'log {:sym 'Math/log :f #(Math/log %)}\n   'exp {:sym 'Math/exp :f #(Math/exp %)}\n   'cos {:sym 'Math/cos :f #(Math/cos %)}\n   'sin {:sym 'Math/sin :f #(Math/sin %)}\n   'tan {:sym 'Math/tan :f #(Math/tan %)}\n   'acos {:sym 'Math/acos :f #(Math/acos %)}\n   'asin {:sym 'Math/asin :f #(Math/asin %)}\n   'atan {:sym 'Math/atan :f #(Math/atan %)}\n   'cosh {:sym 'Math/cosh :f #(Math/cosh %)}\n   'sinh {:sym 'Math/sinh :f #(Math/sinh %)}\n   'tanh {:sym 'Math/tanh :f #(Math/tanh %)}\n   'floor {:sym 'Math/floor :f #(Math/floor %)}\n   'ceiling {:sym 'Math/ceil :f #(Math/ceil %)}\n   'modulo {:sym 'clojure.core/mod :f mod}\n   'remainder {:sym 'clojure.core/rem :f rem}\n   'quotient {:sym 'clojure.core/quot :f quot}\n   'integer-part #?(:clj {:sym 'long :f long}\n                    :cljs {:sym 'Math/trunc\n                           :f #(Math/trunc %)})\n   ;; NOTE that the proper way to handle this substitution is to add a\n   ;; simplification rule that does this transformation for us. If you hit this\n   ;; and it's slow, consider opening a PR for that.\n   'fractional-part {:sym `(fn [^double ~'x]\n                             (- ~'x (~'Math/floor ~'x)))\n                     :fn (fn [^double x]\n                           (- x (Math/floor x)))}\n   #?@(:cljs\n       ;; JS-only entries.\n       ['acosh {:sym 'Math/acosh :f #(Math/acosh %)}\n        'asinh {:sym 'Math/asinh :f #(Math/asinh %)}\n        'atanh {:sym 'Math/atanh :f #(Math/atanh %)}])})\n\n(def ^{:private true\n       :doc \"Dict of `<symbol> -> <symbolic-fn>`. See [[compiled-fn-whitelist]]\n       for more detail.\"}\n  sym->resolved-form\n  (u/map-vals :sym compiled-fn-whitelist))\n\n;; ## Subexpression Elimination\n;;\n;; This section implements subexpression extraction and \"elimination\", the\n;; process we use to avoid redundant computation inside of a simplified function\n;; body.\n;;\n;; The goal of this process is to split some symbolic expression into:\n;;\n;; - a map of symbol -> redundant subexpression\n;; - a new expression with each redundant subexpr replaced with its\n;;   corresponding symbol.\n;;\n;; The invariant we want to achieve is that the new expression, rehydrated using\n;; the symbol->subexpression map, should be equivalent to the old expression.\n;;\n;; First, we write a function to determine how often each subexpression appears.\n;; Subexpressions that appear just once aren't worth extracting, but two\n;; appearances is enough.\n\n(defn- expr-frequencies\n  \"Returns a map from distinct subexpressions in the supplied `expr` to the\n  number of times each appears.\n\n  If `skip?` returns true given a subexpression it won't be included as a key in\n  the returned map.\"\n  [expr skip?]\n  (let [children (partial filter seq?)]\n    (->> (rest\n          (tree-seq seq? children expr))\n         (remove skip?)\n         (frequencies))))\n\n;; The next function assumes that we have the two data structures we referenced\n;; earlier. We want to be careful that we only generate and bind subexpressions\n;; that are actually used in the final computation.\n;;\n;; `discard-unferenced-syms` ensures this by removing any entry from our\n;; replacement map that doesn't appear in the expression it's passed, or any\n;; subexpression referenced by a symbol in the expression, etc etc.\n;;\n;; The algorithm is:\n;;\n;; - consider the intersection of all variables in the replacement map and the\n;;   supplied expression, and store these into a map of \"referenced\" symbols.\n;;\n;; - Look up the corresponding subexpression for each of these symbols, and add\n;;   all potential replacements from each subexpression into the \"referenced\"\n;;   list, continuing this process recursively until all candidates are\n;;   exhausted.\n;;\n;; - Return subset of the original `sym->expr` by removing any key not found in\n;; - the accumulated \"referenced\" set.\n\n(defn- discard-unreferenced-syms\n  \"Trims down a proposed map of `sym->expr` replacements (suitable for a let-binding,\n  say) to include only entries relevant to the supplied `expr`.\n\n  Accepts:\n\n  - `sym->expr`, a map of symbol -> symbolic expression\n  - `expr`, an expression that potentially contains symbols referenced in the\n    keyset of `sym->expr`\n\n  And returns a subset of `sym->expr` containing only entries where the\n  symbol-key is found in:\n\n  - the original `expr`, or\n  - in an expression referenced by a symbol in the original `expr`\"\n  [sym->expr expr]\n  (let [syms        (u/keyset sym->expr)\n        lookup-syms (mapcat (comp x/variables-in sym->expr))]\n    (loop [referenced #{}\n           sym-batch  (-> (x/variables-in expr)\n                          (set/intersection syms))]\n      (if (empty? sym-batch)\n        (select-keys sym->expr referenced)\n        (let [referenced'   (set/union referenced sym-batch)\n              syms-in-exprs (-> (into #{} lookup-syms sym-batch)\n                                (set/intersection syms)\n                                (set/difference referenced'))]\n          (recur referenced' syms-in-exprs))))))\n\n;; This final function implements common subexpression extraction in\n;; continuation-passing-style. Pass it a callback and it will invoke the\n;; callback with the two arguments described above, and detailed below in its\n;; docstring.\n;;\n;; The algorithm is:\n;;\n;; - For every subexpression that appears more than once in the supplied\n;;   expression, generate a new, unique symbol.\n;;\n;; - Generate a new expression by replacing every subexpression in the supplied\n;;   expression with a symbol using the new mapping of symbol -> subexpression.\n;;\n;; - Recursively keep going until there are no more common subexpressions to\n;;   replace. At this point, discard all extra bindings (see\n;;   `discard-unreferenced-syms` above) and call the continuation function with\n;;   the /new/ slimmed expression, and a sorted-by-symbol list of binding pairs.\n;;\n;; These two return values satisfy the invariant we described above: the new\n;; expression, rehydrated using the symbol->subexpression map, should give us\n;; back the old expression.\n;;\n;; NOTE that the algorithm as implemented below uses a postwalk tree traversal!\n;; This is important, as it forces us to consider smaller subexpressions first.\n;; Consider some expression like:\n\n#_\n(+ (* (sin x) (cos x))\n   (* (sin x) (cos x))\n   (* (sin x) (cos x)))\n\n;; At first pass, we have three repeated subexpressions:\n;;\n;; - `(sin x)`\n;; - `(cos x)`\n;; - `(* (sin x) (cos x))`\n;;\n;; Postwalk traversal guarantees that we replace the `sin` and `cos` terms\n;; before the larger term that contains them both. And in fact the returned pair\n;; looks like:\n\n#_\n[(+ g3 g3 g3) ([g1 (sin x)] [g2 (cos x)] [g3 (* g1 g2)])]\n\n;; NOTE also that:\n;;\n;; - this is why the `:symbol-generator` below must generate symbols that sort\n;;   in the order they're generated. Else, the final binding vector might put\n;;   the `g3` term in the example above /before/ the smaller subexpressions it\n;;   uses.\n;;\n;; - This algorithm justifies `discard-unreferenced-syms` above. Each pass will\n;;   larger subexpressions like `'(* (sin x) (cos x))` that should never make it\n;;   out, since they never appear in this form (since they contain smaller\n;;   subexpressions).\n\n(def sortable-gensym\n  (a/monotonic-symbol-generator \"G\"))\n\n(defn extract-common-subexpressions\n  \"Considers an S-expression from the point of view of optimizing its evaluation\n  by isolating common subexpressions into auxiliary variables.\n\n  Accepts:\n\n  - A symbolic expression `expr`\n  - a continuation fn `continue` of two arguments:\n    - a new equivalent expression with possibly some subexpressions replaced by\n      new variables (delivered by the supplied generator, see below)\n    - a seq of pairs of `[aux variable, subexpression]` used to reconstitute the\n      value.\n\n  Calls the continuation at completion and returns the continuation's value.\n\n  ### Optional Arguments\n\n  `:symbol-generator`: side-effecting function that returns a new, unique\n  variable name on each invocation. `sortable-gensym` by default.\n\n  NOTE that the symbols should appear in sorted order! Otherwise we can't\n  guarantee that the binding sequence passed to `continue` won't contain entries\n  that reference previous entries.\n\n  `:deterministic?`: if true, the function will assign aux variables by sorting\n  the string representations of each term before assignment. Otherwise, the\n  nondeterministic order of hash maps inside this function won't guarantee a\n  consistent variable naming convention in the returned function. For tests, set\n  `:deterministic? true`.\"\n  ([expr continue] (extract-common-subexpressions expr continue {}))\n  ([expr continue {:keys [symbol-generator deterministic?]\n                   :or {symbol-generator sortable-gensym}}]\n   (let [sort (if deterministic?\n                (partial sort-by (comp str vec first))\n                identity)]\n     (loop [x         expr\n            expr->sym {}]\n       (let [expr->count (expr-frequencies x expr->sym)\n             new-syms    (into {} (for [[k v] (sort expr->count)\n                                        :when (> v 1)]\n                                    [k (symbol-generator)]))]\n         (if (empty? new-syms)\n           (let [sym->expr (-> (set/map-invert expr->sym)\n                               (discard-unreferenced-syms x))]\n             (continue x (sort-by key sym->expr)))\n           (let [expr->sym' (merge expr->sym new-syms)]\n             (recur (w/postwalk-replace expr->sym' x)\n                    expr->sym'))))))))\n\n;; This final wrapper function invokes `extract-common-subexpressions` to turn a\n;; symbolic expression a new, valid Clojure(script) form that uses a `let`\n;; binding to bind any common subexpressions exposed during the above search.\n;;\n;; If there are no common subexpressions, `cse-form` will round-trip its input.\n\n(defn cse-form\n  \"Given a symbolic expression `expr`, returns a new expression potentially\n  wrapped in a `let` binding with one binding per extracted common\n  subexpression.\n\n  ## Optional Arguments TODO say `see blah for options`\n\n  `:symbol-generator`: side-effecting function that returns a new, unique symbol\n  on each invocation. These generated symbols are used to create unique binding\n  names for extracted subexpressions. `sortable-gensym` by default.\n\n  NOTE that the symbols should appear in sorted order! Otherwise we can't\n  guarantee that the binding sequence won't contain entries that reference\n  previous entries, resulting in \\\"Unable to resolve symbol\\\" errors.\n\n  `:deterministic?`: if true, the function will order the let-binding contents\n  by sorting the string representations of each term before assignment. If false\n  the function won't guarantee a consistent variable naming convention in the\n  returned function. For tests, we recommend `:deterministic? true`.\"\n  ([expr] (cse-form expr {}))\n  ([expr opts]\n   (letfn [(callback [new-expression bindings]\n             (let [n-bindings (count bindings)]\n               (if (pos? n-bindings)\n                 (let [binding-vec (into [] cat bindings)]\n                   (log/info\n                    (format \"common subexpression elimination: %d expressions\" n-bindings))\n                   `(let ~binding-vec\n                      ~new-expression))\n                 new-expression)))]\n     (extract-common-subexpressions expr callback opts))))\n\n(def ^{:private true\n       :doc \"Similar to [[compiled-fn-whitelist]], but restricted to numeric\n  operations.\"}\n  numeric-whitelist\n  (dissoc compiled-fn-whitelist 'up 'down))\n\n(defn ^:no-doc struct->array\n  \"Converts a structure to array lookups.\"\n  ([xs]\n   (struct->array\n    xs\n    #?(:clj  (make-array Double/TYPE ~(count xs))\n       :cljs (make-array ~(count xs)))))\n  ([xs output]\n   (let [output (or output)]\n     `(doto ~output\n        ~@(map-indexed (fn [i x]\n                         `(aset ~i ~x))\n                       xs)))))\n\n#_([body]\n   (apply-numeric-ops\n    body\n    #?(:clj  (make-array Double/TYPE ~(count xs))\n       :cljs (make-array ~(count xs)))))\n\n(defn ^:no-doc apply-numeric-ops\n  \"Takes a function body and returns a new body with all numeric operations\n  like `(/ 1 2)` evaluated and all numerical literals converted to `double` or\n  `js/Number`.\n\n  TODO expand this??\"\n  ([body]\n   (w/postwalk\n    (fn [expr]\n      (cond (v/real? expr) (u/double expr)\n            (sequential? expr)\n            (let [[f & xs] expr]\n              (if-let [m (and (every? number? xs)\n                              (numeric-whitelist f))]\n                (u/double (apply (:f m) xs))\n                expr))\n            :else expr))\n    body)))\n\n;; ### SCI vs Native Compilation\n;;\n;; Armed with the above compiler optimization we can move on to the actual\n;; compilation step.\n;;\n;; This library provides two compilation modes:\n;;\n;; - Native compilation via `eval`\n;; - interpreted compilation via [SCI](https://github.com/borkdude/sci), the\n;;   Small Clojure Interpreter.\n;;\n;; We default to SCI mode in CLJS, but :native in Clojure for performance.\n\n(def ^{:dynamic true\n       :no-doc true}\n  *mode*\n  #?(:clj :native\n     :cljs :sci))\n\n(def ^{:doc \"Set of all supported compilation modes.\"}\n  valid-modes\n  #{:sci :native :source})\n\n(defn validate-mode!\n  \"Given a keyword `mode` specifying a compilation mode, returns `mode` if valid,\n  and throws otherwise.\"\n  [mode]\n  (or (valid-modes mode)\n      (throw\n       (ex-info\n        (str \"Invalid compilation mode supplied: \" mode\n             \". Please supply (or bind to `*mode*`) one of \" valid-modes)\n        {:mode       mode\n         :valid-mode valid-modes}))))\n\n(defn compiler-mode\n  \"Validates and returns the dynamically bound compilation [[*mode*]].\n  Throws on an invalid setting.\"\n  []\n  (validate-mode! *mode*))\n\n(defn set-compiler-mode!\n  \"Set the default compilation mode by supplying an entry from [[valid-modes]].\"\n  [mode]\n  (validate-mode! mode)\n  #?(:cljs (set! *mode* mode)\n     :clj  (alter-var-root #'*mode* (constantly mode))))\n\n;; Native compilation works on the JVM, and on Clojurescript if you're running\n;; in a self-hosted CLJS environment. Enable this mode by wrapping your call in\n;;\n;; `(binding [*mode* :native] ,,,)`\n;;\n;; ## State Functions\n;;\n;; `compile.cljc` currently supports compilation of:\n;;\n;; - univariate functions (for use with ODEs, `definite-integral` etc)\n;; - \"state\" functions.\n;;\n;; A state function is a function that takes any number of arguments and returns\n;; a new function of a \"structure\", usually an up-or-down tuple or a Clojure\n;; sequence.\n;;\n;; The compiled version of a state function like\n\n#_\n(fn [mass g]\n  (fn [q] ,,,))\n\n;; Has a signature like\n\n#_\n(fn [q [mass g]] ,,,)\n\n;; IE, first the structure, then a vector of the original function's arguments.\n\n(defn- state-argv\n  \"Returns the argument vector for a compiled state function, given:\n\n  - `params`: a seq of symbols equal in count to the original state function's\n    args\n  - `state-model`: a sequence of variables representing the structure of the\n    argument to the nested function returned by the state function\n  - `opts`, a dictionary of compilation options.\n\n  See [[compile-state-fn*]] for a description of the options accepted in\n  `opts`.\"\n  [params state-model output]\n  (let [state (into [] (into [] (flatten state-model)))]\n    [state params output]))\n\n;; The following two functions compile state functions in either native or SCI\n;; mode. The primary difference is that native compilation requires us to\n;; explicitly replace all instances of symbols from `compiled-fn-whitelist`\n;; above with actual functions.\n;;\n;; SCI handles this behind its interface, and simply takes a reusable context\n;; that wraps the fn replacement mapping.\n\n(def ^{:private true\n       :doc \"Reuseable context for SCI compilation. Fork with `sci/fork` to\n  ensure that no call to `sci/eval-*` can inject state that another call can\n  see.\"}\n  sci-context\n  (sci/init\n   {:classes {'Math #?(:cljs js/Math :clj java.lang.Math)}\n\n    ;; These are the only non-Math bindings introduced by the postwalk\n    ;; replacement.\n    :namespaces {'sicmutils.structure\n                 {'up struct/up\n                  'down struct/down}}}))\n\n(defn sci-eval\n  \"Given an unevaluated source code form `f-form` representing a function,\n  evaluates `f-form` using the bindings in [[sci-context]].\n\n  Generate these forms by setting `*mode*` to `:source`.\"\n  [f-form]\n  (sci/eval-form (sci/fork sci-context) f-form))\n\n(defn ^:no-doc array-bindings\n  \"vs is the variables actually used\"\n  [vs arr inputs]\n  (into [] (comp (map-indexed\n                  (fn [i v]\n                    (when (vs v)\n                      [v `(aget ~arr ~i)])))\n                 cat)\n        (flatten inputs)))\n\n(comment\n  (= '[t (clojure.core/aget arr 0)\n       thetadot (clojure.core/aget arr 2)]\n     (array-inputs '(+ t thetadot) 'arr '[t theta thetadot])))\n\n;; TODO add docs for the `output` arg\n\n(defn- compile-state->source\n  \"Returns a natively-evaluated Clojure function that implements `body`, given:\n\n  - `params`: a seq of symbols equal in count to the original state function's\n    args\n  - `state-model`: a sequence of variables representing the structure of the\n    nested function returned by the state function\n  - `body`: a function body making use of any symbol in the args above\"\n  [params state-model body output _opts]\n  (let [state-sym (with-meta (gensym) {:tag 'doubles})\n        param-sym (with-meta (gensym) {:tag 'doubles})\n        body      (w/postwalk-replace sym->resolved-form body)\n        vs        (x/variables-in body)]\n    ;; TODO maybe tidy up, no empty let binding if no params etc?\n    `(fn [~state-sym ~param-sym ~output]\n       (let ~(array-bindings vs state-sym state-model)\n         (let ~(array-bindings vs param-sym params)\n           ~body)))))\n\n(defn- compile-state-native\n  \"Returns a natively-evaluated Clojure function that implements `body`, given:\n\n  - `params`: a seq of symbols equal in count to the original state function's\n    args\n  - `state-model`: a sequence of variables representing the structure of the\n    nested function returned by the state function\n  - `body`: a function body making use of any symbol in the args above\"\n  [params state-model body output opts]\n  (eval\n   (compile-state->source params state-model body output opts)))\n\n(defn- compile-state-sci\n  \"Returns a Clojure function evaluated using SCI. The returned fn implements\n  `body`, given:\n\n  - `params`: a seq of symbols equal in count to the original state function's\n    args\n  - `state-model`: a sequence of variables representing the structure of the\n    nested function returned by the state function\n  - `body`: a function body making use of any symbol in the args above\"\n  ([params state-model body output opts]\n   (sci-eval\n    (compile-state->source params state-model body output opts))))\n\n;; ### State Fn Interface\n;;\n;; Now we come to the final interface for state function compilation. Two\n;; versions of the following function exist, one that uses the global cache\n;; defined above and one that doesn't.\n\n(defn state->argv\n  \"Given a (structural) initial `state` and a `gensym-fn` function from symbol =>\n  generated symbol walks the structure and converts all structures to vectors\n  and all non-structural elements to gensymmed symbols.\"\n  [state gensym-fn]\n  (letfn [(rec [s]\n            (if (struct/structure? s)\n              (mapv rec s)\n              (gensym-fn 'y)))]\n    (rec state)))\n\n;; TODO -\n;;\n;; `:flatten?`, `:generic-params?` need to get killed in favor of\n;;\n;; - `:parameters`, where if these are MISSING we assume they've already been\n;;    supplied, and if present, then we act like `\"generic-params?`\" is true.\n;;\n(defn flatten-structs [x]\n  (letfn [(sym-struct? [expr]\n            (and (sequential? expr)\n                 (struct/symbol-set (first expr))))]\n    (filter (complement sym-struct?)\n            (rest (tree-seq sym-struct? rest x)))))\n\n(defn ^:no-doc ->output [body output]\n  (if (= `let (first body))\n    `(~@(take 2 body)\n      ~(->output (nth body 2) output))\n    `(doto ~output\n       ~@(map-indexed (fn [i x]\n                        `(aset ~i ~x))\n                      (flatten-structs body)))))\n\n(defn ^:no-doc ->js-output [body output]\n  (if (= `let (first body))\n    `(~@(take 2 body)\n      ~(->output (nth body 2) output))\n    `(do\n       ~@(map-indexed (fn [i x]\n                        `(aset ~output ~i ~x))\n                      (flatten-structs body)))))\n\n(comment\n  (= '(clojure.core/doto output\n        (clojure.core/aset 0 t)\n        (clojure.core/aset 1 x0)\n        (clojure.core/aset 2 x1)\n        (clojure.core/aset 3 v0)\n        (clojure.core/aset 4 v1))\n     (->output\n      '(up t (up x0 x1) (up v0 v1))\n      'output)))\n\n(defn compile-state-fn*\n  \"Returns a compiled, simplified function with signature `(f state params)`,\n  given:\n\n  - a (possibly parametric) function `f` of state => state that can accept a\n    symbolic arguments\n\n  - `prototype`: Some structure of the same shape as the argument expected by\n    the fn returned by the state function `f`. Only the shape matters; the values\n    are ignored.\n\n  - an optional argument `opts`. Options accepted are:\n\n    - `:flatten?`: if `true` (default), the returned function will have\n      signature `(f <flattened-state> [params])`. If `false`, the first arg of the\n      returned function will be expected to have the same shape as `initial-state`.\n\n    - `:parameters`; Prototype of params TODO more details\n\n      any sequence of count equal to the number of arguments taken by `f`. The\n      values are ignored. TODO EDIT:: if `true` (default), the returned function\n      will take a second argument for the parameters of the state derivative and\n      keep params generic. If false, the returned function will take a single state\n      argument, and the supplied params will be hardcoded.\n\n    - `:genysym-fn`:\n\n    - `:mode`: Explicitly set the compilation mode to one of the values\n      in [[valid-modes]]. Explicit alternative to dynamically binding [[*mode*]].\n\n  The returned, compiled function expects all `Double` (or `js/Number`) for all\n  state primitives. The function body is simplified and all common\n  subexpressions identified during compilation are extracted and computed only\n  once.\n\n  NOTE this function uses no cache. To take advantage of the global compilation\n  cache, see `compile-state-fn`.\"\n  ([f prototype]\n   (compile-state-fn* f prototype {}))\n  ([f prototype {:keys [parameters\n                        gensym-fn\n                        mode]\n                 :or {gensym-fn gensym}\n                 :as opts}]\n   (let [sw            (us/stopwatch)\n         ;; this needs to be the actual, structural argv at this stage.\n         generic-state (state->argv prototype gensym-fn)\n         [params g]    (if parameters\n                         (let [ps (for [_ parameters] (gensym-fn 'p))]\n                           [ps (apply f ps)])\n                         [nil f])\n         output        (with-meta (gensym) {:tag 'doubles})\n         body          (-> (g generic-state)\n                           (g/simplify)\n                           (v/freeze)\n                           (cse-form)\n                           (apply-numeric-ops)\n                           (->output output))\n         compiler      (case (validate-mode! (or mode *mode*))\n                         :source compile-state->source\n                         :native compile-state-native\n                         :sci compile-state-sci)\n         compiled-fn   (compiler params generic-state body output opts)]\n     (log/info \"compiled state function in\" (us/repr sw) \"with mode\" *mode*)\n     compiled-fn)))\n\n;; TODO: `compile-state-fn` should be more discerning in how it caches!\n\n(defn compile-state-fn\n  \"Version of [[compile-state-fn*]] memoized on the `f` parameter only.\n  See that function's docs for more detail.\n\n  NOTE that this function makes use of a global compilation cache, keyed by the\n  value of `f`. Passing in the same `f` twice, even with different arguments for\n  `prototype`, `opts` and different compilation modes, will return the cached\n  value. See `compile-state-fn*` to avoid the cache.\"\n  ([f prototype]\n   (compile-state-fn f prototype {}))\n  ([f prototype opts]\n   (if-let [cached (@fn-cache f)]\n     (do\n       (log/info \"compiled state function cache hit\")\n       cached)\n     (let [compiled (compile-state-fn* f prototype opts)]\n       (swap! fn-cache assoc f compiled)\n       compiled))))\n\n;; ## To JavaScript\n\n(defn- make-symbol-generator [p]\n  (let [i (atom 0)]\n    (fn [] (symbol\n           #?(:clj\n              (format \"%s%04x\" p (swap! i inc))\n\n              :cljs\n              (let [suffix (-> (swap! i inc)\n                               (.toString 16)\n                               (.padStart 4 \"0\"))]\n                (str p suffix)))))))\n\n(def infix-set\n  '#{* + - / u- =})\n\n(def js-renames\n  {'sin \"Math.sin\"\n   'cos \"Math.cos\"\n   'tan \"Math.tan\"\n   'asin \"Math.asin\"\n   'acos \"Math.acos\"\n   'atan \"Math.atan\"\n   'cosh \"Math.cosh\"\n   'sinh \"Math.sinh\"\n   'tanh \"Math.tanh\"\n   'asinh \"Math.asinh\"\n   'acosh \"Math.acosh\"\n   'atanh \"Math.atanh\"\n   'sqrt \"Math.sqrt\"\n   'abs \"Math.abs\"\n   'expt \"Math.pow\"\n   'log \"Math.log\"\n   'exp \"Math.exp\"\n   'floor \"Math.floor\"\n   'ceiling \"Math.ceil\"\n   'integer-part \"Math.trunc\"\n   'not \"!\"})\n\n;; TODO pull in from render... and TODO add the `else` case in `render`.\n\n(defn- render-infix-ratio\n  \"renders a pair of the form `[numerator denominator]` as a infix ratio of the\n  form `num/denom`.\n\n  If the pair contains only one entry `x`, it's coerced to `[1 x]` (and treated\n  as a denominator).\"\n  [[num denom :as xs]]\n  (let [n (count xs)]\n    (cond (and (= n 1) (v/integral? num))\n          (str \"1/\" num)\n\n          (and (= n 2)\n               (v/integral? num)\n               (v/integral? denom))\n          (str num \"/\" denom)\n\n          :else (str num \" / \" denom))))\n\n(def js-handlers\n  (let [->parens #(str \"(\" % \")\")\n        ->js-vector #(str \\[ (cs/join \", \" %) \\])]\n    {'up ->js-vector\n     'down ->js-vector\n     'modulo (fn [[a b]]\n               (-> (str a \" % \" b)\n                   (->parens)\n                   (str \" + \" b)\n                   (->parens)\n                   (str \" % \" b)\n                   (->parens)))\n     'remainder (fn [[a b]]\n                  (str a \" % \" b))\n     'and (fn [[a b]] (str a \" && \" b))\n     'or  (fn [[a b]] (str a \" || \" b))\n\n     ;; TODO this is dumb for now!!\n     'do  (fn [xs] (apply str xs))\n     `aset\n     (fn [[a i v]] (str \"  \" a \"[\" (int i) \"] = \" v \";\\n\"))\n     '/ render-infix-ratio}))\n\n;; TODO return `(js/Function. \"s\" \"p\" \"out\" \"body\")`\n(let [->parens #(str \"(\" % \")\")]\n  (defn ->js [xs]\n    (str\n     (w/postwalk\n      (fn [expr]\n        (cond (symbol? expr) expr\n              (v/real? expr) (u/double expr)\n              (sequential? expr)\n              (let [[f & xs] expr]\n                (if-let [m (and (every? number? xs)\n                                (numeric-whitelist f))]\n                  (u/double (apply (:f m) xs))\n                  (or (when-let [f' (js-handlers f)]\n                        (f' xs))\n\n                      ;; infix\n                      (when-let [sym (infix-set f)]\n                        (->parens\n                         (cs/join (str \" \" sym \" \") xs)))\n\n                      ;; prefix\n                      (when-let [f-name (js-renames f)]\n                        (str f-name\n                             (->parens\n                              (cs/join \" , \" xs))))\n\n                      (u/illegal (str \"Unknown op: \" f)))))\n              :else expr))\n      xs))))\n\n(comment\n  (let [xs '(+ (* x y z)\n               (- (* a b c)\n                  (/ d g)))]\n    (->js xs)))\n\n;; TODO I expect that the guts here will be mostly the same...\n(defn compile-js\n  ([f prototype]\n   (compile-js f prototype {}))\n  ([f prototype {:keys [parameters\n                        gensym-fn\n                        mode]\n                 :or {gensym-fn gensym}\n                 :as opts}]\n   (let [sw            (us/stopwatch)\n         callback      (fn [new-expression new-vars]\n                         (str (cs/join\n                               (->> (for [[var val] new-vars]\n                                      (str \"  var \" var \" = \" (->js val) \";\\n\"))\n                                    (apply str)))\n                              (->js new-expression) \";\"))\n         ;; this needs to be the actual, structural argv at this stage.\n         generic-state (state->argv prototype gensym-fn)\n         [params g]    (if parameters\n                         (let [ps (for [_ parameters] (gensym-fn 'p))]\n                           [ps (apply f ps)])\n                         [nil f])\n         state-sym     (with-meta (gensym) {:tag 'doubles})\n         param-sym     (with-meta (gensym) {:tag 'doubles})\n         output-sym    (with-meta (gensym) {:tag 'doubles})\n         body (-> (g generic-state)\n                  (g/simplify)\n                  (v/freeze))\n         vs (x/variables-in body)\n         body (-> body\n                  (->js-output output-sym)\n                  (extract-common-subexpressions callback opts))\n         s-bindings (transduce\n                     (comp (map-indexed\n                            (fn [i v]\n                              (when (vs v)\n                                [(str \"  \" v \" = \" state-sym \"[\" i \"];\\n\")])))\n                           cat)\n                     str\n                     (flatten generic-state))\n         p-bindings (transduce\n                     (comp (map-indexed\n                            (fn [i v]\n                              (when (vs v)\n                                [(str \"  \" v \" = \" param-sym \"[\" i \"];\\n\")])))\n                           cat)\n                     str\n                     params)\n         body-str (str s-bindings p-bindings body)]\n     (log/info \"compiled state function in\" (us/repr sw) \"with mode :js\")\n     #_(js/console.log\n        (str state-sym)\n        (str param-sym)\n        (str output-sym)\n        body-str)\n     #?(:clj\n        {:params [(str state-sym)\n                  (str param-sym)\n                  (str output-sym)]\n         :body body-str}\n        :cljs\n        (js/Function.\n         (str state-sym)\n         (str param-sym)\n         (str output-sym)\n         body-str)))))\n\n;; ## Non-State-Functions\n;;\n;; Compiled functions are excellent input for `definite-integral`, ODE solvers,\n;; single variable function minimization, root finding and more.\n;;\n;; The implementation and compilation steps are simpler than the state function\n;; versions above; the function you pass in has to take `n` symbolic arguments,\n;; that's it.\n\n(defn- compile->source\n  \"Returns an unevaluated source code body function that implements `body`, given\n  some sequence `args` of argument symbols.\n\n  `body` should of course make use of the symbols in `args`.\"\n  [args body]\n  (let [body (w/postwalk-replace sym->resolved-form body)]\n    `(fn [~@args] ~body)))\n\n(defn- compile-native\n  \"Returns a natively-evaluated Clojure function that implements `body`, given\n  some sequence `args` of argument symbols.\n\n  `body` should of course make use of the symbols in `args`.\"\n  [args body]\n  (eval\n   (compile->source args body)))\n\n(defn- compile-sci\n  \"Returns a Clojure function evaluated\n  using [SCI](https://github.com/borkdude/sci) The returned fn implements\n  `body`, given some sequence `args` of argument symbols.\n\n  `body` should of course make use of the symbols in `args`.\"\n  [args body]\n  (sci-eval\n   (compile->source args body)))\n\n(defn- retrieve-arity [f]\n  (let [[kwd n :as arity] (f/arity f)]\n    (if (= kwd :exactly)\n      n\n      (u/illegal\n       (str \"`compile-fn` can only infer arity for functions with just one\n           arity, not \" arity \". Please pass an explicit `n`.\")))))\n\n(defn compile-fn*\n  \"Returns a compiled, simplified version of `f`, given a function `f` of arity\n  `n` (ie, able to accept `n` symbolic arguments).\n\n  `n` defaults to `([[f/arity]] f)`.\n\n  The returned, compiled function expects `n` `Double` (or `js/Number`)\n  arguments. The function body is simplified and all common subexpressions\n  identified during compilation are extracted and computed only once.\n\n  NOTE: this function uses no cache. To take advantage of the global compilation\n  cache, see `compile-fn`.\"\n  ([f] (compile-fn* f (retrieve-arity f)))\n  ([f n]\n   (let [sw       (us/stopwatch)\n         args     (repeatedly n #(gensym 'x))\n         body     (-> (apply f args)\n                      (g/simplify)\n                      (v/freeze)\n                      (cse-form)\n                      (apply-numeric-ops))\n         compiled (case (compiler-mode)\n                    :source (compile->source args body)\n                    :native (compile-native args body)\n                    :sci (compile-sci args body))]\n     (log/info \"compiled function of arity\" n \"in\" (us/repr sw) \"with mode\" *mode*)\n     compiled)))\n\n(defn compile-fn\n  \"Memoized version of [[compile-fn*]]. See that function's docs for more detail.\n\n  NOTE: that this function makes use of a global compilation cache, keyed by the\n  vector `[f n *mode*]`. See `compile-fn*` to avoid the cache.\"\n  ([f] (let [[kwd n :as arity] (f/arity f)]\n         (when-not (= kwd :exactly)\n           (u/illegal\n            (str \"`compile-fn` can only infer arity for functions with just one\n           arity, not \" arity \". Please pass an explicit `n`.\")))\n         (compile-fn f n)))\n  ([f n]\n   (let [mode *mode*]\n     (if-let [cached (@fn-cache [f n mode])]\n       (do\n         (log/info \"compiled function cache hit - arity \" n \", mode \" mode)\n         cached)\n       (binding [*mode* mode]\n         (let [compiled (compile-fn* f n)]\n           (swap! fn-cache assoc [f n mode] compiled)\n           compiled))))))\n"]}