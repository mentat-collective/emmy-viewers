{"version":3,"sources":["sicmutils/calculus/map.cljc"],"mappings":"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","names":["sicmutils.calculus.map/pullback-function","mu:N->M","f-on-M","sicmutils.function$.compose","sicmutils.calculus.map/pushforward-function","mu-inverse:M->N","f-on-N","sicmutils.calculus.map/differential-of-map","js/Error","v-on-N","sicmutils.calculus.vector-field/vector-field?","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","v-on-M","g-on-M","G__101497","name","sicmutils.value/freeze","sicmutils.calculus.vector_field.procedure__GT_vector_field","sicmutils.calculus.map/differential","sicmutils.calculus.map/pushforward-vector","op","f","G__101498","sicmutils.calculus.map/literal-manifold-map","source","target","n","sicmutils.calculus.manifold/manifold","m","domain","cljs.core._EQ_","sicmutils.structure/up*","cljs.core.repeat","range","sicmutils.calculus.manifold/point","sicmutils.abstract$.function$.literal_function","sicmutils.calculus.manifold/chart","sicmutils.calculus.map/vector-field->vector-field-over-map","sicmutils.calculus.map/form-field->form-field-over-map","w-on-M","V-over-mu","_","fexpr__101502","vectors-over-map","cljs.core/count","sicmutils.calculus.form-field/get-rank","G__101504","fexpr__101503","cljs.core.apply","cljs.core.map","make-fake-vector-field","rank","sicmutils.calculus.form_field.procedure__GT_nform_field","sicmutils.calculus.map/basis->basis-over-map","basis-on-M","vector-basis-on-M","sicmutils.calculus.basis/basis->vector-basis","dual-basis-on-M","sicmutils.calculus.basis/basis->oneform-basis","sicmutils.calculus.basis/make-basis","sicmutils.structure.mapr","sicmutils.calculus.map/pullback-form","omega-on-M","k","vectors-on-N","sicmutils.calculus.map/pullback-vector-field","var_args","G__101506","sicmutils.calculus.map/pullback","sicmutils.calculus.map.pullback","thing","sicmutils.util/illegal"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.calculus.map\n  \"Various definitions and utilities for working with maps between manifolds.\"\n  (:require [sicmutils.abstract.function :as af]\n            [sicmutils.calculus.basis :as b]\n            [sicmutils.calculus.form-field :as ff]\n            [sicmutils.calculus.manifold :as m]\n            [sicmutils.calculus.vector-field :as vf]\n            [sicmutils.function :as f]\n            [sicmutils.structure :as s]\n            [sicmutils.util :as u]\n            [sicmutils.value :as v]))\n\n;; ## Maps between Manifolds\n;;\n;; If we have a function on a manifold M and a map from manifold N to manifold M\n;; we can define a function on N:\n\n(defn pullback-function\n  [mu:N->M]\n  (fn [f-on-M]\n    (f/compose f-on-M mu:N->M)))\n\n;; If we have an inverse map mu^-1:M->N, we can push a function\n;; on N forward through the map:\n\n(defn pushforward-function [mu-inverse:M->N]\n  (fn [f-on-N]\n    (f/compose f-on-N mu-inverse:M->N)))\n\n;; The map between manifolds induces various ways to transport vectors from one\n;; manifold to another. The simplest of these is the differential.\n\n;; The differential of a function mu:N->M from N to M takes a vector field on\n;; the source manifold N to a vector field-like operator on the target manifold\n;; M. This results in a vector field over the map mu:N->M. The result takes\n;; directional derivatives of functions defined on M, at points of M that are\n;; targets of points of N.\n\n(defn differential-of-map\n  \"Defined on FDG p.72.\"\n  [mu:N->M]\n  (fn [v-on-N]\n    {:pre [(vf/vector-field? v-on-N)]}\n    (let [v-on-M (fn [g-on-M]\n                   (v-on-N\n                    (f/compose g-on-M mu:N->M)))\n          name `((~'d ~(v/freeze mu:N->M))\n                 ~(v/freeze v-on-N))]\n      (vf/procedure->vector-field v-on-M name))))\n\n(def ^{:doc \"Alias for [[differential-of-map]].\"}\n  differential\n  differential-of-map)\n\n;; For a long time we were confused between the concepts of differential and\n;; pushforward. The resolution seems to be that the differential takes the\n;; manifold position in the source manifold and the pushforward takes the\n;; manifold position in the target manifold of the map. So the pushforward needs\n;; an inverse map to define it and so the pushforward is not a very useful idea.\n\n(defn pushforward-vector\n  [mu:N->M mu-inverse:M->N]\n  (fn [v-on-N]\n    (let [op (fn [f]\n               (f/compose (v-on-N (f/compose f mu:N->M))\n                          mu-inverse:M->N))\n          name `((~'pushforward ~(v/freeze mu:N->M))\n                 ~(v/freeze v-on-N))]\n      (vf/procedure->vector-field op name))))\n\n(defn literal-manifold-map\n  [name source target]\n  (let [n (:dimension (m/manifold source))\n        m (:dimension (m/manifold target))\n        domain (if (= n 1) 0 (s/up* (repeat n 0)))\n        range  (s/up* (repeat m 0))]\n    (f/compose (m/point target)\n               (af/literal-function name domain range)\n               (m/chart source))))\n\n;; Another way to obtain a vector field over a map is to start with a vector\n;; field on the target manifold. Given a vector field v-on-M and a map mu:N->M,\n;; we obtain a vector field over the map. This is a thing like a vector field on\n;; M restricted to the targets of mu:N->M and evaluated on points of N.\n\n(defn vector-field->vector-field-over-map\n  \"Defined on FDG p.72.\"\n  [mu:N->M]\n  (fn [v-on-M]\n    (let [op (fn [f-on-M]\n               (f/compose (v-on-M f-on-M)\n                          mu:N->M))\n          name `((~'vector-field->vector-field-over-map ~(v/freeze mu:N->M))\n                 ~(v/freeze v-on-M))]\n      (vf/procedure->vector-field op name))))\n\n;; A form field can also be transported across a map.  Given a form\n;; field on M and a map mu:N->M, we obtain a thing like a form field\n;; on M that measures vectors over the map mu:N->M and is evaluated\n;; on points of N.\n\n(defn form-field->form-field-over-map\n  [mu:N->M]\n  (fn [w-on-M]\n    (letfn [(make-fake-vector-field [V-over-mu n]\n              (vf/procedure->vector-field\n               (fn [f]\n                 (fn [_]\n                   ((V-over-mu f) n)))\n               `(~'make-fake-vector-field\n                 ~(v/freeze V-over-mu))))\n            (op [& vectors-over-map]\n              (assert (= (count vectors-over-map)\n                         (ff/get-rank w-on-M)))\n              (fn [n]\n                ((apply w-on-M\n                        (map (fn [V-over-mu]\n                               (make-fake-vector-field V-over-mu n))\n                             vectors-over-map))\n                 (mu:N->M n))))]\n      (let [rank (ff/get-rank w-on-M)\n            name `((~'form-field->form-field-over-map ~(v/freeze mu:N->M))\n                   ~(v/freeze w-on-M))]\n        (ff/procedure->nform-field op rank name)))))\n\n(defn basis->basis-over-map\n  [mu:N->M basis-on-M]\n  (let [vector-basis-on-M (b/basis->vector-basis basis-on-M)\n        dual-basis-on-M   (b/basis->oneform-basis basis-on-M)]\n    (b/make-basis\n     (s/mapr (vector-field->vector-field-over-map mu:N->M)\n             vector-basis-on-M)\n     (s/mapr (form-field->form-field-over-map mu:N->M)\n             dual-basis-on-M))))\n\n(defn pullback-form\n  \"Returns a function which will pull a form back across a map (without needing\n  its inverse)\"\n  [mu:N->M]\n  (fn [omega-on-M]\n    (let [k (ff/get-rank omega-on-M)]\n      (if (zero? k)\n        ((pullback-function mu:N->M) omega-on-M)\n        (let [op (fn [& vectors-on-N]\n                   (apply ((form-field->form-field-over-map mu:N->M) omega-on-M)\n                          (map (differential mu:N->M)\n                               vectors-on-N)))\n              name `((~'pullback ~(v/freeze mu:N->M))\n                     ~(v/freeze omega-on-M))]\n          (ff/procedure->nform-field op k name))))))\n\n(defn pullback-vector-field\n  [mu:N->M mu-inverse:M->N]\n  (pushforward-vector mu-inverse:M->N mu:N->M))\n\n(defn pullback\n  ([mu:N->M] (pullback mu:N->M nil))\n  ([mu:N->M mu-inverse:M->N]\n   (fn [thing]\n     (if (vf/vector-field? thing)\n       (if (nil? mu-inverse:M->N)\n         (u/illegal \"Pullback of a vector requires inverse map\")\n         ((pullback-vector-field mu:N->M mu-inverse:M->N) thing))\n       ((pullback-form mu:N->M) thing)))))\n"]}