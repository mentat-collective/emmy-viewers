shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$element$conic=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;global=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg"));var _constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants")),_coords=
_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coords")),_math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),_numerics=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$numerics")),_geometry=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$geometry")),_type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type"));
global.default.createEllipse=function(board,parents,attributes){var i,F=[];var M=_type.default.copyAttributes(attributes,board.options,"conic","foci");var attr_center=_type.default.copyAttributes(attributes,board.options,"conic","center");attributes=_type.default.copyAttributes(attributes,board.options,"conic");for(i=0;2>i;i++)if(1<parents[i].length)F[i]=board.create("point",parents[i],M);else if(_type.default.isPoint(parents[i]))F[i]=board.select(parents[i]);else if(_type.default.isFunction(parents[i])&&
_type.default.isPoint(parents[i]()))F[i]=parents[i]();else if(_type.default.isString(parents[i]))F[i]=board.select(parents[i]);else throw Error("JSXGraph: Can't create Ellipse with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,point,point], [point,point,number|function]");if(_type.default.isNumber(parents[2]))var majorAxis=_type.default.createFunction(parents[2],board);else if(_type.default.isFunction(parents[2])&&_type.default.isNumber(parents[2]()))majorAxis=
parents[2];else{if(_type.default.isPoint(parents[2]))var C=board.select(parents[2]);else if(1<parents[2].length)C=board.create("point",parents[2],M);else if(_type.default.isFunction(parents[2])&&_type.default.isPoint(parents[2]()))C=parents[2]();else if(_type.default.isString(parents[2]))C=board.select(parents[2]);else throw Error("JSXGraph: Can't create Ellipse with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.\nPossible parent types: [point,point,point], [point,point,number|function]");
majorAxis=function(){return C.Dist(F[0])+C.Dist(F[1])}}_type.default.exists(parents[4])||(parents[4]=2*Math.PI);_type.default.exists(parents[3])||(parents[3]=0);M=board.create("point",[function(){return.5*(F[0].X()+F[1].X())},function(){return.5*(F[0].Y()+F[1].Y())}],attr_center);var curve=board.create("curve",[function(x){return 0},function(x){return 0},parents[3],parents[4]],attributes);curve.majorAxis=majorAxis;var hasPointOrg=curve.hasPoint;var polarForm=function(phi,suspendUpdate){if(!suspendUpdate){phi=
majorAxis();suspendUpdate=phi*phi;var ax=F[0].X();var ay=F[0].Y();var bx=F[1].X();var by=F[1].Y();var axbx=ax-bx;var ayby=ay-by;ax=(suspendUpdate-ax*ax-ay*ay+bx*bx+by*by)/(2*phi);curve.quadraticform=[[ax*ax-bx*bx-by*by,ax*axbx/phi+bx,ax*ayby/phi+by],[ax*axbx/phi+bx,axbx*axbx/suspendUpdate-1,axbx*ayby/suspendUpdate],[ax*ayby/phi+by,axbx*ayby/suspendUpdate,ayby*ayby/suspendUpdate-1]]}};curve.X=function(phi,suspendUpdate){var r=majorAxis(),c=F[1].Dist(F[0]);r=.5*(c*c-r*r)/(c*Math.cos(phi)-r);c=Math.atan2(F[1].Y()-
F[0].Y(),F[1].X()-F[0].X());suspendUpdate||polarForm(phi,suspendUpdate);return F[0].X()+Math.cos(c+phi)*r};curve.Y=function(phi,suspendUpdate){suspendUpdate=majorAxis();var c=F[1].Dist(F[0]);suspendUpdate=.5*(c*c-suspendUpdate*suspendUpdate)/(c*Math.cos(phi)-suspendUpdate);c=Math.atan2(F[1].Y()-F[0].Y(),F[1].X()-F[0].X());return F[0].Y()+Math.sin(c+phi)*suspendUpdate};curve.midpoint=curve.center=M;curve.type=_constants.default.OBJECT_TYPE_CONIC;curve.subs={center:curve.center};curve.inherits.push(curve.center,
F[0],F[1]);_type.default.isPoint(C)&&curve.inherits.push(C);curve.hasPoint=function(x,y){if(_type.default.evaluate(this.visProp.hasinnerpoints)){var ac=F[0].coords;var bc=F[1].coords;var r=this.majorAxis();var p=new _coords.default(_constants.default.COORDS_BY_SCREEN,[x,y],this.board);ac=p.distance(_constants.default.COORDS_BY_USER,ac)+p.distance(_constants.default.COORDS_BY_USER,bc);return ac<=r}return hasPointOrg.apply(this,arguments)};M.addChild(curve);for(i=0;2>i;i++)_type.default.isPoint(F[i])&&
F[i].addChild(curve);_type.default.isPoint(C)&&C.addChild(curve);curve.setParents(parents);return curve};global.default.createHyperbola=function(board,parents,attributes){var i,F=[];var M=_type.default.copyAttributes(attributes,board.options,"conic","foci");var attr_center=_type.default.copyAttributes(attributes,board.options,"conic","center");attributes=_type.default.copyAttributes(attributes,board.options,"conic");for(i=0;2>i;i++)if(1<parents[i].length)F[i]=board.create("point",parents[i],M);else if(_type.default.isPoint(parents[i]))F[i]=
board.select(parents[i]);else if(_type.default.isFunction(parents[i])&&_type.default.isPoint(parents[i]()))F[i]=parents[i]();else if(_type.default.isString(parents[i]))F[i]=board.select(parents[i]);else throw Error("JSXGraph: Can't create Hyperbola with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,point,point], [point,point,number|function]");if(_type.default.isNumber(parents[2]))var majorAxis=_type.default.createFunction(parents[2],board);else if(_type.default.isFunction(parents[2])&&
_type.default.isNumber(parents[2]()))majorAxis=parents[2];else{if(_type.default.isPoint(parents[2]))var C=board.select(parents[2]);else if(1<parents[2].length)C=board.create("point",parents[2],M);else if(_type.default.isFunction(parents[2])&&_type.default.isPoint(parents[2]()))C=parents[2]();else if(_type.default.isString(parents[2]))C=board.select(parents[2]);else throw Error("JSXGraph: Can't create Hyperbola with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"' and '"+typeof parents[2]+
"'.\nPossible parent types: [point,point,point], [point,point,number|function]");majorAxis=function(){return C.Dist(F[0])-C.Dist(F[1])}}_type.default.exists(parents[4])||(parents[4]=1.0001*Math.PI);_type.default.exists(parents[3])||(parents[3]=-1.0001*Math.PI);M=board.create("point",[function(){return.5*(F[0].X()+F[1].X())},function(){return.5*(F[0].Y()+F[1].Y())}],attr_center);var curve=board.create("curve",[function(x){return 0},function(x){return 0},parents[3],parents[4]],attributes);curve.majorAxis=
majorAxis;var polarForm=function(phi,suspendUpdate){if(!suspendUpdate){phi=majorAxis();suspendUpdate=phi*phi;var ax=F[0].X();var ay=F[0].Y();var bx=F[1].X();var by=F[1].Y();var axbx=ax-bx;var ayby=ay-by;ax=(suspendUpdate-ax*ax-ay*ay+bx*bx+by*by)/(2*phi);curve.quadraticform=[[ax*ax-bx*bx-by*by,ax*axbx/phi+bx,ax*ayby/phi+by],[ax*axbx/phi+bx,axbx*axbx/suspendUpdate-1,axbx*ayby/suspendUpdate],[ax*ayby/phi+by,axbx*ayby/suspendUpdate,ayby*ayby/suspendUpdate-1]]}};curve.X=function(phi,suspendUpdate){var r=
majorAxis(),c=F[1].Dist(F[0]);r=.5*(c*c-r*r)/(c*Math.cos(phi)+r);c=Math.atan2(F[1].Y()-F[0].Y(),F[1].X()-F[0].X());suspendUpdate||polarForm(phi,suspendUpdate);return F[0].X()+Math.cos(c+phi)*r};curve.Y=function(phi,suspendUpdate){suspendUpdate=majorAxis();var c=F[1].Dist(F[0]);suspendUpdate=.5*(c*c-suspendUpdate*suspendUpdate)/(c*Math.cos(phi)+suspendUpdate);c=Math.atan2(F[1].Y()-F[0].Y(),F[1].X()-F[0].X());return F[0].Y()+Math.sin(c+phi)*suspendUpdate};curve.midpoint=curve.center=M;curve.subs={center:curve.center};
curve.inherits.push(curve.center,F[0],F[1]);_type.default.isPoint(C)&&curve.inherits.push(C);curve.type=_constants.default.OBJECT_TYPE_CONIC;M.addChild(curve);for(i=0;2>i;i++)_type.default.isPoint(F[i])&&F[i].addChild(curve);_type.default.isPoint(C)&&C.addChild(curve);curve.setParents(parents);return curve};global.default.createParabola=function(board,parents,attributes){var F1=parents[0],l=parents[1],attr_foci=_type.default.copyAttributes(attributes,board.options,"conic","foci");var M$jscomp$0=_type.default.copyAttributes(attributes,
board.options,"conic","center");var attr_curve=_type.default.copyAttributes(attributes,board.options,"conic");if(1<parents[0].length)F1=board.create("point",parents[0],attr_foci);else if(_type.default.isPoint(parents[0]))F1=board.select(parents[0]);else if(_type.default.isFunction(parents[0])&&_type.default.isPoint(parents[0]()))F1=parents[0]();else if(_type.default.isString(parents[0]))F1=board.select(parents[0]);else throw Error("JSXGraph: Can't create Parabola with parent types '"+typeof parents[0]+
"' and '"+typeof parents[1]+"'.\nPossible parent types: [point,line]");_type.default.isArray(l)&&2===l.length&&(attributes=_type.default.copyAttributes(attributes,board.options,"conic","line"),l=board.create("line",l,attributes));_type.default.exists(parents[3])||(parents[3]=2*Math.PI);_type.default.exists(parents[2])||(parents[2]=0);M$jscomp$0=board.create("point",[function(){return _geometry.default.projectPointToLine(F1,l,board).usrCoords}],M$jscomp$0);var curve=board.create("curve",[function(x){return 0},
function(x){return 0},parents[2],parents[3]],attr_curve);curve.midpoint=curve.center=M$jscomp$0;curve.subs={center:curve.center};curve.inherits.push(curve.center);var polarForm=function(t,suspendUpdate){if(!suspendUpdate){t=l.stdform[1];suspendUpdate=l.stdform[2];var c=l.stdform[0];var ab=t*t+suspendUpdate*suspendUpdate;var px=F1.X();var py=F1.Y();curve.quadraticform=[[c*c-ab*(px*px+py*py),c*t+ab*px,c*suspendUpdate+ab*py],[c*t+ab*px,-suspendUpdate*suspendUpdate,t*suspendUpdate],[c*suspendUpdate+ab*
py,t*suspendUpdate,-t*t]]}};curve.X=function(phi,suspendUpdate){var beta=l.getAngle();var a=_geometry.default.distPointLine(F1.coords.usrCoords,l.stdform);var A=l.point1.coords.usrCoords,B=l.point2.coords.usrCoords,M=F1.coords.usrCoords;0===A[0]?A=[1,B[1]+l.stdform[2],B[2]-l.stdform[1]]:0===B[0]&&(B=[1,A[1]+l.stdform[2],A[2]-l.stdform[1]]);a=(0<=(B[1]-A[1])*(M[2]-A[2])-(B[2]-A[2])*(M[1]-A[1])?1:-1)*a/(1-Math.sin(phi));suspendUpdate||polarForm(phi,suspendUpdate);return F1.X()+Math.cos(phi+beta)*a};
curve.Y=function(phi,suspendUpdate){suspendUpdate=l.getAngle();var a=_geometry.default.distPointLine(F1.coords.usrCoords,l.stdform);var A=l.point1.coords.usrCoords,B=l.point2.coords.usrCoords,M=F1.coords.usrCoords;0===A[0]?A=[1,B[1]+l.stdform[2],B[2]-l.stdform[1]]:0===B[0]&&(B=[1,A[1]+l.stdform[2],A[2]-l.stdform[1]]);a=(0<=(B[1]-A[1])*(M[2]-A[2])-(B[2]-A[2])*(M[1]-A[1])?1:-1)*a/(1-Math.sin(phi));return F1.Y()+Math.sin(phi+suspendUpdate)*a};curve.type=_constants.default.OBJECT_TYPE_CONIC;M$jscomp$0.addChild(curve);
_type.default.isPoint(F1)&&(F1.addChild(curve),curve.inherits.push(F1));l.addChild(curve);curve.setParents(parents);return curve};global.default.createConic=function(board,parents,attributes){var eigen,a,b,c,c1,c2,rotationMatrix=[[1,0,0],[0,1,0],[0,0,1]],M=[[1,0,0],[0,1,0],[0,0,1]],points=[],p$jscomp$0=[],attr_point=_type.default.copyAttributes(attributes,board.options,"conic","point"),attr_center=_type.default.copyAttributes(attributes,board.options,"conic","center"),attr_curve=_type.default.copyAttributes(attributes,
board.options,"conic");if(5===parents.length)var givenByPoints=!0;else if(6===parents.length)givenByPoints=!1;else throw Error("JSXGraph: Can't create generic Conic with "+parents.length+" parameters.");if(givenByPoints)for(attributes=0;5>attributes;attributes++)if(1<parents[attributes].length)points[attributes]=board.create("point",parents[attributes],attr_point);else if(_type.default.isPoint(parents[attributes]))points[attributes]=board.select(parents[attributes]);else if(_type.default.isFunction(parents[attributes])&&
_type.default.isPoint(parents[attributes]()))points[attributes]=parents[attributes]();else if(_type.default.isString(parents[attributes]))points[attributes]=board.select(parents[attributes]);else throw Error("JSXGraph: Can't create Conic section with parent types '"+typeof parents[attributes]+"'.\nPossible parent types: [point,point,point,point,point], [a00,a11,a22,a01,a02,a12]");else{var definingMat=[[0,0,0],[0,0,0],[0,0,0]];definingMat[0][0]=_type.default.isFunction(parents[2])?function(){return parents[2]()}:
function(){return parents[2]};definingMat[0][1]=_type.default.isFunction(parents[4])?function(){return parents[4]()}:function(){return parents[4]};definingMat[0][2]=_type.default.isFunction(parents[5])?function(){return parents[5]()}:function(){return parents[5]};definingMat[1][1]=_type.default.isFunction(parents[0])?function(){return parents[0]()}:function(){return parents[0]};definingMat[1][2]=_type.default.isFunction(parents[3])?function(){return parents[3]()}:function(){return parents[3]};definingMat[2][2]=
_type.default.isFunction(parents[1])?function(){return parents[1]()}:function(){return parents[1]}}var sym=function(A){var i,j;for(i=0;3>i;i++)for(j=i;3>j;j++)A[i][j]+=A[j][i];for(i=0;3>i;i++)for(j=0;j<i;j++)A[i][j]=A[j][i];return A};var degconic=function(v,w){var i,j,mat=[[0,0,0],[0,0,0],[0,0,0]];for(i=0;3>i;i++)for(j=0;3>j;j++)mat[i][j]=v[i]*w[j];return sym(mat)};var fitConic=function(A,B,p){var mat=[[0,0,0],[0,0,0],[0,0,0]];var j=_math.default.matVecMult(B,p);var pBp=_math.default.innerProduct(p,
j);j=_math.default.matVecMult(A,p);var pAp=_math.default.innerProduct(p,j);for(p=0;3>p;p++)for(j=0;3>j;j++)mat[p][j]=pBp*A[p][j]-pAp*B[p][j];return mat};var curve=board.create("curve",[function(x){return 0},function(x){return 0},0,2*Math.PI],attr_curve);var polarForm=function(phi,suspendUpdate){var j,v;if(!suspendUpdate){if(givenByPoints){for(suspendUpdate=0;5>suspendUpdate;suspendUpdate++)p$jscomp$0[suspendUpdate]=points[suspendUpdate].coords.usrCoords;c1=degconic(_math.default.crossProduct(p$jscomp$0[0],
p$jscomp$0[1]),_math.default.crossProduct(p$jscomp$0[2],p$jscomp$0[3]));c2=degconic(_math.default.crossProduct(p$jscomp$0[0],p$jscomp$0[2]),_math.default.crossProduct(p$jscomp$0[1],p$jscomp$0[3]));M=fitConic(c1,c2,p$jscomp$0[4])}else for(suspendUpdate=0;3>suspendUpdate;suspendUpdate++)for(j=suspendUpdate;3>j;j++)M[suspendUpdate][j]=definingMat[suspendUpdate][j](),j>suspendUpdate&&(M[j][suspendUpdate]=M[suspendUpdate][j]);curve.quadraticform=M;eigen=_numerics.default.Jacobi(M);0>eigen[0][0][0]&&(eigen[0][0][0]*=
-1,eigen[0][1][1]*=-1,eigen[0][2][2]*=-1);for(suspendUpdate=0;3>suspendUpdate;suspendUpdate++)for(j=0;3>j;j++);rotationMatrix=eigen[1];c=Math.sqrt(Math.abs(eigen[0][0][0]));a=Math.sqrt(Math.abs(eigen[0][1][1]));b=Math.sqrt(Math.abs(eigen[0][2][2]))}0>=eigen[0][1][1]&&0>=eigen[0][2][2]?v=_math.default.matVecMult(rotationMatrix,[1/c,Math.cos(phi)/a,Math.sin(phi)/b]):0>=eigen[0][1][1]&&0<eigen[0][2][2]?v=_math.default.matVecMult(rotationMatrix,[Math.cos(phi)/c,1/a,Math.sin(phi)/b]):0>eigen[0][2][2]&&
(v=_math.default.matVecMult(rotationMatrix,[Math.sin(phi)/c,Math.cos(phi)/a,1/b]));_type.default.exists(v)?(v[1]/=v[0],v[2]/=v[0],v[0]=1):v=[1,NaN,NaN];return v};curve.X=function(phi,suspendUpdate){return polarForm(phi,suspendUpdate)[1]};curve.Y=function(phi,suspendUpdate){return polarForm(phi,suspendUpdate)[2]};curve.midpoint=board.create("point",[function(){var m=curve.quadraticform;return[m[1][1]*m[2][2]-m[1][2]*m[1][2],m[1][2]*m[0][2]-m[2][2]*m[0][1],m[0][1]*m[1][2]-m[1][1]*m[0][2]]}],attr_center);
curve.type=_constants.default.OBJECT_TYPE_CONIC;curve.center=curve.midpoint;curve.subs={center:curve.center};curve.inherits.push(curve.center);curve.inherits=curve.inherits.concat(points);if(givenByPoints){for(attributes=0;5>attributes;attributes++)_type.default.isPoint(points[attributes])&&points[attributes].addChild(curve);curve.setParents(parents)}curve.addChild(curve.center);return curve};global.default.registerElement("ellipse",global.default.createEllipse);global.default.registerElement("hyperbola",
global.default.createHyperbola);global.default.registerElement("parabola",global.default.createParabola);global.default.registerElement("conic",global.default.createConic);exports.default={createEllipse:global.default.createEllipse,createHyperbola:global.default.createHyperbola,createParabola:global.default.createParabola,createConic:global.default.createConic}}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$element$conic.js.map
