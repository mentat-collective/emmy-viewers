shadow$provide.module$node_modules$mathbox$build$esm$shaders$glsl$float_encode=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="/*\nFloat encoding technique by\nCarlos Scheidegger\nhttps://github.com/cscheid/lux/blob/master/src/shade/bits/encode_float.js\n\nConversion to GLSL by:\nhttp://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\n*/\n\nfloat shift_right(float v, float amt) { \n  v \x3d floor(v) + 0.5; \n  return floor(v / exp2(amt)); \n}\n\nfloat shift_left(float v, float amt) { \n  return floor(v * exp2(amt) + 0.5); \n}\n\nfloat mask_last(float v, float bits) { \n  return mod(v, shift_left(1.0, bits)); \n}\n\nfloat extract_bits(float num, float from, float to) { \n  from \x3d floor(from + 0.5); to \x3d floor(to + 0.5); \n  return mask_last(shift_right(num, from), to - from); \n}\n\nvec4 encode_float(float val) { \n  if (val \x3d\x3d 0.0) return vec4(0, 0, 0, 0); \n  float valuesign \x3d val \x3e 0.0 ? 0.0 : 1.0; \n  val \x3d abs(val); \n  float exponent \x3d floor(log2(val)); \n  float biased_exponent \x3d exponent + 127.0; \n  float fraction \x3d ((val / exp2(exponent)) - 1.0) * 8388608.0; \n  float t \x3d biased_exponent / 2.0; \n  float last_bit_of_biased_exponent \x3d fract(t) * 2.0; \n  float remaining_bits_of_biased_exponent \x3d floor(t); \n  float byte4 \x3d extract_bits(fraction, 0.0, 8.0) / 255.0; \n  float byte3 \x3d extract_bits(fraction, 8.0, 16.0) / 255.0; \n  float byte2 \x3d (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \n  float byte1 \x3d (valuesign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \n  return vec4(byte4, byte3, byte2, byte1); \n}\n"}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$shaders$glsl$float_encode.js.map
