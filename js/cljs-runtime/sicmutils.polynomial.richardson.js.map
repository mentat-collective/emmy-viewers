{"version":3,"sources":["sicmutils/polynomial/richardson.cljc"],"mappings":"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","names":["sicmutils.polynomial.richardson/refine-by-doubling","s","sicmutils.generic/sqrt","sicmutils.generic/square","sicmutils.polynomial.richardson/semi-perimeter","n","side-len","sicmutils.polynomial.richardson/side-lengths","cljs.core/iterate","Math/sqrt","sicmutils.polynomial.richardson/side-numbers","p1__88399#","sicmutils.polynomial.richardson/archimedean-pi-sequence","cljs.core.map","sicmutils.polynomial.richardson/accelerate-sequence","xs","t","p","t**p","Math/pow","t**p-1","ah","ah-over-t","cljs.core/rest","var_args","G__88407","sicmutils.polynomial.richardson/make-tableau","js/Error","sicmutils.polynomial.richardson.make_tableau","cljs.core/inc","ps","p__88409","vec__88410","cljs.core.nth","vec__88413","seq__88414","cljs.core/seq","first__88415","cljs.core/first","cljs.core/next","cljs.core.take_while","G__88422","sicmutils.polynomial.richardson/richardson-sequence","sicmutils.polynomial.interpolate/first-terms","p-sequence","q","arithmetic-p-q","p1__88416#","sicmutils.polynomial.richardson.richardson_sequence","G__88438","sicmutils.polynomial.richardson/richardson-column","col","p-seq","p1__88428#","sicmutils.polynomial.richardson.richardson_column","G__88444","sicmutils.polynomial.richardson/richardson-fold","sicmutils.polynomial.richardson.richardson_fold","initial-p","next-p-fn","p__88458","p__88459","vec__88460","vec__88463","x","_","row","cljs.core/peek","cljs.core/last","sicmutils.polynomial.interpolate/tableau-fold-fn","prepare","combine","present","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.polynomial.richardson/richardson-sum","seq88469","G__88470","self__4851__auto__","opts","sicmutils.algebra.fold.fold__GT_sum_fn","cljs.core.apply","sicmutils.polynomial.richardson/richardson-scan","seq88472","G__88473","sicmutils.algebra.fold.fold__GT_scan_fn"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.polynomial.richardson\n  \"Richardson interpolation is a special case of polynomial interpolation; knowing\n  the ratios of successive `x` coordinates in the point sequence allows a more\n  efficient calculation.\"\n  (:require [sicmutils.algebra.fold :as af]\n            [sicmutils.generic :as g]\n            [sicmutils.polynomial.interpolate :as pi]\n            [sicmutils.util.stream :as us]\n            [sicmutils.value :as v]))\n\n;; ## Richardson Interpolation\n;;\n;; This approach (and much of this numerical library!) was inspired by Gerald\n;; Sussman's [\"Abstraction in Numerical\n;; Methods\"](https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence=2)\n;; paper.\n;;\n;; That paper builds up to Richardson interpolation as a method of [\"series\n;; acceleration\"](https://en.wikipedia.org/wiki/Series_acceleration). The\n;; initial example concerns a series of the side lengths of an N-sided polygon\n;; inscribed in a unit circle.\n;;\n;; The paper derives this relationship between the sidelength of an N- and\n;; 2N-sided polygon:\n\n(defn- refine-by-doubling\n  \"`s` is the side length of an N-sided polygon inscribed in the unit circle. The\n  return value is the side length of a 2N-sided polygon.\"\n  [s]\n  (/ s (g/sqrt (+ 2 (g/sqrt (- 4 (g/square s)))))))\n\n;; If we can increase the number of sides => infinity, we should reach a circle.\n;; The \"semi-perimeter\" of an N-sided polygon is\n;;\n;; $$P_n = {n \\over 2} S_n$$\n;;\n;; In code:\n\n(defn- semi-perimeter\n  \"Returns the semi-perimeter length of an `n`-sided regular polygon with side\n  length `side-len`.\"\n  [n side-len]\n  (* (/ n 2) side-len))\n\n;; so as $n \\to \\infty$, $P_n$ should approach $\\pi$, the half-perimeter of a\n;; circle.\n;;\n;; Let's start with a square, ie, $n = 4$ and $s_4 = \\sqrt{2}$. Clojure's\n;; `iterate` function will let us create an infinite sequence of side lengths:\n\n(def ^:private side-lengths\n  (iterate refine-by-doubling (Math/sqrt 2)))\n\n;; and an infinite sequence of the number of sides:\n\n(def ^:private side-numbers\n  (iterate #(* 2 %) 4))\n\n;; Mapping a function across two sequences at once generates a new infinite\n;; sequence, of semi-perimeter lengths in this case:\n\n(def ^:no-doc archimedean-pi-sequence\n  (map semi-perimeter side-numbers side-lengths))\n\n;; I don't have a nice way of embedding the sequence in a notebook, but the\n;; following code will print the first 20 terms:\n\n(comment\n  (us/pprint 20 archimedean-pi-sequence))\n\n;; Unfortunately (for Archimedes, by hand!), as the paper notes, it takes 26\n;; iterations to converge to machine precision:\n\n(comment\n  (= (-> archimedean-pi-sequence\n         (us/seq-limit {:tolerance v/machine-epsilon}))\n\n     {:converged? true\n      :terms-checked 26\n      :result 3.1415926535897944}))\n\n;; Enter Sussman: \"Imagine poor Archimedes doing the arithmetic by hand: square\n;; roots without even the benefit of our place value system! He would be\n;; interested in knowing that full precision can be reached on the fifth term,\n;; by forming linear combinations of the early terms that allow the limit to be\n;; seized by extrapolation.\" (p4, Abstraction in Numerical Methods).\n;;\n;; Sussman does this by noting that you can also write the side length as:\n;;\n;; $$S_n = 2 \\sin {\\pi \\over n}$$\n;;\n;; Then the taylor series expansion for $P_n$ becomes:\n;;\n;; $$\n;;  P_n = {n \\over 2} S_n \\\n;;      = {n \\over 2} 2 \\sin {\\pi \\over n} \\\n;;      = \\pi + {A \\over n^2} + {B \\over n^2} ...\n;; $$\n;;\n;; A couple things to note:\n;;\n;; - At large N, the $A \\over n^2$ term dominates the truncation error.\n;; - when we double $n$ by taking $P_n$, that term becomes $A \\over {4 n^2}$, 4x\n;;   smaller.\n;;\n;; The big idea is to multiply $P_{2n}$ by 4 and subtract $P_n$ (then divide by\n;; 3 to cancel out the extra factor). This will erase the $A \\over n^2$ term and\n;; leave a /new/ sequence with $B \\over n^4$ as the dominant error term.\n;;\n;; Now keep going and watch the error terms drain away.\n;;\n;; Before we write code, let's follow the paper's example and imagine instead\n;; some general sequence of $R(h), R(h/t), R(h/t^2)...$ (where $t = 2$ in the\n;; example above), with a power series expansion that looks like\n;;\n;; $$R(h) = A + B h^{p_1} + C h^{p_2}...$$\n;;\n;; where the exponents $p_1, p_2, ...$ are some OTHER series of error\n;; growth. (In the example above, because the taylor series expanson of $n \\sin\n;; n$ only has even factors, the sequence was the even numbers.)\n;;\n;; In that case, the general way to cancel error between successive terms is:\n;;\n;; $${t^{p_1} R(h/t) - R(h)} = (t^{p_1} - 1) A + C_1 h^{p_2} + ...$$\n;;\n;; or:\n;;\n;; $${t^{p_1} R(h/t) - R(h)} \\over {t^{p_1} - 1} = A + C_2 h^{p_2} + ...$$\n;;\n;; Let's write this in code:\n\n(defn- accelerate-sequence\n  \"Generates a new sequence by combining each term in the input sequence `xs`\n  pairwise according to the rules for richardson acceleration.\n\n  `xs` is a sequence of evaluations of some function of $A$ with its argument\n  smaller by a factor of `t` each time:\n\n  $$A(h), A(h/t), \\\\ldots$$\n\n  `p` is the order of the dominant error term for the sequence.\"\n  [xs t p]\n  (let [t**p   (Math/pow t p)\n        t**p-1 (dec t**p)]\n    (map (fn [ah ah-over-t]\n           (/ (- (* t**p ah-over-t) ah)\n              t**p-1))\n         xs\n         (rest xs))))\n\n;; If we start with the original sequence, we can implement Richardson\n;; extrapolation by using Clojure's `iterate` with the `accelerate-sequence`\n;; function to generate successive columns in the \"Richardson Tableau\". (This is\n;; starting to sound familiar to the scheme for polynomial interpolation, isn't\n;; it?)\n;;\n;; To keep things general, let's take a general sequence `ps`, defaulting to the\n;; sequence of natural numbers.\n\n(defn- make-tableau\n  \"Generates the 'tableau' of succesively accelerated Richardson interpolation\n  columns.\"\n  ([xs t] (make-tableau xs t (iterate inc 1)))\n  ([xs t ps]\n   (->> (iterate (fn [[xs [p & ps]]]\n                   [(accelerate-sequence xs t p) ps])\n                 [xs ps])\n        (map first)\n        (take-while seq))))\n\n;; All we really care about are the FIRST terms of each sequence. These\n;; approximate the sequence's final value with small and smaller error (see the\n;; paper for details).\n;;\n;; Polynomial interpolation in `polynomial.cljc` has a similar tableau\n;; structure (not by coincidence!), so we can use `pi/first-terms` in the\n;; implementation below to fetch this first row.\n;;\n;; Now we can put it all together into a sequence transforming function, with\n;; nice docs:\n\n(defn richardson-sequence\n  \"Takes:\n\n  - `xs`: a (potentially lazy) sequence of points representing function values\n  generated by inputs continually decreasing by a factor of `t`. For example:\n  `[f(x), f(x/t), f(x/t^2), ...]`\n  - `t`: the ratio between successive inputs that generated `xs`.\n\n  And returns a new (lazy) sequence of 'accelerated' using [Richardson\n  extrapolation](https://en.wikipedia.org/wiki/Richardson_extrapolation) to\n  cancel out error terms in the taylor series expansion of `f(x)` around the\n  value the series to which the series is trying to converge.\n\n  Each term in the returned sequence cancels one of the error terms through a\n  linear combination of neighboring terms in the sequence.\n\n  ### Custom P Sequence\n\n  The three-arity version takes one more argument:\n\n  - `p-sequence`: the orders of the error terms in the taylor series expansion\n  of the function that `xs` is estimating. For example, if `xs` is generated\n  from some `f(x)` trying to approximate `A`, then `[p_1, p_2...]` etc are the\n  correction terms:\n\n  ```\n  $$f(x) = A + B x^{p_1} + C x^{p_2}...$$\n  ```\n\n  The two-arity version uses a default `p-sequence` of `[1, 2, 3, ...]`\n\n  ### Arithmetic Progression\n\n  The FOUR arity version takes `xs` and `t` as before, but instead of\n  `p-sequence` makes the assumption that `p-sequence` is an arithmetic\n  progression of the form `p + iq`, customized by:\n\n  - `p`: the exponent on the highest-order error term\n  - `q`: the step size on the error term exponent for each new seq element\n\n  ## Notes\n\n  Richardson extrapolation is a special case of polynomial extrapolation,\n  implemented in `polynomial.cljc`.\n\n  Instead of a sequence of `xs`, if you generate an explicit series of points of\n  the form `[x (f x)]` with successively smaller `x` values and\n  polynomial-extrapolate it forward to x == 0 (with,\n  say, `(polynomial/modified-neville xs 0)`) you'll get the exact same result.\n\n  Richardson extrapolation is more efficient since it can make assumptions about\n  the spacing between points and pre-calculate a few quantities. See the\n  namespace for more discussion.\n\n  References:\n\n  - Wikipedia, [\\\"Richardson Extrapolation\\\"](https://en.wikipedia.org/wiki/Richardson_extrapolation)\n  - GJS, ['Abstraction in Numerical Methods'](https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence=2)\"\n  ([xs t]\n   (pi/first-terms\n    (make-tableau xs t)))\n  ([xs t p-sequence]\n   (pi/first-terms\n    (make-tableau xs t p-sequence)))\n  ([xs t p q]\n   (let [arithmetic-p-q (iterate #(+ q %) p)]\n     (richardson-sequence xs t arithmetic-p-q))))\n\n;; We can now call this function, combined with `us/seq-limit` (a\n;; general-purpose tool that takes elements from a sequence until they\n;; converge), to see how much acceleration we can get:\n\n(comment\n  (= (-> (richardson-sequence archimedean-pi-sequence 2 2 2)\n         (us/seq-limit {:tolerance v/machine-epsilon}))\n\n     {:converged? true\n      :terms-checked 7\n      :result 3.1415926535897936}))\n\n;; Much faster!\n;;\n;; ## Richardson Columns\n;;\n;; Richardson extrapolation works by cancelling terms in the error terms of a\n;; function's taylor expansion about `0`. To cancel the nth error term, the nth\n;; derivative has to be defined. Non-smooth functions aren't going to play well\n;; with `richardson-sequence` above.\n;;\n;; The solution is to look at specific /columns/ of the Richardson tableau. Each\n;; column is a sequence with one further error term cancelled.\n;;\n;; `rational.cljc` and `polynomial.cljc` both have this feature in their\n;; tableau-based interpolation functions. The feature here requires a different\n;; function, because the argument vector is a bit crowded already in\n;; `richardson-sequence` above.\n\n(defn richardson-column\n  \"Function with an identical interface to [[richardson-sequence]], except for an\n  additional second argument `col`.\n\n  `richardson-column` will return that _column_ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  Richardson accelerations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the Richardson tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a single acceleration by combining points\n  from column 0; `2` kills two terms from the error sequence, etc.\n\n  NOTE Given a better interface for [[richardson-sequence]] this function could\n  be merged with that function.\"\n  ([xs col t]\n   (nth (make-tableau xs t) col))\n  ([xs col t p-seq]\n   (nth (make-tableau xs t p-seq) col))\n  ([xs col t p q]\n   (let [arithmetic-p-q (iterate #(+ q %) p)]\n     (richardson-column xs col t arithmetic-p-q))))\n\n\n;; ## Richardson Extrapolation and Polynomial Extrapolation\n;;\n;; It turns out that the Richardson extrapolation is a special case of\n;; polynomial extrapolation using Neville's algorithm (as described in\n;; `polynomial/neville`), evaluated at x == 0.\n;;\n;; Neville's algorithm looks like this:\n;;\n;; $$P(x) = [(x - x_r) P_l(x) - (x - x_l) P_r(x)] / [x_l - x_r]$$\n;;\n;; Where:\n\n;; - $P(x)$ is a polynomial estimate from some sequence of points $(a, b, c,\n;;  ...)$ where a point $a$ has the form $(x_a, f(x_a))$\n;; - $x_l$ is the coordinate of the LEFTmost point, $x_a$\n;; - $x_r$ is the rightmost point, say, $x_c$ in this example\n;; - $x$ is the coordinate where we want to evaluate $P(x)$\n;; - $P_l(x)$ is the estimate with all points but the first, ie, $P_{bc}(x)$\n;; - $P_l(x)$ is the estimate with all points but the LAST, ie, $P_{ab}(x)$\n;;\n;; Fill in $x = 0$ and rearrange:\n;;\n;; $$P(0) = [(x_l P_r(0)) - (x_r P_l(x))] \\over [x_l - x_r]$$\n;;\n;; In the Richardson extrapolation scheme, one of our parameters was `t`, the\n;; ratio between successive elements in the sequence. Now multiply through by $1\n;; = {1 \\over x_r} \\over {1 \\over x_r}$ so that our formula contains ratios:\n;;\n;; $$P(0) = [({x_l \\over x_r} P_r(0)) - P_l(x)] \\over [{x_l \\over x_r} - 1]$$\n;;\n;; Because the sequence of $x_i$ elements looks like $x, x/t, x/t^2$, every\n;; recursive step separates $x_l$ and $x_r$ by another factor of $t$. So\n;;\n;; $${x_l \\over x_r} = {x \\over {x \\over t^n}} = t^n$$\n;;\n;; Where $n$ is the difference between the positions of $x_l$ and $x_r$. So the\n;; formula simplifies further to:\n;;\n;; $$P(0) = [({t^n} P_r(0)) - P_l(x)] \\over [{t^n} - 1]$$\n;;\n;; Now it looks exactly like Richardson extrapolation. The only difference is\n;; that Richardson extrapolation leaves `n` general (and calls it $p_1, p_2$\n;; etc), so that you can customize the jumps in the error series. (I'm sure\n;; there is some detail I'm missing here, so please feel free to make a PR and\n;; jump in!)\n;;\n;; For the example above, we used a geometric series with $p, q = 2$ to fit the\n;; archimedean $\\pi$ sequence. Another way to think about this is that we're\n;; fitting a polynomial to the SQUARE of `h` (the side length), not to the\n;; actual side length.\n;;\n;; Let's confirm that polynomial extrapolation to 0 gives the same result, if we\n;; generate squared $x$ values:\n\n(comment\n  (let [h**2 (fn [i]\n               ;; (1/t^{i + 1})^2\n               (-> (/ 1 (Math/pow 2 (inc i)))\n                   (Math/pow 2)))\n        xs (map-indexed (fn [i fx] [(h**2 i) fx])\n                        archimedean-pi-sequence)]\n    (= (us/seq-limit\n        (richardson-sequence archimedean-pi-sequence 4 1 1))\n\n       (us/seq-limit\n        (pi/modified-neville xs 0.0)))))\n\n;; Success!\n;;\n;; ## Richardson Extrapolation as a Fold\n;;\n;; Because Richardson extrapolation is a simplified case of polynomial\n;; interpolation, it should be possible to write the process as a functional\n;; fold, just as with [[sicmutils.polynomial.interpolate/neville-fold]] and\n;; friends.\n;;\n;; The fold version works by building the tableau from the bottom up, one row at\n;; a time instead of one column at a time. Because point 0 is seen first, this\n;; has the effect of flipping the order of all input points:\n;;\n;; p4 p43 p432 p4321 p43210\n;; p3 p32 p321 p3210 .\n;; p2 p21 p210 .     .\n;; p1 p10 .    .     .\n;; p0 .   .    .     .\n;;\n;; Each new entry is generated by merging the entry to the left, and down the\n;; left diagonal.\n;;\n;; Polynomial interpolation didn't care about this reversal of point order,\n;; because each point was an $(x,y)$ pair. The merge function of the fold is\n;; symmetric.\n;;\n;; Richardson extrapolation does care, however, because the input points are the\n;; results of evaluating some function at progressively smaller values of $x$:\n;;\n;; $$A(h), A(h/t), A(h/t^2) \\ldots$$\n;;\n\n;; The merge function inside of [[accelerate-sequence]] assumed that its first\n;; argument was $A(h)$ and its second argument was $A(h/t)$.\n;;\n;; Flipping the order of the points requires us to /also/ flip the argument\n;; order to this merge function.\n;;\n;; The other bit of trickiness has to do with the sequence of exponents on the\n;; error terms. Generating the tableau column by column allowed the whole column\n;; to share a `p` value. Generating a row at a time requires us to generate\n;; successively longer prefixes of the `p` sequence for each row.\n;;\n;; We'll do this by preparing each point to the initial value of `p`, and then\n;; take a function to produce the next element. (We could also write this to\n;; take prefixes off of an infinite sequence of `p`s! If you need this, please\n;; file a ticket and we'll make it happen.)\n;;\n;; The merge function, as noted, is the same as the merge function inside\n;; of [[accelerate-sequence]] with one change: it's now responsible for\n;; generating the next element of the `p` sequence.\n;;\n;; To \"present\" a full row, simply take the final element and remove the\n;; stashed \"p\". Since \"merge\" is reversed, the diagonal elements of the inverted\n;; tableau match the first row of the original tableau.\n\n(defn richardson-fold\n  \"Returns a fold expected to process the outputs of some function `A` for inputs\n  of the form:\n\n  $$A(h), A(h/t), A(h/t^2) \\\\ldots$$\n\n  and generate (when present is called) successively tighter estimates of A(0)\n  using the algorithm described in [[richardson-sequence]].\n\n  Takes as a required argument:\n\n  - `t`: the ratio between the successive inputs that generated the\n    data to be processed by this fold (see above)\n\n\n  If `initial-p` and `next-p-fn` are not supplied, it's assumed that the order\n  of the error terms in the taylor series expansion of `A` start at 1 and\n  increase by 1 with each new term.\n\n  You can tune this by supplying:\n\n  - `initial-p`: The order of the first error term\n  - `next-p-fn`: a function that will generate the next term given the previous\n    term\n\n  For the geometrically increasing error series `[2, 4, 6, 8]`, for example,\n  try\n\n  ```clj\n  (richardson-fold <t> 2 #(+ % 2))\n  ```\"\n  ([t] (richardson-fold t 1 inc))\n  ([t initial-p next-p-fn]\n   (letfn [(prepare [x] [initial-p x])\n           (combine [[p ah-over-t] [_ ah]]\n             (let [t**p   (Math/pow t p)\n                   t**p-1 (dec t**p)]\n               [(next-p-fn p)\n                (/ (- (* t**p ah-over-t) ah)\n                   t**p-1)]))\n           (present [row]\n             (peek (last row)))]\n     (pi/tableau-fold-fn prepare combine present))))\n\n(defn richardson-sum\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns the best approximation of `A(0)` using the algorithm described\n  in [[richardson-sequence]].\n\n  Equivalent to `(last ([[richardson-sequence]] t))`\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].\"\n  [t & opts]\n  (af/fold->sum-fn\n   (apply richardson-fold t opts)))\n\n(defn richardson-scan\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `A(h), A(h/t), A(h/t^2),...` (where `t` is the `t` argument supplied here) and\n  returns a lazy sequence of successive approximations `A(0)` using the\n  algorithm described in [[richardson-sequence]].\n\n  Equivalent to `([[richardson-sequence]] t)`.\n\n  See [[richardson-fold]] for all supported arities; all arguments are passed\n  through to [[richardson-fold]].\"\n  [t & opts]\n  (af/fold->scan-fn\n   (apply richardson-fold t opts)))\n"]}