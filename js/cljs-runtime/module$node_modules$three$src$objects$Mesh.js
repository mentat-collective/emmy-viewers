shadow$provide.module$node_modules$three$src$objects$Mesh=function(global,require,module,exports){function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA.fromBufferAttribute(position,a);_vB.fromBufferAttribute(position,b);_vC.fromBufferAttribute(position,c);position=object.morphTargetInfluences;if(morphPosition&&position){_morphA.set(0,0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){var influence=
position[i];const morphAttribute=morphPosition[i];0!==influence&&(_tempA.fromBufferAttribute(morphAttribute,a),_tempB.fromBufferAttribute(morphAttribute,b),_tempC.fromBufferAttribute(morphAttribute,c),morphTargetsRelative?(_morphA.addScaledVector(_tempA,influence),_morphB.addScaledVector(_tempB,influence),_morphC.addScaledVector(_tempC,influence)):(_morphA.addScaledVector(_tempA.sub(_vA),influence),_morphB.addScaledVector(_tempB.sub(_vB),influence),_morphC.addScaledVector(_tempC.sub(_vC),influence)))}_vA.add(_morphA);
_vB.add(_morphB);_vC.add(_morphC)}object.isSkinnedMesh&&(object.boneTransform(a,_vA),object.boneTransform(b,_vB),object.boneTransform(c,_vC));morphPosition=_vA;morphTargetsRelative=_vB;position=_vC;influence=_intersectionPoint;null===(material.side===_constants.BackSide?ray.intersectTriangle(position,morphTargetsRelative,morphPosition,!0,influence):ray.intersectTriangle(morphPosition,morphTargetsRelative,position,material.side!==_constants.DoubleSide,influence))?object=null:(_intersectionPointWorld.copy(influence),
_intersectionPointWorld.applyMatrix4(object.matrixWorld),material=raycaster.ray.origin.distanceTo(_intersectionPointWorld),object=material<raycaster.near||material>raycaster.far?null:{distance:material,point:_intersectionPointWorld.clone(),object});object&&(uv&&(_uvA.fromBufferAttribute(uv,a),_uvB.fromBufferAttribute(uv,b),_uvC.fromBufferAttribute(uv,c),object.uv=_Triangle.Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new _Vector2.Vector2)),uv2&&(_uvA.fromBufferAttribute(uv2,a),_uvB.fromBufferAttribute(uv2,
b),_uvC.fromBufferAttribute(uv2,c),object.uv2=_Triangle.Triangle.getUV(_intersectionPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new _Vector2.Vector2)),uv={a,b,c,normal:new _Vector.Vector3,materialIndex:0},_Triangle.Triangle.getNormal(_vA,_vB,_vC,uv.normal),object.face=uv);return object}Object.defineProperty(exports,"__esModule",{value:!0});exports.Mesh=void 0;var _Vector=require("module$node_modules$three$src$math$Vector3"),_Vector2=require("module$node_modules$three$src$math$Vector2");global=require("module$node_modules$three$src$math$Sphere");
module=require("module$node_modules$three$src$math$Ray");var _Matrix=require("module$node_modules$three$src$math$Matrix4"),_Object3D=require("module$node_modules$three$src$core$Object3D"),_Triangle=require("module$node_modules$three$src$math$Triangle"),_constants=require("module$node_modules$three$src$constants"),_MeshBasicMaterial=require("module$node_modules$three$src$materials$MeshBasicMaterial"),_BufferGeometry=require("module$node_modules$three$src$core$BufferGeometry");const _inverseMatrix=
new _Matrix.Matrix4,_ray=new module.Ray,_sphere=new global.Sphere,_vA=new _Vector.Vector3,_vB=new _Vector.Vector3,_vC=new _Vector.Vector3,_tempA=new _Vector.Vector3,_tempB=new _Vector.Vector3,_tempC=new _Vector.Vector3,_morphA=new _Vector.Vector3,_morphB=new _Vector.Vector3,_morphC=new _Vector.Vector3,_uvA=new _Vector2.Vector2,_uvB=new _Vector2.Vector2,_uvC=new _Vector2.Vector2,_intersectionPoint=new _Vector.Vector3,_intersectionPointWorld=new _Vector.Vector3;class Mesh extends _Object3D.Object3D{constructor(geometry=
new _BufferGeometry.BufferGeometry,material=new _MeshBasicMaterial.MeshBasicMaterial){super();this.type="Mesh";this.geometry=geometry;this.material=material;this.updateMorphTargets()}copy(source){super.copy(source);void 0!==source.morphTargetInfluences&&(this.morphTargetInfluences=source.morphTargetInfluences.slice());void 0!==source.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary));this.material=source.material;this.geometry=source.geometry;return this}updateMorphTargets(){var geometry=
this.geometry;if(geometry.isBufferGeometry){geometry=geometry.morphAttributes;var keys=Object.keys(geometry);if(0<keys.length&&(geometry=geometry[keys[0]],void 0!==geometry)){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=geometry.length;m<ml;m++)keys=geometry[m].name||String(m),this.morphTargetInfluences.push(0),this.morphTargetDictionary[keys]=m}}else geometry=geometry.morphTargets,void 0!==geometry&&0<geometry.length&&console.error("THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}raycast(raycaster,
intersects){var geometry=this.geometry;const material=this.material;var matrixWorld=this.matrixWorld;if(void 0!==material&&(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere.copy(geometry.boundingSphere),_sphere.applyMatrix4(matrixWorld),!1!==raycaster.ray.intersectsSphere(_sphere)&&(_inverseMatrix.copy(matrixWorld).invert(),_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix),null===geometry.boundingBox||!1!==_ray.intersectsBox(geometry.boundingBox))))if(geometry.isBufferGeometry){var index=
geometry.index;matrixWorld=geometry.attributes.position;const morphPosition=geometry.morphAttributes.position,morphTargetsRelative=geometry.morphTargetsRelative,uv=geometry.attributes.uv,uv2=geometry.attributes.uv2;var groups=geometry.groups;geometry=geometry.drawRange;if(null!==index)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){var group=groups[i],groupMaterial=material[group.materialIndex];var intersection=Math.max(group.start,geometry.start);var end=Math.min(index.count,Math.min(group.start+
group.count,geometry.start+geometry.count));for(let j=intersection,jl=end;j<jl;j+=3){intersection=index.getX(j);end=index.getX(j+1);const c=index.getX(j+2);if(intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,intersection,end,c))intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=group.materialIndex,intersects.push(intersection)}}else{groups=Math.max(0,geometry.start);geometry=Math.min(index.count,
geometry.start+geometry.count);for(let i=groups,il=geometry;i<il;i+=3)if(geometry=index.getX(i),groups=index.getX(i+1),group=index.getX(i+2),intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,geometry,groups,group))intersection.faceIndex=Math.floor(i/3),intersects.push(intersection)}else if(void 0!==matrixWorld)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){index=groups[i];group=material[index.materialIndex];
groupMaterial=Math.max(index.start,geometry.start);intersection=Math.min(matrixWorld.count,Math.min(index.start+index.count,geometry.start+geometry.count));for(let j=groupMaterial,jl=intersection;j<jl;j+=3)if(intersection=checkBufferGeometryIntersection(this,group,raycaster,_ray,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,j,j+1,j+2))intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=index.materialIndex,intersects.push(intersection)}else{index=Math.max(0,geometry.start);
geometry=Math.min(matrixWorld.count,geometry.start+geometry.count);for(let i=index,il=geometry;i<il;i+=3)if(intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,i,i+1,i+2))intersection.faceIndex=Math.floor(i/3),intersects.push(intersection)}}else geometry.isGeometry&&console.error("THREE.Mesh.raycast() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.")}}exports.Mesh=Mesh;Mesh.prototype.isMesh=!0}
//# sourceMappingURL=module$node_modules$three$src$objects$Mesh.js.map
