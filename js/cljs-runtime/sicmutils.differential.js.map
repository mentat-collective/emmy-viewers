{"version":3,"sources":["sicmutils/differential.cljc"],"mappings":"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","names":["sicmutils$differential$IPerturbed$perturbed_QMARK_$dyn","x__4550__auto__","m__4551__auto__","sicmutils.differential/perturbed?","goog/typeOf","m__4549__auto__","cljs.core/missing-protocol","sicmutils$differential$IPerturbed$replace_tag$dyn","sicmutils.differential/replace-tag","sicmutils$differential$IPerturbed$extract_tangent$dyn","sicmutils.differential/extract-tangent","sicmutils.differential/IPerturbed","this","old-tag","new-tag","tag","_","sicmutils.value/zero-like","sicmutils.differential/tags","term","cljs.core.nth","sicmutils.differential/coefficient","var_args","G__96619","sicmutils.differential/make-term","js/Error","coef","sicmutils.util.vector-set/empty-set","tags","next-tag","cljs.core.atom","sicmutils.differential/fresh-tag","cljs.core.swap_BANG_","cljs.core/inc","sicmutils.differential/tag-in-term?","t","sicmutils.util.vector-set/contains?","sicmutils.differential/terms:+","sicmutils.util.aggregate/merge-fn","cljs.core/compare","sicmutils.generic/add","sicmutils.value/zero?","sicmutils.differential/collect-terms","tags->coefs","terms","iter__4652__auto__","s__96623","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","cljs.core/count","b__96625","cljs.core/chunk-buffer","i__96624","vec__96627","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__96622","cljs.core/chunk-rest","vec__96630","cljs.core/first","cljs.core/cons","cljs.core/rest","tags-coefs","cljs.core/group-by","c","cljs.core.transduce","cljs.core.map","sicmutils.generic/+","cljs.core.into","cljs.core.sort_by","sicmutils.differential/terms:map-coefficients","f","xform","cljs.core.mapcat","c'","G__96635","sicmutils.differential.make_term","p__96637","vec__96638","sicmutils.differential/t*ts","coeff","acc","i","vec__96646","tags1","coeff1","cljs.core/empty?","sicmutils.util.vector-set/intersection","cljs.core.conj","sicmutils.util.vector-set/union","sicmutils.generic._STAR_","sicmutils.differential/terms:*","xlist","ylist","x","call","cljs.core.derive","cljs.core/PROTOCOL_SENTINEL","this__4491__auto__","writer__4492__auto__","opt__4493__auto__","cljs.core/-write","sicmutils.differential/Differential","sicmutils.differential/->Differential","sicmutils.value/numerical?","oldtag","newtag","tagv","sicmutils.util.vector-set/disj","sicmutils.util.vector-set/conj","G__96657","sicmutils.differential/from-terms","process","G__96658","cljs.core/every?","cljs.core.comp","sicmutils.differential/one?","cljs.core/vec","cljs.core.sequence","cljs.core.concat","cljs.core/List","sicmutils.value/freeze","cljs.core.mapv","freeze-term","sicmutils.differential/finite-term","term-strs","cljs.core.pr_str","clojure.string.join","a","b","sicmutils.differential/equiv","sicmutils.differential/compare","writer","cljs.core.write_all","sicmutils.differential/differential?","dx","sicmutils.differential/bare-terms","sicmutils.differential/->terms","cljs.core/vector?","sicmutils.differential/terms->differential","cljs.core._EQ_","sicmutils.differential/map-coefficients","d","sicmutils.differential/*active-tags*","sicmutils.differential/with-active-tag","args","*active-tags*-orig-val__96668","*active-tags*-temp-val__96669","cljs.core.apply","sicmutils.differential/tag-active?","cljs.core/boolean","cljs.core/some","cljs.core/rseq","G__96674","sicmutils.differential/d:+","args-arr__4885__auto__","len__4864__auto__","i__4865__auto__","argseq__4886__auto__","cljs.core/IndexedSeq","seq96671","G__96672","cljs.core/next","G__96673","self__4851__auto__","dy","more","G__96684","sicmutils.differential/d:*","sicmutils.differential/d:+*","G__96688","sicmutils.differential/bundle-element","primal","sicmutils.differential.bundle_element","tangent","sicmutils.util.vector-set/make","G__96694","sicmutils.differential/max-order-tag","seq96692","G__96693","last-term","cljs.core/peek","highest-tag","dxs","temp__5751__auto__","max-order","sicmutils.differential.max_order_tag","orders","max-termv","cljs.core/max","G__96699","sicmutils.differential/primal-part","sicmutils.differential.primal_part","p1__96697#","sans-tag?","cljs.core/filterv","G__96702","sicmutils.differential/tangent-part","sicmutils.differential.tangent_part","p1__96700#","G__96705","sicmutils.differential/primal-tangent-pair","sicmutils.differential.primal_tangent_pair","vec__96706","tangent-terms","primal-terms","p1__96703#","sicmutils.util.stream/separatev","vec__96709","head","ts","vec__96712","p","sicmutils.value/one?","G__96719","sicmutils.differential/eq","seq96716","G__96717","G__96718","sicmutils.value/=","sicmutils.differential.eq","sicmutils.differential/compare-full","sicmutils.value/compare","G__96725","seq96722","G__96723","G__96724","sicmutils.differential.equiv","G__96729","sicmutils.differential/lift-1","df:dx","sicmutils.differential.lift_1","sicmutils.util/illegal","vec__96732","px","tx","fx","sicmutils.value/numeric-zero?","G__96737","sicmutils.differential/lift-2","df:dy","and__4251__auto__","sicmutils.differential.lift_2","y","vec__96738","vec__96741","xe","ye","sicmutils.differential/lift-n","df:dx1","df:dx2","f1","f2","cljs.core.reduce","sicmutils$differential$lift_n_$_call","sicmutils.generic/simplify","sicmutils.differential/defunary","generic-op","differential-op","sicmutils.differential/defbinary","seq__96745","chunk__96746","count__96747","i__96748","c__4679__auto__","cljs.core/chunk-first","signature","sicmutils.generic/negate","sicmutils.generic/sub","mul","sicmutils.generic/mul","sicmutils.generic/dot-product","sicmutils.generic/expt","sicmutils.generic/square","sicmutils.generic/cube","sicmutils.generic/invert","sicmutils.generic/div","sicmutils.generic/negative?","sicmutils.generic/infinite?","sicmutils.generic/abs","func","cljs.core/identity","sicmutils.differential/discont-at-integers","dfdx","f-name","sicmutils.value/integral?","sicmutils.generic/floor","sicmutils.generic/ceiling","sicmutils.generic/integer-part","sicmutils.generic/fractional-part","div","sicmutils.generic/solve-linear","l","r","sicmutils.generic/solve-linear-right","sicmutils.generic/sqrt","sicmutils.generic/log","sicmutils.generic/exp","sicmutils.generic/cos","sicmutils.generic/sin","sicmutils.generic/tan","sicmutils.generic/cot","sicmutils.generic/sec","sicmutils.generic/csc","sicmutils.generic/atan","sicmutils.generic/asin","sicmutils.generic/acos","sicmutils.generic/acot","sicmutils.generic/asec","sicmutils.generic/acsc","sicmutils.generic/cosh","sicmutils.generic/sinh","sicmutils.generic/tanh","sicmutils.generic/sech","sicmutils.generic/coth","sicmutils.generic/csch","sicmutils.generic/acosh","sicmutils.generic/asinh","sicmutils.generic/atanh","sicmutils.generic/acoth","sicmutils.generic/asech","sicmutils.generic/acsch","sicmutils.generic/sinc","sicmutils.generic/sinhc","sicmutils.generic/tanc","sicmutils.generic/tanhc"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n^{:nextjournal.clerk/visibility #{:hide-ns}}\n(ns sicmutils.differential\n  \"This namespace contains an implementation of [[Differential]], a generalized\n  dual number type that forms the basis for the forward-mode automatic\n  differentiation implementation in sicmutils.\n\n  See [[sicmutils.calculus.derivative]] for a fleshed-out derivative\n  implementation using [[Differential]].\"\n  (:refer-clojure :exclude [compare])\n  (:require [clojure.core :as core]\n            [clojure.string :refer [join]]\n            [sicmutils.generic :as g]\n            [sicmutils.util :as u]\n            [sicmutils.util.aggregate :as ua]\n            [sicmutils.util.stream :as us]\n            [sicmutils.util.vector-set :as uv]\n            [sicmutils.value :as v]))\n\n;; ## Differentials, Dual Numbers and Automatic Differentiation\n;;\n;; This namespace develops an implementation of a type called [[Differential]].\n;; A [[Differential]] is a generalization of a type called a [\"dual\n;; number\"](https://en.wikipedia.org/wiki/Dual_number).\n;;\n;; As we'll discuss, passing these numbers as arguments to some function $f$\n;; built out of the [[sicmutils.generic]] operators allows us to build up the\n;; _derivative_ of $f$ in parallel to our evaluation of $f$. Complex programs\n;; are built out of simple pieces that we know how to evaluate; we can build up\n;; derivatives of entire programs in a similar way by building them out of the\n;; derivatives of the smaller pieces of those programs.\n;;\n;; ### Forward-Mode Automatic Differentiation\n;;\n;; For many scientific computing applications, it's valuable be able to generate\n;; a \"derivative\" of a function; given some tiny increment in the inputs, what\n;; tiny increment will the function produce in the output values?\n;;\n;; we know how to take derivatives of many of the generic functions exposed by\n;; SICMUtils, like [[+]], [[*]], [[g/sin]] and friends. It turns out that we can\n;; take the derivatives of large, complicated functions by combining the\n;; derivatives of these smaller functions using the [chain\n;; rule]((https://en.wikipedia.org/wiki/Automatic_differentiation#The_chain_rule,_forward_and_reverse_accumulation))\n;; as a clever bookkeeping device.\n;;\n;; The technique of evaluating a function and its derivative in parallel is\n;; called \"forward-mode [Automatic\n;; Differentiation](https://en.wikipedia.org/wiki/Automatic_differentiation)\".\n;; The [SICMUtils\n;; wiki](https://github.com/sicmutils/sicmutils/wiki/Automatic-Differentiation)\n;; has more information on the history of this technique, and links to the many\n;; other implementations you'll find in different languages. See the [cljdocs\n;; Automatic Differentiation\n;; page](https://cljdoc.org/d/sicmutils/sicmutils/CURRENT/doc/calculus/automatic-differentiation)\n;; for \"how do I use this?\"-style questions.\n;;\n;; NOTE: The other flavor of automatic differentiation (AD) is \"reverse-mode\n;; AD\". See [[sicmutils.tape]] for an implementation of this style, coming soon!\n;;\n;; ### Dual Numbers and AD\n;;\n;; Our goal is to build up derivatives of complex functions out of the\n;; derivatives of small pieces. A [dual\n;; number](https://en.wikipedia.org/wiki/Dual_number) is a relatively simple\n;; piece of machinery that will help us accomplish this goal.\n\n;; A [dual number](https://en.wikipedia.org/wiki/Dual_number) is a pair of\n;; numbers of the form\n;;\n;; $$a + b \\varepsilon$$\n;;\n;; where $a$ and $b$ are real numbers, and $\\varepsilon$ is an abstract thing,\n;; with the property that $\\varepsilon^2 = 0$.\n\n;; NOTE: This might remind you of the definition of a complex number of the form\n;; $a + bi$, where $i$ is also a new thing with the property that $i^2 = -1$.\n;; You are very wise! The bigger idea lurking here is the [\"generalized complex\n;; number\"](https://people.rit.edu/harkin/research/articles/generalized_complex_numbers.pdf).\n;;\n;; Why are dual numbers useful (in SICMUtils)? If you pass $a+b\\varepsilon$ in\n;; to a function $f$, the result is a dual number $f(a) + Df(a) b \\varepsilon$;\n;; the result contains both the function evaluation and the derivative\n;; evaluation at $a$!\n\n;; To see why, look at what happens when you pass a dual number into the [Taylor\n;; series expansion](https://en.wikipedia.org/wiki/Taylor_series) of some\n;; arbitrary function $f$. As a reminder, the Taylor series expansion of $f$\n;; around some point $a$ is:\n;;\n;; $$f(x) = f(a)+\\frac{Df(a)}{1!}(x-a)+\\frac{D^2f(a)}{2!}(x-a)^{2}+\\frac{D^3f(a)}{3!}(x-a)^{3}+\\cdots$$\n;;\n;; NOTE: See this nice overview of [Taylor series\n;; expansion](https://medium.com/@andrew.chamberlain/an-easy-way-to-remember-the-taylor-series-expansion-a7c3f9101063)\n;; by Andrew Chamberlain if you want to understand this idea and why we can\n;; approximate (smooth) functions this way.\n;;\n;; If you evaluate the expansion of $f(x)$ around $a$ with a dual number\n;; argument whose first component is $a$ -- take $x=a+b\\varepsilon$, for example\n;; -- watch how the expansion simplifies:\n;;\n;; $$f(a+b\\varepsilon) = f(a)+\\frac{Df(a)}{1!}(b\\varepsilon)+\\frac{D^2f(a)}{2!}(b\\varepsilon)^2+\\cdots$$\n;;\n;; Since $\\varepsilon^2=0$ we can ignore all terms beyond the first two:\n;;\n;; $$f(a+b\\varepsilon) = f(a)+ (Df(a)b)\\varepsilon$$\n;;\n;; NOTE: See [[lift-1]] for an implementation of this idea.\n;;\n;; This justifies our claim above: applying a function to some dual number\n;; $a+\\varepsilon$ returns a new dual number, where\n;;\n;; - the first component is $f(a)$, the normal function evaluation\n;; - the second component is $Df(a)$, the derivative.\n;;\n;; If we do this twice, the second component of the returned dual number\n;; beautifully recreates the [Chain\n;; Rule](https://en.wikipedia.org/wiki/Chain_rule):\n;;\n;; $$\n;; \\begin{aligned}\n;; g(f(a+\\varepsilon)) &= g(f(a) + Df(a)\\varepsilon) \\\\\n;; &= g(f(a)) + (Dg(f(a)))(Df(a))\\varepsilon\n;; \\end{aligned}\n;; $$\n;;\n;; ### Terminology Change\n;;\n;; A \"dual number\" is a very general idea. Because we're interested in dual\n;; numbers as a bookkeeping device for derivatives, we're going to specialize\n;; our terminology. From now on, we'll rename $a$ and $b$ to $x$ and $x'$. Given\n;; a dual number of the form $x+x'\\varepsilon$: we'll refer to:\n;;\n;; - $x$ as the \"primal\" part of the dual number\n;; - $x'$ as the \"tangent\" part\n;; - $\\varepsilon$ as the \"tag\"\n;;\n;; NOTE: \"primal\" means $x$ is tracking the \"primal\", or \"primary\", part of the\n;; computation. \"tangent\" is a synonym for \"derivative\". \"tag\" is going to make\n;; more sense shortly, when we start talking about mixing together multiple\n;; $\\varepsilon_1$, $\\varepsilon_2$ from different computations.\n;;\n;; ### Binary Functions\n;;\n;; What about functions of more than one variable? We can use the same approach\n;; by leaning on the [multivariable Taylor series\n;; expansion](https://en.wikipedia.org/wiki/Taylor_series#Taylor_series_in_several_variables).\n;; Take $f(x, y)$ as a binary example. If we pass dual numbers in to the taylor\n;; series expansion of $f$, the $\\varepsilon$ multiplication rule will erase all\n;; higher-order terms, leaving us with:\n;;\n;; $$f(x+x'\\varepsilon, y+y'\\varepsilon) = f(x,y) + \\left[\\partial_1 f(x,y)x' + \\partial_2 f(x,y)y'\\right]\\varepsilon$$\n;;\n;; NOTE: See [[lift-2]] for an implementation of this idea.\n;;\n;; This expansion generalizes for n-ary functions; every new argument $x_n +\n;; x'_n\\varepsilon$ contributes $\\partial_n f(...)x'_n$ to the result.\n;;\n;; We can check this with the simple cases of addition, subtraction and\n;; multiplication.\n;;\n;; The real parts of a dual number add commutatively, so we can rearrange the\n;; components of a sum to get a new dual number:\n;;\n;; $$(x+x'\\varepsilon)+(y+y'\\varepsilon) == (x+y)+(x'+y')\\varepsilon$$\n;;\n;; This matches the [sum\n;; rule](https://en.wikipedia.org/wiki/Differentiation_rules#Differentiation_is_linear)\n;; of differentiation, since the partials of $x + y$ with respect to either $x$\n;; or $y$ both equal 1.\n;;\n;; Subtraction is almost identical and agrees with the [subtraction\n;; rule](https://en.wikipedia.org/wiki/Differentiation_rules#Differentiation_is_linear):\n;;\n;; $$(x+x'\\varepsilon)-(y+y'\\varepsilon) == (x-y)+(x'-y')\\varepsilon$$\n;;\n;; Multiplying out the components of two dual numbers again gives us a new dual\n;; number, whose tangent component agrees with the [product\n;; rule](https://en.wikipedia.org/wiki/Product_rule):\n;;\n;; $$\n;; \\begin{aligned}\n;; (x+ x'\\varepsilon)*(y+y'\\epsilon) &= xy+(xy')\\varepsilon+(x'y)\\varepsilon+(x'y')\\epsilon^2 \\\\\n;; &= xy+(xy'+x'y)\\varepsilon\n;; \\end{aligned}\n;; $$\n;;\n;; Stare at these smaller derivations and convince yourself that they agree with\n;; the Taylor series expansion method for binary functions.\n;;\n;; The upshot is that, armed with these techniques, we can implement a\n;; higher-order `derivative` function (almost!) as simply as this:\n\n(comment\n  (defn derivative [f]\n    (fn [x]\n      (extract-tangent\n       (f (make-dual x 1))))))\n\n;; As long as `f` is built out of functions that know how to apply themselves to\n;; dual numbers, this will all Just Work.\n;;\n;; ### Multiple Variables, Nesting\n;;\n;; All of the examples above are about first-order derivatives. Taking\n;; higher-order derivatives is, in theory, straightforward:\n\n(comment\n  (derivative\n   (derivative f)))\n\n;; But this guess hits one of many subtle problems with the implementation of\n;; forward-mode AD. The double-call to `derivative` will expand out to this:\n\n(comment\n  (fn [x]\n    (letfn [(inner-d [x]\n              (extract-tangent\n               (f (make-dual x 1))))]\n      (extract-tangent\n       (inner-d\n        (make-dual x 1))))))\n\n;; the `x` received by `inner-d` will ALREADY be a dual number $x+\\varepsilon$!\n;; This will cause two immediate problems:\n;;\n;; - `(make-dual x 1)` will return $(x+\\varepsilon)+\\varepsilon = x+2\\varepsilon$,\n;;    which is not what we we want\n\n;; - The `extract-tangent` call inside `inner-d` will return the `Df(x)`\n;;   component of the dual number... which, remember, is no longer a dual\n;;   number! So the SECOND call to `extract-tangent` have nothing to extract,\n;;   and can only sensibly return 0.\n;;\n;; The problem here is called \"perturbation confusion\", and is covered in great\n;; detail in\n;; [\"Confusion of Tagged Perturbations in Forward Automatic Differentiation of\n;; Higher-Order Functions\"](https://arxiv.org/abs/1211.4892), by Manzyuk et\n;; al. (2019).\n;;\n;; The solution is to introduce a new $\\varepsilon$ for every level, and allow\n;; different $\\varepsilon$ instances to multiply without annihilating. Each\n;; $\\varepsilon$ is called a \"tag\". [[Differential]] (implemented below) is a\n;; generalized dual number that can track many tags at once, allowing nested\n;; derivatives like the one described above to work.\n;;\n;; This implies that `extract-tangent` needs to take a tag, to determine _which_\n;; tangent to extract:\n\n(comment\n  (defn derivative [f]\n    (let [tag (fresh-tag)]\n      (fn [x]\n        (-> (f (make-dual x 1 tag))\n            (extract-tangent tag))))))\n\n;; This is close to the final form you'll find\n;; at [[sicmutils.calculus.derivative/derivative]].\n;;\n;; ### What Return Values are Allowed?\n;;\n;; Before we discuss the implementation of dual\n;; numbers (called [[Differential]]), [[lift-1]], [[lift-2]] and the rest of the\n;; machinery that makes this all possible; what sorts of objects is `f` allowed\n;; to return?\n;;\n;; The dual number approach is beautiful because we can bring to bear all sorts\n;; of operations in Clojure that never even _see_ dual numbers. For example,\n;; `square-and-cube` called with a dual number returns a PAIR of dual numbers:\n\n(comment\n  (defn square-and-cube [x]\n    (let [x2 (g/square x)\n          x3 (g/cube x)]\n      [x2 x3])))\n\n;; Vectors don't care what they contain! We want the derivative of\n;; `square-and-cube` to also return a vector, whose entries represent the\n;; derivative of _that entry_ with respect to the function's input.\n;;\n;; But this implies that [[extract-tangent]] from the example above needs to\n;; know how to handle vectors and other collections; in the case of a vector `v`\n;; by returning `(mapv extract-tangent v)`.\n;;\n;; What about higher-order functions?\n\n(comment\n  (defn offset-fn\n    \"Returns a function that takes a single-argument function `g`, and returns a new\n  function like `g` that offsets its input by `offset`.\"\n    [offset]\n    (fn [g]\n      (fn [x]\n        (g (+ x offset))))))\n\n;; `(derivative offset-fn)` here returns a function! Manzyuk et al. 2019 makes\n;; the reasonable claim that, if `(f x)` returns a function, then `(derivative\n;; f)` should treat `f` as a multi-argument function with its first argument\n;; curried.\n;;\n;; Let's say `f` takes a number `x` and returns a function `g` that maps number\n;; => number. `(((derivative f) x) y)` should act just like the partial\n;; derivative of the equivalent multi-argument function, with respect to the\n;; first argument:\n;;\n;;```clj\n;;(((partial 0) f-flattened) x y)\n;;```\n;;\n;; In other words, `(derivative offset-fn)` should act just like:\n\n(comment\n  (derivative\n   (fn [offset] (g (+ x offset)))))\n\n;; for some known `g` and `x`, but with the ability to store `(derivative\n;; offset-fn)` and call it later with many different `g`.\n;;\n;; NOTE: We might accomplish this by composing `extract-tangent` with the\n;; returned function, so that the extraction happens later, when the function's\n;; called... but that will fail. The real implementation is more subtle! See\n;; the [[sicmutils.calculus.derivative]] namespace for the actual implementation\n;; of [[IPerturbed]] for functions and multimethods.\n;;\n;; All of this suggests that we need to make [[extract-tangent]] an open\n;; function that other folks can extend for other container-like\n;; types ([functors](https://en.wikipedia.org/wiki/Functor), specifically).\n;;\n;; The [[IPerturbed]] protocol accomplishes this, along with two other functions\n;; that we'll use later:\n\n(defprotocol IPerturbed\n  (perturbed? [this]\n    \"Returns true if the supplied object has some known non-zero tangent to be\n    extracted via [[extract-tangent]], false otherwise. (Return `false` by\n    default if you can't detect a perturbation.)\")\n\n  (replace-tag [this old-tag new-tag]\n    \"If `this` is perturbed, Returns a similar object with the perturbation\n    modified by replacing any appearance of `old-tag` with `new-tag`. Else,\n    return `this`.\")\n\n  (extract-tangent [this tag]\n    \"If `this` is perturbed, return the tangent component paired with the\n    supplied tag. Else, returns `([[sicmutils.value/zero-like]] this)`.\"))\n\n;; `replace-tag` exists to handle subtle bugs that can arise in the case of\n;; functional return values. See the \"Amazing Bug\" sections\n;; in [[sicmutils.calculus.derivative-test]] for detailed examples on how this\n;; might bite you.\n;;\n;; The default implementations are straightforward, and match the docstrings:\n\n(extend-protocol IPerturbed\n  #?(:clj Object :cljs default)\n  (perturbed? [_] false)\n  (replace-tag [this _ _] this)\n  (extract-tangent [this _] (v/zero-like this)))\n\n;; ## Differential Implementation\n;;\n;; We now have a template for how to implement `derivative`. What's left? We\n;; need a dual number type that we can build and split back out into primal and\n;; tangent components, given some tag. We'll call this type a [[Differential]].\n;;\n;; A [[Differential]] is a generalized dual number with a single primal\n;; component, and potentially many tagged terms. Identical tags cancel to 0 when\n;; multiplied, but are allowed to multiply by each other:\n;;\n;; $$a + b\\varepsilon_1 + c\\varepsilon_2 + d\\varepsilon_1 \\varepsilon_2 + \\cdots$$\n;;\n;; Alternatively, you can view a [[Differential]] as a dual number with a\n;; specific tag, that's able to hold dual numbers with some _other_ tag in its\n;; primal and tangent slots. You can turn a [[Differential]] into a dual number\n;; by specifying one of its tags. Here are the primal and tangent components for\n;; $\\varepsilon_2$:\n;;\n;; $$(a + b\\varepsilon_1) + (c + d\\varepsilon_1)\\varepsilon_2$$\n;;\n;; And for $\\varepsilon_1$:\n;;\n;; $$(a + c\\varepsilon_2) + (b + d \\varepsilon_2) \\varepsilon_1$$\n;;\n;; A differential term is implemented as a pair whose first element is a set of\n;; tags and whose second is the coefficient.\n\n(defn- tags [term]\n  (nth term 0))\n\n(defn- coefficient [term]\n  (nth term 1))\n\n;; The set of tags is implemented as a \"vector set\",\n;; from [[sicmutils.util.vector-set]]. This is a sorted set data structure,\n;; backed by a Clojure vector. vector sets provide cheap \"max\" and \"min\"\n;; operations, and acceptable union, intersection and difference performance.\n\n(defn make-term\n  \"Returns a [[Differential]] term with the supplied vector-set of `tags` paired\n  with coefficient `coef`.\n\n  `tags` defaults to [[uv/empty-set]]\"\n  ([coef] [uv/empty-set coef])\n  ([tags coef] [tags coef]))\n\n;; Since the only use of a tag is to distinguish each unnamed $\\varepsilon_n$,\n;; we'll assign a new, unique positive integer for each new tag:\n\n(let [next-tag (atom -1)]\n  (defn fresh-tag\n    \"Returns a new, unique tag for use inside of a [[Differential]] term list.\"\n    []\n    (swap! next-tag inc)))\n\n(defn- tag-in-term?\n  \"Return true if `t` is in the tag-set of the supplied `term`, false otherwise.\"\n  [term t]\n  (uv/contains? (tags term) t))\n\n;; ## Term List Algebra\n;;\n;; The discussion above about Taylor series expansions revealed that for single\n;; variable functions, we can pass a dual number into any function whose\n;; derivative we already know:\n;;\n;; $$f(a+b\\varepsilon) = f(a) + (Df(a)b)\\varepsilon$$\n;;\n;; Because we can split a [[Differential]] into a primal and tangent component\n;; with respect to some tag, we can reuse this result. We'll default to\n;; splitting [[Differential]] instances by the highest-index tag:\n;;\n;; $$\n;; \\begin{aligned}\n;; f(a &+ b\\varepsilon_1 + c\\varepsilon_2 + d\\varepsilon_1 \\varepsilon_2) \\\\\n;; &= f((a + b\\varepsilon_1)+(c + d\\varepsilon_1)\\varepsilon_2) \\\\\n;; &= f(a + b\\varepsilon_1)+Df(a + b\\varepsilon_1)(c + d\\varepsilon_1)\\varepsilon_2 \\\\\n;; \\end{aligned}\n;; $$\n;;\n;; Note that $f$ and $Df$ both received a dual number! One more expansion, this\n;; time in $\\varepsilon_1$, completes the evaluation (and makes abundantly clear\n;; why we want the computer doing this, not pencil-and-paper):\n;;\n;; $$\n;; \\begin{aligned}\n;; f(a &+ b\\varepsilon_1)+Df(a+b\\varepsilon_1)(c+d\\varepsilon_1)\\varepsilon_2 \\\\\n;; &= (f(a)+Df(a)b\\varepsilon_1)+(Df(a)+D^2f(a)b\\varepsilon_1)(c + d\\varepsilon_1)\\varepsilon_2 \\\\\n;; &= f(a)+(Df(a)b+D^2f(a)bc)\\varepsilon_1+Df(a)c\\varepsilon_2+Df(a)d\\varepsilon_1\\varepsilon_2\n;; \\end{aligned}\n;; $$\n;;\n;; The only operations we need to implement between lists of terms are addition\n;; and multiplication.\n;;\n;; ### Add and Multiply\n;;\n;; To efficiently add two [[Differential]] instances (represented as lists of\n;; terms), we keep all terms in sorted order, sorted first by the length of each\n;; tag list (the \"order\" of the differential term), and secondarily by the\n;; values of the tags inside the tag list.\n;;\n;; NOTE: Clojure vectors already implement this ordering properly, so we can\n;; use [[clojure.core/compare]] to determine an ordering on a tag list.\n\n(def ^{:private true\n       :doc \"Returns the sum of the two supplied sequences of differential terms; any terms\n  in the result with a zero coefficient will be removed.\n\n  Each input must be sequence of `[tag-set, coefficient]` pairs, sorted by\n  `tag-set`.\"}\n  terms:+\n  (ua/merge-fn core/compare g/add v/zero? make-term))\n\n;; Because we've decided to store terms as a vector, we can multiply two vectors\n;; of terms by:\n;;\n;; - taking the cartesian product of both term lists\n;; - discarding all pairs of terms that share any tag (since $\\varepsilon^2=0$)\n;; - multiplying the coefficients of all remaining pairs and union-ing their tag\n;;   lists\n;; - grouping and adding any new terms with the SAME list of tags, and filtering\n;;   out zeros\n;;\n;; This final step is required by a number of different operations later, so we\n;; break it out into its own [[collect-terms]] function:\n\n(defn- collect-terms\n  \"Build a term list up of pairs of tags => coefficients by grouping together and\n  summing coefficients paired with the same term list.\n\n  The result will be sorted by term list, and contain no duplicate term lists.\"\n  [tags->coefs]\n  (let [terms (for [[tags tags-coefs] (group-by tags tags->coefs)\n                    :let [c (transduce (map coefficient) g/+ tags-coefs)]\n                    :when (not (v/zero? c))]\n                [tags c])]\n    (into [] (sort-by tags terms))))\n\n(defn- terms:map-coefficients\n  \"Given some function `f` and a sequence of `terms`, returns a vector of terms\n  with all each `c` mapped to `(f c)`. Any term where `(v/zero? (f c))` is true\n  will be filtered out.\"\n  [f terms]\n  (let [xform (mapcat\n               (fn [term]\n                 (let [c' (f (coefficient term))]\n                   (if (v/zero? c')\n                     []\n                     [(make-term (tags term) c')]))))]\n    (into [] xform terms)))\n\n;; [[terms:*]] implements the first three steps, and calls [[collect-terms]] on\n;; the resulting sequence:\n\n(defn- t*ts\n  \"Multiplies a single term on the left by a vector of `terms` on the right.\n  Returns a new vector of terms.\"\n  [[tags coeff] terms]\n  (loop [acc []\n         i 0]\n    (let [t (nth terms i nil)]\n      (if (nil? t)\n        acc\n\t      (let [[tags1 coeff1] t]\n\t        (if (empty? (uv/intersection tags tags1))\n\t\t        (recur (conj acc (make-term\n\t\t                          (uv/union tags tags1)\n\t\t                          (g/* coeff coeff1)))\n\t\t               (inc i))\n\t\t        (recur acc (inc i))))))))\n\n(defn terms:*\n  \"Returns a vector of non-zero [[Differential]] terms that represent the product\n  of the differential term lists `xs` and `ys`.\n\n  NOTE that this function doesn't need to call [[collect-terms]] internally\n  because grouping is accomplished by the internal [[terms:+]] calls.\"\n  [xlist ylist]\n  (letfn [(call [i]\n            (let [x (nth xlist i nil)]\n              (if (nil? x)\n                []\n                (terms:+ (t*ts x ylist)\n\t                       (call (inc i))))))]\n    (call 0)))\n\n;; ## Differential Type Implementation\n;;\n;; Armed with our term list arithmetic operations, we can finally implement\n;; our [[Differential]] type and implement a number of important Clojure and\n;; SICMUtils protocols.\n;;\n;; A [[Differential]] will respond to [[v/kind]] with `::differential`. Because\n;; we want [[Differential]] instances to work in any place that real numbers or\n;; symbolic argument work, let's make `::differential` derive from `::v/scalar`:\n\n(derive ::differential ::v/scalar)\n\n;; Now the actual type. The `terms` field is a term-list vector that will\n;; remain (contractually!) sorted by its list of tags.\n\n(declare compare equiv finite-term from-terms one?)\n\n(deftype Differential [terms]\n  ;; A [[Differential]] as implemented can act as a chain-rule accounting device\n  ;; for all sorts of types, not just numbers. A [[Differential]] is\n  ;; only [[v/numerical?]] if its coefficients are numerical (or if `terms` is\n  ;; empty, interpreted as a [[Differential]] equal to `0`.)\n  v/Numerical\n  (numerical? [_]\n    (or (empty? terms)\n        (v/numerical?\n         (coefficient (nth terms 0)))))\n\n  IPerturbed\n  (perturbed? [_] true)\n\n  ;; There are 3 cases to consider when replacing some tag in a term, annotated\n  ;; below:\n  (replace-tag [_ oldtag newtag]\n    (letfn [(process [term]\n              (let [tagv (tags term)]\n                (if-not (uv/contains? tagv oldtag)\n                  ;; if the term doesn't contain the old tag, ignore it.\n                  [term]\n                  (if (uv/contains? tagv newtag)\n                    ;; if the term _already contains_ the new tag\n                    ;; $\\varepsilon_{new}$, then replacing $\\varepsilon_1$\n                    ;; with a new instance of $\\varepsilon_2$ would cause a\n                    ;; clash. Since $\\varepsilon_2^2=0$, the term should be\n                    ;; removed.\n                    []\n                    ;; else, perform the replacement.\n                    [(make-term (-> tagv\n                                    (uv/disj oldtag)\n                                    (uv/conj newtag))\n                                (coefficient term))]))))]\n      (from-terms\n       (mapcat process terms))))\n\n  ;; To extract the tangent (with respect to `tag`) from a differential, return\n  ;; all terms that contain the tag (with the tag removed!) This can create\n  ;; duplicate terms, so use [[from-terms]] to massage the result into\n  ;; well-formedness again.\n  (extract-tangent [_ tag]\n    (from-terms\n     (mapcat (fn [term]\n               (let [tagv (tags term)]\n                 (if (uv/contains? tagv tag)\n                   [(make-term (uv/disj tagv tag)\n                               (coefficient term))]\n                   [])))\n             terms)))\n\n  v/Value\n  (zero? [_]\n    (every? (comp v/zero? coefficient) terms))\n  (one? [this] (one? this))\n  (identity? [this] (one? this))\n  (zero-like [_] 0)\n  (one-like [_] 1)\n  (identity-like [_] 1)\n  (freeze [_]\n    (letfn [(freeze-term [term]\n              (make-term (tags term)\n                         (v/freeze (coefficient term))))]\n      `[~'Differential\n        ~@(mapv freeze-term terms)]))\n  (exact? [_] false)\n  (kind [_] ::differential)\n\n  Object\n  ;; Comparing [[Differential]] objects using `equals` defaults to [[equiv]],\n  ;; which compares instances only using their non-tagged ('finite') components.\n  ;; If you want to compare two instances using their full term lists,\n  ;; See [[eq]].\n  #?(:clj (equals [a b] (equiv a b)))\n  #?(:cljs (valueOf [this] (.valueOf (finite-term this))))\n  (toString [_]\n    (let [term-strs (map (fn [term]\n                           (str (tags term)\n                                \" \u2192 \"\n                                (pr-str (coefficient term))))\n                         terms)]\n      (str \"D[\" (join \" \" term-strs) \"]\")))\n\n  #?@(:clj\n      ;; This one is slightly subtle. To participate in control flow operations,\n      ;; like comparison with both [[Differential]] and non-[[Differential]]\n      ;; numbers, [[Differential]] instances should compare using ONLY their\n      ;; non-tagged (\"finite\") terms. This means that comparison will totally\n      ;; ignore any difference in tags.\n      [Comparable\n       (compareTo [a b] (compare a b))]\n\n      :cljs\n      [IEquiv\n       (-equiv [a b] (equiv a b))\n\n       IComparable\n       (-compare [a b]  (compare a b))\n\n       IPrintWithWriter\n       (-pr-writer [x writer _]\n                   (write-all writer (.toString x)))]))\n\n#?(:clj\n   (defmethod print-method Differential\n     [^Differential s ^java.io.Writer w]\n     (.write w (.toString s))))\n\n;; ## Accessor Methods\n\n(defn differential?\n  \"Returns true if the supplied object is an instance of [[Differential]], false\n  otherwise.\"\n  [dx]\n  (instance? Differential dx))\n\n(defn- bare-terms\n  \"Returns the `-terms` field of the supplied [[Differential]] object. Errors if\n  any other type is supplied.\"\n  [dx]\n  {:pre [(differential? dx)]}\n  (.-terms ^Differential dx))\n\n;; ## Constructors\n;;\n;; Because a [[Differential]] is really a wrapper around the idea of a\n;; generalized dual number represented as a term-list, we need to be able to get\n;; to and from the term list format from other types, not just [[Differential]]\n;; instances.\n\n(defn- ->terms\n  \"Returns a vector of terms that represent the supplied [[Differential]]; any\n  term with a [[v/zero?]] coefficient will be filtered out before return.\n\n  If you pass a non-[[Differential]], [[->terms]] will return a singleton term\n  list (or `[]` if the argument was zero).\"\n  [dx]\n  (cond (differential? dx) (bare-terms dx)\n        (vector? dx)       dx\n        (v/zero? dx)       []\n        :else              [(make-term dx)]))\n\n(defn- terms->differential\n  \"Returns a differential instance generated from a vector of terms. This method\n  will do some mild cleanup, or canonicalization:\n\n  - any empty term list will return 0\n  - a singleton term list with no tags will return its coefficient\n\n  NOTE this method assumes that the input is properly sorted, and contains no\n  zero coefficients.\"\n  [terms]\n  {:pre [(vector? terms)]}\n  (cond (empty? terms) 0\n\n        (and (= (count terms) 1)\n             (empty? (tags (nth terms 0))))\n        (coefficient (nth terms 0))\n\n        :else (->Differential terms)))\n\n(defn from-terms\n  \"Accepts a sequence of terms (ie, pairs of `[tag-list, coefficient]`), and\n  returns:\n\n  - a well-formed [[Differential]] instance, if the terms resolve to a\n    differential with non-zero infinitesimal terms\n  - the original input otherwise\n\n  Duplicate (by tag list) terms are allowed; their coefficients will be summed\n  together and removed if they sum to zero.\"\n  [tags->coefs]\n  (terms->differential\n   (collect-terms tags->coefs)))\n\n(defn map-coefficients\n  \"Given a function `f` and [[Differential]] instance `d`, returns a\n  new [[Differential]] generated by transforming all coefficients `c` of `d`\n  to `(f c)`.\n\n  Any term in the returned instance with a `v/zero?` coefficient\n  will be filtered out.\"\n  [f d]\n  (let [terms (bare-terms d)]\n    (->Differential\n     (terms:map-coefficients f terms))))\n\n;; ## Differential API\n;;\n;; These first two functions create a way to globally declare, via a dynamic\n;; binding, the stack of tags that are currently in play. If three nested\n;; derivatives are being taken, [[*active-tags*]] will contain three entries\n;; from a perspective inside the function at the deepest level.\n;;\n;; The [[IPerturbed]] implementation for functions uses this information to\n;; determine whether or not to use [[replace-tag]] to protect its tag from\n;; perturbation confusion. If some higher level is not trying to extract the\n;; same tag, there's no need.\n\n(def ^:dynamic *active-tags* [])\n\n(defn with-active-tag\n  \"Like `apply`, but conj-es `tag` onto the dynamic variable [[*active-tags*]]\n  inside the scope of `f`.\n\n  Returns the result of applying `f` to `args`.\"\n  [tag f args]\n  (binding [*active-tags* (conj *active-tags* tag)]\n    (apply f args)))\n\n(defn tag-active?\n  \"Returns true if `tag` is an element of [[*active-tags*]] (and therefore pending\n  for extraction by some nested derivative), false otherwise.\"\n  [tag]\n  (boolean\n   (some #{tag} (rseq *active-tags*))))\n\n;; ### Differential Arithmetic\n;;\n;; This next section lifts slightly-augmented versions of [[terms:+]]\n;; and [[terms:*]] up to operate on [[Differential]] instances. These work just\n;; as before, but handle wrapping and unwrapping the term list.\n\n(defn d:+\n  \"Returns an object representing the sum of the two objects `dx` and `dy`. This\n  works by summing the coefficients of all terms with the same list of tags.\n\n    Works with non-[[Differential]] instances on either or both sides, and returns\n  a [[Differential]] only if it contains any non-zero tangent components.\"\n  ([] 0)\n  ([dx] dx)\n  ([dx dy]\n   (terms->differential\n    (terms:+ (->terms dx)\n             (->terms dy))))\n  ([dx dy & more]\n   (terms->differential\n    (transduce (map ->terms)\n               terms:+\n               (cons dx (cons dy more))))))\n\n(defn d:*\n  \"Returns an object representing the product of the two objects `dx` and `dy`.\n\n  This works by multiplying out all terms:\n\n  $$(dx1 + dx2 + dx3 + ...)(dy1 + dy2 + dy3...)$$\n\n  and then collecting any duplicate terms by summing their coefficients.\n\n  Works with non-[[Differential]] instances on either or both sides, and returns\n  a [[Differential]] only if it contains any non-zero tangent components.\"\n  ([] 1)\n  ([dx] dx)\n  ([dx dy]\n   (terms->differential\n    (terms:* (->terms dx)\n             (->terms dy)))))\n\n(defn d:+*\n  \"Identical to `(d:+ a) (d:* b c)`, but _slightly_ more efficient as the function\n  is able to skip creating a [[Differential]] instance during [[d:*]] and then\n  immediately tearing it down for [[d:+]].\"\n  [a b c]\n  (terms->differential\n   (terms:+ (->terms a)\n            (terms:* (->terms b)\n                     (->terms c)))))\n\n;; Finally, the function we've been waiting for! [[bundle-element]] allows you\n;; to augment some non-[[Differential]] thing with a tag and push it through the\n;; generic arithmetic system, where it will accumulate the derivative of your\n;; original input (tagged with `tag`.)\n\n(defn bundle-element\n  \"Generate a new [[Differential]] object with the supplied `primal` and `tangent`\n  components, and the supplied internal `tag` that this [[Differential]] will\n  carry around to prevent perturbation confusion.\n\n  If the `tangent` component is `0`, acts as identity on `primal`. `tangent`\n  defaults to 1.\n\n  `tag` defaults to a side-effecting call to [[fresh-tag]]; you can retrieve\n  this unknown tag by calling [[max-order-tag]].\"\n  ([primal]\n   {:pre [(v/numerical? primal)]}\n   (bundle-element primal 1 (fresh-tag)))\n  ([primal tag]\n   {:pre [(v/numerical? primal)]}\n   (bundle-element primal 1 tag))\n  ([primal tangent tag]\n   (let [term (make-term (uv/make [tag]) 1)]\n     (d:+* primal tangent [term]))))\n\n;; ## Differential Parts API\n;;\n;; These functions give higher-level access to the components of\n;; a [[Differential]] you're typically interested in.\n\n(defn max-order-tag\n  \"Given one or more well-formed [[Differential]] objects, returns the\n  maximum ('highest order') tag found in the highest-order term of any of\n  the [[Differential]] instances.\n\n  If there is NO maximal tag (ie, if you provide [[Differential]] instances with\n  no non-zero tangent parts, or all non-[[Differential]]s), returns nil.\"\n  ([dx]\n   (when (differential? dx)\n     (let [last-term   (peek (bare-terms dx))\n           highest-tag (peek (tags last-term))]\n       highest-tag)))\n  ([dx & dxs]\n   (letfn [(max-termv [dx]\n             (if-let [max-order (max-order-tag dx)]\n               [max-order]\n               []))]\n     (when-let [orders (seq (mapcat max-termv (cons dx dxs)))]\n       (apply max orders)))))\n\n;; A reminder: the [[primal-part]] of a [[Differential]] is all terms except for\n;; terms containing [[max-order-tag]], and [[tangent-part]] is\n;; a [[Differential]] built out of the remaining terms, all of which contain\n;; that tag.\n\n(defn primal-part\n  \"Returns a [[Differential]] containing only the terms of `dx` that do NOT\n  contain the supplied `tag`, ie, the primal component of `dx` with respect to\n  `tag`.\n\n  If no tag is supplied, defaults to `([[max-order-tag]] dx)`.\n\n  NOTE: every [[Differential]] can be factored into a dual number of the form\n\n      primal + (tangent * tag)\n\n  For each tag in any of its terms. [[primal-part]] returns this first piece,\n  potentially simplified into a non-[[Differential]] if the primal part contains\n  no other tags.\"\n  ([dx] (primal-part dx (max-order-tag dx)))\n  ([dx tag]\n   (if (differential? dx)\n     (let [sans-tag? #(not (tag-in-term? % tag))]\n       (->> (bare-terms dx)\n            (filterv sans-tag?)\n            (terms->differential)))\n     dx)))\n\n(defn tangent-part\n  \"Returns a [[Differential]] containing only the terms of `dx` that contain the\n  supplied `tag`, ie, the tangent component of `dx` with respect to `tag`.\n\n  If no tag is supplied, defaults to `([[max-order-tag]] dx)`.\n\n  NOTE: Every [[Differential]] can be factored into a dual number of the form\n\n      primal + (tangent * tag)\n\n  For each tag in any of its terms. [[tangent-part]] returns a [[Differential]]\n  representing `(tangent * tag)`, or 0 if `dx` contains no terms with the\n  supplied `tag`.\n\n  NOTE: the 2-arity case is similar to `([[extract-tangent]] dx tag)`; the only\n  difference is that [[extract-tangent]] drops the `dx` tag from all terms in\n  the returned value. Call [[extract-tangent]] if you want to drop `tag`.\"\n  ([dx] (tangent-part dx (max-order-tag dx)))\n  ([dx tag]\n   (if (differential? dx)\n     (->> (bare-terms dx)\n          (filterv #(tag-in-term? % tag))\n          (terms->differential))\n     0)))\n\n(defn primal-tangent-pair\n  \"Returns a pair of the primal and tangent components of the supplied `dx`, with\n  respect to the supplied `tag`. See the docs for [[primal-part]]\n  and [[tangent-part]] for more details.\n\n  [[primal-tangent-pair]] is equivalent to\n\n  `[([[primal-part]] dx tag) ([[tangent-part]] dx tag)]`\n\n  but slightly more efficient if you need both.\"\n  ([dx] (primal-tangent-pair dx (max-order-tag dx)))\n  ([dx tag]\n   (if-not (differential? dx)\n     [dx 0]\n     (let [[tangent-terms primal-terms]\n           (us/separatev #(tag-in-term? % tag)\n                         (bare-terms dx))]\n       [(terms->differential primal-terms)\n        (terms->differential tangent-terms)]))))\n\n(defn finite-term\n  \"Returns the term of the supplied [[Differential]] `dx` that has no tags\n  attached to it, `0` otherwise.\n\n  [[Differential]] instances with many can be decomposed many times\n  into [[primal-part]] and [[tangent-part]]. Repeated calls\n  to [[primal-part]] (with different tags!) will eventually yield a\n  non-[[Differential]] value. If you know you want this, [[finite-term]] will\n  get you there in one shot.\n\n  NOTE that this will only work with a well-formed [[Differential]], ie, an\n  instance with all terms sorted by their list of tags.\"\n  [dx]\n  (if (differential? dx)\n    (let [[head] (bare-terms dx)\n          ts     (tags head)]\n      (if (empty? ts)\n        (coefficient head)\n        0))\n    dx))\n\n;; ## Comparison, Control Flow\n;;\n;; Functions like `=`, `<` and friends don't have derivatives; instead, they're\n;; used for control flow inside of Clojure functions. To play nicely with these\n;; functions, the [[Differential]] API exposes a number of methods for comparing\n;; numbers on ONLY their finite parts.\n;;\n;; Why? If `x` is a [[Differential]] instance, `(< x 10)` needs to return true\n;; whenever a non-[[Differential]] `x` would return true. To make this work,\n;; these operations look only at the [[finite-part]].\n;;\n;; HOWEVER! [[v/one?]] and [[v/zero?]] are examples of SICMUtils functions that\n;; are used to skip operations that we _want_ to happen, like multiplication.\n;;\n;; `(g/* x y)` will return `y` if `(v/one? x)` is true... but to propagate the\n;; derivative through we need this multiplication to occur. The compromise is:\n;;\n;; - [[v/one?]] and [[v/zero?]] return true only when ALL [[tangent-part]]s are\n;;   zero and the [[finite-part]] is either [[v/one?]] or [[v/zero?]]\n;;   respectively\n;; - [[eq]] and [[compare-full]] similarly looks at every component in\n;;   the [[Differential]] supplied to both sides\n;;\n;; while:\n;;\n;; - [[equiv]] and [[compare]] only examine the [[finite-part]] of either side.\n\n(defn one?\n  \"Returns true if the supplied instance has a [[finite-part]] that responds true\n  to [[sicmutils.value/one?]], and zero coefficients on any of its tangent\n  components; false otherwise.\n\n  NOTE: This means that [[one?]] will not do what you expect as a conditional\n  inside some function. If you want to branch inside some function you're taking\n  the derivative of, prefer `(= 1 dx)`. This will only look at\n  the [[finite-part]] and ignore the values of the tangent parts.\"\n  [dx]\n  (let [[p t] (primal-tangent-pair dx)]\n    (and (v/one? p)\n         (v/zero? t))))\n\n(defn eq\n  \"For non-differentials, this is identical to [[clojure.core/=]].\n  For [[Differential]] instances, equality acts on tangent components too.\n\n  If you want to ignore the tangent components, use [[equiv]].\"\n  ([_] true)\n  ([a b]\n   (v/= (->terms a)\n        (->terms b)))\n  ([a b & more]\n   (if (eq a b)\n     (if (next more)\n       (recur b (first more) (next more))\n       (eq b (first more)))\n     false)))\n\n(defn compare-full\n  \"Comparator that compares [[Differential]] instances with each other or\n  non-differentials using all tangent terms each instance. Matches the response\n  of [[eq]].\n\n  Acts as [[clojure.core/compare]] for non-differentials.\"\n  [a b]\n  (v/compare\n   (->terms a)\n   (->terms b)))\n\n(defn equiv\n  \"Returns true if all of the supplied objects have equal [[finite-part]]s, false\n  otherwise.\n\n  Use [[equiv]] if you want to compare non-differentials with\n  [[Differential]]s and ignore all tangent components. If you _do_ want to take\n  the tangent components into account, prefer [[eq]].\"\n  ([_] true)\n  ([a b]\n   (v/= (finite-term a)\n        (finite-term b)))\n  ([a b & more]\n   (if (equiv a b)\n     (if (next more)\n       (recur b (first more) (next more))\n       (equiv b (first more)))\n     false)))\n\n(defn compare\n  \"Comparator that compares [[Differential]] instances with each other or\n  non-differentials using only the [[finite-part]] of each instance. Matches the\n  response of [[equiv]].\n\n  Acts as [[clojure.core/compare]] for non-differentials.\"\n  [a b]\n  (v/compare\n   (finite-term a)\n   (finite-term b)))\n\n;; ## Chain Rule and Lifted Functions\n;;\n;; Finally, we come to the heart of it! [[lift-1]] and [[lift-2]] \"lift\", or\n;; augment, unary or binary functions with the ability to\n;; handle [[Differential]] instances in addition to whatever other types they\n;; previously supported.\n;;\n;; These functions are implementations of the single and multivariable Taylor\n;; series expansion methods discussed at the beginning of the namespace.\n;;\n;; There is yet another subtlety here, noted in the docstrings below. [[lift-1]]\n;; and [[lift-2]] really are able to lift functions like [[clojure.core/+]] that\n;; can't accept [[Differential]]s. But the first-order derivatives that you have\n;; to supply _do_ have to be able to take [[Differential]] instances.\n;;\n;; This is because the [[tangent-part]] of [[Differential]] might still be\n;; a [[Differential]], and for `Df` to handle this we need to be able to take\n;; the second-order derivative.\n;;\n;; Magically this will all Just Work if you pass an already-lifted function, or\n;; a function built out of already-lifted components, as `df:dx` or `df:dy`.\n\n(defn lift-1\n  \"Given:\n\n  - some unary function `f`\n  - a function `df:dx` that computes the derivative of `f` with respect to its\n    single argument\n\n  Returns a new unary function that operates on both the original type of `f`\n  and [[Differential]] instances.\n\n  If called without `df:dx`, `df:dx` defaults to `(f :dfdx)`; this will return\n  the derivative registered to a generic function defined with [[g/defgeneric]].\n\n  NOTE: `df:dx` has to ALREADY be able to handle [[Differential]] instances. The\n  best way to accomplish this is by building `df:dx` out of already-lifted\n  functions, and declaring them by forward reference if you need to.\"\n  ([f]\n   (if-let [df:dx (f :dfdx)]\n     (lift-1 f df:dx)\n     (u/illegal \"No df:dx supplied for `f` or registered generically.\")))\n  ([f df:dx]\n   (fn call [x]\n     (if-not (differential? x)\n       (f x)\n       (let [[px tx] (primal-tangent-pair x)\n             fx      (call px)]\n         (if (v/numeric-zero? tx)\n           fx\n           (d:+* fx (df:dx px) tx)))))))\n\n(defn lift-2\n  \"Given:\n\n  - some binary function `f`\n  - a function `df:dx` that computes the derivative of `f` with respect to its\n    single argument\n  - a function `df:dy`, similar to `df:dx` for the second arg\n\n  Returns a new binary function that operates on both the original type of `f`\n  and [[Differential]] instances.\n\n  NOTE: `df:dx` and `df:dy` have to ALREADY be able to handle [[Differential]]\n  instances. The best way to accomplish this is by building `df:dx` and `df:dy`\n  out of already-lifted functions, and declaring them by forward reference if\n  you need to.\"\n  ([f]\n   (let [df:dx (f :dfdx)\n         df:dy (f :dfdy)]\n     (if (and df:dx df:dy)\n       (lift-2 f df:dx df:dy)\n       (u/illegal \"No df:dx, df:dy supplied for `f` or registered generically.\"))))\n  ([f df:dx df:dy]\n   (fn call [x y]\n     (if-not (or (differential? x)\n                 (differential? y))\n       (f x y)\n       (let [tag     (max-order-tag x y)\n             [xe dx] (primal-tangent-pair x tag)\n             [ye dy] (primal-tangent-pair y tag)\n             a (call xe ye)\n             b (if (v/numeric-zero? dx)\n                 a\n                 (d:+* a (df:dx xe ye) dx))]\n         (if (v/numeric-zero? dy)\n           b\n           (d:+* b (df:dy xe ye) dy)))))))\n\n(defn lift-n\n  \"Given:\n\n  - some function `f` that can handle 0, 1 or 2 arguments\n  - `df:dx`, a fn that returns the derivative wrt the single arg in the unary case\n  - `df:dx1` and `df:dx2`, fns that return the derivative with respect to the\n    first and second args in the binary case\n\n  Returns a new any-arity function that operates on both the original type of\n  `f` and [[Differential]] instances.\n\n  NOTE: The n-ary case of `f` is populated by nested calls to the binary case.\n  That means that this is NOT an appropriate lifting method for an n-ary\n  function that isn't built out of associative binary calls. If you need this\n  ability, please file an issue at the [sicmutils issue\n  tracker](https://github.com/sicmutils/sicmutils/issues).\"\n  [f df:dx df:dx1 df:dx2]\n  (let [f1 (lift-1 f df:dx)\n        f2 (lift-2 f df:dx1 df:dx2)]\n    (fn call\n      ([] (f))\n      ([x] (f1 x))\n      ([x y] (f2 x y))\n      ([x y & more]\n       (reduce call (call x y) more)))))\n\n;; ## Generic Method Installation\n;;\n;; Armed with [[lift-1]] and [[lift-2]], we can install [[Differential]] into\n;; the SICMUtils generic arithmetic system.\n;;\n;; Any function built out of these components will work with\n;; the [[sicmutils.calculus.derivative/D]] operator.\n\n(defmethod g/simplify [::differential] [d]\n  (map-coefficients g/simplify d))\n\n(defn- defunary\n  \"Given:\n\n  - a generic unary multimethod `generic-op`\n  - a corresponding single-arity lifted function `differential-op`\n\n  installs an appropriate unary implementation of `generic-op` for\n  `::differential` instances.\"\n  [generic-op differential-op]\n  (defmethod generic-op [::differential] [a] (differential-op a)))\n\n(defn- defbinary\n  \"Given:\n\n  - a generic binary multimethod `generic-op`\n  - a corresponding 2-arity lifted function `differential-op`\n\n  installs an appropriate binary implementation of `generic-op` between\n  `:differential` and `::v/scalar` instances.\"\n  [generic-op differential-op]\n  (doseq [signature [[::differential ::differential]\n                     [::v/scalar ::differential]\n                     [::differential ::v/scalar]]]\n    (defmethod generic-op signature [a b] (differential-op a b))))\n\n;; And now we're off to the races. The rest of the namespace\n;; provides [[defunary]] and [[defbinary]] calls for all of the generic\n;; operations for which we know how to declare partial derivatives.\n\n;; First, install `equiv` as to perform proper equality between `Differential`\n;; instances and scalars. `equiv` compares on only the finite part, not the\n;; differential parts.\n\n(defbinary v/= equiv)\n\n(defbinary g/add d:+)\n(defunary g/negate (lift-1 g/negate))\n(defbinary g/sub (lift-2 g/sub))\n\n(let [mul  (lift-2 g/mul)]\n  (defbinary g/mul mul)\n  (defbinary g/dot-product mul))\n(defbinary g/expt (lift-2 g/expt))\n\n(defunary g/square (lift-1 g/square))\n(defunary g/cube (lift-1 g/cube))\n\n(defunary g/invert (lift-1 g/invert))\n(defbinary g/div (lift-2 g/div))\n\n(defunary g/negative?\n  (comp g/negative? finite-term))\n\n(defunary g/infinite?\n  (comp g/infinite? finite-term))\n\n(defunary g/abs\n  (fn [x]\n    (let [f (finite-term x)\n          func (cond (< f 0) (lift-1 g/negate)\n                     (> f 0) (lift-1 identity (fn [_] 1))\n                     (= f 0) (u/illegal \"Derivative of g/abs undefined at zero\")\n                     :else (u/illegal (str \"error! derivative of g/abs at\" x)))]\n      (func x))))\n\n(defn- discont-at-integers [f dfdx]\n  (let [f (lift-1 f (fn [_] dfdx))\n        f-name (v/freeze f)]\n    (fn [x]\n      (if (v/integral? (finite-term x))\n        (u/illegal\n         (str \"Derivative of g/\" f-name \" undefined at integral points.\"))\n        (f x)))))\n\n(defunary g/floor\n  (discont-at-integers g/floor 0))\n\n(defunary g/ceiling\n  (discont-at-integers g/ceiling 0))\n\n(defunary g/integer-part\n  (discont-at-integers g/integer-part 0))\n\n(defunary g/fractional-part\n  (discont-at-integers g/fractional-part 1))\n\n(let [div (lift-2 g/div)]\n  (defbinary g/solve-linear (fn [l r] (div r l)))\n  (defbinary g/solve-linear-right div))\n\n(defunary g/sqrt (lift-1 g/sqrt))\n(defunary g/log (lift-1 g/log))\n(defunary g/exp (lift-1 g/exp))\n\n(defunary g/cos (lift-1 g/cos))\n(defunary g/sin (lift-1 g/sin))\n(defunary g/tan (lift-1 g/tan))\n(defunary g/cot (lift-1 g/cot))\n(defunary g/sec (lift-1 g/sec))\n(defunary g/csc (lift-1 g/csc))\n\n(defunary g/atan (lift-1 g/atan))\n(defbinary g/atan (lift-2 g/atan))\n(defunary g/asin (lift-1 g/asin))\n(defunary g/acos (lift-1 g/acos))\n(defunary g/acot (lift-1 g/acot))\n(defunary g/asec (lift-1 g/asec))\n(defunary g/acsc (lift-1 g/acsc))\n\n(defunary g/cosh (lift-1 g/cosh))\n(defunary g/sinh (lift-1 g/sinh))\n(defunary g/tanh (lift-1 g/tanh))\n(defunary g/sech (lift-1 g/sech))\n(defunary g/coth (lift-1 g/coth))\n(defunary g/csch (lift-1 g/csch))\n\n(defunary g/acosh (lift-1 g/acosh))\n(defunary g/asinh (lift-1 g/asinh))\n(defunary g/atanh (lift-1 g/atanh))\n(defunary g/acoth (lift-1 g/acoth))\n(defunary g/asech (lift-1 g/asech))\n(defunary g/acsch (lift-1 g/acsch))\n\n(defunary g/sinc (lift-1 g/sinc))\n(defunary g/sinhc (lift-1 g/sinhc))\n(defunary g/tanc (lift-1 g/tanc))\n(defunary g/tanhc (lift-1 g/tanhc))\n"]}