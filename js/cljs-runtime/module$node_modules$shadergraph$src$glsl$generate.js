shadow$provide.module$node_modules$shadergraph$src$glsl$generate=function(global,require,module$jscomp$0,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;
if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,
desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}function lines$jscomp$0(lines){return lines.join("\n")}function list$jscomp$0(lines){return lines.join(", ")}function statements(lines){return lines.join(";\n")}function body$jscomp$0(entry){return{entry,type:"void",params:[],signature:[],return:"",vars:{},calls:[],post:[],chain:{}}}function define(a,b){return`#define ${a} ${b}`}function fn(type,entry,params,vars,calls){return`${type} ${entry}(${params}) {\n${vars}${calls}}`}
function invoke(ret,entry,args){ret=ret?`${ret} = `:"";args=list$jscomp$0(args);return`  ${ret}${entry}(${args})`}function same(a,b){for(let i=0;i<a.length;i++){const A=a[i],B=b[i];if(!B||A.type!==B.type||A.name===$.RETURN_ARG!==(B.name===$.RETURN_ARG))return!1}return!0}function call(lookup,dangling,entry,signature,body){const args=[];let ret="";for(let arg of Array.from(signature)){var shadow=void 0;const {name}=arg;let copy=signature=lookup(name),other=null,meta=null,omit=!1;const isReturn=name===
$.RETURN_ARG;if(shadow=null!=arg.meta?arg.meta.shadowed:void 0)if(other=lookup(shadow))body.vars[other]="  "+arg.param(other),body.calls.push(`  ${other} = ${signature}`),dangling(shadow)?meta={shadowed:other}:arg=arg.split();if(shadow=null!=arg.meta?arg.meta.shadow:void 0)if(other=lookup(shadow))if(dangling(shadow))continue;else arg=arg.split(),omit=!0;isReturn?ret=signature:omit||args.push(null!=other?other:signature);dangling(name)?(shadow="push",isReturn?""===body.return?(shadow="unshift",copy=
name,body.type=arg.spec,body.return=`  return ${signature}`,body.vars[signature]="  "+arg.param(signature)):(body.vars[signature]="  "+arg.param(signature),body.params.push(arg.param(signature,!0))):body.params.push(arg.param(signature,!0)),arg=arg.copy(copy,meta),body.signature[shadow](arg)):body.vars[signature]="  "+arg.param(signature)}return body.calls.push(invoke(ret,entry,args))}function build(body,calls){const {entry}=body;var code=null;calls&&1===calls.length&&"main"!==entry&&(calls=calls[0].module,
same(body.signature,calls.main.signature)&&(code=define(entry,calls.entry)));if(null==code){calls=[];for(var v in body.vars)calls.push(body.vars[v]);v=calls;({calls}=body);({post:code}=body);let {params}=body;const {type}=body,ret=body.return;calls=calls.concat(code);""!==ret&&calls.push(ret);calls.push("");v.length?(v.push(""),v=statements(v)+"\n"):v="";calls=statements(calls);params=list$jscomp$0(params);code=fn(type,entry,params,v,calls)}return{signature:body.signature,code,name:entry}}Object.defineProperty(exports,
"__esModule",{value:!0});exports.unshadow=function(name){const real=name.replace($.SHADOW_ARG,"");return real!==name?real:null};exports.lines=lines$jscomp$0;exports.list=list$jscomp$0;exports.statements=statements;exports.body=body$jscomp$0;exports.define=define;exports.fn=fn;exports.invoke=invoke;exports.same=same;exports.call=call;exports.build=build;exports.links=function(links){const out={defs:[],bodies:[]};for(const l of Array.from(links))link$jscomp$0(l,out);out.defs=lines$jscomp$0(out.defs);
out.bodies=statements(out.bodies);""===out.defs&&delete out.defs;""===out.bodies&&delete out.bodies;return out};exports.defuse=function(code$jscomp$0){const re=/([A-Za-z0-9_]+\s+)?[A-Za-z0-9_]+\s+[A-Za-z0-9_]+\s*\([^)]*\)\s*;\s*/gm,strip=code=>code.replace(re,_m=>"");code$jscomp$0=code$jscomp$0.split(/(?=[{}])/g);let level=0;for(let i=0;i<code$jscomp$0.length;i++){var b=code$jscomp$0[i];switch(b[0]){case "{":level++;break;case "}":level--}if(0===level){b=b.split(/^[ \t]*#/m);for(let j=0;j<b.length;j++){var line=
b[j];if(0<j){line=line.split(/\n/);const head=line.shift();line=line.join("\n");b[j]=[head,strip(line)].join("\n")}else b[j]=strip(line)}code$jscomp$0[i]=b.join("#")}}return code$jscomp$0=code$jscomp$0.join("")};exports.dedupe=function(code){const map={};return code.replace(/((attribute|uniform|varying)\s+)[A-Za-z0-9_]+\s+([A-Za-z0-9_]+)\s*(\[[^\]]*\]\s*)?;\s*/gm,function(m,qual,type,name,_struct){if(map[name])return"";map[name]=!0;return m})};exports.hoist=function(code){const filter=function(lines,
re){const defs=[],out=[];for(const line of Array.from(lines))(line.match(re)?defs:out).push(line);return defs.concat(out)};code=code.split("\n");code=filter(code,/^#define ([^ ]+ _pg_[0-9]+_|_pg_[0-9]+_ [^ ]+)$/);code=filter(code,/^#extension/);return code.join("\n")};exports.link=void 0;var Graph=_interopRequireWildcard(require("module$node_modules$shadergraph$src$graph$index")),$=_interopRequireWildcard(require("module$node_modules$shadergraph$src$glsl$constants"));const link$jscomp$0=(link,out)=>
{const {module,name:name$jscomp$0,external}=link;var {main}=module;({entry:link}=module);if(same(main.signature,external.signature))return out.defs.push(define(name$jscomp$0,link));var ins=[],outs=[];let map={};const returnVar=[module.namespace,$.RETURN_ARG].join("");for(arg of Array.from(external.signature)){var list=arg.inout===Graph.IN?ins:outs;list.push(arg)}for(arg of Array.from(main.signature))list=arg.inout===Graph.IN?ins:outs,list=list.shift().name,list===$.RETURN_ARG&&(list=returnVar),map[arg.name]=
list;var arg=name=>map[name];ins=()=>!0;outs=body$jscomp$0();call(arg,ins,link,main.signature,outs);outs.entry=link;map={return:returnVar};arg=name=>null!=map[name]?map[name]:name;main=body$jscomp$0();call(arg,ins,link,external.signature,main);main.calls=outs.calls;main.entry=name$jscomp$0;out.bodies.push(build(outs).code.split(" {")[0]);return out.bodies.push(build(main).code)};exports.link=link$jscomp$0}
//# sourceMappingURL=module$node_modules$shadergraph$src$glsl$generate.js.map
