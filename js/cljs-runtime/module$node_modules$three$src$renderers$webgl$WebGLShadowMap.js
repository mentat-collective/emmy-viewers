shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLShadowMap=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLShadowMap=function(_renderer,
_objects,_capabilities){function getDepthMaterial(object,geometry,material,light,shadowCameraNear,shadowCameraFar,type){object=!0===light.isPointLight?object.customDistanceMaterial:object.customDepthMaterial;object=void 0!==object?object:!0===light.isPointLight?_distanceMaterial:_depthMaterial;if(_renderer.localClippingEnabled&&!0===material.clipShadows&&0!==material.clippingPlanes.length||material.displacementMap&&0!==material.displacementScale||material.alphaMap&&0<material.alphaTest){var keyA=
object.uuid;geometry=material.uuid;let materialsForVariant=_materialCache[keyA];void 0===materialsForVariant&&(materialsForVariant={},_materialCache[keyA]=materialsForVariant);keyA=materialsForVariant[geometry];void 0===keyA&&(keyA=object.clone(),materialsForVariant[geometry]=keyA);object=keyA}object.visible=material.visible;object.wireframe=material.wireframe;object.side=type===_constants.VSMShadowMap?null!==material.shadowSide?material.shadowSide:material.side:null!==material.shadowSide?material.shadowSide:
shadowSide[material.side];object.alphaMap=material.alphaMap;object.alphaTest=material.alphaTest;object.clipShadows=material.clipShadows;object.clippingPlanes=material.clippingPlanes;object.clipIntersection=material.clipIntersection;object.displacementMap=material.displacementMap;object.displacementScale=material.displacementScale;object.displacementBias=material.displacementBias;object.wireframeLinewidth=material.wireframeLinewidth;object.linewidth=material.linewidth;!0===light.isPointLight&&!0===
object.isMeshDistanceMaterial&&(object.referencePosition.setFromMatrixPosition(light.matrixWorld),object.nearDistance=shadowCameraNear,object.farDistance=shadowCameraFar);return object}function renderObject(object,camera,shadowCamera,light,type){if(!1!==object.visible){if(object.layers.test(camera.layers)&&(object.isMesh||object.isLine||object.isPoints)&&(object.castShadow||object.receiveShadow&&type===_constants.VSMShadowMap)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,
object.matrixWorld);const geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let k=0,kl=groups.length;k<kl;k++){const group=groups[k];var groupMaterial=material[group.materialIndex];groupMaterial&&groupMaterial.visible&&(groupMaterial=getDepthMaterial(object,geometry,groupMaterial,light,shadowCamera.near,shadowCamera.far,type),_renderer.renderBufferDirect(shadowCamera,null,geometry,groupMaterial,object,group))}}else material.visible&&
(material=getDepthMaterial(object,geometry,material,light,shadowCamera.near,shadowCamera.far,type),_renderer.renderBufferDirect(shadowCamera,null,geometry,material,object,null))}object=object.children;for(let i=0,l=object.length;i<l;i++)renderObject(object[i],camera,shadowCamera,light,type)}}let _frustum=new _Frustum.Frustum;const _shadowMapSize=new _Vector2.Vector2,_viewportSize=new _Vector2.Vector2,_viewport=new _Vector.Vector4,_depthMaterial=new _MeshDepthMaterial.MeshDepthMaterial({depthPacking:_constants.RGBADepthPacking}),
_distanceMaterial=new _MeshDistanceMaterial.MeshDistanceMaterial,_materialCache={},_maxTextureSize=_capabilities.maxTextureSize,shadowSide={0:_constants.BackSide,1:_constants.FrontSide,2:_constants.DoubleSide},shadowMaterialVertical=new _ShaderMaterial.ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new _Vector2.Vector2},radius:{value:4}},vertexShader:vsm.vertex,fragmentShader:vsm.fragment}),shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=
1;_capabilities=new _BufferGeometry.BufferGeometry;_capabilities.setAttribute("position",new _BufferAttribute.BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const fullScreenMesh=new _Mesh.Mesh(_capabilities,shadowMaterialVertical),scope=this;this.enabled=!1;this.autoUpdate=!0;this.needsUpdate=!1;this.type=_constants.PCFShadowMap;this.render=function(lights,scene,camera){if(!1!==scope.enabled&&(!1!==scope.autoUpdate||!1!==scope.needsUpdate)&&0!==lights.length){var currentRenderTarget=
_renderer.getRenderTarget(),activeCubeFace=_renderer.getActiveCubeFace(),activeMipmapLevel=_renderer.getActiveMipmapLevel(),_state=_renderer.state;_state.setBlending(_constants.NoBlending);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(!0);_state.setScissorTest(!1);for(let i=0,il=lights.length;i<il;i++){var light=lights[i];const shadow=light.shadow;if(void 0===shadow)console.warn("THREE.WebGLShadowMap:",light,"has no shadow.");else if(!1!==shadow.autoUpdate||!1!==shadow.needsUpdate){_shadowMapSize.copy(shadow.mapSize);
var shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize)_shadowMapSize.x>_maxTextureSize&&(_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x),_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x,shadow.mapSize.x=_viewportSize.x),_shadowMapSize.y>_maxTextureSize&&(_viewportSize.y=Math.floor(_maxTextureSize/shadowFrameExtents.y),_shadowMapSize.y=
_viewportSize.y*shadowFrameExtents.y,shadow.mapSize.y=_viewportSize.y);null!==shadow.map||shadow.isPointLightShadow||this.type!==_constants.VSMShadowMap||(shadowFrameExtents={minFilter:_constants.LinearFilter,magFilter:_constants.LinearFilter,format:_constants.RGBAFormat},shadow.map=new _WebGLRenderTarget.WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,shadowFrameExtents),shadow.map.texture.name=light.name+".shadowMap",shadow.mapPass=new _WebGLRenderTarget.WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,
shadowFrameExtents),shadow.camera.updateProjectionMatrix());null===shadow.map&&(shadow.map=new _WebGLRenderTarget.WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,{minFilter:_constants.NearestFilter,magFilter:_constants.NearestFilter,format:_constants.RGBAFormat}),shadow.map.texture.name=light.name+".shadowMap",shadow.camera.updateProjectionMatrix());_renderer.setRenderTarget(shadow.map);_renderer.clear();shadowFrameExtents=shadow.getViewportCount();for(var vp=0;vp<shadowFrameExtents;vp++){const viewport=
shadow.getViewport(vp);_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type)}shadow.isPointLightShadow||this.type!==_constants.VSMShadowMap||(light=shadow,shadowFrameExtents=camera,vp=_objects.update(fullScreenMesh),shadowMaterialVertical.defines.VSM_SAMPLES!==light.blurSamples&&(shadowMaterialVertical.defines.VSM_SAMPLES=
light.blurSamples,shadowMaterialHorizontal.defines.VSM_SAMPLES=light.blurSamples,shadowMaterialVertical.needsUpdate=!0,shadowMaterialHorizontal.needsUpdate=!0),shadowMaterialVertical.uniforms.shadow_pass.value=light.map.texture,shadowMaterialVertical.uniforms.resolution.value=light.mapSize,shadowMaterialVertical.uniforms.radius.value=light.radius,_renderer.setRenderTarget(light.mapPass),_renderer.clear(),_renderer.renderBufferDirect(shadowFrameExtents,null,vp,shadowMaterialVertical,fullScreenMesh,
null),shadowMaterialHorizontal.uniforms.shadow_pass.value=light.mapPass.texture,shadowMaterialHorizontal.uniforms.resolution.value=light.mapSize,shadowMaterialHorizontal.uniforms.radius.value=light.radius,_renderer.setRenderTarget(light.map),_renderer.clear(),_renderer.renderBufferDirect(shadowFrameExtents,null,vp,shadowMaterialHorizontal,fullScreenMesh,null));shadow.needsUpdate=!1}}scope.needsUpdate=!1;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,activeMipmapLevel)}}};var _constants=
require("module$node_modules$three$src$constants"),_WebGLRenderTarget=require("module$node_modules$three$src$renderers$WebGLRenderTarget"),_MeshDepthMaterial=require("module$node_modules$three$src$materials$MeshDepthMaterial"),_MeshDistanceMaterial=require("module$node_modules$three$src$materials$MeshDistanceMaterial"),_ShaderMaterial=require("module$node_modules$three$src$materials$ShaderMaterial"),_BufferAttribute=require("module$node_modules$three$src$core$BufferAttribute"),_BufferGeometry=require("module$node_modules$three$src$core$BufferGeometry"),
_Mesh=require("module$node_modules$three$src$objects$Mesh"),_Vector=require("module$node_modules$three$src$math$Vector4"),_Vector2=require("module$node_modules$three$src$math$Vector2"),_Frustum=require("module$node_modules$three$src$math$Frustum"),vsm=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);
var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$three$src$renderers$shaders$ShaderLib$vsm_glsl"))}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLShadowMap.js.map
