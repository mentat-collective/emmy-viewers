shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$draw$grid=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;
if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,
desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}Object.defineProperty(exports,"__esModule",{value:!0});exports.Grid=void 0;var UAxis=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$axis")),UJS=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$js"));global=require("module$node_modules$mathbox$build$esm$primitives$primitive");class Grid extends global.Primitive{static initClass(){this.traits="node object visible style line grid area position origin shade axis:x axis:y scale:x scale:y span:x span:y".split(" ");
this.defaults={width:1,zBias:-2}}constructor(node,context,helpers){super(node,context,helpers);this.axes=null}make(){let axis,mask=this._helpers.object.mask();const material=this._helpers.shade.pipeline()||!1;axis=(first,second,transpose)=>{var position,detail=this._get(first+"axis.detail");const samples=detail+1;detail=1/detail;const strips=this._helpers.scale.divide(second),buffer=this._renderables.make("dataBuffer",{width:strips,channels:1});var positionUniforms={gridPosition:this._attributes.make(this._types.vec4()),
gridStep:this._attributes.make(this._types.vec4()),gridAxis:this._attributes.make(this._types.vec4())};const values={gridPosition:positionUniforms.gridPosition.value,gridStep:positionUniforms.gridStep.value,gridAxis:positionUniforms.gridAxis.value};var p=position=this._shaders.shader();null!=transpose&&null!=mask&&(mask=this._helpers.position.swizzle(mask,transpose));p.require(buffer.shader(this._shaders.shader(),2));p.pipe("grid.position",positionUniforms);position=this._helpers.position.pipeline(p);
transpose=this._helpers.style.uniforms();positionUniforms=this._helpers.line.uniforms();p=this._inherit("unit").getUnitUniforms();transpose=UJS.merge(positionUniforms,transpose,p);position=this._renderables.make("line",{uniforms:transpose,samples,strips,position,stroke,join,mask,material});return{first,second,resolution:detail,samples,line:position,buffer,values}};const {lineX,lineY,crossed,axes}=this.props;var transpose$jscomp$0=["0000","x000","y000","z000","w000"][axes[1]];const {stroke,join}=this.props;
this.axes=[];lineX&&this.axes.push(axis("x.","y.",null));lineY&&this.axes.push(axis("y.","x.",crossed?null:transpose$jscomp$0));transpose$jscomp$0=(()=>{const result=[];for(axis of this.axes)result.push(axis.line);return result})();this._helpers.visible.make();this._helpers.object.make(transpose$jscomp$0);this._helpers.span.make();return this._listen(this,"span.range",this.updateRanges)}unmake(){this._helpers.visible.unmake();this._helpers.object.unmake();this._helpers.span.unmake();for(const axis of this.axes)axis.buffer.dispose();
this.axes=null}change(changed,touched,init){if(changed["x.axis.detail"]||changed["y.axis.detail"]||changed["x.axis.factor"]||changed["y.axis.factor"]||changed["grid.lineX"]||changed["grid.lineY"]||changed["line.stroke"]||changed["line.join"]||changed["grid.crossed"]||changed["grid.axes"]&&this.props.crossed)return this.rebuild();if(touched.x||touched.y||touched.area||touched.grid||touched.view||touched.origin||init)return this.updateRanges()}updateRanges(){const axis$jscomp$0=(x,y,range1,range2,axis)=>
{const {second,resolution,samples,line,buffer,values}=axis;axis=range1.x;range1=range1.y;UAxis.setDimension(values.gridPosition,x).multiplyScalar(axis);UAxis.setDimension(values.gridStep,x).multiplyScalar((range1-axis)*resolution);UAxis.addOrigin(values.gridPosition,axes,origin);axis=range2.x;range1=range2.y;x=this._helpers.scale.generate(second,buffer,axis,range1);UAxis.setDimension(values.gridAxis,y);return line.geometry.clip(samples,x.length,1,1)},{axes,origin}=this.props,range1=this._helpers.span.get("x.",
axes[0]),range2=this._helpers.span.get("y.",axes[1]),{lineX,lineY}=this.props;lineX&&axis$jscomp$0(axes[0],axes[1],range1,range2,this.axes[0]);lineY&&axis$jscomp$0(axes[1],axes[0],range2,range1,this.axes[+lineX]);window.cake1=this.axes[0].buffer;window.cake2=this.axes[1].buffer;window.cake3=this.axes[0]}}exports.Grid=Grid;Grid.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$draw$grid.js.map
