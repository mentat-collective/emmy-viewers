{"version":3,"sources":["rewrite_clj/node.cljc"],"mappings":"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","names":["rewrite-clj.node/coerce","form","rewrite-clj.node.protocols/coerce","rewrite-clj.node/children","node","rewrite-clj.node.protocols/children","var_args","G__75145","rewrite-clj.node/child-sexprs","js/Error","rewrite_clj.node.protocols.child_sexprs","opts","rewrite-clj.node/inner?","rewrite-clj.node.protocols/inner?","rewrite-clj.node/leader-length","rewrite-clj.node.protocols/leader-length","rewrite-clj.node/length","rewrite-clj.node.protocols/length","rewrite-clj.node/node?","x","rewrite-clj.node.protocols/node?","rewrite-clj.node/printable-only?","rewrite-clj.node.protocols/printable-only?","rewrite-clj.node/replace-children","children","rewrite-clj.node.protocols/replace-children","G__75151","rewrite-clj.node/sexpr","rewrite_clj.node.protocols.sexpr","rewrite-clj.node/sexpr-able?","rewrite-clj.node.protocols/sexpr-able?","G__75155","rewrite-clj.node/sexprs","nodes","rewrite_clj.node.protocols.sexprs","rewrite-clj.node/map-context-apply","map-qualifier","rewrite-clj.node.protocols/map-context-apply","rewrite-clj.node/map-context-clear","rewrite-clj.node.protocols/map-context-clear","rewrite-clj.node/string","rewrite-clj.node.protocols/string","rewrite-clj.node/tag","rewrite-clj.node.protocols/tag","rewrite-clj.node/value","rewrite-clj.node.protocols/value","G__75157","rewrite-clj.node/comment-node","s","rewrite_clj.node.comment.comment_node","prefix","rewrite-clj.node/comment?","rewrite-clj.node.comment/comment?","rewrite-clj.node/whitespace-or-comment?","rewrite-clj.node.extras/whitespace-or-comment?","rewrite-clj.node/fn-node","rewrite-clj.node.fn/fn-node","rewrite-clj.node/forms-node","rewrite-clj.node.forms/forms-node","G__75159","rewrite-clj.node/integer-node","value","rewrite_clj.node.integer.integer_node","base","G__75164","rewrite-clj.node/keyword-node","k","auto-resolved?","rewrite_clj.node.keyword.keyword_node","rewrite-clj.node/keyword-node?","n","rewrite-clj.node.keyword/keyword-node?","G__75167","rewrite-clj.node/meta-node","rewrite_clj.node.meta.meta_node","metadata","data","G__75170","rewrite-clj.node/raw-meta-node","rewrite_clj.node.meta.raw_meta_node","rewrite-clj.node/map-qualifier-node","rewrite-clj.node.namespaced-map/map-qualifier-node","rewrite-clj.node/namespaced-map-node","rewrite-clj.node.namespaced-map/namespaced-map-node","rewrite-clj.node/regex-node","pattern-string","rewrite-clj.node.regex/regex-node","rewrite-clj.node/deref-node","rewrite-clj.node.reader-macro/deref-node","rewrite-clj.node/eval-node","rewrite-clj.node.reader-macro/eval-node","G__75180","rewrite-clj.node/reader-macro-node","rewrite_clj.node.reader_macro.reader_macro_node","macro-node","form-node","rewrite-clj.node/var-node","rewrite-clj.node.reader-macro/var-node","rewrite-clj.node/list-node","rewrite-clj.node.seq/list-node","rewrite-clj.node/map-node","rewrite-clj.node.seq/map-node","rewrite-clj.node/set-node","rewrite-clj.node.seq/set-node","rewrite-clj.node/vector-node","rewrite-clj.node.seq/vector-node","rewrite-clj.node/string-node","lines","rewrite-clj.node.stringz/string-node","rewrite-clj.node/quote-node","rewrite-clj.node.quote/quote-node","rewrite-clj.node/syntax-quote-node","rewrite-clj.node.quote/syntax-quote-node","rewrite-clj.node/unquote-node","rewrite-clj.node.quote/unquote-node","rewrite-clj.node/unquote-splicing-node","rewrite-clj.node.quote/unquote-splicing-node","G__75184","rewrite-clj.node/token-node","rewrite_clj.node.token.token_node","string-value","rewrite-clj.node/symbol-node?","rewrite-clj.node.token/symbol-node?","rewrite-clj.node/uneval-node","rewrite-clj.node.uneval/uneval-node","rewrite-clj.node/comma-separated","rewrite-clj.node.whitespace/comma-separated","rewrite-clj.node/line-separated","rewrite-clj.node.whitespace/line-separated","rewrite-clj.node/linebreak?","rewrite-clj.node.whitespace/linebreak?","rewrite-clj.node/newlines","rewrite-clj.node.whitespace/newlines","rewrite-clj.node/newline-node","rewrite-clj.node.whitespace/newline-node","rewrite-clj.node/spaces","rewrite-clj.node.whitespace/spaces","rewrite-clj.node/whitespace-node","rewrite-clj.node.whitespace/whitespace-node","rewrite-clj.node/whitespace?","rewrite-clj.node.whitespace/whitespace?","rewrite-clj.node/comma-node","rewrite-clj.node.whitespace/comma-node","rewrite-clj.node/comma?","rewrite-clj.node.whitespace/comma?","rewrite-clj.node/whitespace-nodes","rewrite-clj.node.whitespace/whitespace-nodes"],"sourcesContent":[";; DO NOT EDIT FILE, automatically generated from: ./template/rewrite_clj/node.cljc\n(ns rewrite-clj.node\n  \"Create, update, convert and integorate nodes.\n\n  All nodes represent Clojure/ClojureScript/EDN.\n\n  Because this API contains many functions, we offer the following categorized listing:\n\n  **Node creation**\n  [[comma-node]]\n  [[comment-node]]\n  [[deref-node]]\n  [[eval-node]]\n  [[fn-node]]\n  [[forms-node]]\n  [[integer-node]]\n  [[keyword-node]]\n  [[list-node]]\n  [[map-node]]\n  [[map-qualifier-node]]\n  [[meta-node]]\n  [[namespaced-map-node]]\n  [[newline-node]]\n  [[quote-node]]\n  [[raw-meta-node]]\n  [[reader-macro-node]]\n  [[regex-node]]\n  [[set-node]]\n  [[string-node]]\n  [[syntax-quote-node]]\n  [[token-node]]\n  [[uneval-node]]\n  [[unquote-node]]\n  [[unquote-splicing-node]]\n  [[var-node]]\n  [[vector-node]]\n  [[whitespace-node]]\n\n  **Whitespace creation convenience**\n  [[spaces]]\n  [[newlines]]\n  [[comma-separated]]\n  [[line-separated]]\n  [[whitespace-nodes]]\n\n  **Convert form to node**\n  [[coerce]]\n\n  **Convert node to form**\n  [[sexpr-able?]]\n  [[sexpr]]\n  [[sexprs]]\n  [[child-sexprs]]\n\n  **Convert node to string**\n  [[string]]\n\n  **Node interogation**\n  [[tag]]\n  [[inner?]]\n  [[children]]\n  [[length]]\n  [[leader-length]]\n  [[printable-only?]]\n\n  **Update node**\n  [[replace-children]]\n\n  **Namespaced map element support**\n  [[map-context-apply]]\n  [[map-context-clear]]\n\n  **Test type**\n  [[node?]]\n  [[comment?]]\n  [[whitespace-or-comment?]]\n  [[keyword-node?]]\n  [[symbol-node?]]\n  [[linebreak?]]\n  [[comma?]]\"\n  ^{:added \"0.4.0\"}\n  (:refer-clojure :exclude [string coerce])\n  (:require [rewrite-clj.node.coercer]\n            [rewrite-clj.node.comment]\n            [rewrite-clj.node.extras]\n            [rewrite-clj.node.fn]\n            [rewrite-clj.node.forms]\n            [rewrite-clj.node.integer]\n            [rewrite-clj.node.keyword]\n            [rewrite-clj.node.meta]\n            [rewrite-clj.node.namespaced-map]\n            [rewrite-clj.node.protocols]\n            [rewrite-clj.node.quote]\n            [rewrite-clj.node.reader-macro]\n            [rewrite-clj.node.regex]\n            [rewrite-clj.node.seq]\n            [rewrite-clj.node.stringz]\n            [rewrite-clj.node.token]\n            [rewrite-clj.node.uneval]\n            [rewrite-clj.node.whitespace]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## API Facade\n\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn coerce\n  \"Coerce `form` to node.\"\n  [form] (rewrite-clj.node.protocols/coerce form))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn children\n  \"Returns child nodes for `node`.\"\n  [node] (rewrite-clj.node.protocols/children node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn child-sexprs\n  \"Returns children for `node` converted to Clojure forms.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\"\n  ([node] (rewrite-clj.node.protocols/child-sexprs node))\n  ([node opts] (rewrite-clj.node.protocols/child-sexprs node opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn inner?\n  \"Returns true if `node` can have children.\"\n  [node] (rewrite-clj.node.protocols/inner? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn leader-length\n  \"Returns number of characters before children for `node`.\"\n  [node] (rewrite-clj.node.protocols/leader-length node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn length\n  \"Return number of characters for the string version of `node`.\"\n  [node] (rewrite-clj.node.protocols/length node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn node?\n  \"Returns true if `x` is a rewrite-clj created node.\"\n  [x] (rewrite-clj.node.protocols/node? x))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn printable-only?\n  \"Return true if `node` cannot be converted to an s-expression element.\"\n  [node] (rewrite-clj.node.protocols/printable-only? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn replace-children\n  \"Returns `node` replacing current children with `children`.\"\n  [node children] (rewrite-clj.node.protocols/replace-children node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn sexpr\n  \"Return `node` converted to form.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  ([node] (rewrite-clj.node.protocols/sexpr node))\n  ([node opts] (rewrite-clj.node.protocols/sexpr node opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn sexpr-able?\n  \"Return true if [[sexpr]] is supported for `node`'s element type.\n\n   See [related docs in user guide](/doc/01-user-guide.adoc#not-all-clojure-is-sexpr-able)\"\n  [node] (rewrite-clj.node.protocols/sexpr-able? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn sexprs\n  \"Return forms for `nodes`. Nodes that do not represent s-expression are skipped.\n\n  Optional `opts` can specify:\n  - `:auto-resolve` specify a function to customize namespaced element auto-resolve behavior, see [docs on namespaced elements](/doc/01-user-guide.adoc#namespaced-elements)\n\n  See docs for [sexpr nuances](/doc/01-user-guide.adoc#sexpr-nuances).\"\n  ([nodes] (rewrite-clj.node.protocols/sexprs nodes))\n  ([nodes opts] (rewrite-clj.node.protocols/sexprs nodes opts)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn map-context-apply\n  \"Applies `map-qualifier` context to `node`\"\n  [node map-qualifier] (rewrite-clj.node.protocols/map-context-apply node map-qualifier))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn map-context-clear\n  \"Removes map-qualifier context for `node`\"\n  [node] (rewrite-clj.node.protocols/map-context-clear node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn string\n  \"Return the string version of `node`.\"\n  [node] (rewrite-clj.node.protocols/string node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn tag\n  \"Returns keyword representing type of `node`.\"\n  [node] (rewrite-clj.node.protocols/tag node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.protocols\n(defn ^{:deprecated \"0.4.0\"} value\n  \"DEPRECATED: Get first child as a pair of tag/sexpr (if inner node),\n   or just the node's own sexpr. (use explicit analysis of `children`\n   `child-sexprs` instead) \"\n  [node] (rewrite-clj.node.protocols/value node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.comment\n(defn comment-node\n  \"Create node representing a comment with text `s`.\n\n   You may optionally specify a `prefix` of `\\\";\\\"` or `\\\"#!\\\"`, defaults is `\\\";\\\"`.\n\n   Argument `s`:\n   - must not include the `prefix`\n   - usually includes the trailing newline character, otherwise subsequent nodes will be on the comment line\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/comment-node \\\"; my comment\\\\n\\\")\n       n/string)\n   ;; => \\\";; my comment\\\\n\\\"\n\n   (-> (n/comment-node \\\"#!\\\" \\\"/usr/bin/env bb\\\\n\\\")\n       n/string)\n   ;; => \\\"#!/usr/bin/env bb\\\\n\\\"\n   ```\"\n  ([s] (rewrite-clj.node.comment/comment-node s))\n  ([prefix s] (rewrite-clj.node.comment/comment-node prefix s)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.comment\n(defn comment?\n  \"Returns true if `node` is a comment.\"\n  [node] (rewrite-clj.node.comment/comment? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.extras\n(defn whitespace-or-comment?\n  \"Check whether the given node represents whitespace or comment.\"\n  [node] (rewrite-clj.node.extras/whitespace-or-comment? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.fn\n(defn fn-node\n  \"Create node representing an anonymous function with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/fn-node [(n/token-node '+)\n                   (n/spaces 1)\n                   (n/token-node 1)\n                   (n/spaces 1)\n                   (n/token-node '%1)])\n       n/string)\n   ;; => \\\"#(+ 1 %1)\\\"\n   ```\"\n  [children] (rewrite-clj.node.fn/fn-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.forms\n(defn forms-node\n  \"Create top-level node wrapping multiple `children`.\n   The forms node is equivalent to an implicit `do` at the top-level.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/forms-node [(n/token-node 1)\n                      (n/spaces 1)\n                      (n/token-node 2)])\n       n/string)\n   ;; => \\\"1 2\\\"\n   ```\n   \"\n  [children] (rewrite-clj.node.forms/forms-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.integer\n(defn integer-node\n  \"Create node representing an integer `value` in `base`.\n\n  `base` defaults to 10.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/integer-node 42)\n       n/string)\n   ;; => \\\"42\\\"\n\n   (-> (n/integer-node 31 2)\n       n/string)\n   ;; => \\\"2r11111\\\"\n   ```\n\n   Note: the parser does not currently parse to integer-nodes, but they fully supported for output.\"\n  ([value] (rewrite-clj.node.integer/integer-node value))\n  ([value base] (rewrite-clj.node.integer/integer-node value base)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.keyword\n(defn keyword-node\n  \"Create a node representing a keyword `k`.\n\n   Optionally include `auto-resolved?`, which defaults to `false`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; unqualified keyword\n   (-> (n/keyword-node :kw)\n       n/string)\n   ;; => \\\":kw\\\"\n\n   ;; qualified keyword\n   (-> (n/keyword-node :my-prefix/kw)\n       n/string)\n   ;; => \\\":my-prefix/kw\\\"\n\n   ;; keyword auto-resolved to current ns\n   (-> (n/keyword-node :kw true)\n       n/string)\n   ;; => \\\"::kw\\\"\n\n   ;; keyword auto-resolved to a namespace with given alias\n   (-> (n/keyword-node :ns-alias/kw true)\n       n/string)\n   ;; => \\\"::ns-alias/kw\\\"\n   ```\"\n  ([k auto-resolved?] (rewrite-clj.node.keyword/keyword-node k auto-resolved?))\n  ([k] (rewrite-clj.node.keyword/keyword-node k)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.keyword\n(defn keyword-node?\n  \"Returns true if `n` is a node representing a keyword.\"\n  [n] (rewrite-clj.node.keyword/keyword-node? n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.meta\n(defn meta-node\n  \"Create a node representing a form with metadata.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/meta-node (n/keyword-node :foo)\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \\\"^:foo [1]\\\"\n\n   (-> (n/meta-node (n/map-node [:foo (n/spaces 1) 42])\n                    (n/vector-node [(n/token-node 1)]))\n       n/string)\n   ;; => \\\"^{:foo 42} [1]\\\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (-> (n/meta-node [(n/keyword-node :foo)\n                     (n/spaces 1)\n                     (n/vector-node [(n/token-node 1)])])\n       n/string)\n   ;; => \\\"^:foo [1]\\\"\n   ```\n   See also: [[raw-meta-node]]\"\n  ([children] (rewrite-clj.node.meta/meta-node children))\n  ([metadata data] (rewrite-clj.node.meta/meta-node metadata data)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.meta\n(defn raw-meta-node\n  \"Create a node representing a form with metadata that renders to the reader syntax.\n\n   When creating manually, you can specify `metadata` and `data` and spacing between the 2 elems will be included:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/raw-meta-node (n/keyword-node :foo)\n                        (n/vector-node [(n/token-node 2)]))\n        n/string)\n   ;; => \\\"#^:foo [2]\\\"\n\n   (-> (n/raw-meta-node (n/map-node [:foo (n/spaces 1) 42])\n                        (n/vector-node [(n/token-node 2)]))\n       n/string)\n   ;; => \\\"#^{:foo 42} [2]\\\"\n   ```\n   When specifying a sequence of `children`, spacing is explicit:\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/raw-meta-node [(n/keyword-node :foo)\n                         (n/spaces 1)\n                         (n/vector-node [(n/token-node 2)])])\n       n/string)\n   ;; => \\\"#^:foo [2]\\\"\n   ```\n   See also: [[meta-node]]\"\n  ([children] (rewrite-clj.node.meta/raw-meta-node children))\n  ([metadata data] (rewrite-clj.node.meta/raw-meta-node metadata data)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.namespaced-map\n(defn map-qualifier-node\n  \"Create a map qualifier node.\n   The map qualifier node is a child node of [[namespaced-map-node]].\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; qualified\n   (-> (n/map-qualifier-node false \\\"my-prefix\\\")\n       n/string)\n   ;; => \\\":my-prefix\\\"\n\n   ;; auto-resolved to current ns\n   (-> (n/map-qualifier-node true nil)\n       n/string)\n   ;; => \\\"::\\\"\n\n   ;; auto-resolve to namespace with alias\n   (-> (n/map-qualifier-node true \\\"my-ns-alias\\\")\n       n/string)\n   ;; => \\\"::my-ns-alias\\\"\n   ```\"\n  [auto-resolved? prefix] (rewrite-clj.node.namespaced-map/map-qualifier-node auto-resolved? prefix))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.namespaced-map\n(defn namespaced-map-node\n  \"Create a namespaced map node with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/namespaced-map-node [(n/map-qualifier-node true \\\"my-ns-alias\\\")\n                               (n/spaces 1)\n                               (n/map-node [(n/keyword-node :a)\n                                            (n/spaces 1)\n                                            (n/token-node 1)])])\n       n/string)\n   ;; => \\\"#::my-ns-alias {:a 1}\\\"\n   ```\n\n   Map qualifier context is automatically applied to map keys for sexpr support.\n\n   See also [[map-qualifier-node]] and [[map-node]].\"\n  [children] (rewrite-clj.node.namespaced-map/namespaced-map-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.regex\n(defn regex-node\n  \"Create node representing a regex with `pattern-string`.\n   Use same escape rules for `pattern-string` as you would for `(re-pattern \\\"pattern-string\\\")`\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/regex-node \\\"my\\\\\\\\.lil.*regex\\\")\n       n/string)\n   ;; => \\\"#\\\\\\\"my\\\\\\\\.lil.*regex\\\\\\\"\\\"\n   ```\"\n  [pattern-string] (rewrite-clj.node.regex/regex-node pattern-string))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn deref-node\n  \"Create node representing the dereferencing of a form\n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/deref-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"@my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between @ and form\n   (-> (n/deref-node [(n/spaces 2)\n                      (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"@  my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.reader-macro/deref-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn eval-node\n  \"Create node representing an inline evaluation\n   where `children` is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/eval-node (n/list-node [(n/token-node 'inc)\n                                  (n/spaces 1)\n                                  (n/token-node 1)]))\n       n/string)\n   ;; => \\\"#=(inc 1)\\\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; prefix and the form\n   (-> (n/eval-node [(n/spaces 3)\n                     (n/list-node [(n/token-node 'inc)\n                                   (n/spaces 1)\n                                   (n/token-node 1)])])\n       n/string)\n   ;; => \\\"#=   (inc 1)\\\"\n   ```\"\n  [children] (rewrite-clj.node.reader-macro/eval-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn reader-macro-node\n  \"Create node representing a reader macro with `macro-node` and `form-node` or `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   ;; here we call with macro-node and form-node\n   (-> (n/reader-macro-node (n/token-node 'my-macro)\n                            (n/token-node 42))\n       n/string)\n   ;; => \\\"#my-macro 42\\\"\n\n   ;; calling with a sequence of children gives us control over whitespace\n   (-> (n/reader-macro-node [(n/token-node 'my-macro)\n                             (n/spaces 4)\n                             (n/token-node 42)])\n       n/string)\n   ;; => \\\"#my-macro    42\\\"\n   ```\"\n  ([children] (rewrite-clj.node.reader-macro/reader-macro-node children))\n  ([macro-node form-node] (rewrite-clj.node.reader-macro/reader-macro-node macro-node form-node)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.reader-macro\n(defn var-node\n  \"Create node representing a var where `children` is either a\n   sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/var-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"#'my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; prefix and the var\n   (-> (n/var-node [(n/spaces 2)\n                    (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"#'  my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.reader-macro/var-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn list-node\n  \"Create a node representing a list with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/list-node [(n/token-node 1)\n                     (n/spaces 1)\n                     (n/token-node 2)\n                     (n/spaces 1)\n                     (n/token-node 3)])\n       n/string)\n   ;; => \\\"(1 2 3)\\\"\n   ```\"\n  [children] (rewrite-clj.node.seq/list-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn map-node\n  \"Create a node representing a map with `children`.\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :b)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \\\"{:a 1 :b 2}\\\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, unbalanced map:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)])\n       (n/string))\n   ;; => \\\"{:a}\\\"\n   ```\n   See [docs on unbalanced maps](/doc/01-user-guide.adoc#unbalanced-maps).\n\n   Rewrite-clj also allows the, also technically illegal, map with duplicate keys:\n   ```Clojure\n   (-> (n/map-node [(n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 1)\n                    (n/spaces 1)\n                    (n/keyword-node :a)\n                    (n/spaces 1)\n                    (n/token-node 2)])\n       (n/string))\n   ;; => \\\"{:a 1 :a 2}\\\"\n   ```\n   See [docs on maps with duplicate keys](/doc/01-user-guide.adoc#maps-with-duplicate-keys).\"\n  [children] (rewrite-clj.node.seq/map-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn set-node\n  \"Create a node representing a set with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 2)\n                    (n/spaces 1)\n                    (n/token-node 3)])\n       n/string)\n   ;; => \\\"#{1 2 3}\\\"\n   ```\n\n   Note that rewrite-clj allows the, technically illegal, set with duplicate values:\n   ```Clojure\n   (-> (n/set-node [(n/token-node 1)\n                    (n/spaces 1)\n                    (n/token-node 1)])\n       (n/string))\n   ;; => \\\"#{1 1}\\\"\n   ```\n\n   See [docs on sets with duplicate values](/doc/01-user-guide.adoc#sets-with-duplicate-values).\"\n  [children] (rewrite-clj.node.seq/set-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.seq\n(defn vector-node\n  \"Create a node representing a vector with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/vector-node [(n/token-node 1)\n                       (n/spaces 1)\n                       (n/token-node 2)\n                       (n/spaces 1)\n                       (n/token-node 3)])\n       n/string)\n   ;; => \\\"[1 2 3]\\\"\n   ```\"\n  [children] (rewrite-clj.node.seq/vector-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.stringz\n(defn string-node\n  \"Create node representing a string value where `lines` can be a sequence of strings or a single string.\n\n  When `lines` is a sequence, the resulting node will `tag` will be `:multi-line`, otherwise `:token`.\n\n  ```Clojure\n  (require '[rewrite-clj.node :as n])\n\n  (-> (n/string-node \\\"hello\\\")\n      n/string)\n  ;; => \\\"\\\\\\\"hello\\\\\\\"\\\"\n\n  (-> (n/string-node [\\\"line1\\\" \\\"\\\" \\\"line3\\\"])\n       n/string)\n  ;; => \\\"\\\\\\\"line1\\\\n\\\\nline3\\\\\\\"\\\"\n  ```\"\n  [lines] (rewrite-clj.node.stringz/string-node lines))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn quote-node\n  \"Create node representing a single quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/quote-node (n/token-node 'sym))\n       (n/string))\n   ;; => \\\"'sym\\\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; quote and the quoted\n   (-> (n/quote-node [(n/spaces 10)\n                      (n/token-node 'sym1) ])\n       n/string)\n   ;; => \\\"'          sym1\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/quote-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn syntax-quote-node\n  \"Create node representing a single syntax-quoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/syntax-quote-node (n/token-node 'map))\n       n/string)\n   ;; => \\\"`map\\\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; syntax quote and the syntax quoted\n   (-> (n/syntax-quote-node [(n/spaces 3)\n                             (n/token-node 'map)])\n       n/string)\n   ;; => \\\"`   map\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/syntax-quote-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn unquote-node\n  \"Create node representing a single unquoted form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"~my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; unquote and the uquoted\n   (-> (n/unquote-node [(n/spaces 4)\n                        (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"~    my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/unquote-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.quote\n(defn unquote-splicing-node\n  \"Create node representing a single unquote-spliced form where `children`\n   is either a sequence of nodes or a single node.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/unquote-splicing-node (n/token-node 'my-var))\n       n/string)\n   ;; => \\\"~@my-var\\\"\n\n   ;; specifying a sequence allows for whitespace between the\n   ;; splicing unquote and the splicing unquoted\n   (-> (n/unquote-splicing-node [(n/spaces 2)\n                                 (n/token-node 'my-var)])\n       n/string)\n   ;; => \\\"~@  my-var\\\"\n   ```\"\n  [children] (rewrite-clj.node.quote/unquote-splicing-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.token\n(defn token-node\n  \"Create node for an unspecified token of `value`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/token-node 'sym) n/string)\n   ;; => \\\"sym\\\"\n\n   (-> (n/token-node 42) n/string)\n   ;; => \\\"42\\\"\n   ```\"\n  ([value] (rewrite-clj.node.token/token-node value))\n  ([value string-value] (rewrite-clj.node.token/token-node value string-value)))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.token\n(defn symbol-node?\n  \"Returns true if `n` is a node representing a symbol.\"\n  [n] (rewrite-clj.node.token/symbol-node? n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.uneval\n(defn uneval-node\n  \"Create node representing an unevaled form with `children`.\n\n   ```Clojure\n   (require '[rewrite-clj.node :as n])\n\n   (-> (n/uneval-node [(n/spaces 1)\n                       (n/token-node 42)])\n       n/string)\n   ;; => \\\"#_ 42\\\"\n   ```\"\n  [children] (rewrite-clj.node.uneval/uneval-node children))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn comma-separated\n  \"Interleave `nodes` with `\\\", \\\"` nodes.\"\n  [nodes] (rewrite-clj.node.whitespace/comma-separated nodes))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn line-separated\n  \"Interleave `nodes` with newline nodes.\"\n  [nodes] (rewrite-clj.node.whitespace/line-separated nodes))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn linebreak?\n  \"Returns true if `node` represents one or more linebreaks.\"\n  [node] (rewrite-clj.node.whitespace/linebreak? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn newlines\n  \"Create node representing `n` newline characters.\"\n  [n] (rewrite-clj.node.whitespace/newlines n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn newline-node\n  \"Create newline node of string `s`, where `s` is one or more linebreak characters.\"\n  [s] (rewrite-clj.node.whitespace/newline-node s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn spaces\n  \"Create node representing `n` spaces.\"\n  [n] (rewrite-clj.node.whitespace/spaces n))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn whitespace-node\n  \"Create whitespace node of string `s`, where `s` is one or more space characters.\"\n  [s] (rewrite-clj.node.whitespace/whitespace-node s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn whitespace?\n  \"Returns true if `node` represents Clojure whitespace.\"\n  [node] (rewrite-clj.node.whitespace/whitespace? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn comma-node\n  \"Create comma node of string `s`, where `s` is one or more comma characters.\"\n  [s] (rewrite-clj.node.whitespace/comma-node s))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn comma?\n  \"Returns true if `node` represents one or more commas.\"\n  [node] (rewrite-clj.node.whitespace/comma? node))\n\n;; DO NOT EDIT FILE, automatically imported from: rewrite-clj.node.whitespace\n(defn whitespace-nodes\n  \"Convert string `s` of whitespace to whitespace/newline nodes.\"\n  [s] (rewrite-clj.node.whitespace/whitespace-nodes s))\n"]}