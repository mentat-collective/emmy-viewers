shadow$provide.module$node_modules$three$examples$jsm$controls$OrbitControls=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.MapControls=exports.OrbitControls=void 0;var _three=require("module$node_modules$three$build$three");const _changeEvent={type:"change"},_startEvent={type:"start"},_endEvent={type:"end"};class OrbitControls extends _three.EventDispatcher{constructor(object,domElement$jscomp$0){function getZoomScale(){return Math.pow(.95,
scope.zoomSpeed)}function dollyOut(dollyScale){scope.object.isPerspectiveCamera?scale/=dollyScale:scope.object.isOrthographicCamera?(scope.object.zoom=Math.max(scope.minZoom,Math.min(scope.maxZoom,scope.object.zoom*dollyScale)),scope.object.updateProjectionMatrix(),zoomChanged=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),scope.enableZoom=!1)}function dollyIn(dollyScale){scope.object.isPerspectiveCamera?scale*=dollyScale:scope.object.isOrthographicCamera?
(scope.object.zoom=Math.max(scope.minZoom,Math.min(scope.maxZoom,scope.object.zoom/dollyScale)),scope.object.updateProjectionMatrix(),zoomChanged=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),scope.enableZoom=!1)}function handleTouchStartRotate(){1===pointers.length?rotateStart.set(pointers[0].pageX,pointers[0].pageY):rotateStart.set(.5*(pointers[0].pageX+pointers[1].pageX),.5*(pointers[0].pageY+pointers[1].pageY))}function handleTouchStartPan(){1===
pointers.length?panStart.set(pointers[0].pageX,pointers[0].pageY):panStart.set(.5*(pointers[0].pageX+pointers[1].pageX),.5*(pointers[0].pageY+pointers[1].pageY))}function handleTouchStartDolly(){const dx=pointers[0].pageX-pointers[1].pageX,dy=pointers[0].pageY-pointers[1].pageY;dollyStart.set(0,Math.sqrt(dx*dx+dy*dy))}function handleTouchMoveRotate(event){if(1==pointers.length)rotateEnd.set(event.pageX,event.pageY);else{const position=getSecondPointerPosition(event);rotateEnd.set(.5*(event.pageX+
position.x),.5*(event.pageY+position.y))}rotateDelta.subVectors(rotateEnd,rotateStart).multiplyScalar(scope.rotateSpeed);event=scope.domElement;sphericalDelta.theta-=2*Math.PI*rotateDelta.x/event.clientHeight;sphericalDelta.phi-=2*Math.PI*rotateDelta.y/event.clientHeight;rotateStart.copy(rotateEnd)}function handleTouchMovePan(event){if(1===pointers.length)panEnd.set(event.pageX,event.pageY);else{const position=getSecondPointerPosition(event);panEnd.set(.5*(event.pageX+position.x),.5*(event.pageY+
position.y))}panDelta.subVectors(panEnd,panStart).multiplyScalar(scope.panSpeed);pan(panDelta.x,panDelta.y);panStart.copy(panEnd)}function handleTouchMoveDolly(event){const position=getSecondPointerPosition(event),dx=event.pageX-position.x;event=event.pageY-position.y;dollyEnd.set(0,Math.sqrt(dx*dx+event*event));dollyDelta.set(0,Math.pow(dollyEnd.y/dollyStart.y,scope.zoomSpeed));dollyOut(dollyDelta.y);dollyStart.copy(dollyEnd)}function onPointerDown(event){!1!==scope.enabled&&(0===pointers.length&&
(scope.domElement.setPointerCapture(event.pointerId),scope.domElement.addEventListener("pointermove",onPointerMove),scope.domElement.addEventListener("pointerup",onPointerUp)),pointers.push(event),"touch"===event.pointerType?onTouchStart(event):onMouseDown(event))}function onPointerMove(event){if(!1!==scope.enabled)if("touch"===event.pointerType)switch(trackPointer(event),state){case STATE.TOUCH_ROTATE:if(!1===scope.enableRotate)break;handleTouchMoveRotate(event);scope.update();break;case STATE.TOUCH_PAN:if(!1===
scope.enablePan)break;handleTouchMovePan(event);scope.update();break;case STATE.TOUCH_DOLLY_PAN:if(!1===scope.enableZoom&&!1===scope.enablePan)break;scope.enableZoom&&handleTouchMoveDolly(event);scope.enablePan&&handleTouchMovePan(event);scope.update();break;case STATE.TOUCH_DOLLY_ROTATE:if(!1===scope.enableZoom&&!1===scope.enableRotate)break;scope.enableZoom&&handleTouchMoveDolly(event);scope.enableRotate&&handleTouchMoveRotate(event);scope.update();break;default:state=STATE.NONE}else if(!1!==scope.enabled)switch(state){case STATE.ROTATE:if(!1===
scope.enableRotate)break;rotateEnd.set(event.clientX,event.clientY);rotateDelta.subVectors(rotateEnd,rotateStart).multiplyScalar(scope.rotateSpeed);event=scope.domElement;sphericalDelta.theta-=2*Math.PI*rotateDelta.x/event.clientHeight;sphericalDelta.phi-=2*Math.PI*rotateDelta.y/event.clientHeight;rotateStart.copy(rotateEnd);scope.update();break;case STATE.DOLLY:if(!1===scope.enableZoom)break;dollyEnd.set(event.clientX,event.clientY);dollyDelta.subVectors(dollyEnd,dollyStart);0<dollyDelta.y?dollyOut(getZoomScale()):
0>dollyDelta.y&&dollyIn(getZoomScale());dollyStart.copy(dollyEnd);scope.update();break;case STATE.PAN:!1!==scope.enablePan&&(panEnd.set(event.clientX,event.clientY),panDelta.subVectors(panEnd,panStart).multiplyScalar(scope.panSpeed),pan(panDelta.x,panDelta.y),panStart.copy(panEnd),scope.update())}}function onPointerUp(event){removePointer(event);0===pointers.length&&(scope.domElement.releasePointerCapture(event.pointerId),scope.domElement.removeEventListener("pointermove",onPointerMove),scope.domElement.removeEventListener("pointerup",
onPointerUp));scope.dispatchEvent(_endEvent);state=STATE.NONE}function onPointerCancel(event){removePointer(event)}function onMouseDown(event){let mouseAction;switch(event.button){case 0:mouseAction=scope.mouseButtons.LEFT;break;case 1:mouseAction=scope.mouseButtons.MIDDLE;break;case 2:mouseAction=scope.mouseButtons.RIGHT;break;default:mouseAction=-1}switch(mouseAction){case _three.MOUSE.DOLLY:if(!1===scope.enableZoom)return;dollyStart.set(event.clientX,event.clientY);state=STATE.DOLLY;break;case _three.MOUSE.ROTATE:if(event.ctrlKey||
event.metaKey||event.shiftKey){if(!1===scope.enablePan)return;panStart.set(event.clientX,event.clientY);state=STATE.PAN}else{if(!1===scope.enableRotate)return;rotateStart.set(event.clientX,event.clientY);state=STATE.ROTATE}break;case _three.MOUSE.PAN:if(event.ctrlKey||event.metaKey||event.shiftKey){if(!1===scope.enableRotate)return;rotateStart.set(event.clientX,event.clientY);state=STATE.ROTATE}else{if(!1===scope.enablePan)return;panStart.set(event.clientX,event.clientY);state=STATE.PAN}break;default:state=
STATE.NONE}state!==STATE.NONE&&scope.dispatchEvent(_startEvent)}function onMouseWheel(event){!1!==scope.enabled&&!1!==scope.enableZoom&&state===STATE.NONE&&(event.preventDefault(),scope.dispatchEvent(_startEvent),0>event.deltaY?dollyIn(getZoomScale()):0<event.deltaY&&dollyOut(getZoomScale()),scope.update(),scope.dispatchEvent(_endEvent))}function onKeyDown(event){if(!1!==scope.enabled&&!1!==scope.enablePan){var needsUpdate=!1;switch(event.code){case scope.keys.UP:pan(0,scope.keyPanSpeed);needsUpdate=
!0;break;case scope.keys.BOTTOM:pan(0,-scope.keyPanSpeed);needsUpdate=!0;break;case scope.keys.LEFT:pan(scope.keyPanSpeed,0);needsUpdate=!0;break;case scope.keys.RIGHT:pan(-scope.keyPanSpeed,0),needsUpdate=!0}needsUpdate&&(event.preventDefault(),scope.update())}}function onTouchStart(event){trackPointer(event);switch(pointers.length){case 1:switch(scope.touches.ONE){case _three.TOUCH.ROTATE:if(!1===scope.enableRotate)return;handleTouchStartRotate();state=STATE.TOUCH_ROTATE;break;case _three.TOUCH.PAN:if(!1===
scope.enablePan)return;handleTouchStartPan();state=STATE.TOUCH_PAN;break;default:state=STATE.NONE}break;case 2:switch(scope.touches.TWO){case _three.TOUCH.DOLLY_PAN:if(!1===scope.enableZoom&&!1===scope.enablePan)return;scope.enableZoom&&handleTouchStartDolly();scope.enablePan&&handleTouchStartPan();state=STATE.TOUCH_DOLLY_PAN;break;case _three.TOUCH.DOLLY_ROTATE:if(!1===scope.enableZoom&&!1===scope.enableRotate)return;scope.enableZoom&&handleTouchStartDolly();scope.enableRotate&&handleTouchStartRotate();
state=STATE.TOUCH_DOLLY_ROTATE;break;default:state=STATE.NONE}break;default:state=STATE.NONE}state!==STATE.NONE&&scope.dispatchEvent(_startEvent)}function onContextMenu(event){!1!==scope.enabled&&event.preventDefault()}function removePointer(event){delete pointerPositions[event.pointerId];for(let i=0;i<pointers.length;i++)if(pointers[i].pointerId==event.pointerId){pointers.splice(i,1);break}}function trackPointer(event){let position=pointerPositions[event.pointerId];void 0===position&&(position=new _three.Vector2,
pointerPositions[event.pointerId]=position);position.set(event.pageX,event.pageY)}function getSecondPointerPosition(event){return pointerPositions[(event.pointerId===pointers[0].pointerId?pointers[1]:pointers[0]).pointerId]}super();void 0===domElement$jscomp$0&&console.warn('THREE.OrbitControls: The second parameter "domElement" is now mandatory.');domElement$jscomp$0===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.');
this.object=object;this.domElement=domElement$jscomp$0;this.domElement.style.touchAction="none";this.enabled=!0;this.target=new _three.Vector3;this.minDistance=0;this.maxDistance=Infinity;this.minZoom=0;this.maxZoom=Infinity;this.minPolarAngle=0;this.maxPolarAngle=Math.PI;this.minAzimuthAngle=-Infinity;this.maxAzimuthAngle=Infinity;this.enableDamping=!1;this.dampingFactor=.05;this.enableZoom=!0;this.zoomSpeed=1;this.enableRotate=!0;this.rotateSpeed=1;this.enablePan=!0;this.panSpeed=1;this.screenSpacePanning=
!0;this.keyPanSpeed=7;this.autoRotate=!1;this.autoRotateSpeed=2;this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"};this.mouseButtons={LEFT:_three.MOUSE.ROTATE,MIDDLE:_three.MOUSE.DOLLY,RIGHT:_three.MOUSE.PAN};this.touches={ONE:_three.TOUCH.ROTATE,TWO:_three.TOUCH.DOLLY_PAN};this.target0=this.target.clone();this.position0=this.object.position.clone();this.zoom0=this.object.zoom;this._domElementKeyEvents=null;this.getPolarAngle=function(){return spherical.phi};this.getAzimuthalAngle=
function(){return spherical.theta};this.getDistance=function(){return this.object.position.distanceTo(this.target)};this.listenToKeyEvents=function(domElement){domElement.addEventListener("keydown",onKeyDown);this._domElementKeyEvents=domElement};this.saveState=function(){scope.target0.copy(scope.target);scope.position0.copy(scope.object.position);scope.zoom0=scope.object.zoom};this.reset=function(){scope.target.copy(scope.target0);scope.object.position.copy(scope.position0);scope.object.zoom=scope.zoom0;
scope.object.updateProjectionMatrix();scope.dispatchEvent(_changeEvent);scope.update();state=STATE.NONE};this.update=function(){const offset=new _three.Vector3,quat=(new _three.Quaternion).setFromUnitVectors(object.up,new _three.Vector3(0,1,0)),quatInverse=quat.clone().invert(),lastPosition=new _three.Vector3,lastQuaternion=new _three.Quaternion,twoPI=2*Math.PI;return function(){const position=scope.object.position;offset.copy(position).sub(scope.target);offset.applyQuaternion(quat);spherical.setFromVector3(offset);
scope.autoRotate&&state===STATE.NONE&&(sphericalDelta.theta-=2*Math.PI/60/60*scope.autoRotateSpeed);scope.enableDamping?(spherical.theta+=sphericalDelta.theta*scope.dampingFactor,spherical.phi+=sphericalDelta.phi*scope.dampingFactor):(spherical.theta+=sphericalDelta.theta,spherical.phi+=sphericalDelta.phi);let min=scope.minAzimuthAngle,max=scope.maxAzimuthAngle;isFinite(min)&&isFinite(max)&&(min<-Math.PI?min+=twoPI:min>Math.PI&&(min-=twoPI),max<-Math.PI?max+=twoPI:max>Math.PI&&(max-=twoPI),spherical.theta=
min<=max?Math.max(min,Math.min(max,spherical.theta)):spherical.theta>(min+max)/2?Math.max(min,spherical.theta):Math.min(max,spherical.theta));spherical.phi=Math.max(scope.minPolarAngle,Math.min(scope.maxPolarAngle,spherical.phi));spherical.makeSafe();spherical.radius*=scale;spherical.radius=Math.max(scope.minDistance,Math.min(scope.maxDistance,spherical.radius));!0===scope.enableDamping?scope.target.addScaledVector(panOffset,scope.dampingFactor):scope.target.add(panOffset);offset.setFromSpherical(spherical);
offset.applyQuaternion(quatInverse);position.copy(scope.target).add(offset);scope.object.lookAt(scope.target);!0===scope.enableDamping?(sphericalDelta.theta*=1-scope.dampingFactor,sphericalDelta.phi*=1-scope.dampingFactor,panOffset.multiplyScalar(1-scope.dampingFactor)):(sphericalDelta.set(0,0,0),panOffset.set(0,0,0));scale=1;return zoomChanged||1E-6<lastPosition.distanceToSquared(scope.object.position)||1E-6<8*(1-lastQuaternion.dot(scope.object.quaternion))?(scope.dispatchEvent(_changeEvent),lastPosition.copy(scope.object.position),
lastQuaternion.copy(scope.object.quaternion),zoomChanged=!1,!0):!1}}();this.dispose=function(){scope.domElement.removeEventListener("contextmenu",onContextMenu);scope.domElement.removeEventListener("pointerdown",onPointerDown);scope.domElement.removeEventListener("pointercancel",onPointerCancel);scope.domElement.removeEventListener("wheel",onMouseWheel);scope.domElement.removeEventListener("pointermove",onPointerMove);scope.domElement.removeEventListener("pointerup",onPointerUp);null!==scope._domElementKeyEvents&&
scope._domElementKeyEvents.removeEventListener("keydown",onKeyDown)};const scope=this,STATE={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let state=STATE.NONE;const spherical=new _three.Spherical,sphericalDelta=new _three.Spherical;let scale=1;const panOffset=new _three.Vector3;let zoomChanged=!1;const rotateStart=new _three.Vector2,rotateEnd=new _three.Vector2,rotateDelta=new _three.Vector2,panStart=new _three.Vector2,panEnd=new _three.Vector2,
panDelta=new _three.Vector2,dollyStart=new _three.Vector2,dollyEnd=new _three.Vector2,dollyDelta=new _three.Vector2,pointers=[],pointerPositions={},panLeft=function(){const v=new _three.Vector3;return function(distance,objectMatrix){v.setFromMatrixColumn(objectMatrix,0);v.multiplyScalar(-distance);panOffset.add(v)}}(),panUp=function(){const v=new _three.Vector3;return function(distance,objectMatrix){!0===scope.screenSpacePanning?v.setFromMatrixColumn(objectMatrix,1):(v.setFromMatrixColumn(objectMatrix,
0),v.crossVectors(scope.object.up,v));v.multiplyScalar(distance);panOffset.add(v)}}(),pan=function(){const offset=new _three.Vector3;return function(deltaX,deltaY){const element=scope.domElement;if(scope.object.isPerspectiveCamera){offset.copy(scope.object.position).sub(scope.target);let targetDistance=offset.length();targetDistance*=Math.tan(scope.object.fov/2*Math.PI/180);panLeft(2*deltaX*targetDistance/element.clientHeight,scope.object.matrix);panUp(2*deltaY*targetDistance/element.clientHeight,
scope.object.matrix)}else scope.object.isOrthographicCamera?(panLeft(deltaX*(scope.object.right-scope.object.left)/scope.object.zoom/element.clientWidth,scope.object.matrix),panUp(deltaY*(scope.object.top-scope.object.bottom)/scope.object.zoom/element.clientHeight,scope.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),scope.enablePan=!1)}}();scope.domElement.addEventListener("contextmenu",onContextMenu);scope.domElement.addEventListener("pointerdown",
onPointerDown);scope.domElement.addEventListener("pointercancel",onPointerCancel);scope.domElement.addEventListener("wheel",onMouseWheel,{passive:!1});this.update()}}exports.OrbitControls=OrbitControls;class MapControls extends OrbitControls{constructor(object,domElement){super(object,domElement);this.screenSpacePanning=!1;this.mouseButtons.LEFT=_three.MOUSE.PAN;this.mouseButtons.RIGHT=_three.MOUSE.ROTATE;this.touches.ONE=_three.TOUCH.PAN;this.touches.TWO=_three.TOUCH.DOLLY_ROTATE}}exports.MapControls=
MapControls}
//# sourceMappingURL=module$node_modules$three$examples$jsm$controls$OrbitControls.js.map
