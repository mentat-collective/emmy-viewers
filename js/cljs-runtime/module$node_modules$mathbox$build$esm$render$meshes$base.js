shadow$provide.module$node_modules$mathbox$build$esm$render$meshes$base=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Base=void 0;var UGLSL=function(obj,
nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;
desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$mathbox$build$esm$util$glsl")),_RawShaderMaterial=require("module$node_modules$three$src$materials$RawShaderMaterial");global=require("module$node_modules$mathbox$build$esm$render$renderable");class Base extends global.Renderable{constructor(renderer,shaders,options){super(renderer,shaders,options);this.zUnits=
null!=options.zUnits?options.zUnits:0}raw(){for(const object of Array.from(this.renders))this._raw(object);return null}depth(write,test){for(const object of Array.from(this.renders))this._depth(object,write,test);return null}polygonOffset(factor,units){for(const object of Array.from(this.renders))this._polygonOffset(object,factor,units);return null}show(transparent,blending,order){return Array.from(this.renders).map(object=>this._show(object,transparent,blending,order))}hide(){for(const object of Array.from(this.renders))this._hide(object);
return null}_injectPreamble(preamble,code){preamble=preamble+"\n"+code;return code.match(/#extension/)?this._hoist(preamble):preamble}_hoist(code){code=code.split("\n");const out=[];for(const line of Array.from(code))line.match(/^\s*#extension/)?out.unshift(line):out.push(line);return out.join("\n")}_material(options){var precision=this.renderer.capabilities.precision;const vertexPrefix=`\
    precision ${precision} float;
    precision ${precision} int;
uniform mat4 modelMatrix;
uniform mat4 modelViewMatrix;
uniform mat4 projectionMatrix;
uniform mat4 viewMatrix;
uniform mat3 normalMatrix;
uniform vec3 cameraPosition;\
`;precision=`\
    precision ${precision} float;
    precision ${precision} int;
uniform mat4 viewMatrix;
uniform vec3 cameraPosition;\
`;const shaderOptions={};Object.assign(shaderOptions,options);delete shaderOptions.attributes;delete shaderOptions.varyings;delete shaderOptions.inspect;delete shaderOptions.vertexGraph;delete shaderOptions.fragmentGraph;const material=new _RawShaderMaterial.RawShaderMaterial(shaderOptions);["vertexGraph","fragmentGraph","inspect"].forEach(key=>material[key]=options[key]);material.vertexShader=this._injectPreamble(vertexPrefix,material.vertexShader);material.fragmentShader=this._injectPreamble(precision,
material.fragmentShader);return material}_raw(object){object.rotationAutoUpdate=!1;object.frustumCulled=!1;object.matrixAutoUpdate=!1;object.material.defaultAttributeValues=void 0}_depth(object,write,test){object=object.material;object.depthWrite=write;return object.depthTest=test}_polygonOffset(object,factor,units){units-=this.zUnits;const enabled=0!==units;object=object.material;if(object.polygonOffset=enabled)return object.polygonOffsetFactor=factor,object.polygonOffsetUnits=units}_show(object,
transparent,blending,order){transparent=object.material;object.renderOrder=-order;object.visible=!0;transparent.transparent=!0;transparent.blending=blending;return null}_hide(object){return object.visible=!1}_vertexColor(color,mask){if(color||mask){var v=this.shaders.shader();color&&(v.require(color),v.pipe("mesh.vertex.color",this.uniforms));mask&&(v.require(mask),v.pipe("mesh.vertex.mask",this.uniforms));return v}}_vertexPosition(position,material,map,channels,stpq){let defs;const v=this.shaders.shader();
if(map||material&&!0!==material){defs={};if(0<channels||stpq)defs.POSITION_MAP="";0<channels&&(defs[["POSITION_U","POSITION_UV","POSITION_UVW","POSITION_UVWO"][channels-1]]="");stpq&&(defs.POSITION_STPQ="")}v.require(position);return v.pipe("mesh.vertex.position",this.uniforms,defs)}_fragmentColor(hasStyle,material,color,mask,map,channels,stpq,combine,linear){const f=this.shaders.shader();let join=!1,gamma=!1;const defs={};0<channels&&(defs[["POSITION_U","POSITION_UV","POSITION_UVW","POSITION_UVWO"][channels-
1]]="");stpq&&(defs.POSITION_STPQ="");hasStyle&&(f.pipe("style.color",this.uniforms),join=!0,color||map||material)&&(linear&&!color||f.pipe("mesh.gamma.in"),gamma=!0);color&&(f.isolate(),f.pipe("mesh.fragment.color",this.uniforms),linear&&!join||f.pipe("mesh.gamma.in"),f.end(),join&&f.pipe(UGLSL.binaryOperator("vec4","*")),linear&&join&&f.pipe("mesh.gamma.out"),gamma=join=!0);map&&(!join&&combine&&f.pipe(UGLSL.constant("vec4","vec4(1.0)")),f.isolate(),f.require(map),f.pipe("mesh.fragment.map",this.uniforms,
defs),linear||f.pipe("mesh.gamma.in"),f.end(),combine?f.pipe(combine):join&&f.pipe(UGLSL.binaryOperator("vec4","*")),gamma=join=!0);material&&(join||f.pipe(UGLSL.constant("vec4","vec4(1.0)")),!0===material?f.pipe("mesh.fragment.shaded",this.uniforms):(f.require(material),f.pipe("mesh.fragment.material",this.uniforms,defs)),gamma=!0);gamma&&!linear&&f.pipe("mesh.gamma.out");mask&&(f.pipe("mesh.fragment.mask",this.uniforms),join&&f.pipe(UGLSL.binaryOperator("vec4","*")));return f}}exports.Base=Base}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$render$meshes$base.js.map
