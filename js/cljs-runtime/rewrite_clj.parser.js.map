{"version":3,"sources":["rewrite_clj/parser.cljc"],"mappings":";;AAgBA;;;2BAAA,3BAAeA,8DAESC;AAFxB,AAGE,OAACC,mCAAaD;;AAEhB;;;+BAAA,/BAAeE,sEAESF;AAFxB,AAGE,IAAMG,8EAAW,mDAAA,nDAACC,tEACD,AAACC,mDAAWC;AADZ,AAAa,OAACP,yBAAMC;;IAE/BO,gBAAc,AAACC,uGAAM,AAACC,eAAK,AAACC,gBAAMP,QACb,4DAAA,mFAAA,2DAAA,1MAACQ,sBAAY,AAACF,eAAK,AAACG,eAAKT;AAHpD,AAKE,OAACU,oBAAU,AAACC,kCAAkBX,OAAOI;;AAIzC;;;kCAAA,lCAAMQ,4EAEHC;AAFH,AAGE,OAACjB,yBAAM,AAACkB,iCAAqBD;;AAE/B;;;sCAAA,tCAAME,oFAEHF;AAFH,AAGE,OAACd,6BAAU,AAACe,iCAAqBD","names":["rewrite-clj.parser/parse","reader","rewrite-clj.parser.core/parse-next","rewrite-clj.parser/parse-all","nodes","cljs.core.repeatedly","cljs.core.take_while","cljs.core/identity","position-meta","cljs.core.merge","cljs.core/meta","cljs.core/first","cljs.core/select-keys","cljs.core/last","cljs.core/with-meta","rewrite-clj.node.forms/forms-node","rewrite-clj.parser/parse-string","s","rewrite-clj.reader/string-reader","rewrite-clj.parser/parse-string-all"],"sourcesContent":["(ns rewrite-clj.parser\n  \"Parse Clojure/ClojureScript/EDN source code to nodes.\n\n  Parsing includes all source code elements including whitespace.\n\n  After parsing, the typical next step is [[rewrite-clj.zip/edn]] to create zipper.\n\n  Alternatively consider parsing and zipping in one step from [[rewrite-clj.zip/of-string]] or [[rewrite-clj.zip/of-file]].\"\n  (:require [rewrite-clj.node.forms :as nforms]\n            [rewrite-clj.parser.core :as p]\n            [rewrite-clj.reader :as reader]))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; ## Parser Core\n\n(defn ^:no-doc parse\n  \"Parse next form from the given reader.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (p/parse-next reader))\n\n(defn ^:no-doc parse-all\n  \"Parse all forms from the given reader.\"\n  [#?(:cljs ^not-native reader :default reader)]\n  (let [nodes (->> (repeatedly #(parse reader))\n                   (take-while identity))\n        position-meta (merge (meta (first nodes))\n                             (select-keys (meta (last nodes))\n                                          [:end-row :end-col]))]\n    (with-meta (nforms/forms-node nodes) position-meta)))\n\n;; ## Specialized Parsers\n\n(defn parse-string\n  \"Return a node for first source code element in string `s`.\"\n  [s]\n  (parse (reader/string-reader s)))\n\n(defn parse-string-all\n  \"Return forms node for all source code elements in string `s`.\"\n  [s]\n  (parse-all (reader/string-reader s)))\n\n#?(:clj\n   (defn parse-file\n     \"Return node for first source code element in file `f`.\"\n     [f]\n     (with-open [r (reader/file-reader f)]\n       (parse r))))\n\n#?(:clj\n   (defn parse-file-all\n     \"Return forms node for all source code elements in file `f`.\"\n     [f]\n     (with-open [r (reader/file-reader f)]\n       (parse-all r))))\n"]}