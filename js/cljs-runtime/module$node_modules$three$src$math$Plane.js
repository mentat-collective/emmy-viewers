shadow$provide.module$node_modules$three$src$math$Plane=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Plane=void 0;global=require("module$node_modules$three$src$math$Matrix3");var _Vector=require("module$node_modules$three$src$math$Vector3");const _vector1=new _Vector.Vector3,_vector2=new _Vector.Vector3,_normalMatrix=new global.Matrix3;class Plane{constructor(normal=new _Vector.Vector3(1,0,0),constant=0){this.normal=normal;this.constant=constant}set(normal,
constant){this.normal.copy(normal);this.constant=constant;return this}setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this}setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this}setFromCoplanarPoints(a,b,c){b=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();this.setFromNormalAndCoplanarPoint(b,a);return this}copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this}normalize(){const inverseNormalLength=
1/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this}negate(){this.constant*=-1;this.normal.negate();return this}distanceToPoint(point){return this.normal.dot(point)+this.constant}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius}projectPoint(point,target){return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point)}intersectLine(line,target){const direction=line.delta(_vector1);
var denominator=this.normal.dot(direction);if(0===denominator)return 0===this.distanceToPoint(line.start)?target.copy(line.start):null;denominator=-(line.start.dot(this.normal)+this.constant)/denominator;return 0>denominator||1<denominator?null:target.copy(direction).multiplyScalar(denominator).add(line.start)}intersectsLine(line){const startSign=this.distanceToPoint(line.start);line=this.distanceToPoint(line.end);return 0>startSign&&0<line||0>line&&0<startSign}intersectsBox(box){return box.intersectsPlane(this)}intersectsSphere(sphere){return sphere.intersectsPlane(this)}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(matrix,
optionalNormalMatrix){optionalNormalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);matrix=this.coplanarPoint(_vector1).applyMatrix4(matrix);optionalNormalMatrix=this.normal.applyMatrix3(optionalNormalMatrix).normalize();this.constant=-matrix.dot(optionalNormalMatrix);return this}translate(offset){this.constant-=offset.dot(this.normal);return this}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant}clone(){return(new this.constructor).copy(this)}}
exports.Plane=Plane;Plane.prototype.isPlane=!0}
//# sourceMappingURL=module$node_modules$three$src$math$Plane.js.map
