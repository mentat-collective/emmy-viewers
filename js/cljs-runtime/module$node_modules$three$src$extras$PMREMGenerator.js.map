{
"version":3,
"file":"module$node_modules$three$src$extras$PMREMGenerator.js",
"lineCount":25,
"mappings":"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",
"sources":["node_modules/three/src/extras/PMREMGenerator.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$src$extras$PMREMGenerator\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PMREMGenerator = void 0;\n\nvar _constants = require(\"../constants.js\");\n\nvar _BufferAttribute = require(\"../core/BufferAttribute.js\");\n\nvar _BufferGeometry = require(\"../core/BufferGeometry.js\");\n\nvar _Mesh = require(\"../objects/Mesh.js\");\n\nvar _OrthographicCamera = require(\"../cameras/OrthographicCamera.js\");\n\nvar _PerspectiveCamera = require(\"../cameras/PerspectiveCamera.js\");\n\nvar _RawShaderMaterial = require(\"../materials/RawShaderMaterial.js\");\n\nvar _Vector = require(\"../math/Vector2.js\");\n\nvar _Vector2 = require(\"../math/Vector3.js\");\n\nvar _Color = require(\"../math/Color.js\");\n\nvar _WebGLRenderTarget = require(\"../renderers/WebGLRenderTarget.js\");\n\nvar _MeshBasicMaterial = require(\"../materials/MeshBasicMaterial.js\");\n\nvar _BoxGeometry = require(\"../geometries/BoxGeometry.js\");\n\nconst LOD_MIN = 4;\nconst LOD_MAX = 8;\nconst SIZE_MAX = Math.pow(2, LOD_MAX); // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];\nconst TOTAL_LODS = LOD_MAX - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/new _OrthographicCamera.OrthographicCamera();\n\nconst {\n  _lodPlanes,\n  _sizeLods,\n  _sigmas\n} = /*@__PURE__*/_createPlanes();\n\nconst _clearColor = /*@__PURE__*/new _Color.Color();\n\nlet _oldTarget = null; // Golden Ratio\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nconst _axisDirections = [/*@__PURE__*/new _Vector2.Vector3(1, 1, 1), /*@__PURE__*/new _Vector2.Vector3(-1, 1, 1), /*@__PURE__*/new _Vector2.Vector3(1, 1, -1), /*@__PURE__*/new _Vector2.Vector3(-1, 1, -1), /*@__PURE__*/new _Vector2.Vector3(0, PHI, INV_PHI), /*@__PURE__*/new _Vector2.Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new _Vector2.Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new _Vector2.Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new _Vector2.Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new _Vector2.Vector3(-PHI, INV_PHI, 0)];\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._blurMaterial = _getBlurShader(MAX_SAMPLES);\n    this._equirectShader = null;\n    this._cubemapShader = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n\n\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = this._allocateTargets();\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromCubemap(cubemap, renderTarget = null) {\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileCubemapShader() {\n    if (this._cubemapShader === null) {\n      this._cubemapShader = _getCubemapShader();\n\n      this._compileMaterial(this._cubemapShader);\n    }\n  }\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileEquirectangularShader() {\n    if (this._equirectShader === null) {\n      this._equirectShader = _getEquirectShader();\n\n      this._compileMaterial(this._equirectShader);\n    }\n  }\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n\n\n  dispose() {\n    this._blurMaterial.dispose();\n\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n    if (this._cubemapShader !== null) this._cubemapShader.dispose();\n    if (this._equirectShader !== null) this._equirectShader.dispose();\n\n    for (let i = 0; i < _lodPlanes.length; i++) {\n      _lodPlanes[i].dispose();\n    }\n  } // private interface\n\n\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget);\n\n    outputTarget.scissorTest = false;\n\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture, renderTarget) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets(texture);\n\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets(texture) {\n    // warning: null texture is valid\n    const params = {\n      magFilter: _constants.LinearFilter,\n      minFilter: _constants.LinearFilter,\n      generateMipmaps: false,\n      type: _constants.HalfFloatType,\n      format: _constants.RGBAFormat,\n      encoding: _constants.LinearEncoding,\n      depthBuffer: false\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(params);\n\n    cubeUVRenderTarget.depthBuffer = texture ? false : true;\n\n    if (this._pingPongRenderTarget === null) {\n      this._pingPongRenderTarget = _createRenderTarget(params);\n    }\n\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    const tmpMesh = new _Mesh.Mesh(_lodPlanes[0], material);\n\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new _PerspectiveCamera.PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = _constants.NoToneMapping;\n    renderer.autoClear = false;\n    const backgroundMaterial = new _MeshBasicMaterial.MeshBasicMaterial({\n      name: 'PMREM.Background',\n      side: _constants.BackSide,\n      depthWrite: false,\n      depthTest: false\n    });\n    const backgroundBox = new _Mesh.Mesh(new _BoxGeometry.BoxGeometry(), backgroundMaterial);\n    let useSolidColor = false;\n    const background = scene.background;\n\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      _setViewport(cubeUVRenderTarget, col * SIZE_MAX, i > 2 ? SIZE_MAX : 0, SIZE_MAX, SIZE_MAX);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n\n      renderer.render(scene, cubeCamera);\n    }\n\n    backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n    renderer.toneMapping = toneMapping;\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === _constants.CubeReflectionMapping || texture.mapping === _constants.CubeRefractionMapping;\n\n    if (isCubeTexture) {\n      if (this._cubemapShader === null) {\n        this._cubemapShader = _getCubemapShader();\n      }\n\n      this._cubemapShader.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;\n    } else {\n      if (this._equirectShader === null) {\n        this._equirectShader = _getEquirectShader();\n      }\n    }\n\n    const material = isCubeTexture ? this._cubemapShader : this._equirectShader;\n    const mesh = new _Mesh.Mesh(_lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n\n    if (!isCubeTexture) {\n      uniforms['texelSize'].value.set(1.0 / texture.image.width, 1.0 / texture.image.height);\n    }\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * SIZE_MAX, 2 * SIZE_MAX);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (let i = 1; i < TOTAL_LODS; i++) {\n      const sigma = Math.sqrt(_sigmas[i] * _sigmas[i] - _sigmas[i - 1] * _sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n\n\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new _Mesh.Mesh(_lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = _sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = LOD_MAX - lodIn;\n    const outputSize = _sizeLods[lodOut];\n    const x = 3 * Math.max(0, SIZE_MAX - 2 * outputSize);\n    const y = (lodOut === 0 ? 0 : 2 * SIZE_MAX) + 2 * outputSize * (lodOut > LOD_MAX - LOD_MIN ? lodOut - LOD_MAX + LOD_MIN : 0);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n\n}\n\nexports.PMREMGenerator = PMREMGenerator;\n\nfunction _createPlanes() {\n  const _lodPlanes = [];\n  const _sizeLods = [];\n  const _sigmas = [];\n  let lod = LOD_MAX;\n\n  for (let i = 0; i < TOTAL_LODS; i++) {\n    const sizeLod = Math.pow(2, lod);\n\n    _sizeLods.push(sizeLod);\n\n    let sigma = 1.0 / sizeLod;\n\n    if (i > LOD_MAX - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - LOD_MAX + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n\n    _sigmas.push(sigma);\n\n    const texelSize = 1.0 / (sizeLod - 1);\n    const min = -texelSize / 2;\n    const max = 1 + texelSize / 2;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    const planes = new _BufferGeometry.BufferGeometry();\n    planes.setAttribute('position', new _BufferAttribute.BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new _BufferAttribute.BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new _BufferAttribute.BufferAttribute(faceIndex, faceIndexSize));\n\n    _lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    _lodPlanes,\n    _sizeLods,\n    _sigmas\n  };\n}\n\nfunction _createRenderTarget(params) {\n  const cubeUVRenderTarget = new _WebGLRenderTarget.WebGLRenderTarget(3 * SIZE_MAX, 3 * SIZE_MAX, params);\n  cubeUVRenderTarget.texture.mapping = _constants.CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(maxSamples) {\n  const weights = new Float32Array(maxSamples);\n  const poleAxis = new _Vector2.Vector3(0, 1, 0);\n  const shaderMaterial = new _RawShaderMaterial.RawShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': maxSamples\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n    blending: _constants.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectShader() {\n  const texelSize = new _Vector.Vector2(1, 1);\n  const shaderMaterial = new _RawShaderMaterial.RawShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'texelSize': {\n        value: texelSize\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tvec2 f = fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -= f * texelSize;\n\t\t\t\tvec3 tl = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x += texelSize.x;\n\t\t\t\tvec3 tr = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y += texelSize.y;\n\t\t\t\tvec3 br = texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -= texelSize.x;\n\t\t\t\tvec3 bl = texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm = mix( tl, tr, f.x );\n\t\t\t\tvec3 bm = mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb = mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t`,\n    blending: _constants.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCubemapShader() {\n  const shaderMaterial = new _RawShaderMaterial.RawShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'flipEnvMap': {\n        value: -1\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n    blending: _constants.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  );\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_createRenderTarget","params","cubeUVRenderTarget","_WebGLRenderTarget","WebGLRenderTarget","SIZE_MAX","texture","mapping","_constants","CubeUVReflectionMapping","name","scissorTest","_setViewport","target","x","y","width","height","viewport","set","scissor","_getEquirectShader","texelSize","_Vector","Vector2","shaderMaterial","_RawShaderMaterial","RawShaderMaterial","uniforms","value","vertexShader","_getCommonVertexShader","fragmentShader","blending","NoBlending","depthTest","depthWrite","_getCubemapShader","Object","defineProperty","PMREMGenerator","_BufferAttribute","_BufferGeometry","_Mesh","_OrthographicCamera","_PerspectiveCamera","_Vector2","_Color","_MeshBasicMaterial","_BoxGeometry","Math","pow","LOD_MAX","EXTRA_LOD_SIGMA","TOTAL_LODS","length","_flatCamera","OrthographicCamera","_lodPlanes","_sizeLods","_sigmas","_createPlanes","lod","i","sizeLod","push","sigma","LOD_MIN","min","max","uv1","position","Float32Array","uv","faceIndex","face","cubeFaces","coordinates","fill","planes","BufferGeometry","setAttribute","BufferAttribute","positionSize","uvSize","faceIndexSize","_clearColor","Color","_oldTarget","PHI","sqrt","INV_PHI","_axisDirections","Vector3","constructor","renderer","_renderer","_pingPongRenderTarget","weights","MAX_SAMPLES","poleAxis","_blurMaterial","defines","_cubemapShader","_equirectShader","_compileMaterial","fromScene","scene","near","far","getRenderTarget","_allocateTargets","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","renderTarget","_fromTexture","fromCubemap","cubemap","compileCubemapShader","compileEquirectangularShader","dispose","outputTarget","setRenderTarget","_textureToCubeUV","magFilter","LinearFilter","minFilter","generateMipmaps","type","HalfFloatType","format","RGBAFormat","encoding","LinearEncoding","depthBuffer","material","tmpMesh","Mesh","compile","cubeCamera","PerspectiveCamera","fov","aspect","upSign","forwardSign","originalAutoClear","autoClear","toneMapping","getClearColor","NoToneMapping","backgroundMaterial","MeshBasicMaterial","side","BackSide","backgroundBox","BoxGeometry","useSolidColor","background","isColor","color","copy","col","up","lookAt","render","geometry","isCubeTexture","CubeReflectionMapping","CubeRefractionMapping","flipEnvMap","isRenderTargetTexture","mesh","image","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","floor","STANDARD_DEVIATIONS","warn","sum","weight","exp","outputSize"]
}
