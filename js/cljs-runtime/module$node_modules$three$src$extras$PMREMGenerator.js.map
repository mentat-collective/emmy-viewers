{
"version":3,
"file":"module$node_modules$three$src$extras$PMREMGenerator.js",
"lineCount":26,
"mappings":"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",
"sources":["node_modules/three/src/extras/PMREMGenerator.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$three$src$extras$PMREMGenerator\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PMREMGenerator = void 0;\n\nvar _constants = require(\"../constants.js\");\n\nvar _BufferAttribute = require(\"../core/BufferAttribute.js\");\n\nvar _BufferGeometry = require(\"../core/BufferGeometry.js\");\n\nvar _Mesh = require(\"../objects/Mesh.js\");\n\nvar _OrthographicCamera = require(\"../cameras/OrthographicCamera.js\");\n\nvar _PerspectiveCamera = require(\"../cameras/PerspectiveCamera.js\");\n\nvar _ShaderMaterial = require(\"../materials/ShaderMaterial.js\");\n\nvar _Vector = require(\"../math/Vector3.js\");\n\nvar _Color = require(\"../math/Color.js\");\n\nvar _WebGLRenderTarget = require(\"../renderers/WebGLRenderTarget.js\");\n\nvar _MeshBasicMaterial = require(\"../materials/MeshBasicMaterial.js\");\n\nvar _BoxGeometry = require(\"../geometries/BoxGeometry.js\");\n\nconst LOD_MIN = 4; // The standard deviations (radians) associated with the extra mips. These are\n// chosen to approximate a Trowbridge-Reitz distribution function times the\n// geometric shadowing function. These sigma values squared must match the\n// variance #defines in cube_uv_reflection_fragment.glsl.js.\n\nconst EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582]; // The maximum length of the blur for loop. Smaller sigmas will use fewer\n// samples and exit early, but not recompile the shader.\n\nconst MAX_SAMPLES = 20;\n\nconst _flatCamera = /*@__PURE__*/new _OrthographicCamera.OrthographicCamera();\n\nconst _clearColor = /*@__PURE__*/new _Color.Color();\n\nlet _oldTarget = null; // Golden Ratio\n\nconst PHI = (1 + Math.sqrt(5)) / 2;\nconst INV_PHI = 1 / PHI; // Vertices of a dodecahedron (except the opposites, which represent the\n// same axis), used as axis directions evenly spread on a sphere.\n\nconst _axisDirections = [/*@__PURE__*/new _Vector.Vector3(1, 1, 1), /*@__PURE__*/new _Vector.Vector3(-1, 1, 1), /*@__PURE__*/new _Vector.Vector3(1, 1, -1), /*@__PURE__*/new _Vector.Vector3(-1, 1, -1), /*@__PURE__*/new _Vector.Vector3(0, PHI, INV_PHI), /*@__PURE__*/new _Vector.Vector3(0, PHI, -INV_PHI), /*@__PURE__*/new _Vector.Vector3(INV_PHI, 0, PHI), /*@__PURE__*/new _Vector.Vector3(-INV_PHI, 0, PHI), /*@__PURE__*/new _Vector.Vector3(PHI, INV_PHI, 0), /*@__PURE__*/new _Vector.Vector3(-PHI, INV_PHI, 0)];\n/**\n * This class generates a Prefiltered, Mipmapped Radiance Environment Map\n * (PMREM) from a cubeMap environment texture. This allows different levels of\n * blur to be quickly accessed based on material roughness. It is packed into a\n * special CubeUV format that allows us to perform custom interpolation so that\n * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap\n * chain, it only goes down to the LOD_MIN level (above), and then creates extra\n * even more filtered 'mips' at the same LOD_MIN resolution, associated with\n * higher roughness levels. In this way we maintain resolution to smoothly\n * interpolate diffuse lighting while limiting sampling computation.\n *\n * Paper: Fast, Accurate Image-Based Lighting\n * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view\n*/\n\nclass PMREMGenerator {\n  constructor(renderer) {\n    this._renderer = renderer;\n    this._pingPongRenderTarget = null;\n    this._lodMax = 0;\n    this._cubeSize = 0;\n    this._lodPlanes = [];\n    this._sizeLods = [];\n    this._sigmas = [];\n    this._blurMaterial = null;\n    this._cubemapMaterial = null;\n    this._equirectMaterial = null;\n\n    this._compileMaterial(this._blurMaterial);\n  }\n  /**\n   * Generates a PMREM from a supplied Scene, which can be faster than using an\n   * image if networking bandwidth is low. Optional sigma specifies a blur radius\n   * in radians to be applied to the scene before PMREM generation. Optional near\n   * and far planes ensure the scene is rendered in its entirety (the cubeCamera\n   * is placed at the origin).\n   */\n\n\n  fromScene(scene, sigma = 0, near = 0.1, far = 100) {\n    _oldTarget = this._renderer.getRenderTarget();\n\n    this._setSize(256);\n\n    const cubeUVRenderTarget = this._allocateTargets();\n\n    cubeUVRenderTarget.depthBuffer = true;\n\n    this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);\n\n    if (sigma > 0) {\n      this._blur(cubeUVRenderTarget, 0, 0, sigma);\n    }\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n  /**\n   * Generates a PMREM from an equirectangular texture, which can be either LDR\n   * or HDR. The ideal input image size is 1k (1024 x 512),\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromEquirectangular(equirectangular, renderTarget = null) {\n    return this._fromTexture(equirectangular, renderTarget);\n  }\n  /**\n   * Generates a PMREM from an cubemap texture, which can be either LDR\n   * or HDR. The ideal input cube size is 256 x 256,\n   * as this matches best with the 256 x 256 cubemap output.\n   */\n\n\n  fromCubemap(cubemap, renderTarget = null) {\n    return this._fromTexture(cubemap, renderTarget);\n  }\n  /**\n   * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileCubemapShader() {\n    if (this._cubemapMaterial === null) {\n      this._cubemapMaterial = _getCubemapMaterial();\n\n      this._compileMaterial(this._cubemapMaterial);\n    }\n  }\n  /**\n   * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during\n   * your texture's network fetch for increased concurrency.\n   */\n\n\n  compileEquirectangularShader() {\n    if (this._equirectMaterial === null) {\n      this._equirectMaterial = _getEquirectMaterial();\n\n      this._compileMaterial(this._equirectMaterial);\n    }\n  }\n  /**\n   * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,\n   * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on\n   * one of them will cause any others to also become unusable.\n   */\n\n\n  dispose() {\n    this._dispose();\n\n    if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();\n    if (this._equirectMaterial !== null) this._equirectMaterial.dispose();\n  } // private interface\n\n\n  _setSize(cubeSize) {\n    this._lodMax = Math.floor(Math.log2(cubeSize));\n    this._cubeSize = Math.pow(2, this._lodMax);\n  }\n\n  _dispose() {\n    if (this._blurMaterial !== null) this._blurMaterial.dispose();\n    if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();\n\n    for (let i = 0; i < this._lodPlanes.length; i++) {\n      this._lodPlanes[i].dispose();\n    }\n  }\n\n  _cleanup(outputTarget) {\n    this._renderer.setRenderTarget(_oldTarget);\n\n    outputTarget.scissorTest = false;\n\n    _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);\n  }\n\n  _fromTexture(texture, renderTarget) {\n    if (texture.mapping === _constants.CubeReflectionMapping || texture.mapping === _constants.CubeRefractionMapping) {\n      this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);\n    } else {\n      // Equirectangular\n      this._setSize(texture.image.width / 4);\n    }\n\n    _oldTarget = this._renderer.getRenderTarget();\n\n    const cubeUVRenderTarget = renderTarget || this._allocateTargets();\n\n    this._textureToCubeUV(texture, cubeUVRenderTarget);\n\n    this._applyPMREM(cubeUVRenderTarget);\n\n    this._cleanup(cubeUVRenderTarget);\n\n    return cubeUVRenderTarget;\n  }\n\n  _allocateTargets() {\n    const width = 3 * Math.max(this._cubeSize, 16 * 7);\n    const height = 4 * this._cubeSize;\n    const params = {\n      magFilter: _constants.LinearFilter,\n      minFilter: _constants.LinearFilter,\n      generateMipmaps: false,\n      type: _constants.HalfFloatType,\n      format: _constants.RGBAFormat,\n      encoding: _constants.LinearEncoding,\n      depthBuffer: false\n    };\n\n    const cubeUVRenderTarget = _createRenderTarget(width, height, params);\n\n    if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width) {\n      if (this._pingPongRenderTarget !== null) {\n        this._dispose();\n      }\n\n      this._pingPongRenderTarget = _createRenderTarget(width, height, params);\n      const {\n        _lodMax\n      } = this;\n      ({\n        sizeLods: this._sizeLods,\n        lodPlanes: this._lodPlanes,\n        sigmas: this._sigmas\n      } = _createPlanes(_lodMax));\n      this._blurMaterial = _getBlurShader(_lodMax, width, height);\n    }\n\n    return cubeUVRenderTarget;\n  }\n\n  _compileMaterial(material) {\n    const tmpMesh = new _Mesh.Mesh(this._lodPlanes[0], material);\n\n    this._renderer.compile(tmpMesh, _flatCamera);\n  }\n\n  _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {\n    const fov = 90;\n    const aspect = 1;\n    const cubeCamera = new _PerspectiveCamera.PerspectiveCamera(fov, aspect, near, far);\n    const upSign = [1, -1, 1, 1, 1, 1];\n    const forwardSign = [1, 1, 1, -1, -1, -1];\n    const renderer = this._renderer;\n    const originalAutoClear = renderer.autoClear;\n    const toneMapping = renderer.toneMapping;\n    renderer.getClearColor(_clearColor);\n    renderer.toneMapping = _constants.NoToneMapping;\n    renderer.autoClear = false;\n    const backgroundMaterial = new _MeshBasicMaterial.MeshBasicMaterial({\n      name: 'PMREM.Background',\n      side: _constants.BackSide,\n      depthWrite: false,\n      depthTest: false\n    });\n    const backgroundBox = new _Mesh.Mesh(new _BoxGeometry.BoxGeometry(), backgroundMaterial);\n    let useSolidColor = false;\n    const background = scene.background;\n\n    if (background) {\n      if (background.isColor) {\n        backgroundMaterial.color.copy(background);\n        scene.background = null;\n        useSolidColor = true;\n      }\n    } else {\n      backgroundMaterial.color.copy(_clearColor);\n      useSolidColor = true;\n    }\n\n    for (let i = 0; i < 6; i++) {\n      const col = i % 3;\n\n      if (col === 0) {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(forwardSign[i], 0, 0);\n      } else if (col === 1) {\n        cubeCamera.up.set(0, 0, upSign[i]);\n        cubeCamera.lookAt(0, forwardSign[i], 0);\n      } else {\n        cubeCamera.up.set(0, upSign[i], 0);\n        cubeCamera.lookAt(0, 0, forwardSign[i]);\n      }\n\n      const size = this._cubeSize;\n\n      _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);\n\n      renderer.setRenderTarget(cubeUVRenderTarget);\n\n      if (useSolidColor) {\n        renderer.render(backgroundBox, cubeCamera);\n      }\n\n      renderer.render(scene, cubeCamera);\n    }\n\n    backgroundBox.geometry.dispose();\n    backgroundBox.material.dispose();\n    renderer.toneMapping = toneMapping;\n    renderer.autoClear = originalAutoClear;\n    scene.background = background;\n  }\n\n  _textureToCubeUV(texture, cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const isCubeTexture = texture.mapping === _constants.CubeReflectionMapping || texture.mapping === _constants.CubeRefractionMapping;\n\n    if (isCubeTexture) {\n      if (this._cubemapMaterial === null) {\n        this._cubemapMaterial = _getCubemapMaterial();\n      }\n\n      this._cubemapMaterial.uniforms.flipEnvMap.value = texture.isRenderTargetTexture === false ? -1 : 1;\n    } else {\n      if (this._equirectMaterial === null) {\n        this._equirectMaterial = _getEquirectMaterial();\n      }\n    }\n\n    const material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;\n    const mesh = new _Mesh.Mesh(this._lodPlanes[0], material);\n    const uniforms = material.uniforms;\n    uniforms['envMap'].value = texture;\n    const size = this._cubeSize;\n\n    _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);\n\n    renderer.setRenderTarget(cubeUVRenderTarget);\n    renderer.render(mesh, _flatCamera);\n  }\n\n  _applyPMREM(cubeUVRenderTarget) {\n    const renderer = this._renderer;\n    const autoClear = renderer.autoClear;\n    renderer.autoClear = false;\n\n    for (let i = 1; i < this._lodPlanes.length; i++) {\n      const sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);\n      const poleAxis = _axisDirections[(i - 1) % _axisDirections.length];\n\n      this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);\n    }\n\n    renderer.autoClear = autoClear;\n  }\n  /**\n   * This is a two-pass Gaussian blur for a cubemap. Normally this is done\n   * vertically and horizontally, but this breaks down on a cube. Here we apply\n   * the blur latitudinally (around the poles), and then longitudinally (towards\n   * the poles) to approximate the orthogonally-separable blur. It is least\n   * accurate at the poles, but still does a decent job.\n   */\n\n\n  _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {\n    const pingPongRenderTarget = this._pingPongRenderTarget;\n\n    this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);\n\n    this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);\n  }\n\n  _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {\n    const renderer = this._renderer;\n    const blurMaterial = this._blurMaterial;\n\n    if (direction !== 'latitudinal' && direction !== 'longitudinal') {\n      console.error('blur direction must be either latitudinal or longitudinal!');\n    } // Number of standard deviations at which to cut off the discrete approximation.\n\n\n    const STANDARD_DEVIATIONS = 3;\n    const blurMesh = new _Mesh.Mesh(this._lodPlanes[lodOut], blurMaterial);\n    const blurUniforms = blurMaterial.uniforms;\n    const pixels = this._sizeLods[lodIn] - 1;\n    const radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);\n    const sigmaPixels = sigmaRadians / radiansPerPixel;\n    const samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;\n\n    if (samples > MAX_SAMPLES) {\n      console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);\n    }\n\n    const weights = [];\n    let sum = 0;\n\n    for (let i = 0; i < MAX_SAMPLES; ++i) {\n      const x = i / sigmaPixels;\n      const weight = Math.exp(-x * x / 2);\n      weights.push(weight);\n\n      if (i === 0) {\n        sum += weight;\n      } else if (i < samples) {\n        sum += 2 * weight;\n      }\n    }\n\n    for (let i = 0; i < weights.length; i++) {\n      weights[i] = weights[i] / sum;\n    }\n\n    blurUniforms['envMap'].value = targetIn.texture;\n    blurUniforms['samples'].value = samples;\n    blurUniforms['weights'].value = weights;\n    blurUniforms['latitudinal'].value = direction === 'latitudinal';\n\n    if (poleAxis) {\n      blurUniforms['poleAxis'].value = poleAxis;\n    }\n\n    const {\n      _lodMax\n    } = this;\n    blurUniforms['dTheta'].value = radiansPerPixel;\n    blurUniforms['mipInt'].value = _lodMax - lodIn;\n    const outputSize = this._sizeLods[lodOut];\n    const x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);\n    const y = 4 * (this._cubeSize - outputSize);\n\n    _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);\n\n    renderer.setRenderTarget(targetOut);\n    renderer.render(blurMesh, _flatCamera);\n  }\n\n}\n\nexports.PMREMGenerator = PMREMGenerator;\n\nfunction _createPlanes(lodMax) {\n  const lodPlanes = [];\n  const sizeLods = [];\n  const sigmas = [];\n  let lod = lodMax;\n  const totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;\n\n  for (let i = 0; i < totalLods; i++) {\n    const sizeLod = Math.pow(2, lod);\n    sizeLods.push(sizeLod);\n    let sigma = 1.0 / sizeLod;\n\n    if (i > lodMax - LOD_MIN) {\n      sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];\n    } else if (i === 0) {\n      sigma = 0;\n    }\n\n    sigmas.push(sigma);\n    const texelSize = 1.0 / (sizeLod - 2);\n    const min = -texelSize;\n    const max = 1 + texelSize;\n    const uv1 = [min, min, max, min, max, max, min, min, max, max, min, max];\n    const cubeFaces = 6;\n    const vertices = 6;\n    const positionSize = 3;\n    const uvSize = 2;\n    const faceIndexSize = 1;\n    const position = new Float32Array(positionSize * vertices * cubeFaces);\n    const uv = new Float32Array(uvSize * vertices * cubeFaces);\n    const faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);\n\n    for (let face = 0; face < cubeFaces; face++) {\n      const x = face % 3 * 2 / 3 - 1;\n      const y = face > 2 ? 0 : -1;\n      const coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];\n      position.set(coordinates, positionSize * vertices * face);\n      uv.set(uv1, uvSize * vertices * face);\n      const fill = [face, face, face, face, face, face];\n      faceIndex.set(fill, faceIndexSize * vertices * face);\n    }\n\n    const planes = new _BufferGeometry.BufferGeometry();\n    planes.setAttribute('position', new _BufferAttribute.BufferAttribute(position, positionSize));\n    planes.setAttribute('uv', new _BufferAttribute.BufferAttribute(uv, uvSize));\n    planes.setAttribute('faceIndex', new _BufferAttribute.BufferAttribute(faceIndex, faceIndexSize));\n    lodPlanes.push(planes);\n\n    if (lod > LOD_MIN) {\n      lod--;\n    }\n  }\n\n  return {\n    lodPlanes,\n    sizeLods,\n    sigmas\n  };\n}\n\nfunction _createRenderTarget(width, height, params) {\n  const cubeUVRenderTarget = new _WebGLRenderTarget.WebGLRenderTarget(width, height, params);\n  cubeUVRenderTarget.texture.mapping = _constants.CubeUVReflectionMapping;\n  cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';\n  cubeUVRenderTarget.scissorTest = true;\n  return cubeUVRenderTarget;\n}\n\nfunction _setViewport(target, x, y, width, height) {\n  target.viewport.set(x, y, width, height);\n  target.scissor.set(x, y, width, height);\n}\n\nfunction _getBlurShader(lodMax, width, height) {\n  const weights = new Float32Array(MAX_SAMPLES);\n  const poleAxis = new _Vector.Vector3(0, 1, 0);\n  const shaderMaterial = new _ShaderMaterial.ShaderMaterial({\n    name: 'SphericalGaussianBlur',\n    defines: {\n      'n': MAX_SAMPLES,\n      'CUBEUV_TEXEL_WIDTH': 1.0 / width,\n      'CUBEUV_TEXEL_HEIGHT': 1.0 / height,\n      'CUBEUV_MAX_MIP': `${lodMax}.0`\n    },\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'samples': {\n        value: 1\n      },\n      'weights': {\n        value: weights\n      },\n      'latitudinal': {\n        value: false\n      },\n      'dTheta': {\n        value: 0\n      },\n      'mipInt': {\n        value: 0\n      },\n      'poleAxis': {\n        value: poleAxis\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t`,\n    blending: _constants.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n  return shaderMaterial;\n}\n\nfunction _getEquirectMaterial() {\n  return new _ShaderMaterial.ShaderMaterial({\n    name: 'EquirectangularToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t`,\n    blending: _constants.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\nfunction _getCubemapMaterial() {\n  return new _ShaderMaterial.ShaderMaterial({\n    name: 'CubemapToCubeUV',\n    uniforms: {\n      'envMap': {\n        value: null\n      },\n      'flipEnvMap': {\n        value: -1\n      }\n    },\n    vertexShader: _getCommonVertexShader(),\n    fragmentShader:\n    /* glsl */\n    `\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t`,\n    blending: _constants.NoBlending,\n    depthTest: false,\n    depthWrite: false\n  });\n}\n\nfunction _getCommonVertexShader() {\n  return (\n    /* glsl */\n    `\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t`\n  );\n}\n};"],
"names":["shadow$provide","global","require","module","exports","_createRenderTarget","width","height","params","cubeUVRenderTarget","_WebGLRenderTarget","WebGLRenderTarget","texture","mapping","_constants","CubeUVReflectionMapping","name","scissorTest","_setViewport","target","x","y","viewport","set","scissor","_getEquirectMaterial","_ShaderMaterial","ShaderMaterial","uniforms","value","vertexShader","_getCommonVertexShader","fragmentShader","blending","NoBlending","depthTest","depthWrite","_getCubemapMaterial","Object","defineProperty","PMREMGenerator","_BufferAttribute","_BufferGeometry","_Mesh","_OrthographicCamera","_PerspectiveCamera","_Vector","_Color","_MeshBasicMaterial","_BoxGeometry","EXTRA_LOD_SIGMA","_flatCamera","OrthographicCamera","_clearColor","Color","_oldTarget","PHI","Math","sqrt","INV_PHI","_axisDirections","Vector3","constructor","renderer","_renderer","_pingPongRenderTarget","_cubeSize","_lodMax","_lodPlanes","_sizeLods","_sigmas","_equirectMaterial","_cubemapMaterial","_blurMaterial","_compileMaterial","fromScene","scene","sigma","near","far","getRenderTarget","_setSize","_allocateTargets","depthBuffer","_sceneToCubeUV","_blur","_applyPMREM","_cleanup","fromEquirectangular","equirectangular","renderTarget","_fromTexture","fromCubemap","cubemap","compileCubemapShader","compileEquirectangularShader","dispose","_dispose","cubeSize","floor","log2","pow","i","length","outputTarget","setRenderTarget","CubeReflectionMapping","CubeRefractionMapping","image","_textureToCubeUV","max","magFilter","LinearFilter","minFilter","generateMipmaps","type","HalfFloatType","format","RGBAFormat","encoding","LinearEncoding","lodPlanes","sizeLods","sigmas","lod","lodMax","totalLods","LOD_MIN","sizeLod","push","texelSize","min","uv1","position","Float32Array","uv","faceIndex","face","cubeFaces","coordinates","fill","planes","BufferGeometry","setAttribute","BufferAttribute","positionSize","uvSize","faceIndexSize","weights","MAX_SAMPLES","poleAxis","shaderMaterial","defines","material","tmpMesh","Mesh","compile","cubeCamera","PerspectiveCamera","fov","aspect","upSign","forwardSign","originalAutoClear","autoClear","toneMapping","getClearColor","NoToneMapping","backgroundMaterial","MeshBasicMaterial","side","BackSide","backgroundBox","BoxGeometry","useSolidColor","background","isColor","color","copy","col","up","lookAt","size","render","geometry","isCubeTexture","flipEnvMap","isRenderTargetTexture","mesh","lodIn","lodOut","pingPongRenderTarget","_halfBlur","targetIn","targetOut","sigmaRadians","direction","blurMaterial","console","error","blurMesh","blurUniforms","pixels","radiansPerPixel","isFinite","PI","sigmaPixels","samples","STANDARD_DEVIATIONS","warn","sum","weight","exp","outputSize"]
}
