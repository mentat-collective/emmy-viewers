{"version":3,"sources":["sicmutils/util/permute.cljc"],"mappings":"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","names":["sicmutils.util.permute/delete-nth","xs","n","cljs.core.concat","cljs.core.take","cljs.core.drop","sicmutils.util.permute/permutations","cljs.core/empty?","i","item","cljs.core.map","perm","cljs.core/cons","G__100986","cljs.core.sequence","cljs.core.comp","cljs.core.map_indexed","f","cljs.core/cat","sicmutils.util.permute/combinations","p","more","cljs.core.conj","cljs.core/first","G__100987","G__100988","cljs.core/rest","G__100989","G__100990","sicmutils.util.permute/cartesian-product","colls","iter__4652__auto__","s__100996","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","xs__6308__auto__","iterys__4648__auto__","s__100998","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","cljs.core/count","b__101000","cljs.core/chunk-buffer","i__100999","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__100997","cljs.core/chunk-rest","fs__4649__auto__","iter__100995","G__101055","x","sicmutils.util.permute/list-interchanges","permuted-list","original-list","plist","fp","bigger","p1__101056#","cljs.core.drop_while","cljs.core.not_EQ_","lp2","l","increment","lp1","cljs.core/not","cljs.core/some","sicmutils.util.permute/permutation-interchanges","vec__101083","seq__101084","first__101085","cljs.core/next","sicmutils.util.permute/same-set?","x1","x2","cljs.core._EQ_","cljs.core.sort_by","cljs.core/hash","var_args","G__101089","sicmutils.util.permute/permutation-parity","js/Error","swaps","cljs.core/even?","sicmutils.util.permute/permute","permutation","cljs.core/vec","cljs.core.get","sicmutils.util.permute/index-of","v","fexpr__101113","cljs.core/-indexOf","sicmutils.util.permute/sort-and-permute","ulist","<?","cont","lsource","cljs.core/vector","cljs.core.range","ltarget","cljs.core/comparator","sorted","cljs.core.mapv","cljs.core/second","iperm","G__101124","G__101125","G__101126","G__101127","sicmutils.util.permute/subpermute","m","cljs.core/reduce-kv","acc","k","cljs.core.assoc","sicmutils.util.permute/number-of-permutations","sicmutils.special.factorial/factorial","sicmutils.util.permute/number-of-combinations","sicmutils.special.factorial/binomial-coefficient","div","sicmutils.generic//","sicmutils.util.permute/multichoose","G__101153","G__101154","sicmutils.special.factorial/rising-factorial","sicmutils.util.permute/permutation-sequence","as","p1__101155#","a","cljs.core.object_array","c","cljs.core.int_array","cljs.core.repeat","o","return","cljs.core.into","the-next","cljs.core.atom","has-next","step","j","s","q","i1","i2","t","G__101157","fexpr__101156","cljs.core/chunkIteratorSeq","js/sicmutils","js/sicmutils.util","js/sicmutils.util.permute","js/sicmutils.util.permute.t_sicmutils$util$permute101158","sicmutils.util.permute/t_sicmutils$util$permute101158","_101160","meta101159","cljs.core/deref","this__4491__auto__","writer__4492__auto__","opt__4493__auto__","cljs.core/-write","sicmutils.util.permute/->t_sicmutils$util$permute101158","_","prev","cljs.core/reset!","G__101177","G__101178","this","cljs.core/chunk-first"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.util.permute\n  \"Utilities for generating permutations of sequences.\"\n  (:require [sicmutils.special.factorial :as sf]\n            #?(:cljs [sicmutils.generic :as g]))\n  #?(:clj\n     (:import (clojure.lang APersistentVector))))\n\n(defn ^:no-doc delete-nth\n  \"returns the sequence `xs` with its `n`th element dropped.\"\n  [xs n]\n  (concat (take n xs)\n          (drop (inc n) xs)))\n\n(defn permutations\n  \"Returns a lazy sequence of every possible arrangement of the elements of `xs`.\"\n  [xs]\n  (if (empty? xs)\n    '(())\n    (letfn [(f [i item]\n              (map (fn [perm]\n                     (cons item perm))\n                   (permutations\n                    (delete-nth xs i))))]\n      (sequence (comp (map-indexed f) cat)\n                xs))))\n\n(defn combinations\n  \"Returns a lazy sequence of every possible set of `p` elements chosen from\n  `xs`.\"\n  [xs p]\n  (cond (zero? p) '(())\n        (empty? xs) ()\n        :else (concat\n               (map (fn [more]\n                      (conj more (first xs)))\n                    (combinations (rest xs)\n                                  (dec p)))\n               (combinations (rest xs) p))))\n\n(defn cartesian-product\n  \"Accepts a sequence of collections `colls` and returns a lazy sequence of the\n  cartesian product of all collections.\n\n  The cartesian product of N collections is a sequences of sequences, each `N`\n  long, of every possible way of choosing `N` items where the first comes from\n  the first entry in `colls`, the second from the second entry and so on.\n\n  NOTE: This implementation comes from Alan Malloy at this [StackOverflow\n  post](https://stackoverflow.com/a/18248031). Thanks, Alan!\"\n  [colls]\n  (if (empty? colls)\n    '(())\n    (for [more (cartesian-product (rest colls))\n          x (first colls)]\n      (cons x more))))\n\n(defn list-interchanges\n  \"Given a `permuted-list` and the `original-list`, returns the number of\n  interchanges required to generate the permuted list from the original list.\"\n  [permuted-list original-list]\n  (letfn [(lp1 [plist n]\n            (if (empty? plist)\n              n\n              (let [fp     (first plist)\n                    bigger (rest (drop-while #(not= % fp) original-list))\n                    more   (rest plist)]\n                (lp2 n bigger more more 0))))\n          (lp2 [n bigger more l increment]\n            (if (empty? l)\n              (lp1 more (+ n increment))\n              (lp2 n bigger more\n                   (rest l)\n                   (if-not (some #{(first l)} bigger)\n                     (inc increment)\n                     increment))))]\n    (lp1 permuted-list 0)))\n\n(defn permutation-interchanges [permuted-list]\n  (letfn [(lp1 [plist n]\n            (if (empty? plist)\n              n\n              (let [[x & xs] plist]\n                (lp2 n x xs xs 0))))\n          (lp2 [n x xs l increment]\n            (if (empty? l)\n              (lp1 xs (+ n increment))\n              (lp2 n x xs\n                   (rest l)\n                   (if (>= (first l) x)\n                     increment\n                     (inc increment)))))]\n    (lp1 permuted-list 0)))\n\n(defn- same-set?\n  \"Returns true if `x1` and `x2` contain the same elements, false otherwise.\"\n  [x1 x2]\n  (= (sort-by hash x1)\n     (sort-by hash x2)))\n\n(defn permutation-parity\n  \"If a single `permuted-list` is supplied, returns the parity of the number of\n  interchanges required to sort the permutation.\n\n  NOTE that the requirement that elements be sortable currently constrains\n  `permuted-list`'s elements to be numbers that respond to `>=`.\n\n  For two arguments, given a `permuted-list` and the `original-list`, returns\n  the parity (1 for even, -1 for odd) of the number of the number of\n  interchanges required to generate the permuted list from the original list.\n\n  In the two-argument case, if the two lists aren't permutations of each other,\n  returns 0.\"\n  ([permuted-list]\n   (let [swaps (permutation-interchanges permuted-list)]\n     (if (even? swaps) 1 -1)))\n  ([permuted-list original-list]\n   (if (and (= (count permuted-list)\n               (count original-list))\n            (same-set? permuted-list original-list))\n     (if (even? (list-interchanges permuted-list original-list))\n       1\n       -1)\n     0)))\n\n(defn permute\n  \"Given a `permutation` (represented as a list of numbers), and a sequence `xs`\n  to be permuted, construct the list so permuted.\"\n  [permutation xs]\n  (let [xs (vec xs)]\n    (map (fn [p] (get xs p))\n         permutation)))\n\n(defn- index-of [v x]\n  #?(:clj (.indexOf ^APersistentVector v x)\n     :cljs (#'-indexOf v x)))\n\n(defn sort-and-permute\n  \"cont = (fn [ulist slist perm iperm] ...)\n\n  Given a short list and a comparison function, to sort the list by the\n  comparison, returning the original list, the sorted list, the permutation\n  procedure and the inverse permutation procedure developed by the sort.\"\n  [ulist <? cont]\n  (let [n       (count ulist)\n        lsource (map vector ulist (range n))\n        ltarget (sort-by first (comparator <?) lsource)\n        sorted  (mapv first ltarget)\n        perm    (mapv second ltarget)\n        iperm   (map (fn [i] (index-of perm i))\n                     (range n))]\n    (cont ulist\n          sorted\n          (fn [l] (permute perm l))\n          (fn [l] (permute iperm l)))))\n\n;; Sometimes we want to permute some of the elements of a list, as follows:\n\n(defn subpermute\n  \"Given a sequence `xs` and a map `m` of replacement indices, returns a new\n  version of `xs` with the element at the position marked by each key in `m`\n  replaced by the element at each value in the original `xs`.\"\n  [m xs]\n  (reduce-kv (fn [acc k v]\n               (assoc acc k (get xs v)))\n             xs\n             m))\n\n(defn number-of-permutations\n  \"Returns the number of possible ways of permuting a collection of `n` distinct\n  elements.\"\n  [n]\n  (sf/factorial n))\n\n(defn number-of-combinations\n  \"Returns 'n choose k', the number of possible ways of choosing `k` distinct\n  elements from a collection of `n` total items.\"\n  [n k]\n  {:pre [(>= n 0)]}\n  (sf/binomial-coefficient n k))\n\n(let [div #?(:clj / :cljs g//)]\n  (defn multichoose\n    \"Returns the number of possible ways of choosing a multiset with cardinality `k`\n  from a set of `n` items, where each item is allowed to be chosen multiple\n  times.\"\n    [n k]\n    {:pre [(>= n 0) (>= k 0)]}\n    (if (zero? k)\n      1\n      (div (sf/rising-factorial n k)\n           (sf/factorial k)))))\n\n(defn permutation-sequence\n  \"Produces an iterable sequence developing the permutations of the input sequence\n  of objects (which are considered distinct) in church-bell-changes order - that\n  is, each permutation differs from the previous by a transposition of adjacent\n  elements (Algorithm P from \u00a77.2.1.2 of Knuth).\n\n  This is an unusual way to go about this in a functional language, but it's\n  fun.\n\n  This approach has the side-effect of arranging for the parity of the generated\n  permutations to alternate; the first permutation yielded is the identity\n  permutation (which of course is even).\n\n  Inside, there is a great deal of mutable state, but this cannot be observed by\n  the user.\"\n  [as]\n  (let [n (count as)\n        a (object-array as)\n        c (int-array n (repeat 0)) ;; P1. [Initialize.]\n        o (int-array n (repeat 1))\n        return #(into [] %)\n        the-next (atom (return a))\n        has-next (atom true)\n        ;; step implements one-through of algorithm P up to step P2,\n        ;; at which point we return false if we have terminated, true\n        ;; if a has been set to a new permutation. Knuth's code is\n        ;; one-based; this is zero-based.\n        step (fn [j s]\n               (let [q (int (+ (aget c j) (aget o j)))] ;; P4. [Ready to change?]\n                 (cond (< q 0)\n                       (do ;; P7. [Switch direction.]\n                         (aset o j (int (- (aget o j))))\n                         (recur (dec j) s))\n\n                       (= q (inc j))\n                       (if (zero? j)\n                         false ;; All permutations have been delivered.\n                         (do (aset o j (int (- (aget o j)))) ;; P6. [Increase s.]\n                             (recur (dec j) (inc s)))) ;; P7. [Switch direction.]\n\n                       :else ;; P5. [Change.]\n                       (let [i1 (+ s (- j (aget c j)))\n                             i2 (+ s (- j q))\n                             t (aget a i1)\n                             ]\n                         (aset a i1 (aget a i2))\n                         (aset a i2 t)\n                         (aset c j q)\n                         true ;; More permutations are forthcoming.\n                         ))))]\n    (#?(:clj iterator-seq :cljs #'cljs.core/chunkIteratorSeq)\n     (reify #?(:clj java.util.Iterator :cljs Object)\n       (hasNext [_] @has-next)\n       (next [_]  ;; P2. [Visit.]\n         (let [prev @the-next]\n           (reset! has-next (step (dec n) 0))\n           (reset! the-next (return a))\n           prev))\n\n       #?@(:cljs\n           [IIterable\n            (-iterator [this] this)])))))\n"]}