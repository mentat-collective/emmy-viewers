{"version":3,"sources":["sicmutils/expression/analyze.cljc"],"mappings":"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","names":["sicmutils.expression.analyze/*inhibit-expt-simplify*","sicmutils.expression.analyze/make-vcompare","var-set","v","w","cljs.core/compare","sicmutils.expression.analyze/monotonic-symbol-generator","prefix","count","cljs.core.atom","cljs.core.symbol","i","cljs.core.swap_BANG_","cljs.core/inc","suffix","sicmutils$expression$analyze$ICanonicalize$expression__GT_$dyn","x__4550__auto__","m__4551__auto__","sicmutils.expression.analyze/expression->","goog/typeOf","m__4549__auto__","cljs.core/missing-protocol","var_args","G__82610","js/Error","sicmutils$expression$analyze$ICanonicalize$__GT_expression$dyn","sicmutils.expression.analyze/->expression","sicmutils$expression$analyze$ICanonicalize$known_operation_QMARK_$dyn","sicmutils.expression.analyze/known-operation?","sicmutils.expression.analyze/ICanonicalize","analyzer","x","continue","compare-fn","b","variables","G__82625","sicmutils.expression.analyze/make-analyzer","backend","sicmutils.expression.analyze.make_analyzer","symbol-generator","ref","cljs.core/atom","alter","cljs.core/swap!","ref-set","cljs.core/reset!","expr->var","G__82626","var->expr","G__82627","v1","v2","fexpr__82652","cljs.core/deref","expr","cljs.core/sequential?","cljs.core._EQ_","cljs.core/first","G__82654","G__82655","G__82656","G__82657","unquoted-list?","analyzed-expr","cljs.core.doall","cljs.core.map","ianalyze","and__4251__auto__","sicmutils.numsymb/operator","cljs.core/not","sicmutils.numsymb/expt?","sicmutils.value/integral?","cljs.core/second","sicmutils.numsymb/operands","temp__5751__auto__","existing-expr","fexpr__82653","new-kernels","vcompare","sicmutils.expression/variables-in","simplified-expr","base-simplify","op","sicmutils.numsymb/symbolic-operator","cljs.core.apply","add-symbols!","expr-k","sicmutils.value/freeze","cljs.core/identity","fexpr__82647","var","cljs.core/assoc","new","add-symbol!","backsubstitute","cljs.core/Symbol","fexpr__82661","p1__82622#","p2__82623#","v-compare","*incremental-simplifier*-orig-val__82658","*incremental-simplifier*-temp-val__82659","sicmutils.numsymb/*incremental-simplifier*","analyze","analyze-expression","new-analysis!","simplify-expression","sicmutils.expression/expression-of","sicmutils.expression/literal?","sicmutils.expression/fmap","simplify","sicmutils.expression.analyze/default-simplifier","sicmutils.expression.analyze/expression-simplifier","sicmutils.expression.analyze/initializer","sicmutils.expression.analyze/expression-analyzer","sicmutils.expression.analyze/auxiliary-variable-fetcher"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.expression.analyze\n  \"This namespace defines an API for working with 'expression analyzers' and\n  the [[ICanonicalize]] protocol.\n\n  Expression analyzers find canonical forms of inputs over limited vocabularies\n  of operations. For example, a polynomial analyzer will expose operations like\n  addition, subtraction, multiplication, and exponentiation by positive\n  integers (but not division).\n\n  An expression containing only these operations and symbols can then be\n  converted to and from a polynomial canonical form, which in this example would\n  have the effect of grouping like terms; a rational function backend would\n  include the division operation and be capable of cancellation. Canonicalizing\n  an expression with respect to an analyzer is therefore effected by a\n  round-trip to and from the canonical form.\"\n  (:require [sicmutils.expression :as x]\n            [sicmutils.numsymb :as sym]\n            [sicmutils.value :as v]))\n\n;; ## General Recursive Simplifier Maker\n;;\n;; The heading, and the following block of comments, is based on the narrative\n;; in `simplify/simplify.scm` of the scmutils repository.\n;;\n;; Given a set of operations, the protocols and functions in this namespace\n;; allow you to define recursive simplifiers that simplify expressions involving\n;; these operations, treating other combinations as atomic.\n;;\n;; To break an expression up into manipulable and nonmanipulable parts with\n;; respect to a set of algebraic operators. This is done by the introduction of\n;; auxiliary variables.\n;;\n;; For example, the equation\n;;\n;;    I = Is (exp((V2 - V3)/Vt) - 1) ;; I, V2, V3\n;;\n;; can be broken into three equations:\n;;\n;;    I + Is = Is*X                  ;; I, X\n;;    V2/Vt - V3/Vt = Y              ;; V2, V3, Y\n;;    X = (exp Y)                    ;; X, Y\n;;\n;; where X and Y are new variables. The first two parts contain only addition,\n;; subtraction, multiplication, and division and the third is not expressible in\n;; terms of those operations.\n;;\n;;\n;; ## Implementation\n\n(def ^{:dynamic true\n       :doc \"Exponential expressions with non-integer exponents must become\n       kernels, because they cannot become polynomial exponentials.\n\n       To disable this guard, bind this variable to `false`.\"}\n  *inhibit-expt-simplify*\n  true)\n\n;; ### Utilities\n\n(defn- make-vcompare\n  \"Returns\n  a [Comparator](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html)\n  function taking account of the input variable set `var-set` in the following\n  way:\n\n  If both inputs to the comparator are in `var-set,` or both are not, then the\n  results are as `clojure.core/compare` would return. But if one is in `var-set`\n  and the other is not, then the other will always compare greater.\n\n  In this way, expressions produced by the simplifier will have simple variables\n  sorted earlier than expressions involving those variables.\"\n  [var-set]\n  (fn [v w]\n    (cond\n      (var-set v) (if (var-set w)\n                    (compare v w)\n                    -1)\n      (var-set w) 1\n      :else (compare v w))))\n\n(defn monotonic-symbol-generator\n  \"Returns a function which generates a sequence of symbols with the given\n  `prefix` with the property that later symbols will sort after earlier symbols.\n\n  This is important for the stability of the simplifier. (If we just used\n  `clojure.core/gensym`, then a temporary symbol like `G__1000` will sort\n  earlier than `G__999`. This will trigger errors at unpredictable times,\n  whenever `clojure.core/gensym` returns two symbols that cross an\n  order-of-magnitude boundary.)\"\n  [prefix]\n  (let [count (atom -1)]\n    (fn [] (symbol\n           #?(:clj\n              (format \"%s%016x\" prefix (swap! count inc))\n\n              :cljs\n              (let [i (swap! count inc)\n                    suffix (-> (.toString i 16)\n                               (.padStart 16 \"0\"))]\n                (str prefix suffix)))))))\n\n(defprotocol ICanonicalize\n  \"[[ICanonicalize]] captures the methods exposed by a SICMUtils analyzer backend.\"\n  (expression->\n    [analyzer x continue]\n    [analyzer x continue compare-fn]\n    \"Invokes `continue` with two arguments:\n\n  - A version of `x` converted to the canonical form represented by `analyzer`\n  - A (sorted by `compare-fn`) sequence of variables found in `x`.\n\n  `compare-fn` is used to sort variables. Defaults\n  to [[clojure.core/compare]].\")\n\n  (->expression [analyzer b variables]\n    \"Convert a canonical form `b` back to S-expression form.\n\n    Each [[ICanonicalize]] instance uses `variables` in different ways. The\n    `variables` sequence is typically obtained from the continuation invoked\n    by [[expression->]], so these functions are complementary.\")\n\n  (known-operation? [analyzer x]\n    \"Returns true if the symbolic operation `x` is considered fundamental by\n    `analyzer`, false otherwise.\"))\n\n(defn make-analyzer\n  \"Make-analyzer takes an analyzer `backend` (which implements [[ICanonicalize]])\n  and returns a dictionary with the apparatus necessary to prepare expressions\n  for analysis by replacing subexpressions formed from operations unknown to the\n  analyzer with generated symbols, and backsubstituting after analysis is\n  complete.\n\n  For example, in the case of polynomial canonical form, we would replace a\n  subexpression like `(sin x)` with a gensym, before entry, since the `sin`\n  operation is not available to the polynomial canonicalizer, and restore it\n  afterwards.\"\n  ([backend]\n   (make-analyzer backend (monotonic-symbol-generator \"-g-\")))\n  ([backend symbol-generator]\n   (let [ref #?(:clj ref :cljs atom)\n         alter #?(:clj alter :cljs swap!)\n         ref-set #?(:clj ref-set :cljs reset!)\n         expr->var (ref {})\n         var->expr (ref {})\n         compare-fn (atom compare)]\n     (letfn [(v-compare [v1 v2]\n               (@compare-fn v1 v2))\n\n             (unquoted-list? [expr]\n               (and (sequential? expr)\n                    (not (= (first expr) 'quote))))\n\n             ;; Prepare for new analysis\n             (new-analysis! []\n               (reset! compare-fn compare)\n               (#?(:clj dosync :cljs do)\n                (ref-set expr->var {})\n                (ref-set var->expr {}))\n               nil)\n\n             (ianalyze [expr]\n               (if (unquoted-list? expr)\n                 (let [analyzed-expr (doall (map ianalyze expr))]\n                   (if (and (known-operation? backend (sym/operator analyzed-expr))\n                            (not (and *inhibit-expt-simplify*\n                                      (sym/expt? analyzed-expr)\n                                      (not (v/integral?\n                                            (second\n                                             (sym/operands analyzed-expr)))))))\n                     analyzed-expr\n                     (if-let [existing-expr (@expr->var analyzed-expr)]\n                       existing-expr\n                       (new-kernels analyzed-expr))))\n                 expr))\n\n             (analyze [expr]\n               (let [vcompare (make-vcompare (x/variables-in expr))]\n                 (reset! compare-fn vcompare))\n               (ianalyze expr))\n\n\n             ;; NOTE: use `doall` to force the variable-binding side effects\n             ;; of `base-simplify`.\n             (new-kernels [expr]\n               (let [simplified-expr (doall (map base-simplify expr))\n                     op (sym/operator simplified-expr)]\n                 (if-let [v (sym/symbolic-operator op)]\n                   (let [w (apply v (sym/operands simplified-expr))]\n                     (if (and (sequential? w)\n                              (= (sym/operator w) op))\n                       (add-symbols! w)\n                       (ianalyze w)))\n                   (add-symbols! simplified-expr))))\n\n             (add-symbol! [expr]\n               (if (unquoted-list? expr)\n                 ;; in a transaction, probe and maybe update the expr->var->expr\n                 ;; maps.\n                 ;;\n                 ;; NOTE: Make sure to use the FROZEN version of the expression\n                 ;; as the key!\n                 (let [expr-k (v/freeze expr)]\n                   (#?(:clj dosync :cljs identity)\n                    (if-let [existing-expr (@expr->var expr-k)]\n                      existing-expr\n                      (let [var (symbol-generator)]\n                        (alter expr->var assoc expr-k var)\n                        (alter var->expr assoc var expr)\n                        var))))\n                 expr))\n\n             (add-symbols! [expr]\n               ;; NOTE: FORCE the side effect of binding all symbols.\n               (let [new (doall (map add-symbol! expr))]\n                 (add-symbol! new)))\n\n             (backsubstitute [expr]\n               (cond (sequential? expr) (doall\n                                         (map backsubstitute expr))\n                     (symbol? expr) (if-let [w (@var->expr expr)]\n                                      (backsubstitute w)\n                                      expr)\n                     :else expr))\n\n             (base-simplify [expr]\n               (if (unquoted-list? expr)\n                 (expression-> backend\n                               expr\n                               #(->expression backend %1 %2)\n                               v-compare)\n                 expr))\n\n             (analyze-expression [expr]\n               (binding [sym/*incremental-simplifier* false]\n                 (base-simplify\n                  (analyze expr))))\n\n             ;; Simplify relative to existing tables.\n             (simplify-expression [expr]\n               (backsubstitute\n                (analyze-expression expr)))\n\n             ;; Default simplifier\n             (simplify [expr]\n               (new-analysis!)\n               (simplify-expression\n                (x/expression-of expr)))]\n       {:simplify\n        (fn [expr]\n          (if (x/literal? expr)\n            (x/fmap simplify expr)\n            (simplify expr)))\n\n        :simplify-expression\n        (fn [expr]\n          (if (x/literal? expr)\n            (x/fmap simplify-expression expr)\n            (simplify-expression expr)))\n\n        :initializer new-analysis!\n        :analyze-expression analyze-expression\n        :get-var->expr (fn [] @var->expr)\n        :get-expr->var (fn [] @expr->var)}))))\n\n;; These functions allow you to take different pieces of the analyzer apart.\n\n(defn default-simplifier\n  \"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression => simplified S-expression) that will\n  reset its internal symbolic bindings at every invocation.\n\n  Equivalent to:\n\n  ```clojure\n  (let [new-analysis! (initializer analyzer)\n        simplify (expression-simplifier analyzer)]\n    (fn [expr]\n      (new-analysis!)\n      (simplify expr)))\n  ```\n\n  See [[expression-simplifier]] for a version that will assign the same symbol\n  to every expression it sees more than once.\"\n  [analyzer]\n  (:simplify analyzer))\n\n(defn expression-simplifier\n  \"Given an `analyzer` instance created with [[make-analyzer]], returns a\n  simplifier (a function of S-expression => simplified S-expression) that will\n  NOT reset its internal symbolic bindings across invocations.\n\n  This can be useful if the analyzer backend has any sort of memoization or\n  caching of expressions.\n\n  Pass `analyzer` to [[initializer]] to create a function that, when called,\n  will explicitly reset the internal cache:\n\n  ```clojure\n  (def reset-analyzer! (initializer analyzer))\n  (def simplify (expression-simplifier analyzer))\n\n  (reset-analyzer!)\n  (simplify <expr>)\n  ```\n\n  See [[default-simplifier]] for a version that will reset its internal variable\n  assignment cache at each invocation.\"\n  [analyzer]\n  (:simplify-expression analyzer))\n\n(defn initializer\n  \"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will reset the analyzer's internal caches\n  of symbol => subexpression and subexpression => symbol.\"\n  [analyzer]\n  (:initializer analyzer))\n\n(defn expression-analyzer\n  \"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  that will take a symbolic expression, and return a simplified expression with\n  any subexpression NOT supported by the analyzer backend replaced by a\n  generated symbol.\n\n  Any replaced subexpression will map to the SAME symbol over repeated\n  invocations, unless you call the resetting function generated by passing\n  `analyzer` to [[initializer]].\n\n  For example:\n\n  ```clojure\n  (let [a  (poly-analyzer)\n        ea (expression-analyzer a)]\n    (ea '(+ x x x (sin x) (sin x))))\n  ;;=> (+ (* 3 x) (* 2 -s-0000000000000000))\n  ```\"\n  [analyzer]\n  (:analyze-expression analyzer))\n\n(defn auxiliary-variable-fetcher\n  \"Given an `analyzer` instance created with [[make-analyzer]], returns a function\n  of no arguments that, when called, will return the analyzer's current map of\n  generated symbol => subexpression.\n\n  Call the no-argument function returned by passing `analyzer`\n  to [[initializer]] to reset the table.\n\n  For example:\n\n  ```clojure\n  (def a (poly-analyzer))\n  (def ea (expression-analyzer a))\n\n  (def get-tables (auxiliary-variable-fetcher a))\n  (def reset-tables! (initializer a))\n\n  (ea '(+ x x x (sin x) (sin x)))\n  ;;=> (+ (* 3 x) (* 2 -s-0000000000000000))\n\n  (get-tables)\n  ;;=> {'-s-0000000000000000 '(sin x)}\n\n  (reset-tables!)\n  (get-tables)\n  ;;=> {}\n  ```\"\n  [analyzer]\n  (:get-var->expr analyzer))\n"]}