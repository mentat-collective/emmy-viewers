shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderLib$vsm_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.vertex="\nvoid main() {\n\n\tgl_Position \x3d vec4( position, 1.0 );\n\n}\n";exports.fragment="\nuniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n\n#include \x3cpacking\x3e\n\nvoid main() {\n\n\tconst float samples \x3d float( VSM_SAMPLES );\n\n\tfloat mean \x3d 0.0;\n\tfloat squared_mean \x3d 0.0;\n\n\t// This seems totally useless but it's a crazy work around for a Adreno compiler bug\n\t// float depth \x3d unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy ) / resolution ) );\n\n\tfloat uvStride \x3d samples \x3c\x3d 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart \x3d samples \x3c\x3d 1.0 ? 0.0 : - 1.0;\n\tfor ( float i \x3d 0.0; i \x3c samples; i ++ ) {\n\n\t\tfloat uvOffset \x3d uvStart + i * uvStride;\n\n\t\t#ifdef HORIZONTAL_PASS\n\n\t\t\tvec2 distribution \x3d unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean +\x3d distribution.x;\n\t\t\tsquared_mean +\x3d distribution.y * distribution.y + distribution.x * distribution.x;\n\n\t\t#else\n\n\t\t\tfloat depth \x3d unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean +\x3d depth;\n\t\t\tsquared_mean +\x3d depth * depth;\n\n\t\t#endif\n\n\t}\n\n\tmean \x3d mean / samples;\n\tsquared_mean \x3d squared_mean / samples;\n\n\tfloat std_dev \x3d sqrt( squared_mean - mean * mean );\n\n\tgl_FragColor \x3d pack2HalfToRGBA( vec2( mean, std_dev ) );\n\n}\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderLib$vsm_glsl.js.map
