shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$data$volume=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Volume=void 0;global=require("module$node_modules$mathbox$build$esm$primitives$types$data$voxel");class Volume extends global.Voxel{static initClass(){this.traits="node buffer active data source index texture voxel span:x span:y span:z volume sampler:x sampler:y sampler:z raw".split(" ")}updateSpan(){var dimensions=
this.props.axes;({width:inverseX}=this.props);({height:inverseY}=this.props);({depth:inverseZ}=this.props);const {centeredX}=this.props,{centeredY}=this.props,{centeredZ}=this.props,padX=this.props.paddingX,padY=this.props.paddingY,padZ=this.props.paddingZ;var rangeX=this._helpers.span.get("x.",dimensions[0]),rangeY=this._helpers.span.get("y.",dimensions[1]);dimensions=this._helpers.span.get("z.",dimensions[2]);this.aX=rangeX.x;this.aY=rangeY.x;this.aZ=dimensions.x;rangeX=rangeX.y-rangeX.x;rangeY=
rangeY.y-rangeY.x;dimensions=dimensions.y-dimensions.x;inverseX+=2*padX;inverseY+=2*padY;inverseZ+=2*padZ;if(centeredX){var inverseX=1/Math.max(1,inverseX);this.aX+=rangeX*inverseX/2}else inverseX=1/Math.max(1,inverseX-1);if(centeredY){var inverseY=1/Math.max(1,inverseY);this.aY+=rangeY*inverseY/2}else inverseY=1/Math.max(1,inverseY-1);if(centeredZ){var inverseZ=1/Math.max(1,inverseZ);this.aZ+=dimensions*inverseZ/2}else inverseZ=1/Math.max(1,inverseZ-1);this.bX=rangeX*inverseX;this.bY=rangeY*inverseY;
this.bZ=dimensions*inverseZ;this.aX+=this.bX*padX;this.aY+=this.bY*padY;return this.aZ+=this.bZ*padY}callback(callback){this.updateSpan();if(this.last===callback)return this._callback;this.last=callback;return 7>=callback.length?this._callback=(emit,i,j,k)=>callback(emit,this.aX+this.bX*i,this.aY+this.bY*j,this.aZ+this.bZ*k,i,j,k):this._callback=(emit,i,j,k)=>callback(emit,this.aX+this.bX*i,this.aY+this.bY*j,this.aZ+this.bZ*k,i,j,k,this.bufferClock,this.bufferStep)}make(){super.make();this._helpers.span.make();
return this._listen(this,"span.range",this.updateSpan)}unmake(){super.unmake();return this._helpers.span.unmake()}change(changed,touched,init){super.change(changed,touched,init);(touched.x||touched.y||touched.z)&&this.updateSpan()}}exports.Volume=Volume;Volume.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$data$volume.js.map
