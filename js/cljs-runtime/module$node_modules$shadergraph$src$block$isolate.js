shadow$provide.module$node_modules$shadergraph$src$block$isolate=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Isolate=void 0;var _graph=require("module$node_modules$shadergraph$src$graph$index");global=require("module$node_modules$shadergraph$src$block$block");class Isolate extends global.Block{constructor(graph){super(!0);this.graph=graph;this.construct()}refresh(){super.refresh();return delete this.subroutine}clone(){return new Isolate(this.graph)}makeOutlets(){this.make();
const outlets=[],seen={};for(const set of["inputs","outputs"])for(const outlet of Array.from(this.graph[set]())){let name=void 0;["return","callback"].includes(outlet.hint)&&outlet.inout===_graph.Graph.OUT&&(name=outlet.hint);null!=seen[name]&&(name=void 0);const dupe=outlet.dupe(name);null==dupe.meta.child&&(dupe.meta.child=outlet);outlet.meta.parent=dupe;null!=name&&(seen[name]=!0);outlets.push(dupe)}return outlets}make(){return this.subroutine=this.graph.compile(this.namespace)}call(program,depth){this._call(this.subroutine,
program,depth);return this._inputs(this.subroutine,program,depth)}export(layout,depth){if(layout.visit(this.namespace,depth))return this._link(this.subroutine,layout,depth),this._trace(this.subroutine,layout,depth),this.graph.export(layout,depth)}callback(layout,depth,name,external,outlet){outlet=outlet.meta.child;return outlet.node.owner.callback(layout,depth,name,external,outlet)}}exports.Isolate=Isolate}
//# sourceMappingURL=module$node_modules$shadergraph$src$block$isolate.js.map
