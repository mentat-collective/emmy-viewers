{"version":3,"sources":["nextjournal/clojure_mode/extensions/match_brackets.cljs"],"mappings":"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","names":["nextjournal.clojure-mode.extensions.match-brackets/base-theme","js/module$node_modules$$codemirror$view$dist$index_cjs.EditorView","nextjournal.clojure-mode.extensions.match-brackets/matching-mark","js/module$node_modules$$codemirror$view$dist$index_cjs.Decoration","nextjournal.clojure-mode.extensions.match-brackets/nonmatching-mark","nextjournal.clojure-mode.extensions.match-brackets/mark-node","node","mark","nextjournal.clojure-mode.node/start","nextjournal.clojure-mode.node/end","nextjournal.clojure-mode.extensions.match-brackets/state","cljs.core/constantly","p__89362","map__89367","cljs.core/PROTOCOL_SENTINEL","cljs.core.apply","cljs.core/hash-map","obj89375","js/undefined","obj89379","obj89383","deco","tr","state","docChanged","selection","or__4253__auto__","decos","cljs.core.reduce","p__89398","map__89407","obj89422","obj89427","out","head","empty","temp__5753__auto__","bracket","and__4251__auto__","nextjournal.clojure_mode.node.tree","cljs.core.filter","cljs.core.some_fn","nextjournal.clojure-mode.node/start-edge?","nextjournal.clojure-mode.node/end-edge?","cljs.core/first","temp__5751__auto__","other-bracket","cljs.core._EQ_","nextjournal.clojure-mode.node/up","nextjournal.clojure-mode.node/down-last","p1__89350#","nextjournal.clojure-mode.util/guard","nextjournal.clojure-mode.node/name","nextjournal.clojure-mode.node/closed-by","nextjournal.clojure-mode.node/down","p1__89353#","nextjournal.clojure-mode.node/opened-by","cljs.core.conj","unparsed-bracket","cljs.core/not","nextjournal.clojure-mode.node/closest","nextjournal.clojure-mode.node/string?","G__89444","fexpr__89443","nextjournal.clojure_mode.node.from_to","cljs.core.into_array","js/module$node_modules$$codemirror$state$dist$index_cjs.StateField","nextjournal.clojure-mode.extensions.match-brackets/extension"],"sourcesContent":["(ns nextjournal.clojure-mode.extensions.match-brackets\n  (:require\n   [\"@codemirror/state\" :refer [EditorState\n                                StateField\n                                Extension]]\n   [\"@codemirror/view\" :refer [EditorView\n                               Decoration DecorationSet]]\n   [applied-science.js-interop :as j]\n   [nextjournal.clojure-mode.node :as n]\n   [nextjournal.clojure-mode.util :as u]))\n\n(def base-theme\n  (->>\n    (j/lit {:$matchingBracket {:color \"#0b0\"}\n            :$nonmatchingBracket {:color \"#a22\"}})\n    (.baseTheme EditorView)))\n\n(def ^js matching-mark (.mark Decoration (j/obj :class \"cm-matchingBracket\")))\n(def ^js nonmatching-mark (.mark Decoration (j/obj :class \"cm-nonmatchingBracket\")))\n\n(defn mark-node [node ^js mark]\n  (.range mark (n/start node) (n/end node)))\n\n(def state\n  (->>\n   (j/lit\n    {:create (constantly (.-none Decoration))\n     :update (j/fn [deco ^:js {:as tr :keys [state docChanged selection]}]\n               (if (or docChanged selection)\n                 (let [decos (->> (.. tr -state -selection -ranges)\n                                  (reduce\n                                   (j/fn [out ^:js {:keys [head empty]}]\n                                     (or\n                                      ;; a parsed bracket is found before/after cursor\n                                      (when-let [bracket (and empty\n                                                              (->> [(n/tree state head -1) (n/tree state head 1)]\n                                                                   (filter (some-fn n/start-edge? n/end-edge?))\n                                                                   first))]\n                                        ;; try finding a matching bracket\n                                        (if-let [other-bracket (cond\n\n                                                                 ;; are we at starting position?\n                                                                 (and (n/start-edge? bracket)\n                                                                      (= (n/start bracket)\n                                                                         (n/start (n/up bracket))))\n                                                                 ;; get end-bracket\n                                                                 (-> bracket n/up n/down-last\n                                                                     (u/guard #(= (n/name %)\n                                                                                  (n/closed-by bracket))))\n\n                                                                 ;; are we at ending position?\n                                                                 (and (n/end-edge? bracket)\n                                                                      (= (n/end bracket)\n                                                                         (n/end (n/up bracket))))\n                                                                 ;; get start-bracket\n                                                                 (-> bracket n/up n/down\n                                                                     (u/guard #(= (n/name %)\n                                                                                  (n/opened-by bracket)))))]\n                                          (conj out\n                                                (mark-node bracket matching-mark)\n                                                (mark-node other-bracket matching-mark))\n                                          (conj out (mark-node bracket nonmatching-mark))))\n                                      ;; lezer does not produce tokens for non-matching close-brackets\n                                      ;; (we haven't entered a collection, so brackets are not valid tokens\n                                      ;;  and aren't parsed). So we need to check the string to see if an\n                                      ;; unmatched bracket is sitting in front of the cursor.\n                                      (when-let [unparsed-bracket (and\n                                                                   ;; skip this check if we're inside a string\n                                                                   (not (-> (n/tree state head) (n/closest n/string?)))\n                                                                   (-> (.. tr -state -doc (slice head (inc head)) toString)\n                                                                       (#{\\] \\) \\}})))]\n                                        (conj out (mark-node (n/from-to head (inc head)) nonmatching-mark)))\n                                      out)) []))]\n                   (.set Decoration (into-array decos) true))\n                 deco))})\n   (.define StateField)))\n\n(defn extension []\n  #js[base-theme\n      state\n      (.. EditorView -decorations (from state))])\n"]}