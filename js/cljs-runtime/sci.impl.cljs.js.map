{"version":3,"sources":["sci/impl/cljs.cljc"],"mappings":";AAOA,AAAKA,gCAAyB,iBAAAC,WAAQ,EAAA,QAAAC,iCAAAC,0CAAAC,8CAAAC,+CAAA,AAAA,KAAAC,cAAA;AAAA,AAAAC;GAAA,AAAA,6QAAA,OAAA;AAAR,AAAA,GAAA,CAAAN,YAAA;AAAA;;AAAA,uBAAAA,hBAAgDO;;;AAC9E,AAAKC,6BAAsB,iBAAAC,WAAQ,EAAA,QAAAR,iCAAAC,0CAAAC,8CAAAO,4CAAA,AAAA,KAAAL,cAAA;AAAA,AAAAM;GAAA,AAAA,uQAAA,OAAA;AAAR,AAAA,GAAA,CAAAF,YAAA;AAAA;;AAAA,uBAAAA,hBAA6CF;;;AAExE","names":["sci.impl.cljs/cljs-ns-publics","G__77335","js/cljs","js/cljs.analyzer","js/cljs.analyzer.api","js/cljs.analyzer.api.ns-publics","cljs.core/Var","cljs.analyzer.api/ns-publics","cljs.core/deref","sci.impl.cljs/cljs-resolve","G__77358","js/cljs.analyzer.api.resolve","cljs.analyzer.api/resolve"],"sourcesContent":["(ns sci.impl.cljs\n  {:no-doc true}\n  (:require [sci.impl.macros :as macros])\n  #?(:cljs (:require-macros [sci.impl.cljs :refer [require-cljs-analyzer-api]])))\n\n;; self-hosted is satisfied here\n\n(def cljs-ns-publics #?(:cljs (some-> (resolve 'cljs.analyzer.api/ns-publics) deref)))\n(def cljs-resolve #?(:cljs (some-> (resolve 'cljs.analyzer.api/resolve) deref)))\n\n(macros/deftime\n\n  (defmacro require-cljs-analyzer-api []\n    (macros/? :clj\n              ;; noop, macro executed from JVM Clojure, not within CLJS compiler\n              nil\n              :cljs #?(;; macro executed from JVM Clojure, within CLJS compiler\n                       :clj\n                       ;; This takes care of the scenario that sci.core is loaded outside of CLJS first and then again from CLJS vis :require-macros\n                       (do (require '[cljs.analyzer.api])\n                           (intern 'sci.impl.cljs 'cljs-ns-publics @(resolve 'cljs.analyzer.api/ns-publics))\n                           (intern 'sci.impl.cljs 'cljs-resolve @(resolve 'cljs.analyzer.api/resolve)))\n                       :cljs nil))))\n"]}