{
"version":3,
"file":"module$node_modules$$motionone$utils$dist$interpolate_cjs.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,yDAAA,CAA8E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGtHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIC,IAAMN,OAAA,CAAQ,mDAAR,CAAV,CACIO,KAAOP,OAAA,CAAQ,oDAAR,CADX,CAEIQ,OAASR,OAAA,CAAQ,sDAAR,CAFb,CAGIS,SAAWT,OAAA,CAAQ,wDAAR,CAHf,CAIIU,OAASV,OAAA,CAAQ,sDAAR,CAJb;AAKIW,MAAQX,OAAA,CAAQ,qDAAR,CAyBZE,QAAQU,CAAAA,WAAR,CAvBAA,QAAoB,CAACC,MAAD,CAASC,KAAA,CAAQN,MAAOO,CAAAA,aAAP,CAAqBF,MAAOG,CAAAA,MAA5B,CAAjB,CAAsDC,QAAA,CAAWV,IAAKW,CAAAA,UAAtE,CAAkF,CAClG,MAAMF,OAASH,MAAOG,CAAAA,MAAtB,CAOMG,UAAYH,MAAZG,CAAqBL,KAAME,CAAAA,MACrB,EAAZ,CAAAG,SAAA,EAAiBX,MAAOY,CAAAA,UAAP,CAAkBN,KAAlB,CAAyBK,SAAzB,CACjB,OAAQE,EAAD,EAAO,CACV,IAAIC,EAAI,CACR,KAAA,CAAOA,CAAP,CAAWN,MAAX,CAAoB,CAApB,EACQ,EAAAK,CAAA,CAAIP,KAAA,CAAMQ,CAAN,CAAU,CAAV,CAAJ,CADR,CAAuBA,CAAA,EAAvB,EAIIC,CAAAA,CAAkBZ,KAAMA,CAAAA,KAAN,CAAY,CAAZ,CAAe,CAAf,CAAkBF,QAASA,CAAAA,QAAT,CAAkBK,KAAA,CAAMQ,CAAN,CAAlB,CAA4BR,KAAA,CAAMQ,CAAN,CAAU,CAAV,CAA5B,CAA0CD,CAA1C,CAAlB,CAEtBE,EAAA,CADsBb,MAAOc,CAAAA,mBAAPC,CAA2BR,QAA3BQ,CAAqCH,CAArCG,CACJ,CAAcF,CAAd,CAClB,OAAOjB,IAAIA,CAAAA,GAAJ,CAAQO,MAAA,CAAOS,CAAP,CAAR,CAAmBT,MAAA,CAAOS,CAAP,CAAW,CAAX,CAAnB,CAAkCC,CAAlC,CATG,CAVoF,CAZgB;",
"sources":["node_modules/@motionone/utils/dist/interpolate.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$motionone$utils$dist$interpolate_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar mix = require('./mix.cjs.js');\nvar noop = require('./noop.cjs.js');\nvar offset = require('./offset.cjs.js');\nvar progress = require('./progress.cjs.js');\nvar easing = require('./easing.cjs.js');\nvar clamp = require('./clamp.cjs.js');\n\nfunction interpolate(output, input = offset.defaultOffset(output.length), easing$1 = noop.noopReturn) {\n    const length = output.length;\n    /**\n     * If the input length is lower than the output we\n     * fill the input to match. This currently assumes the input\n     * is an animation progress value so is a good candidate for\n     * moving outside the function.\n     */\n    const remainder = length - input.length;\n    remainder > 0 && offset.fillOffset(input, remainder);\n    return (t) => {\n        let i = 0;\n        for (; i < length - 2; i++) {\n            if (t < input[i + 1])\n                break;\n        }\n        let progressInRange = clamp.clamp(0, 1, progress.progress(input[i], input[i + 1], t));\n        const segmentEasing = easing.getEasingForSegment(easing$1, i);\n        progressInRange = segmentEasing(progressInRange);\n        return mix.mix(output[i], output[i + 1], progressInRange);\n    };\n}\n\nexports.interpolate = interpolate;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","mix","noop","offset","progress","easing","clamp","interpolate","output","input","defaultOffset","length","easing$1","noopReturn","remainder","fillOffset","t","i","progressInRange","getEasingForSegment","segmentEasing"]
}
