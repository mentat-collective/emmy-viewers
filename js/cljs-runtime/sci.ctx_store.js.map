{"version":3,"sources":["sci/ctx_store.cljc"],"mappings":";;AAQA;;;;gCAAA,hCACEA;AAKF;;;gCAAA,hCAAMC,wEAEHC;AAFH,AAIW,QAAMF,gCAAME;;AAEvB,AAAA;;;+BAAA,uCAAAC,tEAAMM;AAAN,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,kEAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,oEAAA,pEAAME,+EAEHM,EAAIC;AAFP,AAIW,QAAMhB,gCAAM,AAACiB,8CAAMF,EAAEf,8BAAMgB;;;AAJtC,CAAA,uDAAA,vDAAMP;;AAAN;AAAA,CAAA,iDAAA,WAAAC,5DAAMD;AAAN,AAAA,IAAAE,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,SAAAD;;;AAAA,AAMA;;;wBAAA,xBAAMQ;AAAN,AAGE,IAAAC,mBAAInB;AAAJ,AAAA,oBAAAmB;AAAAA;;AACI,UAAA,NAAMC;AAAN,AACE,MACgB,KAAAC,MAAWD","names":["sci.ctx-store/*ctx*","sci.ctx-store/reset-ctx!","ctx","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","sci.ctx-store/swap-ctx!","seq79944","G__79945","cljs.core/first","cljs.core/next","self__5754__auto__","f","args","cljs.core.apply","sci.ctx-store/get-ctx","or__5045__auto__","msg","js/Error"],"sourcesContent":["(ns sci.ctx-store\n  \"Canonical place for projects to store, update and retrieve a context.\n  This can be used by projects that need to expose their context to\n  functions. SCI does not populate this dynamic var itself during\n  evaluation. Projects like `sci.configs` assume this var to be set in\n  some of their functions.\"\n  #?(:cljs (:require-macros [sci.ctx-store :refer [with-ctx]])))\n\n(def ^:private ^:dynamic\n  *ctx*\n  \"Dynamic var in which context is stored. Don't use directly, but only\n  via public API.\"\n  nil)\n\n(defn reset-ctx!\n  \"Store `ctx`\"\n  [ctx]\n  #?(:clj (clojure.core/alter-var-root (var *ctx*) (constantly ctx))\n     :cljs (set! *ctx* ctx)))\n\n(defn swap-ctx!\n  \"Update `ctx` using `f` and `args`\"\n  [f & args]\n  #?(:clj (apply clojure.core/alter-var-root (var *ctx*) f args)\n     :cljs (set! *ctx* (apply f *ctx* args))))\n\n(defn get-ctx\n  \"Retrieve stored ctx or throw an exception.\"\n  []\n  (or *ctx*\n      (let [msg \"No context found in: sci.ctx-store/*ctx*. Please set it using sci.ctx-store/reset-ctx!\"]\n        (throw #?(:clj (java.lang.IllegalStateException. msg)\n                  :cljs (js/Error. msg))))))\n\n(defmacro with-ctx\n  \"Bind `ctx` during execution of body.\"\n  [ctx & body]\n  `(binding [*ctx* ~ctx]\n     ~@body))\n"]}