{"version":3,"sources":["sicmutils/util/stream.cljc"],"mappings":"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","names":["sicmutils.util.stream/seq-print","n","xs","seq__80332","cljs.core/seq","chunk__80333","count__80334","i__80335","temp__5753__auto__","cljs.core/chunked-seq?","c__4679__auto__","cljs.core/chunk-first","cljs.core/chunk-rest","cljs.core/count","cljs.core/first","cljs.core/next","x","cljs.core.take","cljs.core.prn","sicmutils.generic/simplify","sicmutils.util.stream/pprint","seq__80339","chunk__80340","count__80341","i__80342","cljs.pprint.pprint","var_args","G__80348","sicmutils.util.stream/powers","js/Error","sicmutils.util.stream.powers","p1__80346#","cljs.core/iterate","G__80357","sicmutils.util.stream/zeno","sicmutils.util.stream.zeno","p1__80355#","sicmutils.util.stream/vector:generate","f","cljs.core.mapv","cljs.core.range","sicmutils.util.stream/separatev","pred","coll","vec__80364","cljs.core.nth","ts","fs","cljs.core.reduce","p__80367","vec__80368","t","o","cljs.core.conj_BANG_","cljs.core/transient","cljs.core/persistent!","sicmutils.util.stream/close-enuf?","tolerance","h1","h2","sicmutils.generic/abs","G__80372","sicmutils.util.stream/seq-limit","p__80373","map__80374","cljs.core/--destructure-map","cljs.core.get","sicmutils.util.stream.seq_limit","minterms","maxterms","convergence-fn","sicmutils.value/sqrt-machine-epsilon","cljs.core/empty?","stop?","i","cljs.core/constantly","G__80384","vec__80385","seq__80386","first__80387","vec__80388","vec__80391","seq__80392","first__80393","vec__80394","x1","x2","more","terms-checked","converged?","and__4251__auto__","or__4253__auto__"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.util.stream\n  \"This namespace contains various standard sequences, as well as utilities for\n  working with strict and lazy sequences.\"\n  (:require [clojure.pprint :as pp]\n            [sicmutils.generic :as g]\n            [sicmutils.value :as v]))\n\n(defn seq-print\n  \"Realizes, simplifies and prints `n` elements from the supplied sequence `xs`.\"\n  [n xs]\n  (doseq [x (take n xs)]\n    (prn (g/simplify x))))\n\n(defn pprint\n  \"Realizes, simplifies and pretty-prints `n` elements from the supplied sequence\n  `xs`.\"\n  [n xs]\n  (doseq [x (take n xs)]\n    (pp/pprint\n     (g/simplify x))))\n\n(defn powers\n  \"Returns an infinite sequence of `x * n^i`, starting with `i == 0`. `x` defaults\n  to 1.\"\n  ([n] (powers n 1))\n  ([n x] (iterate #(* n %) x)))\n\n(defn zeno\n  \"Returns an infinite sequence of `x / n^i`, starting with `i == 0`. `x` defaults\n  to 1.\"\n  ([n] (zeno n 1))\n  ([n x] (iterate #(/ % n) x)))\n\n(defn vector:generate\n  \"Generates a new vector of length `n` by applying the function `f` to integers\n  in the range $[0,n)$.\"\n  [n f]\n  (mapv f (range n)))\n\n(defn separatev\n  \"Returns a pair of vectors:\n\n  - the first contains the items in coll for which (pred item) returns true\n  - the second contains the items for which (pred item) returns false\n\n  pred must be free of side-effects.\"\n  [pred coll]\n  (let [[ts fs] (reduce (fn [[t f] o] (if (pred o)\n                                       [(conj! t o) f]\n                                       [t (conj! f o)]))\n                        [(transient []) (transient [])]\n                        coll)]\n    [(persistent! ts) (persistent! fs)]))\n\n;; ## Convergence Tests\n;;\n;; This convergence tester comes from Gerald Sussman's \"Abstraction in Numerical\n;; Methods\":\n;; https://dspace.mit.edu/bitstream/handle/1721.1/6060/AIM-997.pdf?sequence=2\n;;\n;; We're planning on adding a number of these here and consolidating all of the\n;; available ideas about relative and maximum tolerance so we can share (and\n;; combine) them across different stream functions.\n\n(defn ^:no-doc close-enuf?\n  \"relative closeness, transitioning to absolute closeness when we get\n  significantly smaller than 1.\"\n  [tolerance]\n  (fn [h1 h2]\n    (<= (g/abs (- h1 h2))\n        (* 0.5 tolerance (+ 2 (g/abs h1) (g/abs h2))))))\n\n;; I have a dream that a function like `seq-limit` could service most of the\n;; numerical methods in this library. Function minimization, root finding,\n;; definite integrals and numerical derivatives can all be expressed as\n;; successive approximations, with convergence tests (or other stopping\n;; conditions) checked and applied between iterations.\n;;\n;; As of 10.2020 we use this exclusively for various numerical integration\n;; routines. But it has more promise than this!\n\n(defn seq-limit\n  \"Accepts a sequence, iterates through it and returns a dictionary of this form:\n\n  {:converged? <boolean>\n   :terms-checked <int>\n   :result <sequence element>}\n\n  `:converged?` is true if the sequence reached convergence by passing the tests\n  described below, false otherwise.\n\n  `:terms-checked` will be equal to the number of items examined in the\n  sequence.\n\n  `:result` holds the final item examined in the sequence.\n\n  ## Optional keyword args:\n\n  `:convergence-fn` user-supplied function of two successive elements in `xs`\n  that stops iteration and signals convergence if it returns true.\n\n  `:minterms` `seq-limit` won't return until at least this many terms from the\n  sequence have been processed.\n\n  `:maxterms` `seq-limit` will return (with `:converged? false`) after\n  processing this many elements without passing any other checks.\n\n  `:tolerance` A combination of relative and absolute tolerance. defaults to\n  `sqrt(machine epsilon)`.\"\n  ([xs] (seq-limit xs {}))\n  ([xs {:keys [minterms\n               maxterms\n               tolerance\n               convergence-fn]\n        :or {minterms       2\n             tolerance      v/sqrt-machine-epsilon\n             convergence-fn (close-enuf? tolerance)}}]\n   (if (empty? xs)\n     {:converged? false\n      :terms-checked 0\n      :result        nil}\n     (let [stop? (if maxterms\n                   (fn [i] (>= i maxterms))\n                   (constantly false))]\n       (loop [[x1 & [x2 :as more]] xs\n              terms-checked 1]\n         (if (empty? more)\n           {:converged?    false\n            :terms-checked terms-checked\n            :result        x1}\n           (let [terms-checked (inc terms-checked)\n                 converged?    (convergence-fn x1 x2)]\n             (if (and (>= terms-checked minterms)\n                      (or converged?\n                          (stop? terms-checked)))\n               {:converged?    converged?\n                :terms-checked terms-checked\n                :result        x2}\n               (recur more terms-checked)))))))))\n"]}