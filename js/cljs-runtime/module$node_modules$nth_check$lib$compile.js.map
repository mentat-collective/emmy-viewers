{
"version":3,
"file":"module$node_modules$nth_check$lib$compile.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,yCAAA,CAA8D,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAEtGC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CACAH,QAAQI,CAAAA,OAAR,CAAkB,IAAK,EACvB,KAAIC,WAAaP,OAAA,CAAQ,oCAAR,CAmDjBE,QAAQI,CAAAA,OAAR,CAjCAA,QAAgB,CAACE,MAAD,CAAS,CACrB,IAAIC,EAAID,MAAA,CAAO,CAAP,CAAR,CAEIE,EAAIF,MAAA,CAAO,CAAP,CAAJE,CAAgB,CAQpB,IAAQ,CAAR,CAAIA,CAAJ,EAAkB,CAAlB,EAAaD,CAAb,CACI,MAAOF,WAAWI,CAAAA,SAEtB,IAAU,CAAC,CAAX,GAAIF,CAAJ,CACI,MAAO,SAAS,CAACG,KAAD,CAAQ,CAAE,MAAOA,MAAP,EAAgBF,CAAlB,CAC5B,IAAU,CAAV,GAAID,CAAJ,CACI,MAAO,SAAS,CAACG,KAAD,CAAQ,CAAE,MAAOA,MAAP,GAAiBF,CAAnB,CAE5B,IAAU,CAAV,GAAID,CAAJ,CACI,MAAW,EAAJ,CAAAC,CAAA,CAAQH,UAAWM,CAAAA,QAAnB,CAA8B,QAAS,CAACD,KAAD,CAAQ,CAAE,MAAOA,MAAP;AAAgBF,CAAlB,CAM1D,KAAII,KAAOC,IAAKC,CAAAA,GAAL,CAASP,CAAT,CAAX,CAEIQ,MAASP,CAATO,CAAaH,IAAbG,CAAqBH,IAArBG,EAA6BH,IACjC,OAAW,EAAJ,CAAAL,CAAA,CACD,QAAS,CAACG,KAAD,CAAQ,CAAE,MAAOA,MAAP,EAAgBF,CAAhB,EAAqBE,KAArB,CAA6BE,IAA7B,GAAsCG,IAAxC,CADhB,CAED,QAAS,CAACL,KAAD,CAAQ,CAAE,MAAOA,MAAP,EAAgBF,CAAhB,EAAqBE,KAArB,CAA6BE,IAA7B,GAAsCG,IAAxC,CA/BF,CAtB6E;",
"sources":["node_modules/nth-check/lib/compile.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$nth_check$lib$compile\"] = function(global,require,module,exports) {\n\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compile = void 0;\nvar boolbase_1 = require(\"boolbase\");\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","compile","boolbase_1","parsed","a","b","falseFunc","index","trueFunc","absA","Math","abs","bMod"]
}
