{
"version":3,
"file":"module$node_modules$nth_check$lib$compile.js",
"lineCount":3,
"mappings":"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",
"sources":["node_modules/nth-check/lib/compile.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$nth_check$lib$compile\"] = function(global,require,module,exports) {\n\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.generate = exports.compile = void 0;\nvar boolbase_1 = __importDefault(require(\"boolbase\"));\n/**\n * Returns a function that checks if an elements index matches the given rule\n * highly optimized to return the fastest solution.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A highly optimized function that returns whether an index matches the nth-check.\n * @example\n *\n * ```js\n * const check = nthCheck.compile([2, 3]);\n *\n * check(0); // `false`\n * check(1); // `false`\n * check(2); // `true`\n * check(3); // `false`\n * check(4); // `true`\n * check(5); // `false`\n * check(6); // `true`\n * ```\n */\nfunction compile(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    /*\n     * When `b <= 0`, `a * n` won't be lead to any matches for `a < 0`.\n     * Besides, the specification states that no elements are\n     * matched when `a` and `b` are 0.\n     *\n     * `b < 0` here as we subtracted 1 from `b` above.\n     */\n    if (b < 0 && a <= 0)\n        return boolbase_1.default.falseFunc;\n    // When `a` is in the range -1..1, it matches any element (so only `b` is checked).\n    if (a === -1)\n        return function (index) { return index <= b; };\n    if (a === 0)\n        return function (index) { return index === b; };\n    // When `b <= 0` and `a === 1`, they match any element.\n    if (a === 1)\n        return b < 0 ? boolbase_1.default.trueFunc : function (index) { return index >= b; };\n    /*\n     * Otherwise, modulo can be used to check if there is a match.\n     *\n     * Modulo doesn't care about the sign, so let's use `a`s absolute value.\n     */\n    var absA = Math.abs(a);\n    // Get `b mod a`, + a if this is negative.\n    var bMod = ((b % absA) + absA) % absA;\n    return a > 1\n        ? function (index) { return index >= b && index % absA === bMod; }\n        : function (index) { return index <= b && index % absA === bMod; };\n}\nexports.compile = compile;\n/**\n * Returns a function that produces a monotonously increasing sequence of indices.\n *\n * If the sequence has an end, the returned function will return `null` after\n * the last index in the sequence.\n *\n * @param parsed A tuple [a, b], as returned by `parse`.\n * @returns A function that produces a sequence of indices.\n * @example <caption>Always increasing (2n+3)</caption>\n *\n * ```js\n * const gen = nthCheck.generate([2, 3])\n *\n * gen() // `1`\n * gen() // `3`\n * gen() // `5`\n * gen() // `8`\n * gen() // `11`\n * ```\n *\n * @example <caption>With end value (-2n+10)</caption>\n *\n * ```js\n *\n * const gen = nthCheck.generate([-2, 5]);\n *\n * gen() // 0\n * gen() // 2\n * gen() // 4\n * gen() // null\n * ```\n */\nfunction generate(parsed) {\n    var a = parsed[0];\n    // Subtract 1 from `b`, to convert from one- to zero-indexed.\n    var b = parsed[1] - 1;\n    var n = 0;\n    // Make sure to always return an increasing sequence\n    if (a < 0) {\n        var aPos_1 = -a;\n        // Get `b mod a`\n        var minValue_1 = ((b % aPos_1) + aPos_1) % aPos_1;\n        return function () {\n            var val = minValue_1 + aPos_1 * n++;\n            return val > b ? null : val;\n        };\n    }\n    if (a === 0)\n        return b < 0\n            ? // There are no result \u2014 always return `null`\n                function () { return null; }\n            : // Return `b` exactly once\n                function () { return (n++ === 0 ? b : null); };\n    if (b < 0) {\n        b += a * Math.ceil(-b / a);\n    }\n    return function () { return a * n++ + b; };\n}\nexports.generate = generate;\n//# sourceMappingURL=compile.js.map\n};"],
"names":["shadow$provide","global","require","module","exports","__importDefault","mod","__esModule","Object","defineProperty","value","generate","compile","boolbase_1","parsed","a","b","default","falseFunc","index","trueFunc","absA","Math","abs","bMod","n","aPos_1","minValue_1","val","ceil"]
}
