import "./cljs_env.js";
shadow$provide.module$node_modules$$nextjournal$lang_clojure$dist$index_cjs=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});global=require("module$node_modules$$nextjournal$lezer_clojure$dist$index_cjs");module=require("module$node_modules$$lezer$highlight$dist$index_cjs");var language=require("module$node_modules$$codemirror$language$dist$index_cjs");const {coll}=global.props,clojureLanguage=language.LRLanguage.define({parser:global.parser.configure({props:[module.styleTags({NS:module.tags.keyword,
DefLike:module.tags.keyword,"Operator/Symbol":module.tags.keyword,"VarName/Symbol":module.tags.definition(module.tags.variableName),Boolean:module.tags.atom,"DocString/...":module.tags.emphasis,"Discard!":module.tags.comment,Number:module.tags.number,StringContent:module.tags.string,'"\\""':module.tags.string,Keyword:module.tags.atom,Nil:module.tags.null,LineComment:module.tags.lineComment,RegExp:module.tags.regexp}),language.indentNodeProp.add(nodeType=>context=>{let {node}=context;return nodeType.prop(coll)?
(context=context.column(node.firstChild.to),"List"==nodeType.name&&["NS","DefLike","Operator"].includes(node.firstChild.nextSibling.type.name)?context+1:context):0}),language.foldNodeProp.add({["Vector Map List"]:language.foldInside})]}),languageData:{commentTokens:{line:";;"}}});exports.clojure=function(){return new language.LanguageSupport(clojureLanguage)};exports.clojureLanguage=clojureLanguage}
//# sourceMappingURL=module$node_modules$$nextjournal$lang_clojure$dist$index_cjs.js.map
