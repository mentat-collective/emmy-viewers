{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_block$list.js",
"lineCount":10,
"mappings":"AAAAA,cAAA,CAAA,oDAAA,CAAyE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAUjHC,QAASA,qBAAoB,CAACC,KAAD,CAAQC,SAAR,CAAmB,CAG9C,IAAAC,IAAMF,KAAMG,CAAAA,MAAN,CAAaF,SAAb,CAANC,CAAgCF,KAAMI,CAAAA,MAAN,CAAaH,SAAb,CAChC,KAAAI,IAAML,KAAMM,CAAAA,MAAN,CAAaL,SAAb,CAENM,UAAA,CAASP,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBP,GAAA,EAArB,CAQT,OANe,GAMf,GANIK,SAMJ,EALe,EAKf,GALIA,SAKJ,EAJe,EAIf,GAJIA,SAIJ,EAAIL,GAAJ,CAAUG,GAAV,GACEK,KAEI,CAFCV,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBP,GAArB,CAED,CAAA,CAACS,OAAA,CAAQD,KAAR,CAHP,EAKW,CAAC,CALZ,CASOR,GAvBuC,CA4BhDU,QAASA,sBAAqB,CAACZ,KAAD,CAAQC,SAAR,CAAmB,CAAA,IAE3CY,MAAQb,KAAMG,CAAAA,MAAN,CAAaF,SAAb,CAARY,CAAkCb,KAAMI,CAAAA,MAAN,CAAaH,SAAb,CAFS;AAG3CC,IAAMW,KAHqC,CAI3CR,IAAML,KAAMM,CAAAA,MAAN,CAAaL,SAAb,CAGV,IAAIC,GAAJ,CAAU,CAAV,EAAeG,GAAf,CAAsB,MAAO,CAAC,CAE9BK,UAAA,CAAKV,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBP,GAAA,EAArB,CAEL,IAAS,EAAT,CAAIQ,SAAJ,EAA6B,EAA7B,CAAwBA,SAAxB,CAA4C,MAAO,CAAC,CAEpD,KAAA,CAAA,CAAA,CAAS,CAEP,GAAIR,GAAJ,EAAWG,GAAX,CAAkB,MAAO,CAAC,CAE1BK,UAAA,CAAKV,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBP,GAAA,EAArB,CAEL,IAAU,EAAV,EAAIQ,SAAJ,EAA+B,EAA/B,EAAyBA,SAAzB,CAIE,IAAmB,EAAnB,EAAIR,GAAJ,CAAUW,KAAV,CAAyB,MAAO,CAAC,CAAjC,CAJF,IAAA,CAUA,GAAW,EAAX,GAAIH,SAAJ,EAAiC,EAAjC,GAA0BA,SAA1B,CACE,KAGF,OAAO,CAAC,CAdR,CANO,CAwBT,MAAIR,IAAJ,CAAUG,GAAV,GACEK,SAEI,CAFCV,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBP,GAArB,CAED,CAAA,CAACS,OAAA,CAAQD,SAAR,CAHP,EAKW,CAAC,CALZ,CAQOR,GA7CwC,CAjCjD,IAAIS,QAAUf,OAAA,CAAQ,kDAAR,CAA2Be,CAAAA,OA+FzCd,OAAOC,CAAAA,OAAP,CAAiBgB,QAAa,CAACd,KAAD;AAAQC,SAAR,CAAmBc,OAAnB,CAA4BC,MAA5B,CAAoC,CAAA,IAM5DC,OAN4D,CAS5DC,CAT4D,CAiB5DC,aAYAC,KAAAA,eAAyB,CAAA,CA5B7B,KA6BIC,MAAQ,CAAA,CAWZ,IARiD,CAQjD,EARIrB,KAAMsB,CAAAA,MAAN,CAAarB,SAAb,CAQJ,CAR8BD,KAAMuB,CAAAA,SAQpC,EAAwB,CAAxB,EAAIvB,KAAMwB,CAAAA,UAAV,EACkD,CADlD,EACIxB,KAAMsB,CAAAA,MAAN,CAAarB,SAAb,CADJ,CAC8BD,KAAMwB,CAAAA,UADpC,EAEIxB,KAAMsB,CAAAA,MAAN,CAAarB,SAAb,CAFJ,CAE8BD,KAAMuB,CAAAA,SAFpC,CAGE,MAAO,CAAA,CAKLP,OAAJ,EAAmC,WAAnC,GAAchB,KAAMyB,CAAAA,UAApB,EAMMzB,KAAMsB,CAAAA,MAAN,CAAarB,SAAb,CANN,EAMiCD,KAAMuB,CAAAA,SANvC,GAOIH,cAPJ,CAO6B,CAAA,CAP7B,CAYA,IAAkE,CAAlE,GAAKM,aAAL,CAAsBd,qBAAA,CAAsBZ,KAAtB,CAA6BC,SAA7B,CAAtB,EAAqE,CACnE,IAAA0B,UAAY,CAAA,CACZ,KAAAd,MAAQb,KAAMG,CAAAA,MAAN,CAAaF,SAAb,CAARY,CAAkCb,KAAMI,CAAAA,MAAN,CAAaH,SAAb,CAClC,KAAA2B;AAAcC,MAAA,CAAO7B,KAAMQ,CAAAA,GAAIsB,CAAAA,KAAV,CAAgBjB,KAAhB,CAAuBa,aAAvB,CAAwC,CAAxC,CAAP,CAId,IAAIN,cAAJ,EAA8C,CAA9C,GAA8BQ,SAA9B,CAAiD,MAAO,CAAA,CAPW,CAArE,IASO,IAAiE,CAAjE,GAAKF,aAAL,CAAsB3B,oBAAA,CAAqBC,KAArB,CAA4BC,SAA5B,CAAtB,EACL0B,SAAA,CAAY,CAAA,CADP,KAIL,OAAO,CAAA,CAKT,IAAIP,cAAJ,EACMpB,KAAM+B,CAAAA,UAAN,CAAiBL,aAAjB,CADN,EAC0C1B,KAAMM,CAAAA,MAAN,CAAaL,SAAb,CAD1C,CACmE,MAAO,CAAA,CAI1E+B,eAAA,CAAiBhC,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBiB,aAArB,CAAsC,CAAtC,CAGjB,IAAIV,MAAJ,CAAc,MAAO,CAAA,CAGrBiB,OAAA,CAAajC,KAAMkC,CAAAA,MAAOC,CAAAA,MAE1B,IAAIR,SAAJ,CAAe,CACb,IAAAS,UAAcpC,KAAMqC,CAAAA,IAAN,CAAW,mBAAX,CAAgC,IAAhC,CAAsC,CAAtC,CACM,EAApB,GAAIT,SAAJ,GACEQ,SAAME,CAAAA,KADR,CACgB,CAAE,CAAE,OAAF,CAAWV,SAAX,CAAF,CADhB,CAFa,CAAf,IAOEQ,UAAA;AAAcpC,KAAMqC,CAAAA,IAAN,CAAW,kBAAX,CAA+B,IAA/B,CAAqC,CAArC,CAGhBD,UAAMG,CAAAA,GAAN,CAAeC,SAAf,CAA2B,CAAEvC,SAAF,CAAa,CAAb,CAC3BmC,UAAMK,CAAAA,MAAN,CAAeC,MAAOC,CAAAA,YAAP,CAAoBX,cAApB,CAMf,KAAAY,aAAW3C,SACX,KAAA4C,aAAe,CAAA,CACf,KAAAC,gBAAkB9C,KAAM+C,CAAAA,EAAGC,CAAAA,KAAMC,CAAAA,KAAMC,CAAAA,QAArB,CAA8B,MAA9B,CAElB,KAAAC,cAAgBnD,KAAMyB,CAAAA,UAGtB,KAFAzB,KAAMyB,CAAAA,UAEN,CAFmB,MAEnB,CAAOmB,YAAP,CAAkB7B,OAAlB,CAAA,CAA2B,CACzBb,SAAA,CAAMwB,aACN,KAAArB,EAAML,KAAMM,CAAAA,MAAN,CAAasC,YAAb,CAIN,KAFA3B,OAEA,CAFUmC,CAEV,CAFmBpD,KAAMsB,CAAAA,MAAN,CAAasB,YAAb,CAEnB,CAF4ClB,aAE5C,EAF8D1B,KAAMG,CAAAA,MAAN,CAAaF,SAAb,CAE9D,CAFwFD,KAAMI,CAAAA,MAAN,CAAaH,SAAb,CAExF,EAAOC,SAAP,CAAaG,CAAb,CAAA,CAAkB,CAChB,IAAAK;AAAKV,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBP,SAArB,CAEL,IAAW,CAAX,GAAIQ,EAAJ,CACE0C,CAAA,EAAU,CAAV,EAAeA,CAAf,CAAwBpD,KAAMqD,CAAAA,OAAN,CAAcT,YAAd,CAAxB,EAAmD,CADrD,KAEO,IAAW,EAAX,GAAIlC,EAAJ,CACL0C,CAAA,EADK,KAGL,MAGFlD,UAAA,EAXgB,CAclBoD,YAAA,CAAepD,SAIbqD,GAAA,CAFED,YAAJ,EAAoBjD,CAApB,CAEsB,CAFtB,CAIsB+C,CAJtB,CAI+BnC,OAKP,EAAxB,CAAIsC,EAAJ,GAA6BA,EAA7B,CAAiD,CAAjD,CAIAC,GAAA,CAASvC,OAAT,CAAmBsC,EAGnBnB,UAAA,CAAepC,KAAMqC,CAAAA,IAAN,CAAW,gBAAX,CAA6B,IAA7B,CAAmC,CAAnC,CACfD,UAAMK,CAAAA,MAAN,CAAeC,MAAOC,CAAAA,YAAP,CAAoBX,cAApB,CACfI,UAAMG,CAAAA,GAAN,CAAekB,OAAf,CAA2B,CAAExD,SAAF,CAAa,CAAb,CACvB0B,UAAJ,GACES,SAAMsB,CAAAA,IADR,CACe1D,KAAMQ,CAAAA,GAAIsB,CAAAA,KAAV,CAAgBjB,KAAhB,CAAuBa,aAAvB,CAAwC,CAAxC,CADf,CAKA,KAAAiC,SAAW3D,KAAMqB,CAAAA,KACjB,KAAAuC,UAAY5D,KAAMI,CAAAA,MAAN,CAAaH,SAAb,CACZ4D,UAAA,CAAY7D,KAAMsB,CAAAA,MAAN,CAAarB,SAAb,CAMZkB;aAAA,CAAgBnB,KAAMwB,CAAAA,UACtBxB,MAAMwB,CAAAA,UAAN,CAAmBxB,KAAMuB,CAAAA,SACzBvB,MAAMuB,CAAAA,SAAN,CAAkBiC,EAElBxD,MAAMqB,CAAAA,KAAN,CAAc,CAAA,CACdrB,MAAMI,CAAAA,MAAN,CAAaH,SAAb,CAAA,CAA0BqD,YAA1B,CAAyCtD,KAAMG,CAAAA,MAAN,CAAaF,SAAb,CACzCD,MAAMsB,CAAAA,MAAN,CAAarB,SAAb,CAAA,CAA0BmD,CAEtBE,aAAJ,EAAoBjD,CAApB,EAA2BL,KAAM8D,CAAAA,OAAN,CAAc7D,SAAd,CAA0B,CAA1B,CAA3B,CAQED,KAAM+D,CAAAA,IARR,CAQeC,IAAKC,CAAAA,GAAL,CAASjE,KAAM+D,CAAAA,IAAf,CAAsB,CAAtB,CAAyBhD,OAAzB,CARf,CAUEf,KAAM+C,CAAAA,EAAGC,CAAAA,KAAMkB,CAAAA,QAAf,CAAwBlE,KAAxB,CAA+BC,SAA/B,CAA0Cc,OAA1C,CAAmD,CAAA,CAAnD,CAIF,IAAI,CAACf,KAAMqB,CAAAA,KAAX,EAAoBwB,YAApB,CACExB,KAAA,CAAQ,CAAA,CAIVwB,aAAA,CAA0C,CAA1C,CAAgB7C,KAAM+D,CAAAA,IAAtB,CAA6B9D,SAA7B,EAA+CD,KAAM8D,CAAAA,OAAN,CAAc9D,KAAM+D,CAAAA,IAApB,CAA2B,CAA3B,CAE/C/D,MAAMuB,CAAAA,SAAN,CAAkBvB,KAAMwB,CAAAA,UACxBxB,MAAMwB,CAAAA,UAAN,CAAmBL,aACnBnB,MAAMI,CAAAA,MAAN,CAAaH,SAAb,CAAA;AAA0B2D,SAC1B5D,MAAMsB,CAAAA,MAAN,CAAarB,SAAb,CAAA,CAA0B4D,SAC1B7D,MAAMqB,CAAAA,KAAN,CAAcsC,QAEdvB,UAAA,CAAepC,KAAMqC,CAAAA,IAAN,CAAW,iBAAX,CAA8B,IAA9B,CAAoC,CAAC,CAArC,CACfD,UAAMK,CAAAA,MAAN,CAAeC,MAAOC,CAAAA,YAAP,CAAoBX,cAApB,CAEfY,aAAA,CAAW3C,SAAX,CAAuBD,KAAM+D,CAAAA,IAC7BN,QAAA,CAAU,CAAV,CAAA,CAAeb,YAGf,IAAIA,YAAJ,EAAgB7B,OAAhB,CAA2B,KAK3B,IAAIf,KAAMsB,CAAAA,MAAN,CAAasB,YAAb,CAAJ,CAA6B5C,KAAMuB,CAAAA,SAAnC,CAAgD,KAGhD,IAAiD,CAAjD,EAAIvB,KAAMsB,CAAAA,MAAN,CAAarB,SAAb,CAAJ,CAA8BD,KAAMuB,CAAAA,SAApC,CAAsD,KAGtD4C,cAAA,CAAY,CAAA,CACPC,EAAA,CAAI,CAAT,KAAYlD,CAAZ,CAAgB4B,eAAgBX,CAAAA,MAAhC,CAAwCiC,CAAxC,CAA4ClD,CAA5C,CAA+CkD,CAAA,EAA/C,CACE,GAAItB,eAAA,CAAgBsB,CAAhB,CAAA,CAAmBpE,KAAnB,CAA0B4C,YAA1B,CAAoC7B,OAApC,CAA6C,CAAA,CAA7C,CAAJ,CAAwD,CACtDoD,aAAA,CAAY,CAAA,CACZ,MAFsD,CAK1D,GAAIA,aAAJ,CAAiB,KAGjB;GAAIxC,SAAJ,CAAe,CACbD,aAAA,CAAiBd,qBAAA,CAAsBZ,KAAtB,CAA6B4C,YAA7B,CACjB,IAAqB,CAArB,CAAIlB,aAAJ,CAA0B,KAC1Bb,MAAA,CAAQb,KAAMG,CAAAA,MAAN,CAAayC,YAAb,CAAR,CAAiC5C,KAAMI,CAAAA,MAAN,CAAawC,YAAb,CAHpB,CAAf,IAME,IADAlB,aACI,CADa3B,oBAAA,CAAqBC,KAArB,CAA4B4C,YAA5B,CACb,CAAiB,CAAjB,CAAAlB,aAAJ,CAA0B,KAG5B,IAAIM,cAAJ,GAAuBhC,KAAMQ,CAAAA,GAAIC,CAAAA,UAAV,CAAqBiB,aAArB,CAAsC,CAAtC,CAAvB,CAAmE,KA9H1C,CAmIzBU,SAAA,CADET,SAAJ,CACU3B,KAAMqC,CAAAA,IAAN,CAAW,oBAAX,CAAiC,IAAjC,CAAuC,CAAC,CAAxC,CADV,CAGUrC,KAAMqC,CAAAA,IAAN,CAAW,mBAAX,CAAgC,IAAhC,CAAsC,CAAC,CAAvC,CAEVD,UAAMK,CAAAA,MAAN,CAAeC,MAAOC,CAAAA,YAAP,CAAoBX,cAApB,CAEfQ,UAAA,CAAU,CAAV,CAAA,CAAeI,YACf5C,MAAM+D,CAAAA,IAAN,CAAanB,YAEb5C;KAAMyB,CAAAA,UAAN,CAAmB0B,aAGnB,IAAI9B,KAAJ,CA7QA,IAFIgD,SAEc,CA8QIrE,KAhRJqE,CAAAA,KAEA,CAFQ,CAER,CAAbD,OAAa,CA8QWnC,MA9QX,CAAH,CAAG,CAAAf,SAAA,CA8QIlB,KA9QMkC,CAAAA,MAAOC,CAAAA,MAAjB,CAA0B,CAA5C,CAA+CiC,OAA/C,CAAmDlD,SAAnD,CAAsDkD,OAAA,EAAtD,CA8QsBpE,KA7QVkC,CAAAA,MAAN,CAAakC,OAAb,CAAgBC,CAAAA,KAApB,GAA8BA,SAA9B,EAAgE,gBAAhE,GA6QoBrE,KA7QyBkC,CAAAA,MAAN,CAAakC,OAAb,CAAgBE,CAAAA,IAAvD,GA6QoBtE,KA5QZkC,CAAAA,MAAN,CAAakC,OAAb,CAAiB,CAAjB,CAAoBG,CAAAA,MAEpB,CAF6B,CAAA,CAE7B,CA0QkBvE,KA3QZkC,CAAAA,MAAN,CAAakC,OAAb,CAAgBG,CAAAA,MAChB,CADyB,CAAA,CACzB,CAAAH,OAAA,EAAK,CAHP,CAgRF,OAAO,CAAA,CAvQyD,CApG+C;",
"sources":["node_modules/markdown-it/lib/rules_block/list.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$list\"] = function(global,require,module,exports) {\n// Lists\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max, ch;\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1;\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      pos = start,\n      max = state.eMarks[startLine];\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1; }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1; }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1; }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1; }\n\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break;\n    }\n\n    return -1;\n  }\n\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i, l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\n\n\nmodule.exports = function list(state, startLine, endLine, silent) {\n  var ch,\n      contentStart,\n      i,\n      indent,\n      indentAfterMarker,\n      initial,\n      isOrdered,\n      itemLines,\n      l,\n      listLines,\n      listTokIdx,\n      markerCharCode,\n      markerValue,\n      max,\n      nextLine,\n      offset,\n      oldListIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      oldTight,\n      pos,\n      posAfterMarker,\n      prevEmptyEnd,\n      start,\n      terminate,\n      terminatorRules,\n      token,\n      isTerminatingParagraph = false,\n      tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[startLine] - state.listIndent >= 4 &&\n      state.sCount[startLine] < state.blkIndent) {\n    return false;\n  }\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[startLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[startLine]) return false;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true; }\n\n  // Start list\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [ [ 'start', markerValue ] ];\n    }\n\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1);\n  }\n\n  token.map    = listLines = [ startLine, 0 ];\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.md.block.ruler.getRules('list');\n\n  oldParentType = state.parentType;\n  state.parentType = 'list';\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n\n    initial = offset = state.sCount[nextLine] + posAfterMarker - (state.bMarks[startLine] + state.tShift[startLine]);\n\n    while (pos < max) {\n      ch = state.src.charCodeAt(pos);\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n\n      pos++;\n    }\n\n    contentStart = pos;\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1; }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    token.map    = itemLines = [ startLine, 0 ];\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1);\n    }\n\n    // change current state, then restore it after parser subcall\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldSCount = state.sCount[startLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n\n    state.tight = true;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.sCount[startLine] = offset;\n\n    if (contentStart >= max && state.isEmpty(startLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, startLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - startLine) > 1 && state.isEmpty(state.line - 1);\n\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[startLine] = oldTShift;\n    state.sCount[startLine] = oldSCount;\n    state.tight = oldTight;\n\n    token        = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) { break; }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break; }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[startLine] - state.blkIndent >= 4) { break; }\n\n    // fail if terminating block found\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) { break; }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) { break; }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break; }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n\n  listLines[1] = nextLine;\n  state.line = nextLine;\n\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","skipBulletListMarker","state","startLine","pos","bMarks","tShift","max","eMarks","marker","src","charCodeAt","ch","isSpace","skipOrderedListMarker","start","module.exports","endLine","silent","initial","l","oldListIndent","isTerminatingParagraph","tight","sCount","blkIndent","listIndent","parentType","posAfterMarker","isOrdered","markerValue","Number","slice","skipSpaces","markerCharCode","listTokIdx","tokens","length","token","push","attrs","map","listLines","markup","String","fromCharCode","nextLine","prevEmptyEnd","terminatorRules","md","block","ruler","getRules","oldParentType","offset","bsCount","contentStart","indentAfterMarker","indent","itemLines","info","oldTight","oldTShift","oldSCount","isEmpty","line","Math","min","tokenize","terminate","i","level","type","hidden"]
}
