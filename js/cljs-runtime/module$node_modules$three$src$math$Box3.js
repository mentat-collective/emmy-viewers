shadow$provide.module$node_modules$three$src$math$Box3=function(global,require,module,exports){function satForAxes(axes,v0,v1,v2,extents){for(let i=0,j=axes.length-3;i<=j;i+=3){_testAxis.fromArray(axes,i);const r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z),p0=v0.dot(_testAxis),p1=v1.dot(_testAxis),p2=v2.dot(_testAxis);if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r)return!1}return!0}Object.defineProperty(exports,"__esModule",{value:!0});exports.Box3=
void 0;var _Vector=require("module$node_modules$three$src$math$Vector3");class Box3{constructor(min=new _Vector.Vector3(Infinity,Infinity,Infinity),max=new _Vector.Vector3(-Infinity,-Infinity,-Infinity)){this.min=min;this.max=max}set(min,max){this.min.copy(min);this.max.copy(max);return this}setFromArray(array){let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;for(let i=0,l=array.length;i<l;i+=3){const x=array[i],y=array[i+1],z=array[i+2];x<minX&&(minX=x);
y<minY&&(minY=y);z<minZ&&(minZ=z);x>maxX&&(maxX=x);y>maxY&&(maxY=y);z>maxZ&&(maxZ=z)}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this}setFromBufferAttribute(attribute){let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;for(let i=0,l=attribute.count;i<l;i++){const x=attribute.getX(i),y=attribute.getY(i),z=attribute.getZ(i);x<minX&&(minX=x);y<minY&&(minY=y);z<minZ&&(minZ=z);x>maxX&&(maxX=x);y>maxY&&(maxY=y);z>maxZ&&(maxZ=z)}this.min.set(minX,
minY,minZ);this.max.set(maxX,maxY,maxZ);return this}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++)this.expandByPoint(points[i]);return this}setFromCenterAndSize(center,size){size=_vector.copy(size).multiplyScalar(.5);this.min.copy(center).sub(size);this.max.copy(center).add(size);return this}setFromObject(object,precise=!1){this.makeEmpty();return this.expandByObject(object,precise)}clone(){return(new this.constructor).copy(this)}copy(box){this.min.copy(box.min);this.max.copy(box.max);
return this}makeEmpty(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min)}expandByPoint(point){this.min.min(point);this.max.max(point);return this}expandByVector(vector){this.min.sub(vector);
this.max.add(vector);return this}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this}expandByObject(object,precise=!1){object.updateWorldMatrix(!1,!1);var geometry=object.geometry;if(void 0!==geometry)if(precise&&void 0!=geometry.attributes&&void 0!==geometry.attributes.position){geometry=geometry.attributes.position;for(let i=0,l=geometry.count;i<l;i++)_vector.fromBufferAttribute(geometry,i).applyMatrix4(object.matrixWorld),this.expandByPoint(_vector)}else null===
geometry.boundingBox&&geometry.computeBoundingBox(),_box.copy(geometry.boundingBox),_box.applyMatrix4(object.matrixWorld),this.union(_box);object=object.children;for(let i=0,l=object.length;i<l;i++)this.expandByObject(object[i],precise);return this}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y||point.z<this.min.z||point.z>this.max.z?!1:!0}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=
this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(box){return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?!1:!0}intersectsSphere(sphere){this.clampPoint(sphere.center,_vector);return _vector.distanceToSquared(sphere.center)<=
sphere.radius*sphere.radius}intersectsPlane(plane){let min,max;0<plane.normal.x?(min=plane.normal.x*this.min.x,max=plane.normal.x*this.max.x):(min=plane.normal.x*this.max.x,max=plane.normal.x*this.min.x);0<plane.normal.y?(min+=plane.normal.y*this.min.y,max+=plane.normal.y*this.max.y):(min+=plane.normal.y*this.max.y,max+=plane.normal.y*this.min.y);0<plane.normal.z?(min+=plane.normal.z*this.min.z,max+=plane.normal.z*this.max.z):(min+=plane.normal.z*this.max.z,max+=plane.normal.z*this.min.z);return min<=
-plane.constant&&max>=-plane.constant}intersectsTriangle(triangle){if(this.isEmpty())return!1;this.getCenter(_center);_extents.subVectors(this.max,_center);_v0.subVectors(triangle.a,_center);_v1.subVectors(triangle.b,_center);_v2.subVectors(triangle.c,_center);_f0.subVectors(_v1,_v0);_f1.subVectors(_v2,_v1);_f2.subVectors(_v0,_v2);triangle=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(triangle,
_v0,_v1,_v2,_extents))return!1;triangle=[1,0,0,0,1,0,0,0,1];if(!satForAxes(triangle,_v0,_v1,_v2,_extents))return!1;_triangleNormal.crossVectors(_f0,_f1);triangle=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(triangle,_v0,_v1,_v2,_extents)}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max)}distanceToPoint(point){return _vector.copy(point).clamp(this.min,this.max).sub(point).length()}getBoundingSphere(target){this.getCenter(target.center);target.radius=
.5*this.getSize(_vector).length();return target}intersect(box){this.min.max(box.min);this.max.min(box.max);this.isEmpty()&&this.makeEmpty();return this}union(box){this.min.min(box.min);this.max.max(box.max);return this}applyMatrix4(matrix){if(this.isEmpty())return this;_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);_points[3].set(this.min.x,
this.max.y,this.max.z).applyMatrix4(matrix);_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);this.setFromPoints(_points);return this}translate(offset){this.min.add(offset);this.max.add(offset);return this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}
exports.Box3=Box3;Box3.prototype.isBox3=!0;const _points=[new _Vector.Vector3,new _Vector.Vector3,new _Vector.Vector3,new _Vector.Vector3,new _Vector.Vector3,new _Vector.Vector3,new _Vector.Vector3,new _Vector.Vector3],_vector=new _Vector.Vector3,_box=new Box3,_v0=new _Vector.Vector3,_v1=new _Vector.Vector3,_v2=new _Vector.Vector3,_f0=new _Vector.Vector3,_f1=new _Vector.Vector3,_f2=new _Vector.Vector3,_center=new _Vector.Vector3,_extents=new _Vector.Vector3,_triangleNormal=new _Vector.Vector3,_testAxis=
new _Vector.Vector3}
//# sourceMappingURL=module$node_modules$three$src$math$Box3.js.map
