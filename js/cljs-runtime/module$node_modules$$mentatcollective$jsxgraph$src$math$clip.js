shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$math$clip=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;global=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg"));var _constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants")),_coords=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coords")),
_math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),_geometry=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$geometry")),_type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type"));_math.default.Clip={_isSeparator:function(node){return isNaN(node.coords.usrCoords[1])&&isNaN(node.coords.usrCoords[2])},makeDoublyLinkedList:function(S){var i,first=null,components=[],le=
S.length;if(0<le)for(i=0;i<le;i++)this._isSeparator(S[i])?(S[i]._next=S[(i+1)%le],S[i]._prev=S[(le+i-1)%le]):(null===first&&(first=i,components.push(first)),this._isSeparator(S[(i+1)%le])||i===le-1?(S[i]._next=S[first],S[first]._prev=S[i],S[i]._end=!0,first=null):(S[i]._next=S[(i+1)%le],S[first]._prev=S[i]),this._isSeparator(S[(le+i-1)%le])||(S[i]._prev=S[(le+i-1)%le]));return components},Vertex:function(coords,i,alpha,path,pathname,type){this.pos=i;this.intersection=!0;this.coords=coords;this.elementClass=
_constants.default.OBJECT_CLASS_POINT;this.data={alpha,path,pathname,done:!1,type,idx:0};this.neighbour=null;this.entry_exit=!1},_addToList:function(list,coords,pos){var len=list.length,eps=_math.default.eps*_math.default.eps;0<len&&Math.abs(list[len-1].coords.usrCoords[0]-coords.usrCoords[0])<eps&&Math.abs(list[len-1].coords.usrCoords[1]-coords.usrCoords[1])<eps&&Math.abs(list[len-1].coords.usrCoords[2]-coords.usrCoords[2])<eps||list.push({pos,intersection:!1,coords,elementClass:_constants.default.OBJECT_CLASS_POINT})},
sortIntersections:function(P_crossings){var i,P_intersect=[],P_le=P_crossings.length;for(i=0;i<P_le;i++)if(P_crossings[i].sort(function(a,b){return a.data.alpha>b.data.alpha?1:-1}),0<P_crossings[i].length){var last=P_crossings[i].length-1;var P=P_crossings[i][0];var j=P.data.path[P.pos];var next_node=j._next;i===P_le-1&&(j._end=!1);0===P.data.alpha&&"T"===P.data.type?(j.intersection=!0,j.data=P.data,j.neighbour=P.neighbour,j.neighbour.neighbour=j,j.entry_exit=!1,P_crossings[i][0]=j):(P._prev=j,P._prev._next=
P);for(j=1;j<=last;j++)P=P_crossings[i][j],P._prev=P_crossings[i][j-1],P._prev._next=P;P=P_crossings[i][last];P._next=next_node;P._next._prev=P;i===P_le-1&&(P._end=!0);P_intersect=P_intersect.concat(P_crossings[i])}return P_intersect},_inbetween:function(q,p1,p2){var eps=_math.default.eps*_math.default.eps;var alpha=p2[1]-p1[1];p2=p2[2]-p1[2];var qx=q[1]-p1[1];q=q[2]-p1[2];if(0===alpha&&0===p2&&0===qx&&0===q)return!0;alpha=Math.abs(qx)<eps&&Math.abs(alpha)<eps?q/p2:qx/alpha;Math.abs(alpha)<eps&&(alpha=
0);return alpha},_print_array:function(arr){var i;for(i=0;i<arr.length;i++)try{var end="";arr[i]._end&&(end=" end");console.log(i,arr[i].coords.usrCoords,arr[i].data.type,"\t","prev",arr[i]._prev.coords.usrCoords,"next",arr[i]._next.coords.usrCoords+end)}catch(e){console.log(i,arr[i].coords.usrCoords)}},_print_list:function(P){for(var cnt=0,alpha;100>cnt;){alpha=P.data?P.data.alpha:"-";console.log("\t",P.coords.usrCoords,"\n\t\tis:",P.intersection,"end:",P._end,alpha,"\n\t\t-:",P._prev.coords.usrCoords,
"\n\t\t+:",P._next.coords.usrCoords,"\n\t\tn:",P.intersection?P.neighbour.coords.usrCoords:"-");if(P._end)break;P=P._next;cnt++}},_noOverlap:function(p1,p2,q1,q2){var k,eps=Math.sqrt(_math.default.eps),no_overlap=!1;for(k=0;3>k;k++){var minp=Math.min(p1[k],p2[k]);var maxp=Math.max(p1[k],p2[k]);var minq=Math.min(q1[k],q2[k]);var maxq=Math.max(q1[k],q2[k]);if(maxp<minq-eps||minp>maxq+eps){no_overlap=!0;break}}return no_overlap},findIntersections:function(S,C,board){var eps=_math.default.eps,i,j,S_le=
S.length,C_le=C.length,S_crossings=[],C_crossings=[],hasMultCompsS=!1,hasMultCompsC=!1;for(j=0;j<C_le;j++)C_crossings.push([]);for(i=0;i<S_le;i++)if(S_crossings.push([]),this._isSeparator(S[i])||this._isSeparator(S[(i+1)%S_le]))hasMultCompsS=!0;else{if(hasMultCompsS&&i===S_le-1)break;var Si=S[i].coords.usrCoords;var Si1=S[(i+1)%S_le].coords.usrCoords;for(j=0;j<C_le;j++)if(this._isSeparator(C[j])||this._isSeparator(C[(j+1)%C_le]))hasMultCompsC=!0;else{if(hasMultCompsC&&j===C_le-1)break;var Cj=C[j].coords.usrCoords;
var Cj1=C[(j+1)%C_le].coords.usrCoords;if(!this._noOverlap(Si,Si1,Cj,Cj1)){var res=_geometry.default.meetSegmentSegment(Si,Si1,Cj,Cj1);var d1=_geometry.default.distance(Si,Si1,3);var d2=_geometry.default.distance(Cj,Cj1,3);if(res[1]*d1>-eps&&res[1]<1-eps/d1&&res[2]*d2>-eps&&res[2]<1-eps/d2||Infinity===res[1]&&Infinity===res[2]&&_math.default.norm(res[0],3)<eps){var crds=new _coords.default(_constants.default.COORDS_BY_USER,res[0],board);var type="X";if(Math.abs(res[1])*d1<eps||Math.abs(res[2])*d2<
eps)type="T",Math.abs(res[1])*d1<eps&&(res[1]=0),Math.abs(res[2])*d2<eps&&(res[2]=0),crds=0===res[1]?new _coords.default(_constants.default.COORDS_BY_USER,Si,board):new _coords.default(_constants.default.COORDS_BY_USER,Cj,board);else if(Infinity===res[1]&&Infinity===res[2]&&_math.default.norm(res[0],3)<eps){Cj1=this._inbetween(Si,Cj,Cj1);0<=Cj1&&1>Cj1&&(type="T",crds=new _coords.default(_constants.default.COORDS_BY_USER,Si,board),res[1]=0,res[2]=Cj1,Cj1=new this.Vertex(crds,i,res[1],S,"S",type),crds=
new this.Vertex(crds,j,res[2],C,"C",type),Cj1.neighbour=crds,crds.neighbour=Cj1,S_crossings[i].push(Cj1),C_crossings[j].push(crds));Cj1=this._inbetween(Cj,Si,Si1);_geometry.default.distance(Si,Cj,3)>eps&&0<=Cj1&&1>Cj1&&(type="T",crds=new _coords.default(_constants.default.COORDS_BY_USER,Cj,board),res[1]=Cj1,res[2]=0,Cj1=new this.Vertex(crds,i,res[1],S,"S",type),crds=new this.Vertex(crds,j,res[2],C,"C",type),Cj1.neighbour=crds,crds.neighbour=Cj1,S_crossings[i].push(Cj1),C_crossings[j].push(crds));
continue}Cj1=new this.Vertex(crds,i,res[1],S,"S",type);crds=new this.Vertex(crds,j,res[2],C,"C",type);Cj1.neighbour=crds;crds.neighbour=Cj1;S_crossings[i].push(Cj1);C_crossings[j].push(crds)}}}}S=this.sortIntersections(S_crossings);for(i=0;i<S.length;i++)S[i].data.idx=i,S[i].neighbour.data.idx=i;i=this.sortIntersections(C_crossings);return[S,i]},_getPosition:function(q,p1,p2,p3){var s1=_geometry.default.det3p(q,p1,p2);q=_geometry.default.det3p(q,p2,p3);return 0<=_geometry.default.det3p(p1,p2,p3)?
0<=s1&&0<=q?"left":"right":0<=s1||0<=q?"left":"right"},_classifyDegenerateIntersections:function(P){var det=_geometry.default.det3p;var cnt=0;for(P._tours=0;;){if(P.intersection&&"T"===P.data.type){var Pp=P._next.coords.usrCoords;var Pm=P._prev.coords.usrCoords;_geometry.default.distance(P.coords.usrCoords,Pp,3)<_math.default.eps&&(Pp=P._next._next.coords.usrCoords);_geometry.default.distance(P.coords.usrCoords,Pm,3)<_math.default.eps&&(Pm=P._prev._prev.coords.usrCoords);var Q=P.neighbour;var Qm=
Q._prev.coords.usrCoords;var Qp=Q._next.coords.usrCoords;_geometry.default.distance(Q.coords.usrCoords,Qp,3)<_math.default.eps&&(Qp=Q._next._next.coords.usrCoords);_geometry.default.distance(Q.coords.usrCoords,Qm,3)<_math.default.eps&&(Qm=Q._prev._prev.coords.usrCoords);var s1=det(P.coords.usrCoords,Pm,Qm);var s2=det(P.coords.usrCoords,Pp,Qp);var s3=det(P.coords.usrCoords,Pm,Qp);var s4=det(P.coords.usrCoords,Pp,Qm);0===s1&&0===s2&&0===s3&&0===s4&&(P.coords.usrCoords[1]*=1+Math.random()*_math.default.eps,
P.coords.usrCoords[2]*=1+Math.random()*_math.default.eps,Q.coords.usrCoords[1]=P.coords.usrCoords[1],Q.coords.usrCoords[2]=P.coords.usrCoords[2],s1=det(P.coords.usrCoords,Pm,Qm),s2=det(P.coords.usrCoords,Pp,Qp),s3=det(P.coords.usrCoords,Pm,Qp),s4=det(P.coords.usrCoords,Pp,Qm));var tmp=!1;0===s1?0>_geometry.default.affineRatio(P.coords.usrCoords,Pm,Qm)&&(tmp=!0):0===s2?0>_geometry.default.affineRatio(P.coords.usrCoords,Pp,Qp)&&(tmp=!0):0===s3?0<_geometry.default.affineRatio(P.coords.usrCoords,Pm,Qp)&&
(tmp=!0):0===s4&&0<_geometry.default.affineRatio(P.coords.usrCoords,Pp,Qm)&&(tmp=!0);tmp&&(tmp=Qm,Qm=Qp,Qp=tmp,s1=s3,s2=s4);_type.default.exists(P.delayedStatus)||(P.delayedStatus=[]);0===s1&&0===s2?P.delayedStatus=["on","on"]:0===s1?(Pp=this._getPosition(Pp,Qm,Q.coords.usrCoords,Qp),P.delayedStatus=["on",Pp]):0===s2?(Pp=this._getPosition(Pm,Qm,Q.coords.usrCoords,Qp),P.delayedStatus=[Pp,"on"]):0===P.delayedStatus.length&&(this._getPosition(Pm,Qm,Q.coords.usrCoords,Qp)!==this._getPosition(Pp,Qm,Q.coords.usrCoords,
Qp)?P.data.type="X":P.data.type="B")}_type.default.exists(P._tours)&&P._tours++;if(3<P._tours||P._end||1E3<cnt){1E3<cnt&&console.log("Clipping: _classifyDegenerateIntersections exit");_type.default.exists(P._tours)&&delete P._tours;break}P.intersection&&cnt++;P=P._next}},_handleIntersectionChains:function(P){for(var cnt=0,start_status="Null",P_start,intersection_chain=!1,wait_for_exit=!1;;){!0===P.intersection&&("T"===P.data.type&&("on"!==P.delayedStatus[0]&&"on"===P.delayedStatus[1]?(intersection_chain=
!0,P_start=P,start_status=P.delayedStatus[0]):intersection_chain&&"on"===P.delayedStatus[0]&&"on"===P.delayedStatus[1]?P.data.type="B":intersection_chain&&"on"===P.delayedStatus[0]&&"on"!==P.delayedStatus[1]&&(intersection_chain=!1,start_status===P.delayedStatus[1]?(P_start.data.type="DB",P.data.type="DB"):(P_start.data.type="DX",P.data.type="DX"))),cnt++);P._end&&(wait_for_exit=!0);if(wait_for_exit&&!intersection_chain)break;if(1E3<cnt){console.log("Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations");
break}P=P._next}},_handleFullyDegenerateCase:function(S,C,board){var Q,is_on_Q,arr=[S,C];for(C=0;2>C;C++){S=arr[C];var crds=S.length;var i=0;for(Q=!0;i<crds;i++)if(!S[i].intersection){Q=!1;break}if(Q){Q=arr[(C+1)%2];var leQ=Q.length;for(i=0;i<crds;i++){var M=S[i].coords.usrCoords;var q2=S[i]._next.coords.usrCoords;M=[.5*(M[0]+q2[0]),.5*(M[1]+q2[1]),.5*(M[2]+q2[2])];q2=0;for(is_on_Q=!1;q2<leQ;q2++)if(Math.abs(_geometry.default.det3p(Q[q2].coords.usrCoords,Q[(q2+1)%leQ].coords.usrCoords,M))<_math.default.eps){is_on_Q=
!0;break}if(!is_on_Q){crds=new _coords.default(_constants.default.COORDS_BY_USER,M,board);crds={pos:i,intersection:!1,coords:crds,elementClass:_constants.default.OBJECT_CLASS_POINT};Q=S[i]._next;S[i]._next=crds;crds._prev=S[i];crds._next=Q;Q._prev=crds;S[i]._end&&(S[i]._end=!1,crds._end=!0);break}}}}},_getStatus:function(P,path){for(;P.intersection&&!P._end;)P=P._next;path=0===_geometry.default.windingNumber(P.coords.usrCoords,path)?"entry":"exit";return[P,path]},markEntryExit:function(path1,path2,
starters){var i,intersection_chain;var len=starters.length;for(i=0;i<len;i++){var P=starters[i];this._classifyDegenerateIntersections(path1[P]);this._handleIntersectionChains(path1[P]);var status=this._getStatus(path1[P],path2);P=status[0];status=status[1];P._starter=!0;var cnt=0;var chain_start=null;for(intersection_chain=0;;){if(!0===P.intersection){"X"===P.data.type&&1===intersection_chain&&(chain_start.entry_exit=status,"exit"===status&&(chain_start.data.type="X"),intersection_chain=2);if("X"===
P.data.type||"DB"===P.data.type)P.entry_exit=status,status="entry"===status?"exit":"entry";"DX"===P.data.type&&(0===intersection_chain?(chain_start=P,intersection_chain=1):1===intersection_chain?(P.entry_exit=status,chain_start.entry_exit=status,"exit"===status?chain_start.data.type="X":P.data.type="X",status="entry"===status?"exit":"entry",chain_start=null,intersection_chain=0):2===intersection_chain&&(P.entry_exit=status,P.data.type="X",status="entry"===status?"exit":"entry",chain_start=null,intersection_chain=
0))}P=P._next;if(_type.default.exists(P._starter)||1E4<cnt)break;cnt++}}},_stayOnPath:function(P,status){var stay=!0;P.intersection&&"B"!==P.data.type&&(stay=status===P.entry_exit);return stay},_addVertex:function(path,vertex,DEBUG){isNaN(vertex.coords.usrCoords[1])||isNaN(vertex.coords.usrCoords[2])||path.push(vertex);if(vertex.intersection&&vertex.data.done)return DEBUG&&console.log("Add last intersection point",vertex.coords.usrCoords,"on",vertex.data.pathname,vertex.entry_exit,vertex.data.type),
!0;vertex.intersection&&(vertex.data.done=!0,DEBUG&&console.log("Add intersection point",vertex.coords.usrCoords,"on",vertex.data.pathname,vertex.entry_exit,vertex.data.type));return!1},tracing:function(S,S_intersect,clip_type){for(var P,current,start,cnt=0,status,S_idx=0,path=[],done;S_idx<S_intersect.length&&1E4>cnt;){current=S_intersect[S_idx];if(!current.data.done&&"X"===current.data.type){0<path.length&&path.push([NaN,NaN]);start=current.data.idx;P=S;done=this._addVertex(path,current,!1);status=
current.entry_exit;do{if(done)break;if("intersection"===clip_type&&"entry"===current.entry_exit||"union"===clip_type&&"exit"===current.entry_exit||"difference"===clip_type&&P===S===("exit"===current.entry_exit)){do if(current=current._next,done=this._addVertex(path,current,!1))break;while(this._stayOnPath(current,status))}else{do if(current=current._prev,done=this._addVertex(path,current,!1))break;while(this._stayOnPath(current,status))}cnt++;if(done)break;if(!current.neighbour)return console.log("Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!",
cnt),[[0],[0]];current=current.neighbour;if(current.data.done)break;current.data.done=!0;status=current.entry_exit;P=current.data.path}while(current.data.idx!==start&&1E4>cnt);1E4<=cnt&&console.log("Tracing: stopping an infinite loop!",cnt)}S_idx++}return this._getCoordsArrays(path,!1)},isEmptyCase:function(S,C,clip_type){return"intersection"===clip_type&&(0===S.length||0===C.length)||"union"===clip_type&&0===S.length&&0===C.length||"difference"===clip_type&&0===S.length?!0:!1},_getCoordsArrays:function(path,
doClose){var pathX=[],pathY=[],i,le=path.length;for(i=0;i<le;i++)path[i].coords?(pathX.push(path[i].coords.usrCoords[1]),pathY.push(path[i].coords.usrCoords[2])):(pathX.push(path[i][0]),pathY.push(path[i][1]));doClose&&0<le&&(path[0].coords?(pathX.push(path[0].coords.usrCoords[1]),pathY.push(path[0].coords.usrCoords[2])):(pathX.push(path[0][0]),pathY.push(path[0][1])));return[pathX,pathY]},handleEmptyIntersection:function(S,C,clip_type){var P,Q,doClose=!1,path=[];if(0===S.length)return path="union"===
clip_type?C:[],this._getCoordsArrays(path,!0);if(0===C.length)return path="intersection"===clip_type?[]:S,this._getCoordsArrays(path,!0);if(0<S.length)for(P=S[0];P.intersection&&(P=P._next,!P._end););if(0<C.length)for(Q=C[0];Q.intersection&&(Q=Q._next,!Q._end););if(0===_geometry.default.windingNumber(P.coords.usrCoords,C))if(0!==_geometry.default.windingNumber(Q.coords.usrCoords,S)){if("union"===clip_type?(path=path.concat(S),path.push(S[0])):"difference"===clip_type&&(path=path.concat(S),path.push(S[0]),
0<_geometry.default.signedPolygon(S)*_geometry.default.signedPolygon(C)&&path.reverse(),path.push([NaN,NaN])),"difference"===clip_type||"intersection"===clip_type)path=path.concat(C),path.push(C[0]),doClose=!1}else"difference"===clip_type?(path=path.concat(S),doClose=!0):"union"===clip_type&&(path=path.concat(S),path.push(S[0]),path.push([NaN,NaN]),path=path.concat(C),path.push(C[0]));else"intersection"===clip_type?(path=path.concat(S),doClose=!0):"union"===clip_type&&(path=path.concat(C),path.push(C[0]));
return this._getCoordsArrays(path,doClose)},_countCrossingIntersections:function(intersections){var i,le=intersections.length,sum=0;for(i=0;i<le;i++)"X"===intersections[i].data.type&&sum++;return sum},_getPath:function(obj,board){var S=[];if(obj.elementClass===_constants.default.OBJECT_CLASS_CURVE&&(obj.type===_constants.default.OBJECT_TYPE_ARC||obj.type===_constants.default.OBJECT_TYPE_SECTOR)){var i=_geometry.default.rad(obj.radiuspoint,obj.center,obj.anglepoint);var steps=Math.floor(180*i/Math.PI);
var len=obj.Radius();var rad=i/steps;var alpha=Math.atan2(obj.radiuspoint.coords.usrCoords[2]-obj.center.coords.usrCoords[2],obj.radiuspoint.coords.usrCoords[1]-obj.center.coords.usrCoords[1]);obj.type===_constants.default.OBJECT_TYPE_SECTOR&&this._addToList(S,obj.center.coords,0);for(i=0;i<=steps;i++)this._addToList(S,new _coords.default(_constants.default.COORDS_BY_USER,[obj.center.coords.usrCoords[0],obj.center.coords.usrCoords[1]+Math.cos(i*rad+alpha)*len,obj.center.coords.usrCoords[2]+Math.sin(i*
rad+alpha)*len],board),i+1);obj.type===_constants.default.OBJECT_TYPE_SECTOR&&this._addToList(S,obj.center.coords,steps+2)}else if(obj.elementClass===_constants.default.OBJECT_CLASS_CURVE&&_type.default.exists(obj.points))for(len=obj.numberPoints,i=0;i<len;i++)this._addToList(S,obj.points[i],i);else if(obj.type===_constants.default.OBJECT_TYPE_POLYGON)for(i=0;i<obj.vertices.length;i++)this._addToList(S,obj.vertices[i].coords,i);else if(obj.elementClass===_constants.default.OBJECT_CLASS_CIRCLE)for(steps=
359,len=obj.Radius(),rad=2*Math.PI/steps,i=0;i<=steps;i++)this._addToList(S,new _coords.default(_constants.default.COORDS_BY_USER,[obj.center.coords.usrCoords[0],obj.center.coords.usrCoords[1]+Math.cos(i*rad)*len,obj.center.coords.usrCoords[2]+Math.sin(i*rad)*len],board),i);else if(_type.default.isArray(obj))for(len=obj.length,i=0;i<len;i++)_type.default.exists(obj[i].coords)?this._addToList(S,obj[i].coords,i):_type.default.isArray(obj[i])?this._addToList(S,new _coords.default(_constants.default.COORDS_BY_USER,
obj[i],board),i):_type.default.exists(obj[i].usrCoords)&&this._addToList(S,obj[i],i);return S},greinerHormann:function(subject,clip,clip_type,board){subject=this._getPath(subject,board);var len=subject.length;0<len&&_geometry.default.distance(subject[0].coords.usrCoords,subject[len-1].coords.usrCoords,3)<_math.default.eps&&subject.pop();clip=this._getPath(clip,board);len=clip.length;0<len&&_geometry.default.distance(clip[0].coords.usrCoords,clip[len-1].coords.usrCoords,3)<_math.default.eps*_math.default.eps&&
clip.pop();if(this.isEmptyCase(subject,clip,clip_type))return[[],[]];var S_starters=this.makeDoublyLinkedList(subject);var C_starters=this.makeDoublyLinkedList(clip);len=this.findIntersections(subject,clip,board)[0];this._handleFullyDegenerateCase(subject,clip,board);this.markEntryExit(subject,clip,S_starters);this.markEntryExit(clip,subject,C_starters);return 0===this._countCrossingIntersections(len)?this.handleEmptyIntersection(subject,clip,clip_type):this.tracing(subject,len,clip_type)},union:function(path1,
path2,board){return this.greinerHormann(path1,path2,"union",board)},intersection:function(path1,path2,board){return this.greinerHormann(path1,path2,"intersection",board)},difference:function(path1,path2,board){return this.greinerHormann(path1,path2,"difference",board)}};global.default.extend(_math.default.Clip,{});exports.default=_math.default.Clip}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$math$clip.js.map
