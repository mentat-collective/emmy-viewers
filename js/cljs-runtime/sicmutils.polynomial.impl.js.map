{"version":3,"sources":["sicmutils/polynomial/impl.cljc"],"mappings":"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","names":["var_args","G__100095","sicmutils.polynomial.impl/make-term","js/Error","coef","sicmutils.polynomial.exponent/empty","expts","sicmutils.polynomial.impl/exponents","term","cljs.core.nth","sicmutils.polynomial.impl/coefficient","sicmutils.polynomial.impl/constant-term?","cljs.core/empty?","sicmutils.polynomial.impl/term->str","cljs.core.pr_str","sicmutils.polynomial.impl/empty-terms","sicmutils.polynomial.impl/*monomial-order*","sicmutils.polynomial.exponent/graded-lex-order","sicmutils.polynomial.impl/constant->terms","sicmutils.value/zero?","sicmutils.polynomial.impl.make_term","sicmutils.polynomial.impl/dense->terms","coefs","->term","i","sicmutils.polynomial.exponent/make","xform","cljs.core.comp","cljs.core.map_indexed","cljs.core/cat","cljs.core.into","G__100122","sicmutils.polynomial.impl/sparse->terms","expts->coef","sicmutils.polynomial.impl.sparse__GT_terms","comparator","iter__4652__auto__","s__100126","cljs.core/LazySeq","temp__5753__auto__","cljs.core/seq","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","cljs.core/count","b__100128","cljs.core/chunk-buffer","i__100127","vec__100133","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__100125","cljs.core/chunk-rest","vec__100138","cljs.core/first","cljs.core/cons","cljs.core/rest","terms","cljs.core/group-by","coef-sum","cljs.core.transduce","cljs.core.map","sicmutils.generic/+","cljs.core/vector?","sicmutils.polynomial.exponent/dense->exponents","cljs.core/sorted?","cljs.core/map?","sicmutils.util/illegal","cljs.core.sort_by","sicmutils.polynomial.impl/map-coefficients","f","s__100152","b__100154","i__100153","vec__100162","iter__100151","vec__100165","c","f-c","sicmutils.polynomial.impl/add","sicmutils.util.aggregate/merge-fn","sicmutils.generic/add","sicmutils.polynomial.impl/sub","u","v","sicmutils.generic/negate","p__100170","vec__100171","sicmutils.polynomial.impl/t*ts","tags","coeff","acc","cljs.core/transient","t","cljs.core/persistent!","vec__100174","tags1","coeff1","cljs.core.conj_BANG_","sicmutils.polynomial.exponent/mul","sicmutils.generic/mul","sicmutils.polynomial.impl/mul","x","call","sicmutils.polynomial.impl/div","vec__100178","p1__100177#","vn-expts","vn-coeff","cljs.core/peek","good?","sicmutils.polynomial.exponent/every-power?","cljs.core/pos?","quotient","remainder","vec__100184","r-exponents","r-coeff","residues","sicmutils.polynomial.exponent/div","new-coeff","sicmutils.generic/div","new-term","cljs.core/chunk-first"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns ^:no-doc sicmutils.polynomial.impl\n  (:require [sicmutils.generic :as g]\n            [sicmutils.polynomial.exponent :as xpt]\n            [sicmutils.util :as u]\n            [sicmutils.util.aggregate :as ua]\n            [sicmutils.value :as v]))\n\n;; ## Flat Polynomial Form\n;;\n;; This namespace uses the sparse exponent representation introduced in\n;; `sicmutils.polynomial.exponent` to build up a polynomial arithmetic package\n;; using Clojure vectors. `sicmutils.polynomial` uses this representation to\n;; represent polynomial terms in the [[Polynomial]] data structure.\n;;\n;; Polynomials are sums of monomial terms; a monomial is a pair of some non-zero\n;; coefficient and a product of some number of variables, each raised to some\n;; power. The latter are represented by the \"exponents\" data structure defined\n;; in `sicmutils.polynomial.exponent`.\n;;\n;; More concisely, polynomials are linear combinations of the exponents.\n;;\n;;\n;; ## Polynomial Terms\n;;\n;; Terms are represented as pairs of [<exponents>, <coef>].\n\n(defn make-term\n  \"Constructs a polynomial term out of the supplied coefficient `coef` and\n  exponents `expts`. Retrieve these with [[coefficient]] and [[exponents]].\n\n  Optionally, passing a single coefficient argument sets the exponents to a\n  default value of [[exponent/empty]].\"\n  ([coef] [xpt/empty coef])\n  ([expts coef] [expts coef]))\n\n(defn exponents\n  \"Returns the exponents portion of the supplied `term`. Defaults to returning\n  [[exponent/empty]] if some non-compatible input is supplied.\"\n  [term]\n  (nth term 0 xpt/empty))\n\n(defn coefficient\n  \"Returns the coefficient portion of the supplied `term`. Defaults to returning\n  `0` if some non-compatible input is supplied.\"\n  [term]\n  (nth term 1 0))\n\n(defn constant-term?\n  \"Returns true if the term has an empty exponent portion, false otherwise.\"\n  [term]\n  (empty?\n   (exponents term)))\n\n(defn term->str\n  \"Returns a string representation of the supplied `term`.\"\n  [term]\n  (let [expts (exponents term)\n        coef  (coefficient term)]\n    (str (pr-str coef) \"*\" (pr-str expts))))\n\n;; Polynomial Terms\n;;\n;; Polynomials are represented as ordered vectors of terms. the empty vector\n;; needs no ordering:\n\n(def ^:no-doc empty-terms [])\n\n;; For multiple terms, terms are ordered with a [monomial\n;; order](https://en.wikipedia.org/wiki/Monomial_order).\n;; `sicmutils.polynomial.exponent` supplies a few of these that you can choose.\n;; Set the ordering via the [[*monomial-order*]] dynamic variable.\n\n(def ^{:dynamic true\n       :doc \"This variable defines monomial order used in the construction and\n  arithmetic of polynomials. Bind this variable to a comparator on the exponents\n  of each monomial term.\n\n  Defaults to [[exponent/graded-lex-order]].\"}\n  *monomial-order*\n  xpt/graded-lex-order)\n\n;; The next-simplest polynomial is a constant polynomial:\n\n(defn constant->terms\n  \"Given some constant coefficient `coef`, returns a constant polynomial.\"\n  [coef]\n  (if (v/zero? coef)\n    empty-terms\n    [(make-term xpt/empty coef)]))\n\n;; Univariate polynomials can be specified by a sequence of their coefficients:\n\n(defn dense->terms\n  \"Accepts a sequence of dense coefficients of a univariate polynomial (in\n  ascending order), and returns a polynomial in flat polynomial form that\n  matches the supplied coefficient sequence.\n\n  For example:\n\n  ```clojure\n  (dense->terms [1 0 0 4 5])\n  ;;=> [[{} 1] [{0 3} 4] [{0 4} 5]]\n  ```\"\n  [coefs]\n  (let [->term (fn [i coef]\n                 (when-not (v/zero? coef)\n                   (let [expts (if (zero? i)\n                                 xpt/empty\n                                 (xpt/make 0 i))]\n                     [(make-term expts coef)])))\n        xform  (comp (map-indexed ->term)\n                     cat)]\n    (into empty-terms xform coefs)))\n\n;; When multivariate polynomials have high arity, it can be quite a task to\n;; supply every possible term. [[sparse->terms]] allows you to specify a mapping\n;; of exponents => coefficient, where \"exponents\" can be:\n;;\n;; - a proper exponent entry created by `sicmutils.polynomial.exponent`\n;; - a map of the form `{variable-index, power}`\n;; - a dense vector of variable powers, like `[3 0 1]` for $x^3z$.\n\n(defn sparse->terms\n  \"Accepts a sparse mapping (or sequence of pairs) of exponent => coefficient, and\n  returns a proper polynomial. Optionally takes a `comparator` on exponent\n  entries; the returned polynomial will be sorted using that comparator.\n\n  `comparator` defaults to [[*monomial-order*]].\n\n  The `exponent` portion of the mapping can be any of:\n\n  - a proper exponent entry created by `sicmutils.polynomial.exponent`\n  - a map of the form `{variable-index, power}`\n  - a dense vector of variable powers, like `[3 0 1]` for $x^3z$.\n\n  For example:\n\n  ```clojure\n  (sparse->terms {{1 2 3 1} 4 [0 2 0 0] 2})\n  ;;=> [[{1 2} 2] [{1 2, 3 1} 4]]\n  ```\"\n  ([expts->coef]\n   (sparse->terms expts->coef *monomial-order*))\n  ([expts->coef comparator]\n   (if (empty? expts->coef)\n     empty-terms\n     (->> (for [[expts terms] (group-by exponents expts->coef)\n                :let [coef-sum (transduce\n                                (map coefficient) g/+ terms)]\n                :when (not (v/zero? coef-sum))\n                :let [expts (cond (vector? expts) (xpt/dense->exponents expts)\n                                  (sorted? expts) expts\n                                  (map? expts) (into xpt/empty expts)\n                                  :else\n                                  (u/illegal \"Invalid inputs to sparse->terms TODO\"))]]\n            (make-term expts coef-sum))\n          (sort-by exponents comparator)\n          (into empty-terms)))))\n\n;; ## API\n;;\n;; We can make polynomials. What can we do with them?\n;;\n;; The main operations we want are `+`, `*` and `-`. We can _also_ divide\n;; polynomials; the catch is that we always have to return an explicit remainder\n;; as well.\n\n(defn map-coefficients\n  \"Returns a new polynomial generated by applying `f` to the coefficient portion\n  of each term in `terms`.\"\n  [f terms]\n  (into empty-terms\n        (for [[expts c] terms\n              :let [f-c (f c)]\n              :when (not (v/zero? f-c))]\n          (make-term expts f-c))))\n\n(def ^{:doc \"Returns the sum of polynomials `u` and `v`. Coefficients paired\n  with matching exponents are combined with [[sicmutils.generic/add]].\"\n       :arglists '([u v])}\n  add\n  (ua/merge-fn #'*monomial-order* g/add v/zero? make-term))\n\n(defn sub\n  \"Returns the difference of polynomials `u` and `v`.\n\n  NOTE that coefficients paired with matching exponents are combined by `(g/add\n  u (g/negate v))`, rather than an explicit call to [[sicmutils.generic/sub]].\"\n  [u v]\n  (add u (map-coefficients g/negate v)))\n\n;; Multiplication works by multiplying the polynomial on the right by each term\n;; on the left and summing up all results. These operations are split into two\n;; functions:\n\n(defn t*ts\n  \"Multiplies a single term on the left by a vector `v` of terms on the right.\n  Returns a new polynomial (ie, vector of terms).\"\n  [[tags coeff] v]\n  (loop [acc (transient [])\n         i 0]\n    (let [t (nth v i nil)]\n      (if (nil? t)\n        (persistent! acc)\n\t      (let [[tags1 coeff1] t]\n\t        (recur (conj! acc (make-term\n\t\t                         (xpt/mul tags tags1)\n\t\t                         (g/mul coeff coeff1)))\n\t\t             (inc i)))))))\n\n(defn mul\n  \"Returns the product of the two polynomial term vectors `u` and `v`.\"\n  [u v]\n  (letfn [(call [i]\n            (let [x (nth u i nil)]\n              (if (nil? x)\n                []\n                (add (t*ts x v)\n\t                   (call (inc i))))))]\n    (call 0)))\n\n;; Division works by examining each term of `u` (in descending order) and\n;; checking whether or not the lead term of `v` can divide into it. If it can,\n;; the algorithm performs the division and tries again with `u-(new-term*v)`, on down until no terms remain.\n;;\n;; See the Wikipedia article on [Polynomial long\n;; division](https://en.wikipedia.org/wiki/Polynomial_long_division) for more\n;; details.\n\n(defn div\n  \"Given two polynomials `u` and `v`, returns a pair of the form `[quotient,\n  remainder]` using [polynomial long\n  division](https://en.wikipedia.org/wiki/Polynomial_long_division).\n\n  The contract satisfied is that\n\n  ```\n  u == (add (mul quotient v) remainder)\n  ```\"\n  [u v]\n  (let [[vn-expts vn-coeff] (peek v)\n        good? #(xpt/every-power? pos? %)]\n    (loop [quotient []\n           remainder u]\n      (if (empty? remainder)\n        [quotient remainder]\n        ;; find a term in the remainder into which the lead term of `v` can be\n        ;; divided.\n        (let [[r-exponents r-coeff] (peek remainder)\n              residues (xpt/div r-exponents vn-expts)]\n          (if (good? residues)\n            (let [new-coeff (g/div r-coeff vn-coeff)\n                  new-term  (make-term residues new-coeff)]\n              (recur (add quotient [new-term])\n                     (sub remainder (t*ts new-term v))))\n            [quotient remainder]))))))\n"]}