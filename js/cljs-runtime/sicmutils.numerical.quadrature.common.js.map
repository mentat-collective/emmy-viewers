{"version":3,"sources":["sicmutils/numerical/quadrature/common.cljc"],"mappings":"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","names":["sicmutils.numerical.quadrature.common/*roundoff-cutoff*","sicmutils.numerical.quadrature.common/open","sicmutils.numerical.quadrature.common/closed","sicmutils.numerical.quadrature.common/open-closed","sicmutils.numerical.quadrature.common/closed-open","sicmutils.numerical.quadrature.common/infinities","sicmutils.numerical.quadrature.common/closed?","x","cljs.core._EQ_","sicmutils.numerical.quadrature.common/open?","cljs.core/complement","p__102373","vec__102374","cljs.core.nth","sicmutils.numerical.quadrature.common/close-l","_","r","p__102381","vec__102382","sicmutils.numerical.quadrature.common/close-r","l","p__102385","vec__102386","sicmutils.numerical.quadrature.common/open-l","p__102393","vec__102394","sicmutils.numerical.quadrature.common/open-r","p__102397","vec__102398","sicmutils.numerical.quadrature.common/flip","sicmutils.numerical.quadrature.common/interval","opts","cljs.core.get","sicmutils.numerical.quadrature.common/with-interval","interval","cljs.core.assoc","sicmutils.numerical.quadrature.common/update-interval","f","k","G__102402","sicmutils.numerical.quadrature.common/narrow-slice?","a","b","cutoff","sum","Math/abs","sicmutils.numerical.quadrature.common/make-integrator-fn","area-fn","seq-fn","p__102407","map__102408","cljs.core/--destructure-map","sicmutils$numerical$quadrature$common$make_integrator_fn_$_call","roundoff-cutoff","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","sicmutils.util.stream.seq_limit","var_args","G__102422","sicmutils.numerical.quadrature.common/name-with-attributes","js/Error","name","body","sicmutils.numerical.quadrature.common.name_with_attributes","meta","vec__102427","vec__102430","docstring","cljs.core/first","cljs.core/next","attr","cljs.core/map?","cljs.core.merge","cljs.core.conj","cljs.core/with-meta"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature.common\n  \"Implements utilities shared by all integrators, for example:\n\n  - code to wrap a sequence of progressively better estimates in a common `integrator` interface\n  - data structures implementing various integration intervals.\"\n  (:refer-clojure :exclude [infinite?])\n  (:require [sicmutils.util.stream :as us]\n            [taoensso.timbre :as log]))\n\n\n;; This dynamic variable holds the default \"roundoff cutoff\" used by all\n;; integrators to decide when to return an estimate based on a single slice, vs\n;; attempting to converge a sequence of progressively finer estimates. When this\n;; condition is satisfied:\n;;\n;; |b - a| / |a| + |b| <= `cutoff`\n;;\n;; An integrator will estimate a single slice directly. Else, it will attempt to\n;; converge a sequence.\n;;\n;; NOTE - we don't have an interface yet to bind this dynamic variable. bind it\n;; manually to modify the cutoff for a specific call to some integrator:\n;;\n;; (binding [*roundoff-cutoff* 1e-6]\n;;   (integrate f a b))\n\n(def ^:dynamic *roundoff-cutoff* 1e-14)\n\n;; ## Intervals\n;;\n;; Implementations of the various intervals used by the adaptive integral\n;; interface. By default, integration endpoints are considered /open/.\n\n(def open        [::open ::open])\n(def closed      [::closed ::closed])\n(def open-closed [::open ::closed])\n(def closed-open [::closed ::open])\n(def infinities #{##Inf ##-Inf})\n\n(defn closed?\n  \"Returns true if the argument represents an explicit `closed` interval, false\n  otherwise.\"\n  [x] (= x closed))\n(def open? (complement closed?))\n\n;; These functions modify an interval by opening or closing either of its\n;; endpoints.\n\n(defn close-l [[_ r]] [::closed r])\n(defn close-r [[l _]] [l ::closed])\n(defn open-l [[_ r]] [::open r])\n(defn open-r [[l _]] [l ::open])\n(defn flip [[l r]] [r l])\n\n(defn interval\n  \"Extracts the interval (or `open` as a default) from the supplied integration\n  options dict.\"\n  [opts]\n  (get opts :interval open))\n\n(defn with-interval\n  \"Sets the specified interval to a key inside the suppled `opts` map of arbitrary\n  integration options.\"\n  [opts interval]\n  (assoc opts :interval interval))\n\n(defn update-interval\n  \"Accepts:\n\n  - a dictionary of arbitrary options\n  - one of the 4 interval modification functions\n\n  and returns a dict of options with `f` applied to the contained interval (or\n  `open` if no interval is set).\n  \"\n  [opts f]\n  (let [k :interval]\n    (assoc opts k (f (interval opts)))))\n\n;; ## Common Integration Interface\n;;\n;; The following two functions define a shared interface that integration\n;; namespaces can use to create an \"integrator\" from:\n;;\n;; - a fn that can estimate the area of a single integration slice, and\n;; - a fn that can return a sequence of progressively finer estimates.\n;;\n;; The first function is called in the case that the integration range $(a,\n;; b)$ (open or closed) is too fine for subdivision. The second function takes\n;; over in all other (most!) cases.\n\n(defn- narrow-slice?\n  \"Returns true if the range $[a, b]$ is strip narrow enough to pass the following\n  test:\n\n  |b - a| / |a| + |b| <= `cutoff`\n\n  False otherwise. This inequality measures how close the two floating point\n  values are, scaled by the sum of their magnitudes.\"\n  [^double a ^double b cutoff]\n  (let [sum (+ (Math/abs a)\n               (Math/abs b))]\n    (or (<= sum cutoff)\n        (<= (Math/abs (- b a))\n            (* cutoff sum)))))\n\n(defn make-integrator-fn\n  \"Generates an `integrator` function from two functions with the following\n  signatures and descriptions:\n\n  - `(area-fn f a b)` estimates the integral of `f` over the interval `(a, b)`\n  with no subdivision, nothing clever at all.\n\n  - `(seq-fn f a b opts)` returns a sequence of successively refined estimates\n  of the integral of `f` over `(a, b)`. `opts` can contain kv pairs that\n  configure the behavior of the sequence function (a sequence of the number of\n  integration slices to use, for example.)\n\n  The returned function has the signature:\n\n  `(f a b opts)`\n\n  All `opts` are passed on to `seq-fn`, /and/ to `us/seq-limit` internally,\n  where the options configure the checks on sequence convergence.\"\n  [area-fn seq-fn]\n  (fn call\n    ([f a b] (call f a b {}))\n    ([f a b {:keys [roundoff-cutoff]\n             :or {roundoff-cutoff *roundoff-cutoff*}\n             :as opts}]\n     (if (narrow-slice? a b roundoff-cutoff)\n       (do (log/info \"Integrating narrow slice: \" a b)\n           {:converged? true\n            :terms-checked 1\n            :result (area-fn f a b)})\n       (-> (seq-fn f a b opts)\n           (us/seq-limit opts))))))\n\n(defn- name-with-attributes\n  \"Taken from `clojure.tools.macro/name-with-attributes`.\n\n  Handles optional docstrings and attribute maps for a name to be defined in a\n  list of macro arguments. If the first macro argument is a string, it is added\n  as a docstring to name and removed from the macro argument list. If afterwards\n  the first macro argument is a map, its entries are added to the name's\n  metadata map and the map is removed from the macro argument list. The return\n  value is a vector containing the name with its extended metadata map and the\n  list of unprocessed macro arguments.\"\n  ([name body] (name-with-attributes name body {}))\n  ([name body meta]\n   (let [[docstring body] (if (string? (first body))\n                            [(first body) (next body)]\n                            [nil body])\n         [attr body]      (if (map? (first body))\n                            [(first body) (next body)]\n                            [{} body])\n         attr             (merge meta attr)\n         attr             (if docstring\n                            (assoc attr :doc docstring)\n                            attr)\n         attr             (if (meta name)\n                            (conj (meta name) attr)\n                            attr)]\n     [(with-meta name attr) body])))\n\n(defmacro defintegrator\n  \"Helper macro for defining integrators.\"\n  [sym & body]\n  (let [meta       {:arglists (list 'quote '([f a b] [f a b opts]))}\n        [sym body] (name-with-attributes sym body meta)\n        {:keys [area-fn seq-fn]} (apply hash-map body)]\n    (assert seq-fn (str \"defintegrator \" sym \": seq-fn cannot be nil\"))\n    (assert area-fn (str \"defintegrator \" sym \": area-fn cannot be nil\"))\n    `(def ~sym\n       (make-integrator-fn ~area-fn ~seq-fn))))\n"]}