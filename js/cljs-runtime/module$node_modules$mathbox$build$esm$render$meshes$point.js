shadow$provide.module$node_modules$mathbox$build$esm$render$meshes$point=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Point=void 0;global=require("module$node_modules$mathbox$build$esm$render$meshes$base");var _constants=require("module$node_modules$three$src$constants"),_Mesh=require("module$node_modules$three$src$objects$Mesh"),_spritegeometry=require("module$node_modules$mathbox$build$esm$render$geometry$spritegeometry");class Point extends global.Base{constructor(renderer,
shaders,options){var left;super(renderer,shaders,options);let {uniforms,shape,fill}=options;const {material,position,color,size,mask,map,combine,linear,optical,stpq}=options;null==uniforms&&(uniforms={});shape=+shape;null==fill&&(fill=!0);var hasStyle=null!=uniforms.styleColor;renderer="circle square diamond up down left right".split(" ");var f="circle generic generic generic generic generic generic".split(" ");var scales=[1.2,1,1.414,1.16,1.16,1.16,1.16];f=null!=f[shape]?f[shape]:f[0];renderer=null!=
renderer[shape]?renderer[shape]:renderer[0];scales=null!=(left=optical&&scales[shape])?left:1;left=fill?f:`${f}.hollow`;this.geometry=new _spritegeometry.SpriteGeometry({items:options.items,width:options.width,height:options.height,depth:options.depth});this._adopt(uniforms);this._adopt(this.geometry.uniforms);f={POINT_SHAPE_SCALE:+(scales+1E-5)};options=shaders.material();scales=options.vertex;scales.pipe(this._vertexColor(color,mask));size?(scales.isolate(),scales.require(size),scales.require("point.size.varying",
this.uniforms),scales.end()):scales.require("point.size.uniform",this.uniforms);scales.require(this._vertexPosition(position,material,map,2,stpq));scales.pipe("point.position",this.uniforms,f);scales.pipe("project.position",this.uniforms);options.fragment=this._fragmentColor(hasStyle,material,color,mask,map,2,stpq,combine,linear);hasStyle=shaders.material();hasStyle.vertex.pipe(scales);f=hasStyle.fragment.pipe(options.fragment);f.require(`point.mask.${renderer}`,this.uniforms);f.require(`point.alpha.${left}`,
this.uniforms);f.pipe("point.edge",this.uniforms);shaders=shaders.material();shaders.vertex.pipe(scales);f=shaders.fragment.pipe(options.fragment);f.require(`point.mask.${renderer}`,this.uniforms);f.require(`point.alpha.${left}`,this.uniforms);f.pipe("point.fill",this.uniforms);shaders=shaders.link({side:_constants.DoubleSide});this.fillMaterial=this._material(shaders);renderer=hasStyle.link({side:_constants.DoubleSide});this.edgeMaterial=this._material(renderer);this.fillObject=new _Mesh.Mesh(this.geometry,
this.fillMaterial);this.edgeObject=new _Mesh.Mesh(this.geometry,this.edgeMaterial);this._raw(this.fillObject);this.fillObject.userData=shaders;this._raw(this.edgeObject);this.edgeObject.userData=renderer;this.renders=[this.fillObject,this.edgeObject]}show(transparent,blending,order,depth){this._show(this.edgeObject,!0,blending,order,depth);return this._show(this.fillObject,transparent,blending,order,depth)}dispose(){this.geometry.dispose();this.edgeMaterial.dispose();this.fillMaterial.dispose();this.renders=
this.edgeObject=this.fillObject=this.geometry=this.edgeMaterial=this.fillMaterial=null;return super.dispose()}}exports.Point=Point}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$render$meshes$point.js.map
