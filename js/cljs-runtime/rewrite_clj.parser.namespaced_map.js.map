{"version":3,"sources":["rewrite_clj/parser/namespaced_map.cljc"],"mappings":";;AAQA,oDAAA,pDAAOA,gHACJC;AADH,AAEE,IAAMC,uBAAe,6CAAA,7CAACC,iDAAM,AAACC,4DAAkBH,OAAO,WAAKI;AAAL,AAAQ,oDAAA,7CAACF,iDAAKE;;IAC9DC,SAAO,AAACC,8BAAkBN,OAAO,WAAKI;AAAL,AAAQ,IAAAG,mBAAI,AAACC,mCAAiBJ;AAAtB,AAAA,GAAAG;AAAAA;;AACI,OAACE,qCAAmBL;;;AAFvE,AAGE,OAACM,mDAAyBT,qBACD,yBAAA,OAAA,9BAAM,AAACU,cAAIN,SAAQA;;AAEhD,uDAAA,vDAAOO,sHAAoBZ,OAAOa;AAAlC,AACE,YAAA,RAAOC;;AAAP,AACE,IAAMC,IAAE,CAACF,0CAAAA,kDAAAA,VAAUb,8BAAAA;AAAnB,AACE,oBAAI,iBAAAgB,oBAAKD;AAAL,AAAA,oBAAAC;AAAO,OAACC,8CAAgBF;;AAAxBC;;;AACF,eAAO,AAACE,6CAAKJ,MAAMC;;;;AADrB,0FAEGD,MAAMC;;;;;AAEf;;;yDAAA,zDAAMI,0HAEHnB,OAAOa;AAFV,AAGE,AAACO,0BAAcpB;;AACf,IAAMqB,iBAAe,AAACtB,kDAAgBC;AAAtC,AACE,GAAM,EAAK,AAACsB,cAAI,AAAiBD,0CACtB,0BAAA,zBAAM,AAASA;AAD1B,AAEE,uCAAA,vCAACE,gCAAoBvB;;AAFvB;;AAGA,IAAAwB,aAAkC,AAACZ,qDAAmBZ,OAAOa;uBAA7D,AAAAY,4CAAAD,WAAA,IAAA,9EAAOE;eAAP,AAAAD,4CAAAD,WAAA,IAAA,tEAAwBG;AAAxB,AACE,GAAM,EAAI,AAACL,cAAIK,eACL,gDAAA,hDAACC,mGAAU,AAACC,+BAASF;AAD/B,AAEE,uCAAA,vCAACJ,gCAAoBvB;;AAFvB;;AAGA,OAAC8B,oDACA,sDAAA,6KAAA,nOAACC,yIAAQV,uBAAgBK,sJAAkBC","names":["rewrite-clj.parser.namespaced-map/parse-qualifier","reader","auto-resolved?","cljs.core._EQ_","rewrite_clj.reader.read_while","c","prefix","rewrite-clj.reader/read-until","or__5045__auto__","rewrite-clj.reader/boundary?","rewrite-clj.reader/whitespace?","rewrite-clj.node.namespaced-map/map-qualifier-node","cljs.core/seq","rewrite-clj.parser.namespaced-map/parse-to-next-elem","read-next","nodes","n","and__5043__auto__","rewrite-clj.node.whitespace/whitespace?","cljs.core.conj","rewrite-clj.parser.namespaced-map/parse-namespaced-map","rewrite-clj.reader/ignore","qualifier-node","cljs.core/not","rewrite-clj.reader/throw-reader","vec__75053","cljs.core.nth","whitespace-nodes","map-node","cljs.core.not_EQ_","rewrite-clj.node.protocols/tag","rewrite-clj.node.namespaced-map/namespaced-map-node","cljs.core.concat"],"sourcesContent":["(ns ^:no-doc rewrite-clj.parser.namespaced-map\n  (:require [rewrite-clj.node.namespaced-map :as nsmap]\n            [rewrite-clj.node.protocols :as node]\n            [rewrite-clj.node.whitespace :as nws]\n            [rewrite-clj.reader :as reader] ))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn- parse-qualifier\n  [reader]\n  (let [auto-resolved? (= \":\" (reader/read-while reader (fn [c] (= \\: c))))\n        prefix (reader/read-until reader (fn [c] (or (reader/boundary? c)\n                                                     (reader/whitespace? c))))]\n    (nsmap/map-qualifier-node auto-resolved?\n                             (when (seq prefix) prefix))))\n\n(defn- parse-to-next-elem [reader read-next]\n  (loop [nodes []]\n    (let [n (read-next reader)]\n      (if (and n (nws/whitespace? n))\n        (recur (conj nodes n))\n        [nodes n]))))\n\n(defn parse-namespaced-map\n  \"The caller has parsed up to `#:` and delegates the details to us.\"\n  [reader read-next]\n  (reader/ignore reader)\n  (let [qualifier-node (parse-qualifier reader)]\n    (when (and (not (:auto-resolved? qualifier-node))\n               (nil? (:prefix qualifier-node)))\n      (reader/throw-reader reader \"namespaced map expects a namespace\"))\n    (let [[whitespace-nodes map-node] (parse-to-next-elem reader read-next)]\n      (when (or (not map-node)\n                (not= :map (node/tag map-node)))\n        (reader/throw-reader reader \"namespaced map expects a map\"))\n      (nsmap/namespaced-map-node\n       (concat [qualifier-node] whitespace-nodes [map-node])))))\n"]}