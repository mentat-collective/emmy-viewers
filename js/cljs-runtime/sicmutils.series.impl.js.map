{"version":3,"sources":["sicmutils/series/impl.cljc"],"mappings":";AA2CA;;;;;oCAAA,pCAAMA,gFAIHC;AAJH,AAKE,OAAAC,+CAAA,KAAAC,kBAAA,KAAA;AAAA,AAAUF;GAAV,KAAA,OAAA,KAAAE,kBAAA,KAAA;AAAA,AAAa,OAACC,+CAAO,AAACC,0BAAY,AAACC,gBAAML;GAAzC,KAAA;;AAwBF,+BAAA,/BAAMM,sEAAQN;AAAd,AACE,OAACO,4CAAIC,yBAASR;;AAgBhB,yCAAA,zCAAMS,0FAAOC,EAAEC;AAAf,AACE,OAACJ,4CAAIK,yBAAIF,EAAEC;;AAUb,mCAAA,nCAAME,8EAAOC,EAAEJ;AAAf,AACE,YAAAR,kBAAA,KAAA;AAAA,AACC,OAACa,eAAK,AAACC,uDAAIF,EAAE,AAACT,gBAAMK,IAAI,AAACO,eAAKP;GAD/B,KAAA;;AAGF,mCAAA,nCAAMQ,8EAAOR,EAAEI;AAAf,AACE,YAAAZ,kBAAA,KAAA;AAAA,AACC,OAACa,eAAK,AAACC,uDAAI,AAACX,gBAAMK,GAAGI,GAAG,AAACG,eAAKP;GAD/B,KAAA;;AAaF,oCAAA,pCAAMS,gFAAOT,EAAEC;AAAf,AACE,OAACJ,4CAAIa,oBAAIV,EAAEC;;AAab,8BAAA,9BAAMU,oEAAOX,EAAEI;AAAf,AACE,YAAAZ,kBAAA,KAAA;AAAA,AACC,OAACa,eAAK,AAACO,kDAAI,AAACjB,gBAAMK,GAAGI,GAAG,AAACG,eAAKP;GAD/B,KAAA;;AAUF,8BAAA,9BAAMa,oEAAOT,EAAEJ;AAAf,AACE,YAAAR,kBAAA,KAAA;AAAA,AACC,OAACa,eAAK,AAACO,kDAAIR,EAAE,AAACT,gBAAMK,IAAI,AAACJ,6BAAO,AAACW,eAAKP;GADvC,KAAA;;AAgBF,mCAAA,nCAAMc,8EAAOd,EAAEI;AAAf,AAAkB,mDAAA,WAAAW,vDAAClB;AAAD,AAAM,2DAAAkB,pDAACC,qEAAQZ;GAAGJ;;AACpC,mCAAA,nCAAMiB,8EAAOb,EAAEJ;AAAf,AAAkB,mDAAA,WAAAkB,vDAACrB;AAAD,AAAM,6DAAAqB,tDAACF,oDAAMZ;GAAKJ;;AAYpC,yCAAA,zCAAMmB,0FAAOnB,EAAEC;AAAf,AACE,WAAA,wDAAeD;AAAf,AACU,YAAAR,kBAAA,KAAA;AAAA,AACC,GAAI,AAAC4B,4BAAQ,AAACzB,gBAAMK;AAClB,OAACK,eAAK,AAACV,gBAAMK,OAAG,AAACqB,8CAAK,AAACd,eAAKP;;AAC5B,IAAMsB,WAAK,AAACN,oDAAM,AAACrB,gBAAMK,OAAG,AAACL,gBAAMM;IAC7BsB,YAAK,AAACN,iCAAM,AAACtB,gBAAMK,OAAG,AAACO,eAAKN;IAC5BuB,YAAK,AAACH,8CAAK,AAACd,eAAKP;AAFvB,AAGE,OAACK,eAAKiB,SAAI,AAACvB,uCAAMwB,UAAKC;;GAN3B,KAAA;;AADV,AAQE,YAAAhC,kBAAA,KAAA;AAAA,AACC,GAAI,AAAC4B,4BAAQ,AAACzB,gBAAMM;AAClB,OAACI,eAAK,AAACV,gBAAMM,GAAG,iBAAAwB,WAAOzB;IAAP0B,WAAS,AAACnB,eAAKN;AAAf,AAAA,oJAAAwB,SAAAC,6DAAAD,SAAAC,3NAACP,uEAAAA,0FAAAA;;;AACjB,OAACE,KAAKrB;;GAHT,KAAA;;AA6CJ,4BAAA,5BAAM2B,gEAAK3B,EAAEC;AAAb,AACE,YAAAT,kBAAA,KAAA;AAAA,AACC,IAAMoC,KAAG,AAACjC,gBAAMK;IAAG6B,KAAG,AAACtB,eAAKP;IACtB8B,KAAG,AAACnC,gBAAMM;IAAG8B,KAAG,AAACxB,eAAKN;AAD5B,AAEE,GAAM,EAAK,AAACmB,4BAAQQ,SAAI,AAACR,4BAAQU;AAC3B,QAACH,0DAAAA,iEAAAA,TAAIE,6CAAAA,1CAAGE,6CAAAA;;AADd,GAGM,AAACX,4BAAQQ;AACT,OAACvB,eAAKuB,GAAG,CAACD,0DAAAA,gEAAAA,RAAIE,4CAAAA,zCAAG5B,4CAAAA;;AAJvB,GAMM,AAACmB,4BAAQU;AACT,oCAAA,7BAACE;;AAPP,AASY,IAAMC,IAAE,AAACC,oDAAMN,GAAGE;AAAlB,AACE,OAACzB,eAAK4B,8BAAM,AAACxB,kCAAMoB,GAAG,AAACZ,iCAAMgB,EAAEF,pGACnB,iBAAAI;IAAAC,WAAKnC;AAAL,AAAA,0HAAAkC,SAAAC,gDAAAD,SAAAC,pLAACT,0DAAAA,6EAAAA;;;;;;GAd9B,KAAA;;AAwCF,+BAAA,/BAAMU,sEAAQrC;AAAd,AACE,YAAAR,kBAAA,KAAA;AAAA,AACC,IAAM8C,OAAQ,AAACC,uDAAS,AAAC5C,gBAAMK;IACzBwC,eAAQ,AAACrB,uCAAM,AAACZ,eAAKP,GAAG,CAACqC,6DAAAA,gEAAAA,LAAOrC,4CAAAA;IAChCyC,OAAQ,AAACxB,iCAAMqB,KAAK,AAAC1C,6BAAO4C;AAFlC,AAGE,OAACnC,eAAKiC,KAAKG;GAJd,KAAA;;AAyBF,kCAAA,lCAAMC,4EAAWtC,EAAEJ;AAAnB,AACE,OAACiB,iCAAMb,EAAE,AAACiC,6BAAOrC;;AAqBnB,kCAAA,lCAAM2C,4EAAW3C,EAAEI;AAAnB,AACE,mDAAA,WAAAwC,vDAAC/C;AAAD,AAAM,+DAAA+C,xDAACC,yEAAMzC;GAAGJ;;AA0BlB,gCAAA,hCAAM8C,wEAAS9C,EAAEC;AAAjB,AACE,WAAA,+CAAeD;AAAf,AACU,YAAAR,kBAAA,KAAA;AAAA,AAGC,GAAQ,AAAC4B,4BAAQ,AAACzB,gBAAMM;AAAxB;AAAA,AAAA,MAAA,KAAA8C,MAAA;;;AACA,IAAAC,aAAgBhD;IAAhBiD,aAAA,AAAAC,cAAAF;IAAAG,eAAA,AAAAxD,gBAAAsD;IAAAA,iBAAA,AAAAG,eAAAH;SAAAE,LAAOvB;SAAPqB,LAAYpB;IACNE,KAAG,AAACxB,eAAKN;IACTwC,OAAK,AAACtB,uCAAMY,GAAG,AAACV,qCAAKQ;AAF3B,AAGE,OAACxB,eAAKuB,GAAGa;GAPZ,KAAA;;AADV,AASE,OAACpB,KAAKrB;;AA+BV,+BAAA,/BAAMqD,sEAAQrD;AAAd,AAAA,GACS,AAACoB,4BAAQ,AAACzB,gBAAMK;AADzB;AAAA,AAAA,MAAA,KAAA+C,MAAA;;;AAEE,WAAA,8CAAe/C;AAAf,AACU,YAAAR,kBAAA,KAAA;AAAA,AACC,IAAM8D,KAAK,AAAC/C,eAAKP;IACXuD,IAAK,AAAClC,oCAAKrB;AADjB,AAEE,sBAAA,fAACK,mBAAO,AAACgC,6BACA,AAACS,8BAAQQ,GAAGC;GAJxB,KAAA;;AADV,AAME,OAAClC,KAAKrB;;AAkBV,8BAAA,9BAAMwD,oEAAOxD;AAAb,AACE,OAACH,4CAAI4D,yBAAI,AAAClD,eAAKP,GAAG,gCAAA,hCAAC0D,kBAAQC;;AAU7B,AAAA,iCAAA,yCAAAC,1EAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,6DAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,6DAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAf,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,+DAAA,/DAAMe,0EACFC;AADJ,AACO,sEAAA,/DAACC,6DAASD;;;AADjB,CAAA,+DAAA,/DAAMD,0EAEFC,EAAEE;AAFN,AAGG,OAAC5D,eAAK4D,cACA,AAACpE,4CAAIqC,sBAAM6B,EAAE,gCAAA,hCAACL,kBAAQC;;;AAJ/B,CAAA,yDAAA,zDAAMG;;AAAN,AAyBA,6BAAA,7BAAMI,kEAAMH,EAAEI;AAAd,AACE,WAAA,4CAAeC,KAAKC;AAApB,AACU,IAAOC,IAAED;IACFE,IAAE,kCAAA,mFAAA,rHAAClF;IACHmF,IAAEJ;;AAFT,AAGE,IAAMK,IAAE,AAACC,sBAAMJ;IACTA,QAAE,iBAAA,jBAACK,eAAKL;AADd,AAEE,GACEG;AAAE,eAAOH;eAAEC;eAAE,AAACpD,uCAAMqD,EAAEA;;;;;;AADxB,GAEE,WAAA,VAAOF;AAAG,OAACnD,uCAAMqD,EAAED;;AAFrB,AAGQ,eAAOD;eAAE,AAACnD,uCAAMqD,EAAED;eAAG,AAACpD,uCAAMqD,EAAEA;;;;;;;;;;;AATpD,AAUE,GAAM,KAAA,JAAML;AAAI,OAACS,KAAKb,EAAEI;;AAAxB,GACM,OAAA,NAAOA;AAAG,yCAAA,mFAAA,rHAAC9E;;AADjB,AAEY,OAACgD,6BAAO,AAACuC,KAAKb,EAAE,AAACjE,uDAASqE;;;;;AA+B1C,6BAAA,qCAAAU,lEAAMO;AAAN,AAAA,IAAAN,aAAAD;IAAAE,aAAA,AAAA7B,cAAA4B;IAAAE,eAAA,AAAArF,gBAAAoF;IAAAA,iBAAA,AAAA3B,eAAA2B;SAAAC,LAAaK;IAAbJ,aAAAF;IAAAG,aAAA,AAAAhC,cAAA+B;IAAAE,eAAA,AAAAxF,gBAAAuF;IAAAA,iBAAA,AAAA9B,eAAA8B;SAAAC,LAAmBG;SAAnBJ,LAAwBrD;QAAxBiD,JAAgC9E;AAAhC,AACE,GAAI,EAAK,AAACoB,4BAAQiE,SACT,AAACjE,4BAAQkE;AAChB,OAACjF,eAAKgF,GAAG,CAACD,2DAAAA,+DAAAA,NAAKvD,2CAAAA;;AACf,IAAM0D,SAAM,AAACC,qDAAOH;IACdhE,OAAM,4CAAUpB;AAAV,AACE,YAAAT,kBAAA,KAAA;AAAA,oEACK,AAACmC,0BAAI,AAAC6B,4BAAMvD,GACP,iCAAA,jCAACgB,qCAAQ,AAACI,kCAAKpB,pMACpB,OAAC+D,kMAASuB;GAHf,KAAA;;AAFd,AAME,OAAClE,KAAKrB;;;AA2DZ,AAAKyF,6BACH,KAAAjG,kBAAA,KAAA;AAAA,AACC,+FAAA,xFAACwE,6DAASyB;GADX,KAAA;AAqBF,AAAA,AACA,AAAKC,6BAAK,KAAAlG,kBAAA,KAAA;AAAA,AAAU,OAACwE,6DAAS2B;GAApB,KAAA;AACV,AAAKA,6BAAK,KAAAnG,kBAAA,KAAA;AAAA,AAAU,mCAAA,5BAACqB,gCAAQ,AAACmD,6DAAS0B;GAA7B,KAAA;AA8BV,AAAKE,6BAAK,AAACjE,0BAAI+D,2BAAKC;AACpB,AAAKE,6BAAK,AAACxD,6BAAOsD;AAIlB,AAAKG,8BAAM,AAACzC,6BAAOqC;AACnB,AAAKK,8BAAM,AAAC/B,6DAAS,gBAAA,mFAAA,IAAA,IAAA,KAAA,hHAACgC;AAItB,AAAKC,8BAAM,AAACpF,4BAAM,WAAA,VAAGqF,eAAWJ;AAChC,AAAKK,8BAAM,AAACtF,4BAAM,WAAA,VAAGqF,eAAWH;AAIhC,AAAA,AACA,AAAKK,8BAAM,KAAA5G,kBAAA,KAAA;AAAA,AAAU,gGAAA,zFAACwE,6DAASqC;GAApB,KAAA;AACX,AAAKA,8BAAM,KAAA7G,kBAAA,KAAA;AAAA,AAAU,OAACwE,6DAASoC;GAApB,KAAA;AACX,AAAKE,8BAAM,AAAC3E,0BAAI0E,4BAAMD;AACtB,AAAKG,+BAAO,AAAClD,6BAAOgD;AACpB,AAAKG,+BAAO,AAACnD,6BAAOiD;AAEpB,AAAKG,+BACH,AAACzC,6DAAS,+CAAA,/CAACvE;AAGb,AAAKiH,oCACH,AAAC1C,6DAAS,gBAAA,mFAAA,IAAA,vGAACgC;AAUb,AAAKW,gCACH,AAAApH,+CAAA,KAAAC,kBAAA,KAAA;AAAA,AAAA,0FAAA;GAAA,KAAA,OAAA,KAAAA,kBAAA,KAAA;AAAA,AAAc,OAAC2B,uCAAMwF,8BAAQA;GAA7B,KAAA;AAQF,AAAA;AAAA;AAAA,AACA,AAAKC,0CAAM,AAAArH,+CAAA,KAAAC,kBAAA,KAAA;AAAA,AAAA,0FAAA;GAAA,KAAA,OAAA,KAAAA,kBAAA,KAAA;AAAA,AAAcqH;GAAd,KAAA;AACX,AAAKC,0CAAM,AAAAvH,+CAAA,KAAAC,kBAAA,KAAA;AAAA,AAAA,0FAAA;GAAA,KAAA,OAAA,KAAAA,kBAAA,KAAA;AAAA,AAAcsH;GAAd,KAAA;AACX,AAAKD,4CAAQ,AAAC/D,8BAAQgE,wCAAMF;AAQ5B,AAAKG,4BAAI,AAAAxH,+CAAA,KAAAC,kBAAA,KAAA;AAAA,AAAA,0FAAA,IAAA;GAAA,KAAA,OAAA,KAAAA,kBAAA,KAAA;AAAA,AAAgB,OAACK,4CAAImH,iBAAED,0BAAI,AAACxG,eAAKwG;GAAjC,KAAA;AAKT,uCAAA,vCAAME,sFAAW3C;AAAjB,AACE,QAAA,mDAAY4C,IAAIC,KAAK7C,MAAE8C;;AAAvB,AACU,GAAI,WAAA,VAAO9C;AACT4C;;AACA,IAAMG,OAAK,CAAG,CAAGF,OAAK7C,SAAG8C;IACnBE,mBAAK,AAACC,mDAAML,IAAIG;AADtB,AAEE,eAAOC;eAAKD;eAAK,SAAA,RAAK/C;eAAG,KAAA,JAAK8C;;;;;;;;;;AAL5C,AAME,OAACI,2BACA,uHAAA,MAAA,7HAACxH,EAAE,qBAAA,mFAAA,xGAACyH,yHAAiBnD;;AAE1B;;;iCAAA,jCAAMoD,0EAEHpD;AAFH,AAGE,OAACjF,kCAAS,AAAC4H,qCAAU3C;;AAIvB;;;;AAEEqD,iCACA,AAACC,mDACA1H,yBAAI,AAACL,4CAAIgI,0BAAI,gCAAA,hCAACnE,kBAAQC;AAEzB;;;;AAC4EmE,6BAC1E,AAACjI,4CAAIkI,iCAAQ,gCAAA,hCAACrE,kBAAQC","names":["sicmutils.series.impl/->series","xs","cljs.core.concat","cljs.core/LazySeq","cljs.core.repeat","sicmutils.value/zero-like","cljs.core/first","sicmutils.series.impl/negate","cljs.core.map","sicmutils.generic/negate","sicmutils.series.impl/seq:+","f","g","sicmutils.generic/+","sicmutils.series.impl/c+seq","c","cljs.core/cons","sicmutils.generic._PLUS_","cljs.core/rest","sicmutils.series.impl/seq+c","sicmutils.series.impl/seq:-","sicmutils.generic/-","sicmutils.series.impl/seq-c","sicmutils.generic._","sicmutils.series.impl/c-seq","sicmutils.series.impl/seq*c","p1__97492#","sicmutils.generic/mul","sicmutils.series.impl/c*seq","p1__97493#","sicmutils.series.impl/seq:*","sicmutils.value/zero?","step","f*g","f*G1","F1*G","G__97507","G__97508","sicmutils.series.impl/div","f0","fs","g0","gs","sicmutils.util/arithmetic-ex","q","sicmutils.generic/div","G__97515","G__97516","sicmutils.series.impl/invert","finv","sicmutils.generic/invert","F1*Finv","tail","sicmutils.series.impl/c-div-seq","sicmutils.series.impl/seq-div-c","p1__97531#","sicmutils.generic._SLASH_","sicmutils.series.impl/compose","js/Error","vec__97541","seq__97542","cljs.core/seq","first__97543","cljs.core/next","sicmutils.series.impl/revert","F1","R","sicmutils.series.impl/deriv","sicmutils.generic/*","cljs.core/iterate","cljs.core/inc","var_args","G__97549","sicmutils.series.impl/integral","s","sicmutils.series.impl.integral","constant-term","sicmutils.series.impl/expt","e","base","pow","n","y","z","t","cljs.core/even?","cljs.core/quot","expt","p__97555","vec__97556","seq__97557","first__97558","vec__97559","seq__97560","first__97561","sicmutils.series.impl/sqrt","f1","f2","const","sicmutils.generic/sqrt","sicmutils.series.impl/expx","sicmutils.series.impl/sinx","sicmutils.series.impl/cosx","sicmutils.series.impl/tanx","sicmutils.series.impl/secx","sicmutils.series.impl/asinx","sicmutils.series.impl/atanx","cljs.core/cycle","sicmutils.series.impl/acosx","Math/PI","sicmutils.series.impl/acotx","sicmutils.series.impl/coshx","sicmutils.series.impl/sinhx","sicmutils.series.impl/tanhx","sicmutils.series.impl/asinhx","sicmutils.series.impl/atanhx","sicmutils.series.impl/log1-x","sicmutils.series.impl/log1+x","sicmutils.series.impl/catalan","sicmutils.series.impl/tree'","sicmutils.series.impl/forest'","sicmutils.series.impl/list'","sicmutils.series.impl/fib","cljs.core/+","sicmutils.series.impl/binomial*","acc","prev","k","next","acc'","cljs.core.conj_BANG_","cljs.core/persistent!","cljs.core/transient","sicmutils.series.impl/binomial","sicmutils.series.impl/harmonic","cljs.core.reductions","sicmutils.generic//","sicmutils.series.impl/bell","sicmutils.special.factorial/bell"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns ^:no-doc sicmutils.series.impl\n  \"Backing implementation for the types defined in [[sicmutils.series]], written\n  against pure Clojure sequences.\"\n  (:require [sicmutils.generic :as g]\n            [sicmutils.numbers]\n            [sicmutils.special.factorial :as sf]\n            [sicmutils.util :as u]\n            [sicmutils.value :as v]))\n\n;; # Power Series\n;;\n;; This namespace contains an implementation of two data types:\n;;\n;; - `Series`, which represents a generic infinite series of arbitrary values, and\n;; - `PowerSeries`, a series that represents a power series in a single\n;;   variable; in other words, a series where the nth entry is interpreted as\n;;   the coefficient of $x^n$:\n;;\n;; $$[a b c d ...] == $a + bx + cx^2 + dx^3 + ...$$\n;;\n;; We'll proceed by building up implementations of the arithmetic operations +,\n;; -, *, / and a few others on bare Clojure lazy sequences, and then introduce\n;; `deftype` wrappers so that we can install these types into the generic\n;; dispatch system.\n;;\n;; The implementation follows Doug McIlroy's beautiful paper, [\"Power Series,\n;; Power\n;; Serious\"](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.333.3156&rep=rep1&type=pdf).\n;; Doug also has a 10-line version in Haskell on [his\n;; website](https://www.cs.dartmouth.edu/~doug/powser.html).\n;;\n;; Okay, let's proceed, in roughly the same order as the paper.\n;;\n;; ## Sequence Operations\n;;\n;; A 'series' is an infinite sequence of numbers, represented by Clojure's lazy\n;; sequence. First, a function `->series` that takes some existing sequence,\n;; finite or infinite, and coerces it to an infinite seq by concatenating it\n;; with an infinite sequence of zeros. (We use `v/zero-like` so that everything\n;; plays nicely with generic arithmetic.)\n\n(defn ->series\n  \"Form the infinite sequence starting with the supplied values. The\n  remainder of the series will be filled with the zero-value\n  corresponding to the first of the given values.\"\n  [xs]\n  (lazy-cat xs (repeat (v/zero-like (first xs)))))\n\n;; This works as expected:\n\n#_\n(= [1 2 3 4 0 0 0 0 0 0]\n   (take 10 (->series [1 2 3 4])))\n\n;; The core observation we'll use in the following definitions (courtesy of\n;; McIlroy) is that a power series $F$ in a variable $x$:\n;;\n;; $$F(x)=f_{0}+x f_{1}+x^{2} f_{2}+\\cdots$$\n;;\n;; Decomposes into a head element $f_0$ plus a tail series, multiplied by $x$:\n;;\n;; $$F(x) = F_0(x) = f_0 + x F_1(x)$$\n;;\n;; We'll use this observation to derive the more complicated sequence operations\n;; below.\n\n;; ### Negation\n\n;; To negate a series, negate each element:\n\n(defn negate [xs]\n  (map g/negate xs))\n\n#_\n(let [xs [1 2 3 4]]\n  (= [-1 -2 -3 -4 0 0 0]\n     (take 7 (negate (->series xs)))))\n\n;; ### Addition\n;;\n;; We can derive series addition by expanding the series $F$ and $G$ into head\n;; and tail and rearranging terms:\n;;\n;; $$F+G=\\left(f+x F_{1}\\right)+\\left(g+x G_{1}\\right)=(f+g)+x\\left(F_{1}+G_{1}\\right)$$\n;;\n;; This is particularly straightforward in Clojure, where `map` already merges\n;; sequences elementwise:\n(defn seq:+ [f g]\n  (map g/+ f g))\n\n#_\n(= [0 2 4 6 8]\n   (take 5 (seq:+ (range) (range))))\n\n;; A constant is a series with its first element populated, all zeros otherwise.\n;; To add a constant to another series we only need add it to the first element.\n;; Here are two versions, constant-on-left vs constant-on-right:\n\n(defn c+seq [c f]\n  (lazy-seq\n   (cons (g/+ c (first f)) (rest f))))\n\n(defn seq+c [f c]\n  (lazy-seq\n   (cons (g/+ (first f) c) (rest f))))\n\n#_\n(let [series (->series [1 2 3 4])]\n  (= [11 2 3 4 0 0]\n     (take 6 (seq+c series 10))\n     (take 6 (c+seq 10 series))))\n\n;; ### Subtraction\n;;\n;; Subtraction comes for free from the two definitions above:\n\n(defn seq:- [f g]\n  (map g/- f g))\n\n#_\n(= [0 0 0 0 0]\n   (take 5 (seq:- (range) (range))))\n\n;; We /should/ get equivalent results from mapping `g/-` over both sequences,\n;; and in almost all cases we do... but until we understand and fix this bug\n;; https://github.com/sicmutils/sicmutils/issues/151 that method would\n;; return different results.\n\n;; Subtract a constant from a sequence by subtracting it from the first element:\n\n(defn seq-c [f c]\n  (lazy-seq\n   (cons (g/- (first f) c) (rest f))))\n\n#_\n(= [-10 1 2 3 4]\n   (take 5 (seq-c (range) 10)))\n\n;; To subtract a sequence from a constant, subtract the first element as before,\n;; but negate the tail of the sequence:\n\n(defn c-seq [c f]\n  (lazy-seq\n   (cons (g/- c (first f)) (negate (rest f)))))\n\n#_\n(= [10 -1 -2 -3 -4]\n   (take 5 (c-seq 10 (range))))\n\n;; ### Multiplication\n;;\n;; What does it mean to multiply two infinite sequences? As McIlroy notes,\n;; multiplication is where the lazy-sequence-based approach really comes into\n;; its own.\n;;\n;; First, the simple cases of multiplication by a scalar on either side of a\n;; sequence:\n\n(defn seq*c [f c] (map #(g/mul % c) f))\n(defn c*seq [c f] (map #(g/mul c %) f))\n\n;; To multiply sequences, first recall from above that we can decompose each\n;; sequence $F$ and $G$ into a head and tail.\n;;\n;; Mutiply the expanded representations out and rearrange terms:\n;;\n;; $$F \\times G=\\left(f+x F_{1}\\right) \\times\\left(g+x G_{1}\\right)=f g+x\\left(f G_{1}+F_{1} \\times G\\right)$$\n;;\n;; $G$ appears on the left and the right, so use an inner function that closes\n;; over $g$ to simplify matters, and rewrite the above definition in Clojure:\n\n(defn seq:* [f g]\n  (letfn [(step [f]\n            (lazy-seq\n             (if (v/zero? (first f))\n               (cons (first f) (step (rest f)))\n               (let [f*g  (g/mul (first f) (first g))\n                     f*G1 (c*seq (first f) (rest g))\n                     F1*G (step (rest f))]\n                 (cons f*g (seq:+ f*G1 F1*G))))))]\n    (lazy-seq\n     (if (v/zero? (first g))\n       (cons (first g) (seq:* f (rest g)))\n       (step f)))))\n\n;; This works just fine on two infinite sequences:\n\n#_\n(= [0 4 11 20 30 40 50 60 70 80]\n   (take 10 (seq:* (range) (->series [4 3 2 1]))))\n\n;; NOTE This is also called the \"Cauchy Product\" of the two sequences:\n;; https://en.wikipedia.org/wiki/Cauchy_product The description on the Wikipedia\n;; page has complicated index tracking that simply doesn't come in to play with\n;; the stream-based approach. Amazing!\n\n;; ### Division\n;;\n;; The quotient $Q$ of $F$ and $G$ should satisfy:\n;;\n;; $$F = Q \\times G$$\n;;\n;; From McIlroy, first expand out $F$, $Q$ and one instance of $G$:\n;;\n;; $$\n;; \\begin{aligned}\n;; f+x F_{1} &=\\left(q+x Q_{1}\\right) \\times G=q G+x Q_{1} \\times G=q\\left(g+x G_{1}\\right)+x Q_{1} \\times G \\\\\n;; &=q g+x\\left(q G_{1}+Q_{1} \\times G\\right)\n;; \\end{aligned}\n;; $$\n;;\n;; Look at just the constant terms and note that $q = {f \\over g}$.\n;;\n;; Consider the terms multiplied by $x$ and solve for $Q_1$:\n;;\n;; $$Q_1 = {(F_1 - qG_1) \\over G}$$.\n;;\n;; There are two special cases to consider:\n;;\n;; - If $g=0$, $q = {f \\over g}$ can only succeed if $f=0$; in this case, $Q =\n;;   {F_1 \\over G1}$, from the larger formula above.\n;; - If $f=0$, $Q_1 = {(F_1 - 0 G_1) \\over G} = {F_1 \\over G}$\n;;\n;; Encoded in Clojure:\n\n(defn div [f g]\n  (lazy-seq\n   (let [f0 (first f) fs (rest f)\n         g0 (first g) gs (rest g)]\n     (cond (and (v/zero? f0) (v/zero? g0))\n           (div fs gs)\n\n           (v/zero? f0)\n           (cons f0 (div fs g))\n\n           (v/zero? g0)\n           (u/arithmetic-ex \"ERROR: denominator has a zero constant term\")\n\n           :else (let [q (g/div f0 g0)]\n                   (cons q (-> (seq:- fs (c*seq q gs))\n                               (div g))))))))\n\n;; A simple example shows success:\n\n#_\n(let [series (->series [0 0 0 4 3 2 1])]\n  (= [1 0 0 0 0]\n     (take 5 (div series series))))\n\n;; ### Reciprocal\n;;\n;; We could generate the reciprocal of $F$ by dividing $(1, 0, 0, ...)$ by $F$.\n;; Page 21 of an earlier [paper by\n;; McIlroy](https://swtch.com/~rsc/thread/squint.pdf) gives us a more direct\n;; formula.\n;;\n;; We want $R$ such that $FR = 1$. Expand $F$:\n;;\n;; $$(f + xF_1)R = 1$$\n;;\n;; Solve for R:\n;;\n;; $$R = {1 \\over f} (1 - x(F_1 R))$$\n;;\n;; A recursive definition is no problem in the stream abstraction:\n\n(defn invert [f]\n  (lazy-seq\n   (let [finv    (g/invert (first f))\n         F1*Finv (seq:* (rest f) (invert f))\n         tail    (c*seq finv (negate F1*Finv))]\n     (cons finv tail))))\n\n;; This definition of `invert` matches the more straightforward division\n;; implementation:\n\n#_\n(let [series (iterate inc 3)]\n  (= (take 5 (invert series))\n     (take 5 (div (->series [1]) series))))\n\n;; An example:\n\n#_\n(let [series (iterate inc 3)]\n  (= [1 0 0 0 0]\n     (take 5 (seq:* series (invert series)))\n     (take 5 (div series series))))\n\n;; Division of a constant by a series comes easily from our previous\n;; multiplication definitions and `invert`:\n\n(defn c-div-seq [c f]\n  (c*seq c (invert f)))\n\n;; It's not obvious that this works:\n\n#_\n(let [nats (iterate inc 1)]\n  (= [4 -8 4 0 0 0]\n     (take 6 (c-div-seq 4 nats))))\n\n;; But we can recover the initial series:\n\n#_\n(let [nats       (iterate inc 1)\n      divided    (c-div-seq 4 nats)\n      seq-over-4 (invert divided)\n      original   (seq*c seq-over-4 4)]\n  (= (take 5 nats)\n     (take 5 original)))\n\n;; To divide a series by a constant, divide each element of the series:\n\n(defn seq-div-c [f c]\n  (map #(g// % c) f))\n\n;; Division by a constant undoes multiplication by a constant:\n\n#_\n(let [nats (iterate inc 1)]\n  (= [1 2 3 4 5]\n     (take 5 (seq-div-c (seq*c nats 2) 2))))\n\n;; ### Functional Composition\n;;\n;; To compose two series $F(x)$ and $G(x)$ means to create a new series\n;; $F(G(x))$. Derive this by substituting $G$ for $x$ in the expansion of $F$:\n;;\n;; $$F(G)=f+G \\times F_{1}(G)=f+\\left(g+x G_{1}\\right) \\times F_{1}(G)=\\left(f+g F_{1}(G)\\right)+x G_{1} \\times F_{1}(G)$$\n;;\n;; For the stream-based calculation to work, we need to be able to calculate the\n;; head element and attach it to an infinite tail; unless $g=0$ above the head\n;; element depends on $F_1$, an infinite sequence.\n;;\n;; If $g=0$ the calculation simplifies:\n;;\n;; $$F(G)=f + x G_{1} \\times F_{1}(G)$$\n;;\n;; In Clojure, using an inner function that captures $G$:\n\n(defn compose [f g]\n  (letfn [(step [f]\n            (lazy-seq\n             ;; TODO I don't understand why we get a StackOverflow if I move\n             ;; this assertion out of the `letfn`.\n             (assert (v/zero? (first g)))\n             (let [[f0 & fs] f\n                   gs (rest g)\n                   tail (seq:* gs (step fs))]\n               (cons f0 tail))))]\n    (step f)))\n\n;; Composing $x^2 = (0, 0, 1, 0, 0, ...)$ should square all $x$s, and give us a\n;; sequence of only even powers:\n#_\n(= [1 0 1 0 1 0 1 0 1 0]\n   (take 10 (compose (repeat 1)\n                     (->series [0 0 1]))))\n\n;; ### Reversion\n;;\n;; The functional inverse of a power series $F$ is a series $R$ that satisfies\n;; $F(R(x)) = x$.\n;;\n;; Following McIlroy, we expand $F$ (substituting $R$ for $x$) and one\n;; occurrence of $R$:\n;;\n;; $$F(R(x))=f+R \\times F_{1}(R)=f+\\left(r+x R_{1}\\right) \\times F_{1}(R)=x$$\n;;\n;; Just like in the composition derivation, in the general case the head term\n;; depends on an infinite sequence. Set $r=0$ to address this:\n;;\n;; $$f+x R_{1} \\times F_{1}(R)=x$$\n;;\n;; For this to work, the constant $f$ must be 0 as well, hence\n;;\n;; $R_1 = {1 \\over F_1(R)}$\n;;\n;; This works as an implementation because $r=0$. $R_1$ is allowed to reference\n;; $R$ thanks to the stream-based approach:\n\n(defn revert [f]\n  {:pre [(v/zero? (first f))]}\n  (letfn [(step [f]\n            (lazy-seq\n             (let [F1   (rest f)\n                   R    (step f)]\n               (cons 0 (invert\n                        (compose F1 R))))))]\n    (step f)))\n\n;; An example, inverting a series starting with 0:\n\n#_\n(let [f (cons 0 (iterate inc 1))]\n  (= [0 1 0 0 0]\n     (take 5 (compose f (revert f)))))\n\n;; ### Series Calculus\n;;\n;; Derivatives of power series are simple and mechanical:\n;;\n;; $$D(a x^n)$ = aD(x^n) = a n x^{n-1}$$\n;;\n;; Implies that all entries shift left by 1, and each new entry gets multiplied\n;; by its former index (ie, its new index plus 1).\n\n(defn deriv [f]\n  (map g/* (rest f) (iterate inc 1)))\n\n#_\n(= [1 2 3 4 5 6] ;; 1 + 2x + 3x^2 + ...\n   (take 6 (deriv (repeat 1))))\n\n;; The definite integral $\\int_0^{x}F(t)dt$ is similar. To take the\n;; anti-derivative of each term, move it to the right by appending a constant\n;; term onto the sequence and divide each element by its new position:\n\n(defn integral\n  ([s] (integral s 0))\n  ([s constant-term]\n   (cons constant-term\n         (map g/div s (iterate inc 1)))))\n\n;; With a custom constant term:\n\n#_\n(= [5 1 1 1 1 1]\n   (take 6 (integral (iterate inc 1) 5)))\n\n;; By default, the constant term is 0:\n\n#_\n(= [0 1 1 1 1 1]\n   (take 6 (integral (iterate inc 1))))\n\n;; ### Exponentiation\n;;\n;; Exponentiation of a power series by some integer is simply repeated\n;; multiplication. The implementation here is more efficient the iterating\n;; `seq:*`, and handles negative exponent terms by inverting the original\n;; sequence.\n\n(defn expt [s e]\n  (letfn [(expt [base pow]\n            (loop [n pow\n                   y (->series [1])\n                   z base]\n              (let [t (even? n)\n                    n (quot n 2)]\n                (cond\n                  t (recur n y (seq:* z z))\n                  (zero? n) (seq:* z y)\n                  :else (recur n (seq:* z y) (seq:* z z))))))]\n    (cond (pos? e)  (expt s e)\n          (zero? e) (->series [1])\n          :else (invert (expt s (g/negate e))))))\n\n;; We can use `expt` to verify that $(1+x)^3$ expands to $1 + 3x + 3x^2 + x^3$:\n\n#_\n(= [1 3 3 1 0]\n   (take 5 (expt (->series [1 1]) 3)))\n\n;; ### Square Root of a Series\n;;\n;; The square root of a series $F$ is a series $Q$ such that $Q^2 = F$. We can\n;; find this using our calculus methods from above:\n;;\n;; $$D(F) = 2Q D(Q)$$\n;;\n;; or\n;;\n;; D(Q) = {D(F) \\over {2Q}}\n;;\n;; When the head term of $F$ is nonzero, ie, $f != 0$, the head of $Q =\n;; \\sqrt(F)$ must be $\\sqrt(f)$ for the multiplication to work out.\n;;\n;; Integrate both sides:\n;;\n;; Q = \\sqrt(f) + \\int_0^x {D(F) \\over {2Q}}\n;;\n;; One optimization appears if the first two terms of $F$ vanish, ie,\n;; $F=x^2F_2$. In this case $Q = 0 + x \\sqrt(F_2)$.\n;;\n;; Here it is in Clojure:\n\n(defn sqrt [[f1 & [f2 & fs] :as f]]\n  (if (and (v/zero? f1)\n           (v/zero? f2))\n    (cons f1 (sqrt fs))\n    (let [const (g/sqrt f1)\n          step  (fn step [g]\n                  (lazy-seq\n                   (-> (div (deriv g)\n                            (c*seq 2 (step g)))\n                       (integral const))))]\n      (step f))))\n\n;; And a test that we can recover the naturals:\n\n#_\n(let [xs (iterate inc 1)]\n  (= [1 2 3 4 5 6]\n     (take 6 (seq:* (sqrt xs)\n                    (sqrt xs)))))\n\n;; We can maintain precision of the first element is the square of a rational\n;; number:\n\n#_\n(let [xs (iterate inc 9)]\n  (= [9 10 11 12 13 14]\n     (take 6 (seq:* (sqrt xs)\n                    (sqrt xs)))))\n\n;; We get a correct result if the sequence starts with 0, 0:\n\n#_\n(let [xs (concat [0 0] (iterate inc 9))]\n  (= [0 0 9 10 11 12]\n     (take 6 (seq:* (sqrt xs)\n                    (sqrt xs)))))\n\n;; ## Examples\n\n;; Power series computations can encode polynomial computations. Encoding\n;; $(1-2x^2)^3$ as a power series returns the correct result:\n\n#_\n(= [1 0 -6 0 12 0 -8 0 0 0]\n   (take 10 (expt (->series [1 0 -2]) 3)))\n\n;; Encoding $1 \\over (1-x)$ returns the power series $1 + x + x^2 + ...$ which\n;; sums to that value in its region of convergence:\n\n#_\n(= (take 10 (repeat 1))\n   (take 10 (div (->series [1])\n                 (->series [1 -1]))))\n\n;; $1 \\over (1-x)^2$ is the derivative of the above series:\n\n#_\n(= (take 10 (iterate inc 1))\n   (take 10 (div (->series [1])\n                 (-> (->series [1 -1])\n                     (expt 2)))))\n\n;; ## Various Power Series\n;;\n;; With the above primitives we can define a number of series with somewhat\n;; astonishing brevity.\n;;\n;; $e^x$ is its own derivative, so $e^x = 1 + e^x$:\n\n(def expx\n  (lazy-seq\n   (integral expx 1)))\n\n;; This bare definition is enough to generate the power series for $e^x$:\n\n#_\n(= '(1\n     1\n     (/ 1 2)\n     (/ 1 6)\n     (/ 1 24)\n     (/ 1 120)\n     (/ 1 720)\n     (/ 1 5040)\n     (/ 1 40320)\n     (/ 1 362880))\n   (v/freeze (take 10 expx)))\n\n;; $sin$ and $cos$ afford recursive definitions. $D(sin) = cos$ and $D(cos) =\n;; -sin$, so (with appropriate constant terms added) on:\n\n(declare cosx)\n(def sinx (lazy-seq (integral cosx)))\n(def cosx (lazy-seq (c-seq 1 (integral sinx))))\n\n#_\n(= '(0\n     1\n     0\n     (/ -1 6)\n     0\n     (/ 1 120)\n     0\n     (/ -1 5040)\n     0\n     (/ 1 362880))\n   (v/freeze (take 10 sinx)))\n\n#_\n(= '(1\n     0\n     (/ -1 2)\n     0\n     (/ 1 24)\n     0\n     (/ -1 720)\n     0\n     (/ 1 40320)\n     0)\n   (v/freeze (take 10 cosx)))\n\n;; tangent and secant come easily from these:\n\n(def tanx (div sinx cosx))\n(def secx (invert cosx))\n\n;; Reversion lets us define arcsine from sine:\n\n(def asinx (revert sinx))\n(def atanx (integral (cycle [1 0 -1 0])))\n\n;; These two are less elegant, perhaps:\n\n(def acosx (c-seq (/ Math/PI 2) asinx))\n(def acotx (c-seq (/ Math/PI 2) atanx))\n\n;; The hyperbolic trig functions are defined in a similar way:\n\n(declare sinhx)\n(def coshx (lazy-seq (integral sinhx 1)))\n(def sinhx (lazy-seq (integral coshx)))\n(def tanhx (div sinhx coshx))\n(def asinhx (revert sinhx))\n(def atanhx (revert tanhx))\n\n(def log1-x\n  (integral (repeat -1)))\n\n;; https://en.wikipedia.org/wiki/Mercator_series\n(def log1+x\n  (integral (cycle [1 -1])))\n\n;; ## Generating Functions\n\n;; ### Catalan numbers\n;;\n;; These are a few more examples from McIlroy's \"Power Serious\" paper, presented\n;; here without context. (If you have the energy to write about these, please\n;; feel free and send us a PR!)\n\n(def catalan\n  (lazy-cat [1] (seq:* catalan catalan)))\n\n#_\n(= [1 1 2 5 14 42 132 429 1430 4862]\n   (take 10 catalan))\n\n;; ordered trees...\n\n(declare tree' forest' list')\n(def tree' (lazy-cat [0] forest'))\n(def list' (lazy-cat [1] list'))\n(def forest' (compose list' tree'))\n\n#_\n(= [0 1 1 2 5 14 42 132 429 1430]\n   (take 10 tree'))\n\n;; The catalan numbers again!\n\n(def fib (lazy-cat [0 1] (map + fib (rest fib))))\n\n;; See here for the recurrence relation:\n;; https://en.wikipedia.org/wiki/Binomial_coefficient#Multiplicative_formula\n\n(defn binomial* [n]\n  (letfn [(f [acc prev n k]\n            (if (zero? n)\n              acc\n              (let [next (/ (* prev n) k)\n                    acc' (conj! acc next)]\n                (recur acc' next (dec n) (inc k)))))]\n    (persistent!\n     (f (transient [1]) 1 n 1))))\n\n(defn binomial\n  \"The coefficients of (1+x)^n\"\n  [n]\n  (->series (binomial* n)))\n\n;;\n\n(def ^{:doc \"The sequence of [Harmonic\n  numbers](https://en.wikipedia.org/wiki/Harmonic_number), starting from n=1.\"}\n  harmonic\n  (reductions\n   g/+ (map g// (iterate inc 1))))\n\n(def ^{:doc \"The sequence of [Bell\n  numbers](https://en.wikipedia.org/wiki/Bell_number), starting from n=1.\"} bell\n  (map sf/bell (iterate inc 1)))\n"]}