{
"version":3,
"file":"module$node_modules$markdown_it$lib$parser_inline.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/parser_inline.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$parser_inline\"] = function(global,require,module,exports) {\n/** internal\n * class ParserInline\n *\n * Tokenizes paragraph content.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\n////////////////////////////////////////////////////////////////////////////////\n// Parser rules\n\nvar _rules = [\n  [ 'text',            require('./rules_inline/text') ],\n  [ 'newline',         require('./rules_inline/newline') ],\n  [ 'escape',          require('./rules_inline/escape') ],\n  [ 'backticks',       require('./rules_inline/backticks') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').tokenize ],\n  [ 'emphasis',        require('./rules_inline/emphasis').tokenize ],\n  [ 'link',            require('./rules_inline/link') ],\n  [ 'image',           require('./rules_inline/image') ],\n  [ 'autolink',        require('./rules_inline/autolink') ],\n  [ 'html_inline',     require('./rules_inline/html_inline') ],\n  [ 'entity',          require('./rules_inline/entity') ]\n];\n\nvar _rules2 = [\n  [ 'balance_pairs',   require('./rules_inline/balance_pairs') ],\n  [ 'strikethrough',   require('./rules_inline/strikethrough').postProcess ],\n  [ 'emphasis',        require('./rules_inline/emphasis').postProcess ],\n  [ 'text_collapse',   require('./rules_inline/text_collapse') ]\n];\n\n\n/**\n * new ParserInline()\n **/\nfunction ParserInline() {\n  var i;\n\n  /**\n   * ParserInline#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of inline rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n\n  /**\n   * ParserInline#ruler2 -> Ruler\n   *\n   * [[Ruler]] instance. Second ruler used for post-processing\n   * (e.g. in emphasis-like rules).\n   **/\n  this.ruler2 = new Ruler();\n\n  for (i = 0; i < _rules2.length; i++) {\n    this.ruler2.push(_rules2[i][0], _rules2[i][1]);\n  }\n}\n\n\n// Skip single token by running all rules in validation mode;\n// returns `true` if any rule reported success\n//\nParserInline.prototype.skipToken = function (state) {\n  var ok, i, pos = state.pos,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      maxNesting = state.md.options.maxNesting,\n      cache = state.cache;\n\n\n  if (typeof cache[pos] !== 'undefined') {\n    state.pos = cache[pos];\n    return;\n  }\n\n  if (state.level < maxNesting) {\n    for (i = 0; i < len; i++) {\n      // Increment state.level and decrement it later to limit recursion.\n      // It's harmless to do here, because no tokens are created. But ideally,\n      // we'd need a separate private state variable for this purpose.\n      //\n      state.level++;\n      ok = rules[i](state, true);\n      state.level--;\n\n      if (ok) { break; }\n    }\n  } else {\n    // Too much nesting, just skip until the end of the paragraph.\n    //\n    // NOTE: this will cause links to behave incorrectly in the following case,\n    //       when an amount of `[` is exactly equal to `maxNesting + 1`:\n    //\n    //       [[[[[[[[[[[[[[[[[[[[[foo]()\n    //\n    // TODO: remove this workaround when CM standard will allow nested links\n    //       (we can replace it by preventing links from being parsed in\n    //       validation mode)\n    //\n    state.pos = state.posMax;\n  }\n\n  if (!ok) { state.pos++; }\n  cache[pos] = state.pos;\n};\n\n\n// Generate tokens for input range\n//\nParserInline.prototype.tokenize = function (state) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      end = state.posMax,\n      maxNesting = state.md.options.maxNesting;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n\n    if (state.level < maxNesting) {\n      for (i = 0; i < len; i++) {\n        ok = rules[i](state, false);\n        if (ok) { break; }\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) { break; }\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n\n\n/**\n * ParserInline.parse(str, md, env, outTokens)\n *\n * Process input string and push inline tokens into `outTokens`\n **/\nParserInline.prototype.parse = function (str, md, env, outTokens) {\n  var i, rules, len;\n  var state = new this.State(str, md, env, outTokens);\n\n  this.tokenize(state);\n\n  rules = this.ruler2.getRules('');\n  len = rules.length;\n\n  for (i = 0; i < len; i++) {\n    rules[i](state);\n  }\n};\n\n\nParserInline.prototype.State = require('./rules_inline/state_inline');\n\n\nmodule.exports = ParserInline;\n\n};"],
"names":["shadow$provide","global","require","module","exports","ParserInline","i","ruler","Ruler","_rules","length","push","ruler2","_rules2","tokenize","postProcess","prototype","skipToken","ParserInline.prototype.skipToken","state","pos","rules","getRules","len","maxNesting","md","options","cache","level","ok","posMax","ParserInline.prototype.tokenize","end","pending","src","pushPending","parse","ParserInline.prototype.parse","str","env","outTokens","State"]
}
