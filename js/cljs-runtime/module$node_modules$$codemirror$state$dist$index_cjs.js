shadow$provide.module$node_modules$$codemirror$state$dist$index_cjs=function(global,require$jscomp$0,module,exports){function textLength(text){let length=-1;for(let line of text)length+=line.length+1;return length}function appendText(text,target,from=0,to=1E9){for(let pos=0,i=0,first=!0;i<text.length&&pos<=to;i++){let line=text[i],end=pos+line.length;end>=from&&(end>to&&(line=line.slice(0,to-pos)),pos<from&&(line=line.slice(from-pos)),first?(target[target.length-1]+=line,first=!1):target.push(line));
pos=end+1}return target}function isRegionalIndicator(code){return 127462<=code&&127487>=code}function findClusterBreak(str,pos,forward=!0,includeExtending=!0){return(forward?nextClusterBreak:prevClusterBreak)(str,pos,includeExtending)}function nextClusterBreak(str,pos,includeExtending){if(pos==str.length)return pos;var JSCompiler_temp;if(JSCompiler_temp=pos)JSCompiler_temp=str.charCodeAt(pos),JSCompiler_temp=56320<=JSCompiler_temp&&57344>JSCompiler_temp;JSCompiler_temp&&(JSCompiler_temp=str.charCodeAt(pos-
1),JSCompiler_temp=55296<=JSCompiler_temp&&56320>JSCompiler_temp);JSCompiler_temp&&pos--;JSCompiler_temp=codePointAt(str,pos);for(pos+=codePointSize(JSCompiler_temp);pos<str.length;){var next=codePointAt(str,pos),JSCompiler_temp$jscomp$0;if(!(JSCompiler_temp$jscomp$0=8205==JSCompiler_temp||8205==next)&&(JSCompiler_temp$jscomp$0=includeExtending))a:{for(JSCompiler_temp$jscomp$0=1;JSCompiler_temp$jscomp$0<extend.length;JSCompiler_temp$jscomp$0+=2)if(extend[JSCompiler_temp$jscomp$0]>next){JSCompiler_temp$jscomp$0=
extend[JSCompiler_temp$jscomp$0-1]<=next;break a}JSCompiler_temp$jscomp$0=!1}if(JSCompiler_temp$jscomp$0)pos+=codePointSize(next),JSCompiler_temp=next;else if(isRegionalIndicator(next)){next=0;for(JSCompiler_temp$jscomp$0=pos-2;0<=JSCompiler_temp$jscomp$0&&isRegionalIndicator(codePointAt(str,JSCompiler_temp$jscomp$0));)next++,JSCompiler_temp$jscomp$0-=2;if(0==next%2)break;else pos+=2}else break}return pos}function prevClusterBreak(str,pos,includeExtending){for(;0<pos;){let found=nextClusterBreak(str,
pos-2,includeExtending);if(found<pos)return found;pos--}return 0}function codePointAt(str,pos){let code0=str.charCodeAt(pos);if(!(55296<=code0&&56320>code0)||pos+1==str.length)return code0;str=str.charCodeAt(pos+1);return 56320<=str&&57344>str?(code0-55296<<10)+(str-56320)+65536:code0}function codePointSize(code){return 65536>code?1:2}function addSection(sections,len,ins,forceJoin=!1){if(!(0==len&&0>=ins)){var last=sections.length-2;0<=last&&0>=ins&&ins==sections[last+1]?sections[last]+=len:0==len&&
0==sections[last]?sections[last+1]+=ins:forceJoin?(sections[last]+=len,sections[last+1]+=ins):sections.push(len,ins)}}function addInsert(values,sections,value){if(0!=value.length)if(sections=sections.length-2>>1,sections<values.length)values[values.length-1]=values[values.length-1].append(value);else{for(;values.length<sections;)values.push(Text.empty);values.push(value)}}function iterChanges(desc,f,individual){let inserted=desc.inserted;for(let posA=0,posB=0,i=0;i<desc.sections.length;){let len=
desc.sections[i++],ins=desc.sections[i++];if(0>ins)posA+=len,posB+=len;else{let endA=posA,endB=posB,text=Text.empty;for(;;){endA+=len;endB+=ins;ins&&inserted&&(text=text.append(inserted[i-2>>1]));if(individual||i==desc.sections.length||0>desc.sections[i+1])break;len=desc.sections[i++];ins=desc.sections[i++]}f(posA,endA,posB,endB,text);posA=endA;posB=endB}}}function mapSet(setA,setB,before,mkSet=!1){let sections=[];mkSet=mkSet?[]:null;setA=new SectionIter(setA);setB=new SectionIter(setB);for(let inserted=
-1;;)if(-1==setA.ins&&-1==setB.ins){var len=Math.min(setA.len,setB.len);addSection(sections,len,-1);setA.forward(len);setB.forward(len)}else if(0<=setB.ins&&(0>setA.ins||inserted==setA.i||0==setA.off&&(setB.len<setA.len||setB.len==setA.len&&!before))){len=setB.len;for(addSection(sections,setB.ins,-1);len;){var piece=Math.min(setA.len,len);0<=setA.ins&&inserted<setA.i&&setA.len<=piece&&(addSection(sections,0,setA.ins),mkSet&&addInsert(mkSet,sections,setA.text),inserted=setA.i);setA.forward(piece);
len-=piece}setB.next()}else if(0<=setA.ins){len=0;for(piece=setA.len;piece;)if(-1==setB.ins){let piece$jscomp$0=Math.min(piece,setB.len);len+=piece$jscomp$0;piece-=piece$jscomp$0;setB.forward(piece$jscomp$0)}else if(0==setB.ins&&setB.len<piece)piece-=setB.len,setB.next();else break;addSection(sections,len,inserted<setA.i?setA.ins:0);mkSet&&inserted<setA.i&&addInsert(mkSet,sections,setA.text);inserted=setA.i;setA.forward(setA.len-piece)}else{if(setA.done&&setB.done)return mkSet?ChangeSet.createSet(sections,
mkSet):ChangeDesc.create(sections);throw Error("Mismatched change set lengths");}}function composeSets(setA,setB,mkSet=!1){let sections=[];mkSet=mkSet?[]:null;setA=new SectionIter(setA);setB=new SectionIter(setB);for(let open=!1;;){if(setA.done&&setB.done)return mkSet?ChangeSet.createSet(sections,mkSet):ChangeDesc.create(sections);if(0==setA.ins)addSection(sections,setA.len,0,open),setA.next();else if(0!=setB.len||setB.done){if(setA.done||setB.done)throw Error("Mismatched change set lengths");let len=
Math.min(setA.len2,setB.len),sectionLen=sections.length;if(-1==setA.ins){let insB=-1==setB.ins?-1:setB.off?0:setB.ins;addSection(sections,len,insB,open);mkSet&&insB&&addInsert(mkSet,sections,setB.text)}else-1==setB.ins?(addSection(sections,setA.off?0:setA.len,len,open),mkSet&&addInsert(mkSet,sections,setA.textBit(len))):(addSection(sections,setA.off?0:setA.len,setB.off?0:setB.ins,open),mkSet&&!setB.off&&addInsert(mkSet,sections,setB.text));open=(setA.ins>len||0<=setB.ins&&setB.len>len)&&(open||sections.length>
sectionLen);setA.forward2(len);setB.forward(len)}else addSection(sections,0,setB.ins,open),mkSet&&addInsert(mkSet,sections,setB.text),setB.next()}}function checkSelection(selection,docLength){for(let range of selection.ranges)if(range.to>docLength)throw new RangeError("Selection points outside of document");}function sameArray(a,b){return a==b||a.length==b.length&&a.every((e,i)=>e===b[i])}function compareArray(a,b,compare){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(!compare(a[i],
b[i]))return!1;return!0}function ensureAll(state,addrs){let changed=!1;for(let addr of addrs)ensureAddr(state,addr)&1&&(changed=!0);return changed}function dynamicFacetSlot(addresses,facet,providers){function get(state){let values=[];for(let i=0;i<providerAddrs.length;i++){let value=getAddr(state,providerAddrs[i]);if(2==providerTypes[i])for(let val of value)values.push(val);else values.push(value)}return facet.combine(values)}let providerAddrs=providers.map(p=>addresses[p.id]),providerTypes=providers.map(p=>
p.type),dynamic=providerAddrs.filter(p=>!(p&1)),idx=addresses[facet.id]>>1;return{create(state){for(let addr of providerAddrs)ensureAddr(state,addr);state.values[idx]=get(state);return 1},update(state,tr){if(!ensureAll(state,dynamic))return 0;tr=get(state);if(facet.compare(tr,state.values[idx]))return 0;state.values[idx]=tr;return 1},reconfigure(state,oldState){var depChanged=ensureAll(state,providerAddrs);let oldProviders=oldState.config.facets[facet.id];oldState=oldState.facet(facet);if(oldProviders&&
!depChanged&&sameArray(providers,oldProviders))return state.values[idx]=oldState,0;depChanged=get(state);if(facet.compare(depChanged,oldState))return state.values[idx]=oldState,0;state.values[idx]=depChanged;return 1}}}function prec(value){return ext=>new PrecExtension(ext,value)}function flatten(extension,compartments,newCompartments){function inner(ext,prec){var known=seen.get(ext);if(null!=known){if(known<=prec)return;let found=result[known].indexOf(ext);-1<found&&result[known].splice(found,1);
ext instanceof CompartmentInstance&&newCompartments.delete(ext.compartment)}seen.set(ext,prec);if(Array.isArray(ext))for(let e of ext)inner(e,prec);else if(ext instanceof CompartmentInstance){if(newCompartments.has(ext.compartment))throw new RangeError("Duplicate use of compartment in extensions");known=compartments.get(ext.compartment)||ext.inner;newCompartments.set(ext.compartment,known);inner(known,prec)}else if(ext instanceof PrecExtension)inner(ext.inner,ext.prec);else if(ext instanceof StateField)result[prec].push(ext),
ext.provides&&inner(ext.provides,prec);else if(ext instanceof FacetProvider)result[prec].push(ext),ext.facet.extensions&&inner(ext.facet.extensions,Prec_.default);else{known=ext.extension;if(!known)throw Error(`Unrecognized extension value in extension set (${ext}). This sometimes happens because multiple instances of @codemirror/state are loaded, breaking instanceof checks.`);inner(known,prec)}}let result=[[],[],[],[],[]],seen=new Map;inner(extension,Prec_.default);return result.reduce((a,b)=>a.concat(b))}
function ensureAddr(state,addr){if(addr&1)return 2;addr>>=1;var status=state.status[addr];if(4==status)throw Error("Cyclic dependency between fields and/or facets");if(status&2)return status;state.status[addr]=4;status=state.computeSlot(state,state.config.dynamicSlots[addr]);return state.status[addr]=2|status}function getAddr(state,addr){return addr&1?state.config.staticValues[addr>>1]:state.values[addr>>1]}function mergeTransaction(a,b,sequential){var _a;let mapForB,changes;sequential?(sequential=
b.changes,mapForB=ChangeSet.empty(b.changes.length),changes=a.changes.compose(b.changes)):(sequential=b.changes.map(a.changes),mapForB=a.changes.mapDesc(b.changes,!0),changes=a.changes.compose(sequential));return{changes,selection:b.selection?b.selection.map(mapForB):null===(_a=a.selection)||void 0===_a?void 0:_a.map(sequential),effects:StateEffect.mapEffects(a.effects,sequential).concat(StateEffect.mapEffects(b.effects,mapForB)),annotations:a.annotations.length?a.annotations.concat(b.annotations):
b.annotations,scrollIntoView:a.scrollIntoView||b.scrollIntoView}}function resolveTransactionInner(state,spec,docSize){let sel=spec.selection,annotations=asArray(spec.annotations);spec.userEvent&&(annotations=annotations.concat(Transaction.userEvent.of(spec.userEvent)));return{changes:spec.changes instanceof ChangeSet?spec.changes:ChangeSet.of(spec.changes||[],docSize,state.facet(lineSeparator)),selection:sel&&(sel instanceof EditorSelection?sel:EditorSelection.single(sel.anchor,sel.head)),effects:asArray(spec.effects),
annotations,scrollIntoView:!!spec.scrollIntoView}}function resolveTransaction(state,specs,filter){var s=resolveTransactionInner(state,specs.length?specs[0]:{},state.doc.length);specs.length&&!1===specs[0].filter&&(filter=!1);for(var i=1;i<specs.length;i++){!1===specs[i].filter&&(filter=!1);var seq=!!specs[i].sequential;s=mergeTransaction(s,resolveTransactionInner(state,specs[i],seq?s.changes.newLength:state.doc.length),seq)}state=Transaction.create(state,s.changes,s.selection,s.effects,s.annotations,
s.scrollIntoView);if(filter){filter=state.startState;specs=!0;for(JSCompiler_temp of filter.facet(changeFilter)){s=JSCompiler_temp(state);if(!1===s){specs=!1;break}if(Array.isArray(s))if(!0===specs)specs=s;else a:{i=[];for(let iA=0,iB=0;;){let to;if(iA<specs.length&&(iB==s.length||s[iB]>=specs[iA]))seq=specs[iA++],to=specs[iA++];else if(iB<s.length)seq=s[iB++],to=s[iB++];else{specs=i;break a}!i.length||i[i.length-1]<seq?i.push(seq,to):i[i.length-1]<to&&(i[i.length-1]=to)}}}if(!0!==specs){if(!1===
specs){specs=state.changes.invertedDesc;var JSCompiler_temp=ChangeSet.empty(filter.doc.length)}else specs=state.changes.filter(specs),JSCompiler_temp=specs.changes,specs=specs.filtered.mapDesc(specs.changes).invertedDesc;state=Transaction.create(filter,JSCompiler_temp,state.selection&&state.selection.map(specs),StateEffect.mapEffects(state.effects,specs),state.annotations,state.scrollIntoView)}JSCompiler_temp=filter.facet(transactionFilter);for(specs=JSCompiler_temp.length-1;0<=specs;specs--)state=
JSCompiler_temp[specs](state),state=state instanceof Transaction?state:Array.isArray(state)&&1==state.length&&state[0]instanceof Transaction?state[0]:resolveTransaction(filter,asArray(state),!1);JSCompiler_temp=state}else JSCompiler_temp=state;filter=JSCompiler_temp.startState;state=filter.facet(transactionExtender);specs=JSCompiler_temp;for(s=state.length-1;0<=s;s--)(i=state[s](JSCompiler_temp))&&Object.keys(i).length&&(specs=mergeTransaction(specs,resolveTransactionInner(filter,i,JSCompiler_temp.changes.newLength),
!0));return specs==JSCompiler_temp?JSCompiler_temp:Transaction.create(filter,JSCompiler_temp.changes,JSCompiler_temp.selection,specs.effects,specs.annotations,specs.scrollIntoView)}function asArray(value){return null==value?none:Array.isArray(value)?value:[value]}function makeCategorizer(wordChars){return char=>{if(!/\S/.test(char))return exports.CharCategory.Space;a:if(wordChar)var JSCompiler_inline_result=wordChar.test(char);else{for(JSCompiler_inline_result=0;JSCompiler_inline_result<char.length;JSCompiler_inline_result++){let ch=
char[JSCompiler_inline_result];if(/\w/.test(ch)||""<ch&&(ch.toUpperCase()!=ch.toLowerCase()||nonASCIISingleCaseWordChar.test(ch))){JSCompiler_inline_result=!0;break a}}JSCompiler_inline_result=!1}if(JSCompiler_inline_result)return exports.CharCategory.Word;for(JSCompiler_inline_result=0;JSCompiler_inline_result<wordChars.length;JSCompiler_inline_result++)if(-1<char.indexOf(wordChars[JSCompiler_inline_result]))return exports.CharCategory.Word;return exports.CharCategory.Other}}function cmpRange(a,
b){return a.from-b.from||a.value.startSide-b.value.startSide}function lazySort(ranges){if(1<ranges.length)for(let prev=ranges[0],i=1;i<ranges.length;i++){let cur=ranges[i];if(0<cmpRange(prev,cur))return ranges.slice().sort(cmpRange);prev=cur}return ranges}function findSharedChunks(a,b,textDiff){let inA=new Map;for(var set$jscomp$0 of a)for(a=0;a<set$jscomp$0.chunk.length;a++)0>=set$jscomp$0.chunk[a].maxPoint&&inA.set(set$jscomp$0.chunk[a],set$jscomp$0.chunkPos[a]);set$jscomp$0=new Set;for(let set of b)for(b=
0;b<set.chunk.length;b++)a=inA.get(set.chunk[b]),null==a||(textDiff?textDiff.mapPos(a):a)!=set.chunkPos[b]||(null===textDiff||void 0===textDiff?0:textDiff.touchesRange(a,a+set.chunk[b].length))||set$jscomp$0.add(set.chunk[b]);return set$jscomp$0}function heapBubble(heap,index){for(let cur=heap[index];;){let childIndex=(index<<1)+1;if(childIndex>=heap.length)break;let child=heap[childIndex];childIndex+1<heap.length&&0<=child.compare(heap[childIndex+1])&&(child=heap[childIndex+1],childIndex++);if(0>
cur.compare(child))break;heap[childIndex]=cur;heap[index]=child;index=childIndex}}function compare$jscomp$0(a,startA,b,startB,length,comparator){a.goto(startA);b.goto(startB);length=startB+length;let pos=startB;for(startA=startB-startA;;){startB=a.to+startA-b.to||a.endSide-b.endSide;let end=0>startB?a.to+startA:b.to,clipEnd=Math.min(end,length);a.point||b.point?a.point&&b.point&&(a.point==b.point||a.point.eq(b.point))&&sameValues(a.activeForPoint(a.to+startA),b.activeForPoint(b.to))||comparator.comparePoint(pos,
clipEnd,a.point,b.point):clipEnd>pos&&!sameValues(a.active,b.active)&&comparator.compareRange(pos,clipEnd,a.active,b.active);if(end>length)break;pos=end;0>=startB&&a.next();0<=startB&&b.next()}}function sameValues(a,b){if(a.length!=b.length)return!1;for(let i=0;i<a.length;i++)if(a[i]!=b[i]&&!a[i].eq(b[i]))return!1;return!0}function remove(array,index){for(let i=index,e=array.length-1;i<e;i++)array[i]=array[i+1];array.pop()}function insert(array,index,value){for(let i=array.length-1;i>=index;i--)array[i+
1]=array[i];array[index]=value}function findMinIndex(value,array){let found=-1,foundPos=1E9;for(let i=0;i<array.length;i++)0>(array[i]-foundPos||value[i].endSide-value[found].endSide)&&(found=i,foundPos=array[i]);return found}Object.defineProperty(exports,"__esModule",{value:!0});class Text{constructor(){}lineAt(pos){if(0>pos||pos>this.length)throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);return this.lineInner(pos,!1,1,0)}line(n){if(1>n||n>this.lines)throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);
return this.lineInner(n,!0,1,0)}replace(from,to,text){let parts=[];this.decompose(0,from,parts,2);text.length&&text.decompose(0,text.length,parts,3);this.decompose(to,this.length,parts,1);return TextNode.from(parts,this.length-(to-from)+text.length)}append(other){return this.replace(this.length,this.length,other)}slice(from,to=this.length){let parts=[];this.decompose(from,to,parts,0);return TextNode.from(parts,to-from)}eq(other){if(other==this)return!0;if(other.length!=this.length||other.lines!=this.lines)return!1;
let start=this.scanIdentical(other,1),end=this.length-this.scanIdentical(other,-1),a=new RawTextCursor(this);other=new RawTextCursor(other);for(let skip=start,pos=start;;){a.next(skip);other.next(skip);skip=0;if(a.lineBreak!=other.lineBreak||a.done!=other.done||a.value!=other.value)return!1;pos+=a.value.length;if(a.done||pos>=end)return!0}}iter(dir=1){return new RawTextCursor(this,dir)}iterRange(from,to=this.length){return new PartialTextCursor(this,from,to)}iterLines(from,to){null==from?to=this.iter():
(null==to&&(to=this.lines+1),from=this.line(from).from,to=this.iterRange(from,Math.max(from,to==this.lines+1?this.length:1>=to?0:this.line(to-1).to)));return new LineCursor(to)}toString(){return this.sliceString(0)}toJSON(){let lines=[];this.flatten(lines);return lines}static of(text){if(0==text.length)throw new RangeError("A document must have at least one line");return 1!=text.length||text[0]?32>=text.length?new TextLeaf(text):TextNode.from(TextLeaf.split(text,[])):Text.empty}}class TextLeaf extends Text{constructor(text,
length=textLength(text)){super();this.text=text;this.length=length}get lines(){return this.text.length}get children(){return null}lineInner(target,isLine,line,offset){for(let i=0;;i++){let string=this.text[i],end=offset+string.length;if((isLine?line:end)>=target)return new Line(offset,end,line,string);offset=end+1;line++}}decompose(from,to,target,open){from=0>=from&&to>=this.length?this:new TextLeaf(appendText(this.text,[""],from,to),Math.min(to,this.length)-Math.max(0,from));open&1?(to=target.pop(),
open=appendText(from.text,to.text.slice(),0,from.length),32>=open.length?target.push(new TextLeaf(open,to.length+from.length)):(from=open.length>>1,target.push(new TextLeaf(open.slice(0,from)),new TextLeaf(open.slice(from))))):target.push(from)}replace(from,to,text){if(!(text instanceof TextLeaf))return super.replace(from,to,text);let lines=appendText(this.text,appendText(text.text,appendText(this.text,[""],0,from)),to);from=this.length+text.length-(to-from);return 32>=lines.length?new TextLeaf(lines,
from):TextNode.from(TextLeaf.split(lines,[]),from)}sliceString(from,to=this.length,lineSep="\n"){let result="";for(let pos=0,i=0;pos<=to&&i<this.text.length;i++){let line=this.text[i],end=pos+line.length;pos>from&&i&&(result+=lineSep);from<end&&to>pos&&(result+=line.slice(Math.max(0,from-pos),to-pos));pos=end+1}return result}flatten(target){for(let line of this.text)target.push(line)}scanIdentical(){return 0}static split(text,target){let part=[],len=-1;for(let line of text)part.push(line),len+=line.length+
1,32==part.length&&(target.push(new TextLeaf(part,len)),part=[],len=-1);-1<len&&target.push(new TextLeaf(part,len));return target}}class TextNode extends Text{constructor(children,length){super();this.children=children;this.length=length;this.lines=0;for(let child of children)this.lines+=child.lines}lineInner(target,isLine,line,offset){for(let i=0;;i++){let child=this.children[i],end=offset+child.length,endLine=line+child.lines-1;if((isLine?endLine:end)>=target)return child.lineInner(target,isLine,
line,offset);offset=end+1;line=endLine+1}}decompose(from,to,target,open){for(let i=0,pos=0;pos<=to&&i<this.children.length;i++){let child=this.children[i],end=pos+child.length;if(from<=end&&to>=pos){let childOpen=open&((pos<=from?1:0)|(end>=to?2:0));pos>=from&&end<=to&&!childOpen?target.push(child):child.decompose(from-pos,to-pos,target,childOpen)}pos=end+1}}replace(from,to,text){if(text.lines<this.lines)for(let i=0,pos=0;i<this.children.length;i++){var child=this.children[i],end=pos+child.length;
if(from>=pos&&to<=end){let updated=child.replace(from-pos,to-pos,text);child=this.lines-child.lines+updated.lines;return updated.lines<child>>4&&updated.lines>child>>6?(end=this.children.slice(),end[i]=updated,new TextNode(end,this.length-(to-from)+text.length)):super.replace(pos,end,updated)}pos=end+1}return super.replace(from,to,text)}sliceString(from,to=this.length,lineSep="\n"){let result="";for(let i=0,pos=0;i<this.children.length&&pos<=to;i++){let child=this.children[i],end=pos+child.length;
pos>from&&i&&(result+=lineSep);from<end&&to>pos&&(result+=child.sliceString(from-pos,to-pos,lineSep));pos=end+1}return result}flatten(target){for(let child of this.children)child.flatten(target)}scanIdentical(other,dir){if(!(other instanceof TextNode))return 0;let length=0,[iA,iB,eA,eB]=0<dir?[0,0,this.children.length,other.children.length]:[this.children.length-1,other.children.length-1,-1,-1];for(;;iA+=dir,iB+=dir){if(iA==eA||iB==eB)return length;let chA=this.children[iA],chB=other.children[iB];
if(chA!=chB)return length+chA.scanIdentical(chB,dir);length+=chA.length+1}}static from(children,length=children.reduce((l,ch)=>l+ch.length+1,-1)){function add(child){let last;if(child.lines>maxChunk&&child instanceof TextNode)for(let node of child.children)add(node);else child.lines>minChunk&&(currentLines>minChunk||!currentLines)?(flush(),chunked.push(child)):child instanceof TextLeaf&&currentLines&&(last=currentChunk[currentChunk.length-1])instanceof TextLeaf&&32>=child.lines+last.lines?(currentLines+=
child.lines,currentLen+=child.length+1,currentChunk[currentChunk.length-1]=new TextLeaf(last.text.concat(child.text),last.length+1+child.length)):(currentLines+child.lines>chunk&&flush(),currentLines+=child.lines,currentLen+=child.length+1,currentChunk.push(child))}function flush(){0!=currentLines&&(chunked.push(1==currentChunk.length?currentChunk[0]:TextNode.from(currentChunk,currentLen)),currentLen=-1,currentLines=currentChunk.length=0)}var lines=0;for(let ch of children)lines+=ch.lines;if(32>lines){lines=
[];for(let ch of children)ch.flatten(lines);return new TextLeaf(lines,length)}let chunk=Math.max(32,lines>>5),maxChunk=chunk<<1,minChunk=chunk>>1,chunked=[],currentLines=0,currentLen=-1,currentChunk=[];for(let child of children)add(child);flush();return 1==chunked.length?chunked[0]:new TextNode(chunked,length)}}Text.empty=new TextLeaf([""],0);class RawTextCursor{constructor(text,dir=1){this.dir=dir;this.lineBreak=this.done=!1;this.value="";this.nodes=[text];this.offsets=[0<dir?1:(text instanceof TextLeaf?
text.text.length:text.children.length)<<1]}nextInner(skip,dir){for(this.done=this.lineBreak=!1;;){let last=this.nodes.length-1;var top=this.nodes[last];let offsetValue=this.offsets[last],offset=offsetValue>>1,size=top instanceof TextLeaf?top.text.length:top.children.length;if(offset==(0<dir?size:0)){if(0==last)return this.done=!0,this.value="",this;0<dir&&this.offsets[last-1]++;this.nodes.pop();this.offsets.pop()}else if((offsetValue&1)==(0<dir?0:1)){this.offsets[last]+=dir;if(0==skip)return this.lineBreak=
!0,this.value="\n",this;skip--}else if(top instanceof TextLeaf){top=top.text[offset+(0>dir?-1:0)];this.offsets[last]+=dir;if(top.length>Math.max(0,skip))return this.value=0==skip?top:0<dir?top.slice(skip):top.slice(0,top.length-skip),this;skip-=top.length}else top=top.children[offset+(0>dir?-1:0)],skip>top.length?(skip-=top.length,this.offsets[last]+=dir):(0>dir&&this.offsets[last]--,this.nodes.push(top),this.offsets.push(0<dir?1:(top instanceof TextLeaf?top.text.length:top.children.length)<<1))}}next(skip=
0){0>skip&&(this.nextInner(-skip,-this.dir),skip=this.value.length);return this.nextInner(skip,this.dir)}}class PartialTextCursor{constructor(text,start,end){this.value="";this.done=!1;this.cursor=new RawTextCursor(text,start>end?-1:1);this.pos=start>end?text.length:0;this.from=Math.min(start,end);this.to=Math.max(start,end)}nextInner(skip,dir){if(0>dir?this.pos<=this.from:this.pos>=this.to)return this.value="",this.done=!0,this;skip+=Math.max(0,0>dir?this.pos-this.to:this.from-this.pos);let limit=
0>dir?this.pos-this.from:this.to-this.pos;skip>limit&&(skip=limit);limit-=skip;let {value}=this.cursor.next(skip);this.pos+=(value.length+skip)*dir;this.value=value.length<=limit?value:0>dir?value.slice(value.length-limit):value.slice(0,limit);this.done=!this.value;return this}next(skip=0){0>skip?skip=Math.max(skip,this.from-this.pos):0<skip&&(skip=Math.min(skip,this.to-this.pos));return this.nextInner(skip,this.cursor.dir)}get lineBreak(){return this.cursor.lineBreak&&""!=this.value}}class LineCursor{constructor(inner){this.inner=
inner;this.afterBreak=!0;this.value="";this.done=!1}next(skip=0){let {done,lineBreak,value}=this.inner.next(skip);done?(this.done=!0,this.value=""):lineBreak?this.afterBreak?this.value="":(this.afterBreak=!0,this.next()):(this.value=value,this.afterBreak=!1);return this}get lineBreak(){return!1}}"undefined"!=typeof Symbol&&(Text.prototype[Symbol.iterator]=function(){return this.iter()},RawTextCursor.prototype[Symbol.iterator]=PartialTextCursor.prototype[Symbol.iterator]=LineCursor.prototype[Symbol.iterator]=
function(){return this});class Line{constructor(from,to,number,text){this.from=from;this.to=to;this.number=number;this.text=text}get length(){return this.to-this.from}}let extend="lc 34 7n 7 7b 19    2  2   20 b 1c l g  2t 7 2 6 2 2  4 z  u r 2j b 1m 9 9  o 4  9  3  5 17 3 3b f  w 1j    4 8 4  3 7 a 2 t  1m    2 4 8  9  a 2 q  2 2 1l  4 2 4 2 2 3 3  u 2 3  b 2 1l  4 5  2 4  k 2 m 6   1m   2  4 8  7 3 a 2 u  1n    c  9  14  3  1l 3 5 3  4 7 2 b 2 t  1m  2  2  3  5 2 7 2 b 2 s 2 1l 2   2 4 8  9  a 2 t  20  4  2 3   8  29  2 7 c 8 2q  2 9 b 6 22 2 r      1j e  5  2 5 b  10 9  2u 4  6  2 2 2 p 2 4 3 g 4 d  2 2 6  f  jj 3 qa 3 t 3 t 2 u 2 1s 2  7 8  2 b 9  19 3 3b 2 y  3a 3 4 2 9  6 3 63 2 2  1m   7     2 8 6 a 2  1c h 1r 4 1c 7   5  14 9 c 2 w 4 2 2  3 1k   2 3   3 1m 8 2 2 48 3  d  7 4  6  3 2 5i 1m  5 ek  5f x 2da 3 3x  2o w fe 6 2x 2 n9w 4  a w 2 28 2 7k  3  4  p 2 5  47 2 q i d  12 8 p b 1a 3 1c  2 4 2 2 13  1v 6 2 2 2 2 c  8  1b  1f   3 2 2 5 2   16 2 8  6m  2  4  fn4  kh g g g a6 2 gt  6a  45 5 1ae 3  2 5 4 14 3 4  4l 2 fx 4 ar 2 49 b 4w  1i f 1k 3 1d 4 2 2 1x 3 10 5  8 1q  c 2 1g 9 a 4 2  2n 3 2   2 6  4g  3 8 l 2 1l 2     m  e 7 3 5 5f 8 2 3   n  29  2 6   2   2  2 6j  2 4 6 2  2 r 2 2d 8 2   2 2y    2 6   2t 3 2 4  5 77 9  2 6t  a 2   4  40 4 2 2 4  w a 14 6 2 4 8  9 6 2 3 1a d  2 ba 7  6   2a m 2 7  2  2 3e 6 3   2  7   20 2 3    9n 2 f0b 5 1n 7 t4  1r 4 29  f5k 2 43q   3 4 5 8 8 2 7 u 4 44 3 1iz 1j 4 1e 8  e  m 5  f 11s 7  h 2 7  2  5 79 7 c5 4 15s 7 31 7 240 5 gx7k 2o 3k 6o".split(" ").map(s=>
s?parseInt(s,36):1);for(global=1;global<extend.length;global++)extend[global]+=extend[global-1];const DefaultSplit=/\r\n?|\n/;exports.MapMode=void 0;(function(MapMode){MapMode[MapMode.Simple=0]="Simple";MapMode[MapMode.TrackDel=1]="TrackDel";MapMode[MapMode.TrackBefore=2]="TrackBefore";MapMode[MapMode.TrackAfter=3]="TrackAfter"})(exports.MapMode||(exports.MapMode={}));class ChangeDesc{constructor(sections){this.sections=sections}get length(){let result=0;for(let i=0;i<this.sections.length;i+=2)result+=
this.sections[i];return result}get newLength(){let result=0;for(let i=0;i<this.sections.length;i+=2){let ins=this.sections[i+1];result+=0>ins?this.sections[i]:ins}return result}get empty(){return 0==this.sections.length||2==this.sections.length&&0>this.sections[1]}iterGaps(f){for(let i=0,posA=0,posB=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];0>ins?(f(posA,posB,len),posB+=len):posB+=ins;posA+=len}}iterChangedRanges(f,individual=!1){iterChanges(this,f,individual)}get invertedDesc(){let sections=
[];for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];0>ins?sections.push(len,ins):sections.push(ins,len)}return new ChangeDesc(sections)}composeDesc(other){return this.empty?other:other.empty?this:composeSets(this,other)}mapDesc(other,before=!1){return other.empty?this:mapSet(this,other,before)}mapPos(pos,assoc=-1,mode=exports.MapMode.Simple){let posA=0,posB=0;for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++],endA=posA+len;
if(0>ins){if(endA>pos)return posB+(pos-posA);posB+=len}else{if(mode!=exports.MapMode.Simple&&endA>=pos&&(mode==exports.MapMode.TrackDel&&posA<pos&&endA>pos||mode==exports.MapMode.TrackBefore&&posA<pos||mode==exports.MapMode.TrackAfter&&endA>pos))return null;if(endA>pos||endA==pos&&0>assoc&&!len)return pos==posA||0>assoc?posB:posB+ins;posB+=ins}posA=endA}if(pos>posA)throw new RangeError(`Position ${pos} is out of range for changeset of length ${posA}`);return posB}touchesRange(from,to=from){for(let i=
0,pos=0;i<this.sections.length&&pos<=to;){var len=this.sections[i++];let ins=this.sections[i++];len=pos+len;if(0<=ins&&pos<=to&&len>=from)return pos<from&&len>to?"cover":!0;pos=len}return!1}toString(){let result="";for(let i=0;i<this.sections.length;){let len=this.sections[i++],ins=this.sections[i++];result+=(result?" ":"")+len+(0<=ins?":"+ins:"")}return result}toJSON(){return this.sections}static fromJSON(json){if(!Array.isArray(json)||json.length%2||json.some(a=>"number"!=typeof a))throw new RangeError("Invalid JSON representation of ChangeDesc");
return new ChangeDesc(json)}static create(sections){return new ChangeDesc(sections)}}class ChangeSet extends ChangeDesc{constructor(sections,inserted){super(sections);this.inserted=inserted}apply(doc){if(this.length!=doc.length)throw new RangeError("Applying change set to a document with the wrong length");iterChanges(this,(fromA,toA,fromB,_toB,text)=>doc=doc.replace(fromB,fromB+(toA-fromA),text),!1);return doc}mapDesc(other,before=!1){return mapSet(this,other,before,!0)}invert(doc){let sections=
this.sections.slice(),inserted=[];for(let i=0,pos=0;i<sections.length;i+=2){let len=sections[i];var ins=sections[i+1];if(0<=ins){sections[i]=ins;sections[i+1]=len;for(ins=i>>1;inserted.length<ins;)inserted.push(Text.empty);inserted.push(len?doc.slice(pos,pos+len):Text.empty)}pos+=len}return new ChangeSet(sections,inserted)}compose(other){return this.empty?other:other.empty?this:composeSets(this,other,!0)}map(other,before=!1){return other.empty?this:mapSet(this,other,before,!0)}iterChanges(f,individual=
!1){iterChanges(this,f,individual)}get desc(){return ChangeDesc.create(this.sections)}filter(ranges){let resultSections=[],resultInserted=[],filteredSections=[],iter=new SectionIter(this);a:for(let i=0,pos=0;;){for(var next=i==ranges.length?1E9:ranges[i++];pos<next||pos==next&&0==iter.len;){if(iter.done)break a;var len=Math.min(iter.len,next-pos);addSection(filteredSections,len,-1);let ins=-1==iter.ins?-1:0==iter.off?iter.ins:0;addSection(resultSections,len,ins);0<ins&&addInsert(resultInserted,resultSections,
iter.text);iter.forward(len);pos+=len}for(next=ranges[i++];pos<next;){if(iter.done)break a;len=Math.min(iter.len,next-pos);addSection(resultSections,len,-1);addSection(filteredSections,len,-1==iter.ins?-1:0==iter.off?iter.ins:0);iter.forward(len);pos+=len}}return{changes:new ChangeSet(resultSections,resultInserted),filtered:ChangeDesc.create(filteredSections)}}toJSON(){let parts=[];for(let i=0;i<this.sections.length;i+=2){let len=this.sections[i],ins=this.sections[i+1];0>ins?parts.push(len):0==ins?
parts.push([len]):parts.push([len].concat(this.inserted[i>>1].toJSON()))}return parts}static of(changes,length,lineSep){function flush(force=!1){if(force||sections.length)pos<length&&addSection(sections,length-pos,-1),force=new ChangeSet(sections,inserted),total=total?total.compose(force.map(total)):force,sections=[],inserted=[],pos=0}function process(spec){if(Array.isArray(spec))for(var sub of spec)process(sub);else if(spec instanceof ChangeSet){if(spec.length!=length)throw new RangeError(`Mismatched change set length (got ${spec.length}, expected ${length})`);
flush();total=total?total.compose(spec.map(total)):spec}else{let {from,to=from,insert}=spec;if(from>to||0>from||to>length)throw new RangeError(`Invalid change range ${from} to ${to} (in doc of length ${length})`);spec=insert?"string"==typeof insert?Text.of(insert.split(lineSep||DefaultSplit)):insert:Text.empty;sub=spec.length;if(from!=to||0!=sub)from<pos&&flush(),from>pos&&addSection(sections,from-pos,-1),addSection(sections,to-from,sub),addInsert(inserted,sections,spec),pos=to}}let sections=[],inserted=
[],pos=0,total=null;process(changes);flush(!total);return total}static empty(length){return new ChangeSet(length?[length,-1]:[],[])}static fromJSON(json){if(!Array.isArray(json))throw new RangeError("Invalid JSON representation of ChangeSet");let sections=[],inserted=[];for(let i$jscomp$0=0;i$jscomp$0<json.length;i$jscomp$0++){let part=json[i$jscomp$0];if("number"==typeof part)sections.push(part,-1);else{if(!Array.isArray(part)||"number"!=typeof part[0]||part.some((e,i)=>i&&"string"!=typeof e))throw new RangeError("Invalid JSON representation of ChangeSet");
if(1==part.length)sections.push(part[0],0);else{for(;inserted.length<i$jscomp$0;)inserted.push(Text.empty);inserted[i$jscomp$0]=Text.of(part.slice(1));sections.push(part[0],inserted[i$jscomp$0].length)}}}return new ChangeSet(sections,inserted)}static createSet(sections,inserted){return new ChangeSet(sections,inserted)}}class SectionIter{constructor(set){this.set=set;this.i=0;this.next()}next(){let {sections}=this.set;this.i<sections.length?(this.len=sections[this.i++],this.ins=sections[this.i++]):
(this.len=0,this.ins=-2);this.off=0}get done(){return-2==this.ins}get len2(){return 0>this.ins?this.len:this.ins}get text(){let {inserted}=this.set,index=this.i-2>>1;return index>=inserted.length?Text.empty:inserted[index]}textBit(len){let {inserted}=this.set,index=this.i-2>>1;return index>=inserted.length&&!len?Text.empty:inserted[index].slice(this.off,null==len?void 0:this.off+len)}forward(len){len==this.len?this.next():(this.len-=len,this.off+=len)}forward2(len){-1==this.ins?this.forward(len):
len==this.ins?this.next():(this.ins-=len,this.off+=len)}}class SelectionRange{constructor(from,to,flags){this.from=from;this.to=to;this.flags=flags}get anchor(){return this.flags&16?this.to:this.from}get head(){return this.flags&16?this.from:this.to}get empty(){return this.from==this.to}get assoc(){return this.flags&4?-1:this.flags&8?1:0}get bidiLevel(){let level=this.flags&3;return 3==level?null:level}get goalColumn(){let value=this.flags>>5;return 33554431==value?void 0:value}map(change,assoc=-1){this.empty?
assoc=change=change.mapPos(this.from,assoc):(assoc=change.mapPos(this.from,1),change=change.mapPos(this.to,-1));return assoc==this.from&&change==this.to?this:new SelectionRange(assoc,change,this.flags)}extend(from,to=from){return from<=this.anchor&&to>=this.anchor?EditorSelection.range(from,to):EditorSelection.range(this.anchor,Math.abs(from-this.anchor)>Math.abs(to-this.anchor)?from:to)}eq(other){return this.anchor==other.anchor&&this.head==other.head}toJSON(){return{anchor:this.anchor,head:this.head}}static fromJSON(json){if(!json||
"number"!=typeof json.anchor||"number"!=typeof json.head)throw new RangeError("Invalid JSON representation for SelectionRange");return EditorSelection.range(json.anchor,json.head)}static create(from,to,flags){return new SelectionRange(from,to,flags)}}class EditorSelection{constructor(ranges,mainIndex){this.ranges=ranges;this.mainIndex=mainIndex}map(change,assoc=-1){return change.empty?this:EditorSelection.create(this.ranges.map(r=>r.map(change,assoc)),this.mainIndex)}eq(other){if(this.ranges.length!=
other.ranges.length||this.mainIndex!=other.mainIndex)return!1;for(let i=0;i<this.ranges.length;i++)if(!this.ranges[i].eq(other.ranges[i]))return!1;return!0}get main(){return this.ranges[this.mainIndex]}asSingle(){return 1==this.ranges.length?this:new EditorSelection([this.main],0)}addRange(range,main=!0){return EditorSelection.create([range].concat(this.ranges),main?0:this.mainIndex+1)}replaceRange(range,which=this.mainIndex){let ranges=this.ranges.slice();ranges[which]=range;return EditorSelection.create(ranges,
this.mainIndex)}toJSON(){return{ranges:this.ranges.map(r=>r.toJSON()),main:this.mainIndex}}static fromJSON(json){if(!json||!Array.isArray(json.ranges)||"number"!=typeof json.main||json.main>=json.ranges.length)throw new RangeError("Invalid JSON representation for EditorSelection");return new EditorSelection(json.ranges.map(r=>SelectionRange.fromJSON(r)),json.main)}static single(anchor,head=anchor){return new EditorSelection([EditorSelection.range(anchor,head)],0)}static create(ranges,mainIndex=0){if(0==
ranges.length)throw new RangeError("A selection needs at least one range");for(let pos=0,i=0;i<ranges.length;i++){let range=ranges[i];if(range.empty?range.from<=pos:range.from<pos)return EditorSelection.normalized(ranges.slice(),mainIndex);pos=range.to}return new EditorSelection(ranges,mainIndex)}static cursor(pos,assoc=0,bidiLevel,goalColumn){return SelectionRange.create(pos,pos,(0==assoc?0:0>assoc?4:8)|(null==bidiLevel?3:Math.min(2,bidiLevel))|(null!==goalColumn&&void 0!==goalColumn?goalColumn:
33554431)<<5)}static range(anchor,head,goalColumn){goalColumn=(null!==goalColumn&&void 0!==goalColumn?goalColumn:33554431)<<5;return head<anchor?SelectionRange.create(head,anchor,goalColumn|24):SelectionRange.create(anchor,head,goalColumn|(head>anchor?4:0))}static normalized(ranges,mainIndex=0){mainIndex=ranges[mainIndex];ranges.sort((a,b)=>a.from-b.from);mainIndex=ranges.indexOf(mainIndex);for(let i=1;i<ranges.length;i++){let range=ranges[i];var prev=ranges[i-1];if(range.empty?range.from<=prev.to:
range.from<prev.to){let from=prev.from;prev=Math.max(range.to,prev.to);i<=mainIndex&&mainIndex--;ranges.splice(--i,2,range.anchor>range.head?EditorSelection.range(prev,from):EditorSelection.range(from,prev))}}return new EditorSelection(ranges,mainIndex)}}let nextID=0;class Facet{constructor(combine,compareInput,compare,isStatic,enables){this.combine=combine;this.compareInput=compareInput;this.compare=compare;this.isStatic=isStatic;this.id=nextID++;this.default=combine([]);this.extensions="function"==
typeof enables?enables(this):enables}static define(config={}){return new Facet(config.combine||(a=>a),config.compareInput||((a,b)=>a===b),config.compare||(config.combine?(a,b)=>a===b:sameArray),!!config.static,config.enables)}of(value){return new FacetProvider([],this,0,value)}compute(deps,get){if(this.isStatic)throw Error("Can't compute a static facet");return new FacetProvider(deps,this,1,get)}computeN(deps,get){if(this.isStatic)throw Error("Can't compute a static facet");return new FacetProvider(deps,
this,2,get)}from(field,get){get||(get=x=>x);return this.compute([field],state=>get(state.field(field)))}}class FacetProvider{constructor(dependencies,facet,type,value){this.dependencies=dependencies;this.facet=facet;this.type=type;this.value=value;this.id=nextID++}dynamicSlot(addresses){var _a;let getter=this.value,compare=this.facet.compareInput,id=this.id,idx=addresses[id]>>1,multi=2==this.type,depDoc=!1,depSel=!1,depAddrs=[];for(let dep of this.dependencies)"doc"==dep?depDoc=!0:"selection"==dep?
depSel=!0:0==((null!==(_a=addresses[dep.id])&&void 0!==_a?_a:1)&1)&&depAddrs.push(addresses[dep.id]);return{create(state){state.values[idx]=getter(state);return 1},update(state,tr){if(depDoc&&tr.docChanged||depSel&&(tr.docChanged||tr.selection)||ensureAll(state,depAddrs))if(tr=getter(state),multi?!compareArray(tr,state.values[idx],compare):!compare(tr,state.values[idx]))return state.values[idx]=tr,1;return 0},reconfigure:(state,oldState)=>{let newVal;var oldAddr=oldState.config.address[id];if(null!=
oldAddr){if(oldAddr=getAddr(oldState,oldAddr),this.dependencies.every(dep=>dep instanceof Facet?oldState.facet(dep)===state.facet(dep):dep instanceof StateField?oldState.field(dep,!1)==state.field(dep,!1):!0)||(multi?compareArray(newVal=getter(state),oldAddr,compare):compare(newVal=getter(state),oldAddr)))return state.values[idx]=oldAddr,0}else newVal=getter(state);state.values[idx]=newVal;return 1}}}}const initField=Facet.define({static:!0});class StateField{constructor(id,createF,updateF,compareF,
spec){this.id=id;this.createF=createF;this.updateF=updateF;this.compareF=compareF;this.spec=spec;this.provides=void 0}static define(config){let field=new StateField(nextID++,config.create,config.update,config.compare||((a,b)=>a===b),config);config.provide&&(field.provides=config.provide(field));return field}create(state){let init=state.facet(initField).find(i=>i.field==this);return((null===init||void 0===init?void 0:init.create)||this.createF)(state)}slot(addresses){let idx=addresses[this.id]>>1;
return{create:state=>{state.values[idx]=this.create(state);return 1},update:(state,tr)=>{let oldVal=state.values[idx];tr=this.updateF(oldVal,tr);if(this.compareF(oldVal,tr))return 0;state.values[idx]=tr;return 1},reconfigure:(state,oldState)=>{if(null!=oldState.config.address[this.id])return state.values[idx]=oldState.field(this),0;state.values[idx]=this.create(state);return 1}}}init(create){return[this,initField.of({field:this,create})]}get extension(){return this}}const Prec_={lowest:4,low:3,default:2,
high:1,highest:0};global={highest:prec(Prec_.highest),high:prec(Prec_.high),default:prec(Prec_.default),low:prec(Prec_.low),lowest:prec(Prec_.lowest)};class PrecExtension{constructor(inner,prec){this.inner=inner;this.prec=prec}}class Compartment{of(ext){return new CompartmentInstance(this,ext)}reconfigure(content){return Compartment.reconfigure.of({compartment:this,extension:content})}get(state){return state.config.compartments.get(this)}}class CompartmentInstance{constructor(compartment,inner){this.compartment=
compartment;this.inner=inner}}class Configuration{constructor(base,compartments,dynamicSlots,address,staticValues,facets){this.base=base;this.compartments=compartments;this.dynamicSlots=dynamicSlots;this.address=address;this.staticValues=staticValues;this.facets=facets;for(this.statusTemplate=[];this.statusTemplate.length<dynamicSlots.length;)this.statusTemplate.push(0)}staticFacet(facet){let addr=this.address[facet.id];return null==addr?facet.default:this.staticValues[addr>>1]}static resolve(base,
compartments,oldState){var fields=[];let facets=Object.create(null),newCompartments=new Map;for(var ext of flatten(base,compartments,newCompartments))ext instanceof StateField?fields.push(ext):(facets[ext.facet.id]||(facets[ext.facet.id]=[])).push(ext);let address=Object.create(null);compartments=[];ext=[];for(let field of fields)address[field.id]=ext.length<<1,ext.push(a=>field.slot(a));fields=null===oldState||void 0===oldState?void 0:oldState.config.facets;for(let id in facets){let providers=facets[id],
facet=providers[0].facet;var oldProviders=fields&&fields[id]||[];if(providers.every(p=>0==p.type))address[facet.id]=compartments.length<<1|1,sameArray(oldProviders,providers)?compartments.push(oldState.facet(facet)):(oldProviders=facet.combine(providers.map(p=>p.value)),compartments.push(oldState&&facet.compare(oldProviders,oldState.facet(facet))?oldState.facet(facet):oldProviders));else{for(let p of providers)0==p.type?(address[p.id]=compartments.length<<1|1,compartments.push(p.value)):(address[p.id]=
ext.length<<1,ext.push(a=>p.dynamicSlot(a)));address[facet.id]=ext.length<<1;ext.push(a=>dynamicFacetSlot(a,facet,providers))}}oldState=ext.map(f=>f(address));return new Configuration(base,newCompartments,oldState,address,compartments,facets)}}const languageData=Facet.define(),allowMultipleSelections=Facet.define({combine:values=>values.some(v=>v),static:!0}),lineSeparator=Facet.define({combine:values=>values.length?values[0]:void 0,static:!0}),changeFilter=Facet.define(),transactionFilter=Facet.define(),
transactionExtender=Facet.define(),readOnly=Facet.define({combine:values=>values.length?values[0]:!1});class Annotation{constructor(type,value){this.type=type;this.value=value}static define(){return new AnnotationType}}class AnnotationType{of(value){return new Annotation(this,value)}}class StateEffectType{constructor(map){this.map=map}of(value){return new StateEffect(this,value)}}class StateEffect{constructor(type,value){this.type=type;this.value=value}map(mapping){mapping=this.type.map(this.value,
mapping);return void 0===mapping?void 0:mapping==this.value?this:new StateEffect(this.type,mapping)}is(type){return this.type==type}static define(spec={}){return new StateEffectType(spec.map||(v=>v))}static mapEffects(effects,mapping){if(!effects.length)return effects;let result=[];for(let effect of effects)(effects=effect.map(mapping))&&result.push(effects);return result}}StateEffect.reconfigure=StateEffect.define();StateEffect.appendConfig=StateEffect.define();class Transaction{constructor(startState,
changes,selection,effects,annotations,scrollIntoView){this.startState=startState;this.changes=changes;this.selection=selection;this.effects=effects;this.annotations=annotations;this.scrollIntoView=scrollIntoView;this._state=this._doc=null;selection&&checkSelection(selection,changes.newLength);annotations.some(a=>a.type==Transaction.time)||(this.annotations=annotations.concat(Transaction.time.of(Date.now())))}static create(startState,changes,selection,effects,annotations,scrollIntoView){return new Transaction(startState,
changes,selection,effects,annotations,scrollIntoView)}get newDoc(){return this._doc||(this._doc=this.changes.apply(this.startState.doc))}get newSelection(){return this.selection||this.startState.selection.map(this.changes)}get state(){this._state||this.startState.applyTransaction(this);return this._state}annotation(type){for(let ann of this.annotations)if(ann.type==type)return ann.value}get docChanged(){return!this.changes.empty}get reconfigured(){return this.startState.config!=this.state.config}isUserEvent(event){let e=
this.annotation(Transaction.userEvent);return!(!e||!(e==event||e.length>event.length&&e.slice(0,event.length)==event&&"."==e[event.length]))}}Transaction.time=Annotation.define();Transaction.userEvent=Annotation.define();Transaction.addToHistory=Annotation.define();Transaction.remote=Annotation.define();const none=[];exports.CharCategory=void 0;(function(CharCategory){CharCategory[CharCategory.Word=0]="Word";CharCategory[CharCategory.Space=1]="Space";CharCategory[CharCategory.Other=2]="Other"})(exports.CharCategory||
(exports.CharCategory={}));const nonASCIISingleCaseWordChar=/[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;let wordChar;try{wordChar=RegExp("[\\p{Alphabetic}\\p{Number}_]","u")}catch(_){}class EditorState{constructor(config,doc,selection,values,computeSlot,tr){this.config=config;this.doc=doc;this.selection=selection;this.values=values;this.status=config.statusTemplate.slice();this.computeSlot=computeSlot;tr&&(tr._state=this);for(config=
0;config<this.config.dynamicSlots.length;config++)ensureAddr(this,config<<1);this.computeSlot=null}field(field,require=!0){field=this.config.address[field.id];if(null==field){if(require)throw new RangeError("Field is not present in this state");}else return ensureAddr(this,field),getAddr(this,field)}update(...specs){return resolveTransaction(this,specs,!0)}applyTransaction(tr){let conf=this.config,{base,compartments}=conf;for(var effect of tr.effects)effect.is(Compartment.reconfigure)?(conf&&(compartments=
new Map,conf.compartments.forEach((val,key)=>compartments.set(key,val)),conf=null),compartments.set(effect.value.compartment,effect.value.extension)):effect.is(StateEffect.reconfigure)?(conf=null,base=effect.value):effect.is(StateEffect.appendConfig)&&(conf=null,base=asArray(base).concat(effect.value));conf?effect=tr.startState.values.slice():(conf=Configuration.resolve(base,compartments,this),effect=(new EditorState(conf,this.doc,this.selection,conf.dynamicSlots.map(()=>null),(state,slot)=>slot.reconfigure(state,
this),null)).values);new EditorState(conf,tr.newDoc,tr.newSelection,effect,(state,slot)=>slot.update(state,tr),tr)}replaceSelection(text){"string"==typeof text&&(text=this.toText(text));return this.changeByRange(range=>({changes:{from:range.from,to:range.to,insert:text},range:EditorSelection.cursor(range.from+text.length)}))}changeByRange(f){let sel=this.selection;var result1=f(sel.ranges[0]);let changes=this.changes(result1.changes),ranges=[result1.range];result1=asArray(result1.effects);for(let i=
1;i<sel.ranges.length;i++){let result=f(sel.ranges[i]);var newChanges=this.changes(result.changes);let newMapped=newChanges.map(changes);for(let j=0;j<i;j++)ranges[j]=ranges[j].map(newMapped);newChanges=changes.mapDesc(newChanges,!0);ranges.push(result.range.map(newChanges));changes=changes.compose(newMapped);result1=StateEffect.mapEffects(result1,newMapped).concat(StateEffect.mapEffects(asArray(result.effects),newChanges))}return{changes,selection:EditorSelection.create(ranges,sel.mainIndex),effects:result1}}changes(spec=
[]){return spec instanceof ChangeSet?spec:ChangeSet.of(spec,this.doc.length,this.facet(EditorState.lineSeparator))}toText(string){return Text.of(string.split(this.facet(EditorState.lineSeparator)||DefaultSplit))}sliceDoc(from=0,to=this.doc.length){return this.doc.sliceString(from,to,this.lineBreak)}facet(facet){let addr=this.config.address[facet.id];if(null==addr)return facet.default;ensureAddr(this,addr);return getAddr(this,addr)}toJSON(fields){let result={doc:this.sliceDoc(),selection:this.selection.toJSON()};
if(fields)for(let prop in fields){let value=fields[prop];value instanceof StateField&&null!=this.config.address[value.id]&&(result[prop]=value.spec.toJSON(this.field(fields[prop]),this))}return result}static fromJSON(json,config={},fields){if(!json||"string"!=typeof json.doc)throw new RangeError("Invalid JSON representation for EditorState");let fieldInit=[];if(fields)for(let prop in fields)if(Object.prototype.hasOwnProperty.call(json,prop)){let field=fields[prop],value=json[prop];fieldInit.push(field.init(state=>
field.spec.fromJSON(value,state)))}return EditorState.create({doc:json.doc,selection:EditorSelection.fromJSON(json.selection),extensions:config.extensions?fieldInit.concat([config.extensions]):fieldInit})}static create(config={}){let configuration=Configuration.resolve(config.extensions||[],new Map),doc=config.doc instanceof Text?config.doc:Text.of((config.doc||"").split(configuration.staticFacet(EditorState.lineSeparator)||DefaultSplit));config=config.selection?config.selection instanceof EditorSelection?
config.selection:EditorSelection.single(config.selection.anchor,config.selection.head):EditorSelection.single(0);checkSelection(config,doc.length);configuration.staticFacet(allowMultipleSelections)||(config=config.asSingle());return new EditorState(configuration,doc,config,configuration.dynamicSlots.map(()=>null),(state,slot)=>slot.create(state),null)}get tabSize(){return this.facet(EditorState.tabSize)}get lineBreak(){return this.facet(EditorState.lineSeparator)||"\n"}get readOnly(){return this.facet(readOnly)}phrase(phrase,
...insert){for(let map of this.facet(EditorState.phrases))if(Object.prototype.hasOwnProperty.call(map,phrase)){phrase=map[phrase];break}insert.length&&(phrase=phrase.replace(/\$(\$|\d*)/g,(m,i)=>{if("$"==i)return"$";i=+(i||1);return!i||i>insert.length?m:insert[i-1]}));return phrase}languageDataAt(name,pos,side=-1){let values=[];for(let provider of this.facet(languageData))for(let result of provider(this,pos,side))Object.prototype.hasOwnProperty.call(result,name)&&values.push(result[name]);return values}charCategorizer(at){return makeCategorizer(this.languageDataAt("wordChars",
at).join(""))}wordAt(pos){let {text,from,length}=this.doc.lineAt(pos),cat=this.charCategorizer(pos),start=pos-from;for(pos-=from;0<start;){var prev=findClusterBreak(text,start,!1);if(cat(text.slice(prev,start))!=exports.CharCategory.Word)break;start=prev}for(;pos<length;){prev=findClusterBreak(text,pos);if(cat(text.slice(pos,prev))!=exports.CharCategory.Word)break;pos=prev}return start==pos?null:EditorSelection.range(start+from,pos+from)}}EditorState.allowMultipleSelections=allowMultipleSelections;
EditorState.tabSize=Facet.define({combine:values=>values.length?values[0]:4});EditorState.lineSeparator=lineSeparator;EditorState.readOnly=readOnly;EditorState.phrases=Facet.define({compare(a,b){let kA=Object.keys(a),kB=Object.keys(b);return kA.length==kB.length&&kA.every(k=>a[k]==b[k])}});EditorState.languageData=languageData;EditorState.changeFilter=changeFilter;EditorState.transactionFilter=transactionFilter;EditorState.transactionExtender=transactionExtender;Compartment.reconfigure=StateEffect.define();
class RangeValue{eq(other){return this==other}range(from,to=from){return Range.create(from,to,this)}}RangeValue.prototype.startSide=RangeValue.prototype.endSide=0;RangeValue.prototype.point=!1;RangeValue.prototype.mapMode=exports.MapMode.TrackDel;class Range{constructor(from,to,value){this.from=from;this.to=to;this.value=value}static create(from,to,value){return new Range(from,to,value)}}class Chunk{constructor(from,to,value,maxPoint){this.from=from;this.to=to;this.value=value;this.maxPoint=maxPoint}get length(){return this.to[this.to.length-
1]}findIndex(pos,side,end,startAt=0){let arr=end?this.to:this.from;for(let lo=startAt,hi=arr.length;;){if(lo==hi)return lo;startAt=lo+hi>>1;let diff=arr[startAt]-pos||(end?this.value[startAt].endSide:this.value[startAt].startSide)-side;if(startAt==lo)return 0<=diff?lo:hi;0<=diff?hi=startAt:lo=startAt+1}}between(offset,from,to,f){for(let i=this.findIndex(from,-1E9,!0),e=this.findIndex(to,1E9,!1,i);i<e;i++)if(!1===f(this.from[i]+offset,this.to[i]+offset,this.value[i]))return!1}map(offset,changes){let value=
[],from=[],to=[],newPos=-1,maxPoint=-1;for(let i=0;i<this.value.length;i++){let val=this.value[i],curFrom=this.from[i]+offset;var curTo=this.to[i]+offset,newFrom=void 0;if(curFrom==curTo){newFrom=changes.mapPos(curFrom,val.startSide,val.mapMode);if(null==newFrom)continue;newFrom=curTo=newFrom;if(val.startSide!=val.endSide&&(curTo=changes.mapPos(curFrom,val.endSide),curTo<newFrom))continue}else if(newFrom=changes.mapPos(curFrom,val.startSide),curTo=changes.mapPos(curTo,val.endSide),newFrom>curTo||
newFrom==curTo&&0<val.startSide&&0>=val.endSide)continue;0>(curTo-newFrom||val.endSide-val.startSide)||(0>newPos&&(newPos=newFrom),val.point&&(maxPoint=Math.max(maxPoint,curTo-newFrom)),value.push(val),from.push(newFrom-newPos),to.push(curTo-newPos))}return{mapped:value.length?new Chunk(from,to,value,maxPoint):null,pos:newPos}}}class RangeSet{constructor(chunkPos,chunk,nextLayer,maxPoint){this.chunkPos=chunkPos;this.chunk=chunk;this.nextLayer=nextLayer;this.maxPoint=maxPoint}static create(chunkPos,
chunk,nextLayer,maxPoint){return new RangeSet(chunkPos,chunk,nextLayer,maxPoint)}get length(){let last=this.chunk.length-1;return 0>last?0:Math.max(this.chunkEnd(last),this.nextLayer.length)}get size(){if(this.isEmpty)return 0;let size=this.nextLayer.size;for(let chunk of this.chunk)size+=chunk.value.length;return size}chunkEnd(index){return this.chunkPos[index]+this.chunk[index].length}update(updateSpec){let {add=[],sort=!1,filterFrom=0,filterTo=this.length}=updateSpec;updateSpec=updateSpec.filter;
if(0==add.length&&!updateSpec)return this;sort&&(add=add.slice().sort(cmpRange));if(this.isEmpty)return add.length?RangeSet.of(add):this;let cur=(new LayerCursor(this,null,-1)).goto(0),i=0,spill=[],builder=new RangeSetBuilder;for(;cur.value||i<add.length;)if(i<add.length&&0<=(cur.from-add[i].from||cur.startSide-add[i].value.startSide)){let range=add[i++];builder.addInner(range.from,range.to,range.value)||spill.push(range)}else if(1==cur.rangeIndex&&cur.chunkIndex<this.chunk.length&&(i==add.length||
this.chunkEnd(cur.chunkIndex)<add[i].from)&&(!updateSpec||filterFrom>this.chunkEnd(cur.chunkIndex)||filterTo<this.chunkPos[cur.chunkIndex])&&builder.addChunk(this.chunkPos[cur.chunkIndex],this.chunk[cur.chunkIndex]))cur.nextChunk();else{if(!updateSpec||filterFrom>cur.to||filterTo<cur.from||updateSpec(cur.from,cur.to,cur.value))builder.addInner(cur.from,cur.to,cur.value)||spill.push(Range.create(cur.from,cur.to,cur.value));cur.next()}return builder.finishInner(this.nextLayer.isEmpty&&!spill.length?
RangeSet.empty:this.nextLayer.update({add:spill,filter:updateSpec,filterFrom,filterTo}))}map(changes){if(changes.empty||this.isEmpty)return this;let chunks=[],chunkPos=[],maxPoint=-1;for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i],touch=changes.touchesRange(start,start+chunk.length);if(!1===touch)maxPoint=Math.max(maxPoint,chunk.maxPoint),chunks.push(chunk),chunkPos.push(changes.mapPos(start));else if(!0===touch){let {mapped,pos}=chunk.map(start,changes);mapped&&
(maxPoint=Math.max(maxPoint,mapped.maxPoint),chunks.push(mapped),chunkPos.push(pos))}}changes=this.nextLayer.map(changes);return 0==chunks.length?changes:new RangeSet(chunkPos,chunks,changes||RangeSet.empty,maxPoint)}between(from,to,f){if(!this.isEmpty){for(let i=0;i<this.chunk.length;i++){let start=this.chunkPos[i],chunk=this.chunk[i];if(to>=start&&from<=start+chunk.length&&!1===chunk.between(start,from-start,to-start,f))return}this.nextLayer.between(from,to,f)}}iter(from=0){return HeapCursor.from([this]).goto(from)}get isEmpty(){return this.nextLayer==
this}static iter(sets,from=0){return HeapCursor.from(sets).goto(from)}static compare(oldSets,newSets,textDiff,comparator,minPointSize=-1){oldSets=oldSets.filter(set=>0<set.maxPoint||!set.isEmpty&&set.maxPoint>=minPointSize);newSets=newSets.filter(set=>0<set.maxPoint||!set.isEmpty&&set.maxPoint>=minPointSize);let sharedChunks=findSharedChunks(oldSets,newSets,textDiff),sideA=new SpanCursor(oldSets,sharedChunks,minPointSize),sideB=new SpanCursor(newSets,sharedChunks,minPointSize);textDiff.iterGaps((fromA,
fromB,length)=>compare$jscomp$0(sideA,fromA,sideB,fromB,length,comparator));textDiff.empty&&0==textDiff.length&&compare$jscomp$0(sideA,0,sideB,0,0,comparator)}static eq(oldSets,newSets,from=0,to){null==to&&(to=1E9-1);var a=oldSets.filter(set=>!set.isEmpty&&0>newSets.indexOf(set));let b=newSets.filter(set=>!set.isEmpty&&0>oldSets.indexOf(set));if(a.length!=b.length)return!1;if(!a.length)return!0;let sharedChunks=findSharedChunks(a,b);a=(new SpanCursor(a,sharedChunks,0)).goto(from);for(from=(new SpanCursor(b,
sharedChunks,0)).goto(from);;){if(a.to!=from.to||!sameValues(a.active,from.active)||a.point&&(!from.point||!a.point.eq(from.point)))return!1;if(a.to>to)return!0;a.next();from.next()}}static spans(sets,from,to,iterator,minPointSize=-1){sets=(new SpanCursor(sets,null,minPointSize)).goto(from);for(minPointSize=sets.openStart;;){let curTo=Math.min(sets.to,to);sets.point?(iterator.point(from,curTo,sets.point,sets.activeForPoint(sets.to),minPointSize,sets.pointRank),minPointSize=sets.openEnd(curTo)+(sets.to>
curTo?1:0)):curTo>from&&(iterator.span(from,curTo,sets.active,minPointSize),minPointSize=sets.openEnd(curTo));if(sets.to>to)break;from=sets.to;sets.next()}return minPointSize}static of(ranges,sort=!1){let build=new RangeSetBuilder;for(let range of ranges instanceof Range?[ranges]:sort?lazySort(ranges):ranges)build.add(range.from,range.to,range.value);return build.finish()}}RangeSet.empty=new RangeSet([],[],null,-1);RangeSet.empty.nextLayer=RangeSet.empty;class RangeSetBuilder{constructor(){this.chunks=
[];this.chunkPos=[];this.chunkStart=-1;this.last=null;this.lastTo=this.lastFrom=-1E9;this.from=[];this.to=[];this.value=[];this.setMaxPoint=this.maxPoint=-1;this.nextLayer=null}finishChunk(newArrays){this.chunks.push(new Chunk(this.from,this.to,this.value,this.maxPoint));this.chunkPos.push(this.chunkStart);this.chunkStart=-1;this.setMaxPoint=Math.max(this.setMaxPoint,this.maxPoint);this.maxPoint=-1;newArrays&&(this.from=[],this.to=[],this.value=[])}add(from,to,value){this.addInner(from,to,value)||
(this.nextLayer||(this.nextLayer=new RangeSetBuilder)).add(from,to,value)}addInner(from,to,value){let diff=from-this.lastTo||value.startSide-this.last.endSide;if(0>=diff&&0>(from-this.lastFrom||value.startSide-this.last.startSide))throw Error("Ranges must be added sorted by `from` position and `startSide`");if(0>diff)return!1;250==this.from.length&&this.finishChunk(!0);0>this.chunkStart&&(this.chunkStart=from);this.from.push(from-this.chunkStart);this.to.push(to-this.chunkStart);this.last=value;this.lastFrom=
from;this.lastTo=to;this.value.push(value);value.point&&(this.maxPoint=Math.max(this.maxPoint,to-from));return!0}addChunk(from,chunk){if(0>(from-this.lastTo||chunk.value[0].startSide-this.last.endSide))return!1;this.from.length&&this.finishChunk(!0);this.setMaxPoint=Math.max(this.setMaxPoint,chunk.maxPoint);this.chunks.push(chunk);this.chunkPos.push(from);let last=chunk.value.length-1;this.last=chunk.value[last];this.lastFrom=chunk.from[last]+from;this.lastTo=chunk.to[last]+from;return!0}finish(){return this.finishInner(RangeSet.empty)}finishInner(next){this.from.length&&
this.finishChunk(!1);if(0==this.chunks.length)return next;next=RangeSet.create(this.chunkPos,this.chunks,this.nextLayer?this.nextLayer.finishInner(next):next,this.setMaxPoint);this.from=null;return next}}class LayerCursor{constructor(layer,skip,minPoint,rank=0){this.layer=layer;this.skip=skip;this.minPoint=minPoint;this.rank=rank}get startSide(){return this.value?this.value.startSide:0}get endSide(){return this.value?this.value.endSide:0}goto(pos,side=-1E9){this.chunkIndex=this.rangeIndex=0;this.gotoInner(pos,
side,!1);return this}gotoInner(pos,side,forward){for(;this.chunkIndex<this.layer.chunk.length;){let next=this.layer.chunk[this.chunkIndex];if(!(this.skip&&this.skip.has(next)||this.layer.chunkEnd(this.chunkIndex)<pos||next.maxPoint<this.minPoint))break;this.chunkIndex++;forward=!1}this.chunkIndex<this.layer.chunk.length&&(pos=this.layer.chunk[this.chunkIndex].findIndex(pos-this.layer.chunkPos[this.chunkIndex],side,!0),(!forward||this.rangeIndex<pos)&&this.setRangeIndex(pos));this.next()}forward(pos,
side){0>(this.to-pos||this.endSide-side)&&this.gotoInner(pos,side,!0)}next(){for(;;)if(this.chunkIndex==this.layer.chunk.length){this.from=this.to=1E9;this.value=null;break}else{let chunkPos=this.layer.chunkPos[this.chunkIndex],chunk=this.layer.chunk[this.chunkIndex];this.from=chunkPos+chunk.from[this.rangeIndex];this.to=chunkPos+chunk.to[this.rangeIndex];this.value=chunk.value[this.rangeIndex];this.setRangeIndex(this.rangeIndex+1);if(0>this.minPoint||this.value.point&&this.to-this.from>=this.minPoint)break}}setRangeIndex(index){if(index==
this.layer.chunk[this.chunkIndex].value.length){this.chunkIndex++;if(this.skip)for(;this.chunkIndex<this.layer.chunk.length&&this.skip.has(this.layer.chunk[this.chunkIndex]);)this.chunkIndex++;this.rangeIndex=0}else this.rangeIndex=index}nextChunk(){this.chunkIndex++;this.rangeIndex=0;this.next()}compare(other){return this.from-other.from||this.startSide-other.startSide||this.rank-other.rank||this.to-other.to||this.endSide-other.endSide}}class HeapCursor{constructor(heap){this.heap=heap}static from(sets,
skip=null,minPoint=-1){let heap=[];for(let i=0;i<sets.length;i++)for(let cur=sets[i];!cur.isEmpty;cur=cur.nextLayer)cur.maxPoint>=minPoint&&heap.push(new LayerCursor(cur,skip,minPoint,i));return 1==heap.length?heap[0]:new HeapCursor(heap)}get startSide(){return this.value?this.value.startSide:0}goto(pos,side=-1E9){for(let cur of this.heap)cur.goto(pos,side);for(pos=this.heap.length>>1;0<=pos;pos--)heapBubble(this.heap,pos);this.next();return this}forward(pos,side){for(var cur of this.heap)cur.forward(pos,
side);for(cur=this.heap.length>>1;0<=cur;cur--)heapBubble(this.heap,cur);0>(this.to-pos||this.value.endSide-side)&&this.next()}next(){if(0==this.heap.length)this.from=this.to=1E9,this.value=null,this.rank=-1;else{let top=this.heap[0];this.from=top.from;this.to=top.to;this.value=top.value;this.rank=top.rank;top.value&&top.next();heapBubble(this.heap,0)}}}class SpanCursor{constructor(sets,skip,minPoint){this.minPoint=minPoint;this.active=[];this.activeTo=[];this.activeRank=[];this.minActive=-1;this.point=
null;this.pointRank=this.pointFrom=0;this.to=-1E9;this.endSide=0;this.openStart=-1;this.cursor=HeapCursor.from(sets,skip,minPoint)}goto(pos,side=-1E9){this.cursor.goto(pos,side);this.active.length=this.activeTo.length=this.activeRank.length=0;this.minActive=-1;this.to=pos;this.endSide=side;this.openStart=-1;this.next();return this}forward(pos,side){for(;-1<this.minActive&&0>(this.activeTo[this.minActive]-pos||this.active[this.minActive].endSide-side);)this.removeActive(this.minActive);this.cursor.forward(pos,
side)}removeActive(index){remove(this.active,index);remove(this.activeTo,index);remove(this.activeRank,index);this.minActive=findMinIndex(this.active,this.activeTo)}addActive(trackOpen){let i=0,{value,to,rank}=this.cursor;for(;i<this.activeRank.length&&this.activeRank[i]<=rank;)i++;insert(this.active,i,value);insert(this.activeTo,i,to);insert(this.activeRank,i,rank);trackOpen&&insert(trackOpen,i,this.cursor.from);this.minActive=findMinIndex(this.active,this.activeTo)}next(){let from=this.to;var wasPoint=
this.point;this.point=null;let trackOpen=0>this.openStart?[]:null,trackExtra=0;for(;;){var a=this.minActive;if(-1<a&&0>(this.activeTo[a]-this.cursor.from||this.active[a].endSide-this.cursor.startSide)){if(this.activeTo[a]>from){this.to=this.activeTo[a];this.endSide=this.active[a].endSide;break}this.removeActive(a);trackOpen&&remove(trackOpen,a)}else if(this.cursor.value)if(this.cursor.from>from){this.to=this.cursor.from;this.endSide=this.cursor.startSide;break}else if(a=this.cursor.value,a.point)if(wasPoint&&
this.cursor.to==this.to&&this.cursor.from<this.cursor.to)this.cursor.next();else{this.point=a;this.pointFrom=this.cursor.from;this.pointRank=this.cursor.rank;this.to=this.cursor.to;this.endSide=a.endSide;this.cursor.from<from&&(trackExtra=1);this.cursor.next();this.forward(this.to,this.endSide);break}else this.addActive(trackOpen),this.cursor.from<from&&this.cursor.to>from&&trackExtra++,this.cursor.next();else{this.to=this.endSide=1E9;break}}if(trackOpen){for(wasPoint=0;wasPoint<trackOpen.length&&
trackOpen[wasPoint]<from;)wasPoint++;this.openStart=wasPoint+trackExtra}}activeForPoint(to){if(!this.active.length)return this.active;let active=[];for(let i=this.active.length-1;0<=i&&!(this.activeRank[i]<this.pointRank);i--)(this.activeTo[i]>to||this.activeTo[i]==to&&this.active[i].endSide>=this.point.endSide)&&active.push(this.active[i]);return active.reverse()}openEnd(to){let open=0;for(let i=this.activeTo.length-1;0<=i&&this.activeTo[i]>to;i--)open++;return open}}exports.Annotation=Annotation;
exports.AnnotationType=AnnotationType;exports.ChangeDesc=ChangeDesc;exports.ChangeSet=ChangeSet;exports.Compartment=Compartment;exports.EditorSelection=EditorSelection;exports.EditorState=EditorState;exports.Facet=Facet;exports.Line=Line;exports.Prec=global;exports.Range=Range;exports.RangeSet=RangeSet;exports.RangeSetBuilder=RangeSetBuilder;exports.RangeValue=RangeValue;exports.SelectionRange=SelectionRange;exports.StateEffect=StateEffect;exports.StateEffectType=StateEffectType;exports.StateField=
StateField;exports.Text=Text;exports.Transaction=Transaction;exports.codePointAt=codePointAt;exports.codePointSize=codePointSize;exports.combineConfig=function(configs,defaults,combine={}){let result={};for(let config of configs)for(let key of Object.keys(config)){configs=config[key];let current=result[key];if(void 0===current)result[key]=configs;else if(current!==configs&&void 0!==configs)if(Object.hasOwnProperty.call(combine,key))result[key]=combine[key](current,configs);else throw Error("Config merge conflict for field "+
key);}for(let key in defaults)void 0===result[key]&&(result[key]=defaults[key]);return result};exports.countColumn=function(string,tabSize,to=string.length){let n=0;for(let i=0;i<to;)9==string.charCodeAt(i)?(n+=tabSize-n%tabSize,i++):(n++,i=findClusterBreak(string,i));return n};exports.findClusterBreak=findClusterBreak;exports.findColumn=function(string,col,tabSize,strict){for(let i=0,n=0;;){if(n>=col)return i;if(i==string.length)break;n+=9==string.charCodeAt(i)?tabSize-n%tabSize:1;i=findClusterBreak(string,
i)}return!0===strict?-1:string.length};exports.fromCodePoint=function(code){if(65535>=code)return String.fromCharCode(code);code-=65536;return String.fromCharCode((code>>10)+55296,(code&1023)+56320)}}
//# sourceMappingURL=module$node_modules$$codemirror$state$dist$index_cjs.js.map
