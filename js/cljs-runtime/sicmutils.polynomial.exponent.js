goog.provide('sicmutils.polynomial.exponent');
/**
 * Accepts alternating pairs of integers representing <indeterminate
 *  index>, <exponent value> and returns a `sorted-map` representing the exponent
 *  portion of a polynomial term.
 */
sicmutils.polynomial.exponent.make = new cljs.core.Var(function(){return cljs.core.sorted_map;},new cljs.core.Symbol("cljs.core","sorted-map","cljs.core/sorted-map",-1196662760,null),cljs.core.PersistentHashMap.fromArrays([new cljs.core.Keyword(null,"ns","ns",441598760),new cljs.core.Keyword(null,"name","name",1843675177),new cljs.core.Keyword(null,"file","file",-1269645878),new cljs.core.Keyword(null,"end-column","end-column",1425389514),new cljs.core.Keyword(null,"top-fn","top-fn",-2056129173),new cljs.core.Keyword(null,"column","column",2078222095),new cljs.core.Keyword(null,"line","line",212345235),new cljs.core.Keyword(null,"end-line","end-line",1837326455),new cljs.core.Keyword(null,"arglists","arglists",1661989754),new cljs.core.Keyword(null,"doc","doc",1913296891),new cljs.core.Keyword(null,"test","test",577538877)],[new cljs.core.Symbol(null,"cljs.core","cljs.core",770546058,null),new cljs.core.Symbol(null,"sorted-map","sorted-map",-521216771,null),"cljs/core.cljs",17,new cljs.core.PersistentArrayMap(null, 6, [new cljs.core.Keyword(null,"variadic?","variadic?",584179762),true,new cljs.core.Keyword(null,"fixed-arity","fixed-arity",1586445869),(0),new cljs.core.Keyword(null,"max-fixed-arity","max-fixed-arity",-690205543),(0),new cljs.core.Keyword(null,"method-params","method-params",-980792179),new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [cljs.core.list(new cljs.core.Symbol(null,"keyvals","keyvals",-2067234787,null))], null),new cljs.core.Keyword(null,"arglists","arglists",1661989754),cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,"&","&",-2144855648,null),new cljs.core.Symbol(null,"keyvals","keyvals",-2067234787,null)], null)),new cljs.core.Keyword(null,"arglists-meta","arglists-meta",1944829838),cljs.core.list(null)], null),1,8963,8963,cljs.core.list(new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.Symbol(null,"&","&",-2144855648,null),new cljs.core.Symbol(null,"keyvals","keyvals",-2067234787,null)], null)),"keyval => key val\n  Returns a new sorted map with supplied mappings.",(cljs.core.truth_(cljs.core.sorted_map)?cljs.core.sorted_map.cljs$lang$test:null)]));
/**
 * Singleton instance of an empty exponent map.
 */
sicmutils.polynomial.exponent.empty = (sicmutils.polynomial.exponent.make.cljs$core$IFn$_invoke$arity$0 ? sicmutils.polynomial.exponent.make.cljs$core$IFn$_invoke$arity$0() : sicmutils.polynomial.exponent.make.call(null));
/**
 * Accepts a sequence of pairs of indeterminate index => power, and returns a
 *   sparse representation the exponents portion of a monomial.
 * 
 *   For example:
 * 
 *   ```clojure
 *   (dense->exponents [1 4 0 0 2])
 *   ;;=> {0 1, 1 4, 4 2}
 *   ```
 */
sicmutils.polynomial.exponent.dense__GT_exponents = (function sicmutils$polynomial$exponent$dense__GT_exponents(idx__GT_pow){
return cljs.core.reduce_kv((function (acc,i,x){
if((x === (0))){
return acc;
} else {
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,i,x);
}
}),sicmutils.polynomial.exponent.empty,idx__GT_pow);
});
/**
 * Returns a new exponent vector generated by multiplying all terms in exponent
 *   vectors `l` and `r`.
 */
sicmutils.polynomial.exponent.mul = (function sicmutils$polynomial$exponent$mul(l,r){
return cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic(cljs.core._PLUS_,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l,r], 0));
});
/**
 * Returns a new exponent vector generated by dividing terms in exponent vector
 *   `l` by terms in `r`.
 */
sicmutils.polynomial.exponent.div = (function sicmutils$polynomial$exponent$div(l,r){
return sicmutils.polynomial.exponent.dense__GT_exponents(cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic(cljs.core._PLUS_,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l,sicmutils.util.map_vals(cljs.core._,r)], 0)));
});
/**
 * Returns the exponent vector that is the greatest common divisor of the exponent
 *   vectors `l` and `r`.
 * 
 *   Calling [[gcd]] with a single argument acts as identity.
 */
sicmutils.polynomial.exponent.gcd = (function sicmutils$polynomial$exponent$gcd(var_args){
var G__85165 = arguments.length;
switch (G__85165) {
case 1:
return sicmutils.polynomial.exponent.gcd.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 2:
return sicmutils.polynomial.exponent.gcd.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.polynomial.exponent.gcd.cljs$core$IFn$_invoke$arity$1 = (function (l){
return l;
}));

(sicmutils.polynomial.exponent.gcd.cljs$core$IFn$_invoke$arity$2 = (function (l,r){
var l_SINGLEQUOTE_ = cljs.core.select_keys(l,cljs.core.keys(r));
var r_SINGLEQUOTE_ = cljs.core.select_keys(r,cljs.core.keys(l));
return cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic(cljs.core.min,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l_SINGLEQUOTE_,r_SINGLEQUOTE_], 0));
}));

(sicmutils.polynomial.exponent.gcd.cljs$lang$maxFixedArity = 2);

/**
 * Returns the exponent vector that is the least common multiple of the exponent
 *   vectors `l` and `r`.
 * 
 *   Calling [[lcm]] with no arguments returns the empty exponent vector; calling
 *   with a single argument acts as identity.
 */
sicmutils.polynomial.exponent.lcm = (function sicmutils$polynomial$exponent$lcm(var_args){
var G__85171 = arguments.length;
switch (G__85171) {
case 0:
return sicmutils.polynomial.exponent.lcm.cljs$core$IFn$_invoke$arity$0();

break;
case 1:
return sicmutils.polynomial.exponent.lcm.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 2:
return sicmutils.polynomial.exponent.lcm.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.polynomial.exponent.lcm.cljs$core$IFn$_invoke$arity$0 = (function (){
return sicmutils.polynomial.exponent.empty;
}));

(sicmutils.polynomial.exponent.lcm.cljs$core$IFn$_invoke$arity$1 = (function (l){
return l;
}));

(sicmutils.polynomial.exponent.lcm.cljs$core$IFn$_invoke$arity$2 = (function (l,r){
return cljs.core.merge_with.cljs$core$IFn$_invoke$arity$variadic(cljs.core.max,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([l,r], 0));
}));

(sicmutils.polynomial.exponent.lcm.cljs$lang$maxFixedArity = 2);

/**
 * Returns true if `f` returns true for every positive non-zero exponent in the
 *   supplied exponent vector `m`, false otherwise.
 * 
 *   Defaults to `true` if `m` is empty.
 */
sicmutils.polynomial.exponent.every_power_QMARK_ = (function sicmutils$polynomial$exponent$every_power_QMARK_(f,m){
return cljs.core.every_QMARK_(f,cljs.core.vals(m));
});
/**
 * Replaces the entry for variable `x` in the exponents vector `m` with power `n`.
 *   If `n` is zero, removes `x`'s entry from the returned exponent vector.
 */
sicmutils.polynomial.exponent.assoc = (function sicmutils$polynomial$exponent$assoc(m,x,n){
if((n === (0))){
return cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(m,x);
} else {
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,x,n);
}
});
/**
 * Given some exponent vector `expts`, and an optional variable index
 *   `i` (defaults to `0`), returns a new exponent vector with:
 * 
 *   - the `i`th variable's entry removed
 *   - decremented index for each variable with index > `i`.
 * 
 *   For example:
 * 
 *   ```clojure
 *   (lower {0 3, 1 2, 4 4})
 *   ;;=> {0 2, 3 4}
 * 
 *   (lower {0 3, 1 2, 4 4} 1)
 *   ;;=> {0 3, 3 4}
 *   ```
 */
sicmutils.polynomial.exponent.lower = (function sicmutils$polynomial$exponent$lower(var_args){
var G__85181 = arguments.length;
switch (G__85181) {
case 1:
return sicmutils.polynomial.exponent.lower.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 2:
return sicmutils.polynomial.exponent.lower.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.polynomial.exponent.lower.cljs$core$IFn$_invoke$arity$1 = (function (expts){
return sicmutils.polynomial.exponent.lower.cljs$core$IFn$_invoke$arity$2(expts,(0));
}));

(sicmutils.polynomial.exponent.lower.cljs$core$IFn$_invoke$arity$2 = (function (expts,i){
return cljs.core.reduce_kv((function (acc,k,v){
if((k > i)){
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,(k - (1)),v);
} else {
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,k,v);
}
}),sicmutils.polynomial.exponent.empty,cljs.core.dissoc.cljs$core$IFn$_invoke$arity$2(expts,i));
}));

(sicmutils.polynomial.exponent.lower.cljs$lang$maxFixedArity = 2);

/**
 * Given some exponent vector `expts`, an optional variable index `i` (defaults to
 *   `0`) and an optional exponent power `n` (defaults to `0`), returns a new
 *   exponent vector with:
 * 
 *   - incremented indices for each variable with index >= `i`
 *   - a new `i`th variable created with power `n`
 * 
 *   For example:
 * 
 *   ```clojure
 *   (raise {0 3, 1 2, 4 4})
 *   ;;=> {1 3, 2 2, 5 4}
 * 
 *   (raise {0 3, 1 2, 4 4} 1)
 *   ;;=> {0 3, 2 2, 5 4}
 * 
 *   (raise {0 3, 1 2, 4 4} 1)
 *   ;;=> {0 3, 1 10, 2 2, 5 4}
 *   ```
 */
sicmutils.polynomial.exponent.raise = (function sicmutils$polynomial$exponent$raise(var_args){
var G__85187 = arguments.length;
switch (G__85187) {
case 1:
return sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 2:
return sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
case 3:
return sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$1 = (function (expts){
return sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$3(expts,(0),(0));
}));

(sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$2 = (function (expts,i){
return sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$3(expts,i,(0));
}));

(sicmutils.polynomial.exponent.raise.cljs$core$IFn$_invoke$arity$3 = (function (expts,i,n){
var m = cljs.core.reduce_kv((function (acc,k,v){
if((k >= i)){
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,(k + (1)),v);
} else {
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(acc,k,v);
}
}),sicmutils.polynomial.exponent.empty,expts);
if((n === (0))){
return m;
} else {
return cljs.core.assoc.cljs$core$IFn$_invoke$arity$3(m,i,n);
}
}));

(sicmutils.polynomial.exponent.raise.cljs$lang$maxFixedArity = 3);

/**
 * Returns the [monomial degree](https://en.wikipedia.org/wiki/Monomial#Degree) of
 *   the exponent vector `m`, ie, the sum of the powers of all variables in `m`.
 * 
 *   If the optional `i` is supplied, returns the degree of the `i`th variable, ie,
 *   the entry for `i` in `m`, defaulting to `0`.
 */
sicmutils.polynomial.exponent.monomial_degree = (function sicmutils$polynomial$exponent$monomial_degree(var_args){
var G__85195 = arguments.length;
switch (G__85195) {
case 1:
return sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 2:
return sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$1 = (function (m){
return cljs.core.apply.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,cljs.core.vals(m));
}));

(sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$2 = (function (m,i){
return (m.cljs$core$IFn$_invoke$arity$2 ? m.cljs$core$IFn$_invoke$arity$2(i,(0)) : m.call(null,i,(0)));
}));

(sicmutils.polynomial.exponent.monomial_degree.cljs$lang$maxFixedArity = 2);

/**
 * Given a power product `m`, returns a pair of `sort` and `unsort` functions of a
 *   single power product argument.
 * 
 *   `sort` rearranges the indices of its argument to match the order of increasing
 *   variable degree in `m`. `unsort` undoes this transformation.
 */
sicmutils.polynomial.exponent.__GT_sort_PLUS_unsort = (function sicmutils$polynomial$exponent$__GT_sort_PLUS_unsort(m){
var indices = cljs.core.range.cljs$core$IFn$_invoke$arity$1(cljs.core.count(m));
var order = cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,cljs.core.sort_by.cljs$core$IFn$_invoke$arity$2(m,cljs.core.keys(m)));
var sort = (function sicmutils$polynomial$exponent$__GT_sort_PLUS_unsort_$_sort(m_SINGLEQUOTE_){
return cljs.core.into.cljs$core$IFn$_invoke$arity$3(sicmutils.polynomial.exponent.empty,cljs.core.mapcat.cljs$core$IFn$_invoke$arity$1((function (i){
var temp__5753__auto__ = (function (){var G__85273 = (order.cljs$core$IFn$_invoke$arity$1 ? order.cljs$core$IFn$_invoke$arity$1(i) : order.call(null,i));
return (m_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$1 ? m_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$1(G__85273) : m_SINGLEQUOTE_.call(null,G__85273));
})();
if(cljs.core.truth_(temp__5753__auto__)){
var v = temp__5753__auto__;
return new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [i,v], null)], null);
} else {
return null;
}
})),indices);
});
var unsort = (function sicmutils$polynomial$exponent$__GT_sort_PLUS_unsort_$_unsort(m_SINGLEQUOTE_){
return cljs.core.into.cljs$core$IFn$_invoke$arity$3(sicmutils.polynomial.exponent.empty,cljs.core.mapcat.cljs$core$IFn$_invoke$arity$1((function (i){
var temp__5753__auto__ = (m_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$1 ? m_SINGLEQUOTE_.cljs$core$IFn$_invoke$arity$1(i) : m_SINGLEQUOTE_.call(null,i));
if(cljs.core.truth_(temp__5753__auto__)){
var v = temp__5753__auto__;
return new cljs.core.PersistentVector(null, 1, 5, cljs.core.PersistentVector.EMPTY_NODE, [new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [(order.cljs$core$IFn$_invoke$arity$1 ? order.cljs$core$IFn$_invoke$arity$1(i) : order.call(null,i)),v], null)], null);
} else {
return null;
}
})),indices);
});
return new cljs.core.PersistentVector(null, 2, 5, cljs.core.PersistentVector.EMPTY_NODE, [sort,unsort], null);
});
/**
 * Comparator that responds based on the [lexicographic
 *   order](https://en.wikipedia.org/wiki/Monomial_order#Lexicographic_order), or
 *   'lex order', of the exponent vectors `xs` and `ys`. Accepts any sequence of
 *   pairs of the form `[variable, power]` for `xs` and `ys`.
 * 
 *   Lex order first compares the power of variable `0`, then, in case of equality,
 *   variable `1` and so on. If all powers match, returns `0`.
 * 
 *   If `:reverse? true` is passed, the inputs are compared in reverse lexicographic order.
 * 
 *   Reverse here means two things:
 * 
 *   1. the variables are considered in reverse order; the variable with the
 *   largest index is compared first, then the next-largest, and on down the line.
 *   2. The _smaller_ exponent is grevlex-greater in this comparison.
 */
sicmutils.polynomial.exponent.lex_order = (function sicmutils$polynomial$exponent$lex_order(var_args){
var args__4870__auto__ = [];
var len__4864__auto___85318 = arguments.length;
var i__4865__auto___85319 = (0);
while(true){
if((i__4865__auto___85319 < len__4864__auto___85318)){
args__4870__auto__.push((arguments[i__4865__auto___85319]));

var G__85320 = (i__4865__auto___85319 + (1));
i__4865__auto___85319 = G__85320;
continue;
} else {
}
break;
}

var argseq__4871__auto__ = ((((2) < args__4870__auto__.length))?(new cljs.core.IndexedSeq(args__4870__auto__.slice((2)),(0),null)):null);
return sicmutils.polynomial.exponent.lex_order.cljs$core$IFn$_invoke$arity$variadic((arguments[(0)]),(arguments[(1)]),argseq__4871__auto__);
});

(sicmutils.polynomial.exponent.lex_order.cljs$core$IFn$_invoke$arity$variadic = (function (xs,ys,p__85277){
var map__85278 = p__85277;
var map__85278__$1 = cljs.core.__destructure_map(map__85278);
var reverse_QMARK_ = cljs.core.get.cljs$core$IFn$_invoke$arity$2(map__85278__$1,new cljs.core.Keyword(null,"reverse?","reverse?",-1672868474));
var xs__$1 = cljs.core.vec((cljs.core.truth_(reverse_QMARK_)?cljs.core.rseq(xs):xs));
var ys__$1 = cljs.core.vec((cljs.core.truth_(reverse_QMARK_)?cljs.core.rseq(ys):ys));
var i = cljs.core.long$((0));
while(true){
var x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(xs__$1,i,null);
var y = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(ys__$1,i,null);
if(((cljs.core.not(x)) && (cljs.core.not(y)))){
return (0);
} else {
if(cljs.core.not(x)){
return (-1);
} else {
if(cljs.core.not(y)){
return (1);
} else {
var bit = cljs.core.compare(cljs.core.nth.cljs$core$IFn$_invoke$arity$2(x,(0)),cljs.core.nth.cljs$core$IFn$_invoke$arity$2(y,(0)));
if((bit === (0))){
var xv = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(x,(1));
var yv = cljs.core.nth.cljs$core$IFn$_invoke$arity$2(y,(1));
if(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(xv,yv)){
var G__85322 = (i + (1));
i = G__85322;
continue;
} else {
if(cljs.core.truth_(reverse_QMARK_)){
return (yv - xv);
} else {
return (xv - yv);
}
}
} else {
if((bit < (0))){
return (1);
} else {
return (-1);

}
}

}
}
}
break;
}
}));

(sicmutils.polynomial.exponent.lex_order.cljs$lang$maxFixedArity = (2));

/** @this {Function} */
(sicmutils.polynomial.exponent.lex_order.cljs$lang$applyTo = (function (seq85274){
var G__85275 = cljs.core.first(seq85274);
var seq85274__$1 = cljs.core.next(seq85274);
var G__85276 = cljs.core.first(seq85274__$1);
var seq85274__$2 = cljs.core.next(seq85274__$1);
var self__4851__auto__ = this;
return self__4851__auto__.cljs$core$IFn$_invoke$arity$variadic(G__85275,G__85276,seq85274__$2);
}));

/**
 * Comparator that responds based on the [graded lexicographic
 *   order](https://en.wikipedia.org/wiki/Monomial_order#Graded_lexicographic_order),
 *   or 'grlex order', of the exponent vectors `xs` and `ys`. Accepts any sequence
 *   of pairs of the form `[variable, power]` for `xs` and `ys`.
 * 
 *   grlex order first compares the total degree of `xs` and `ys`, and falls back
 *   to [[lex-order]] in case of a tie. See [[lex-order]] for details on this
 *   case.
 */
sicmutils.polynomial.exponent.graded_lex_order = (function sicmutils$polynomial$exponent$graded_lex_order(xs,ys){
var xd = sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$1(xs);
var yd = sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$1(ys);
if(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(xd,yd)){
return sicmutils.polynomial.exponent.lex_order(xs,ys);
} else {
return (xd - yd);
}
});
/**
 * Comparator that responds based on the [graded reverse lexicographic
 *   order](https://en.wikipedia.org/wiki/Monomial_order#Graded_reverse_lexicographic_order),
 *   or 'grevlex order', of the exponent vectors `xs` and `ys`. Accepts any
 *   sequence of pairs of the form `[variable, power]` for `xs` and `ys`.
 * 
 *   grevlex order first compares the total degree of `xs` and `ys`, and falls back
 *   to reverse [[lex-order]] in case of a tie. Reverse here means two things:
 * 
 *   1. the variables are considered in reverse order; the variable with the
 *   largest index is compared first, then the next-largest, and on down the line.
 *   2. The _smaller_ exponent is grevlex-greater in this comparison.
 */
sicmutils.polynomial.exponent.graded_reverse_lex_order = (function sicmutils$polynomial$exponent$graded_reverse_lex_order(xs,ys){
var xd = sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$1(xs);
var yd = sicmutils.polynomial.exponent.monomial_degree.cljs$core$IFn$_invoke$arity$1(ys);
if(cljs.core._EQ_.cljs$core$IFn$_invoke$arity$2(xd,yd)){
return sicmutils.polynomial.exponent.lex_order.cljs$core$IFn$_invoke$arity$variadic(xs,ys,cljs.core.prim_seq.cljs$core$IFn$_invoke$arity$2([new cljs.core.Keyword(null,"reverse?","reverse?",-1672868474),true], 0));
} else {
return (xd - yd);
}
});

//# sourceMappingURL=sicmutils.polynomial.exponent.js.map
