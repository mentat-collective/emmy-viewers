{"version":3,"sources":["sicmutils/numerical/quadrature/midpoint.cljc"],"mappings":";AA2CA,0DAAA,1DAAeA,4HAAiBC,EAAEC,EAAEC;AAApC,AACE,IAAMC,QAAW,AAACC,kDAAIF,EAAED;IAClBI,aAAW,8DAAA,9DAACC,wDAAIH;IAChBI,WAAW,AAACC,uDAAIP,EAAEI;AAFxB,AAGE,OAACI,uDAAIN,MAAM,CAACH,kCAAAA,4CAAAA,ZAAEO,wBAAAA;;AAIlB,6DAAA,7DAAOG,kIAAeV,EAAEC,EAAEC;AAA1B,AACE,IAAMS,UAAQ,AAACC,gDAAQb,wDAAgBC;AAAvC,AACE,OAACa,oDAAgBF,QAAQV,EAAEC;;AAI/B,AAcA,AAyCA,qDAAA,rDAAOY,kHAASd,EAAEC,EAAEC;AAApB,AACE,IAAMC,QAAM,CAAGD,IAAED;AAAjB,AACE,kBAAKc,GAAGC;AAAR,AACE,IAAMC,IAAS,CAAGd,QAAMa;IAClBE,QAAS,KAAA,JAAGD;IACZE,WAAS,CAAGlB,IAAEiB;IACdE,WAAS,CAAGnB,IAAE,CAAA,MAAKiB;IACnBG,KAAG,WAAKC;AAAL,AACE,IAAMC,KAAG,CAAGD,IAAEL;AAAd,AACE,QAAG,iBAAAO,YAAG,CAAGL,WAASI;AAAf,AAAA,0EAAAC,yBAAAA,3FAACxB,kCAAAA,6CAAAA;OACD,iBAAAyB,YAAG,CAAGL,WAASG;AAAf,AAAA,0EAAAE,yBAAAA,3FAACzB,kCAAAA,6CAAAA;;;AAPjB,QAQM,CAAGe,KAAG,CAAGE,IAAE,8DAAA,9DAACS,2DAAOL,OAAKL,rFACxB,4FAAA;;;AAOZ,AAAA;;;;;;;;;;;;;;;;4DAAA,oEAAAW,hIAAME;AAAN,AAAA,IAAAD,YAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,wFAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,wFAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,0FAAA,1FAAMD,qGAeF7B,EAAEC,EAAEC;AAfR,AAeW,qGAAA,2CAAA,8CAAA,vLAACiC,wFAAkBnC,EAAEC,EAAEC;;;AAflC,CAAA,0FAAA,iBAAA6B,3GAAMF,qGAgBF7B,EAAEC,EAAEC;AAhBR,AAAA,IAAA8B,cAAAD;IAAAC,kBAAA,AAAAC,4BAAAD;QAAA,AAAAE,4CAAAF,gBAAA,8CAAA,9GAgBkBhB;wBAhBlB,AAAAkB,4CAAAF,gBAAA,hFAgBoBI;AAhBpB,AAiBG,IAAMC,IAAO,AAACC,oDAAgBtC,EAAEC,EAAEC;IAC5BqC,SAAO,AAACzB,mDAAQd,EAAEC,EAAEC;IACpBsC,KAAO,+DAAA,/DAACC,sDAAkBJ,EAAEE,WAASvB;AAF3C,AAGE,oBAAI,iBAAA0B,oBAAKN;AAAL,AAAA,oBAAAM;AAAiB,cAAS1B;;AAA1B0B;;;AACF,4FAAA,IAAA,IAAA,7FAACC,kFAAuBH;;AACxBA;;;;AAtBP,CAAA,oFAAA,pFAAMX;;AAAN,AA6BA,AAyCA;;;;;;;;;;AAAAe,mDAAA,AAAAC,yDASW9C,wDACD8B","names":["sicmutils.numerical.quadrature.midpoint/single-midpoint","f","a","b","width","sicmutils.generic._","half-width","sicmutils.generic._SLASH_","midpoint","sicmutils.generic._PLUS_","sicmutils.generic._STAR_","sicmutils.numerical.quadrature.midpoint/midpoint-sum*","area-fn","cljs.core.partial","sicmutils.numerical.quadrature.riemann/windowed-sum","sicmutils.numerical.quadrature.midpoint/Sn->S3n","Sn","n","h","delta","l-offset","r-offset","fx","i","ih","G__102577","G__102578","sicmutils.util.aggregate.sum","var_args","G__102580","sicmutils.numerical.quadrature.midpoint/midpoint-sequence","js/Error","p__102586","map__102587","cljs.core/--destructure-map","cljs.core.get","sicmutils.numerical.quadrature.midpoint.midpoint_sequence","accelerate?","S","sicmutils.numerical.quadrature.riemann/midpoint-sum","next-S","xs","sicmutils.numerical.quadrature.riemann/incrementalize","and__4251__auto__","sicmutils.polynomial.richardson.richardson_sequence","sicmutils.numerical.quadrature.midpoint/integral","sicmutils.numerical.quadrature.common/make-integrator-fn"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature.midpoint\n  (:require [sicmutils.generic :as g]\n            [sicmutils.numerical.quadrature.common :as qc :include-macros true]\n            [sicmutils.numerical.quadrature.riemann :as qr]\n            [sicmutils.polynomial.richardson :as pr]\n            [sicmutils.util :as u]\n            [sicmutils.util.aggregate :as ua]))\n\n;; ## Midpoint Method\n;;\n;; This namespace builds on the ideas introduced in `riemann.cljc`.\n;;\n;; `riemann.cljc` described four different integration schemes ({left, right,\n;; upper, lower} Riemann sums) that were each conceptually simple, but aren't\n;; often used in practice, even in their \"accelerated\" forms.\n;;\n;; One reason for this is that their error terms fall off as $h, h^2, h^3$,\n;; where $h$ is the width of an integration slice. Each order of sequence\n;; acceleration can cancel out one of these terms at a time; but still, the\n;; performance is not great.\n;;\n;; It turns out that by taking the /midpoint/ if each interval, instead of\n;; either side, you can reduce the order of the error series to $O(h^2)$. This\n;; is too good to pass up.\n;;\n;; Additionally, because the error terms fall off as $h^2, h^4, h^6, ...$, each\n;; order of acceleration is worth quite a bit more than in the Riemann sum case.\n;;\n;; This namespace follows the same development as `riemann.cljc`:\n;;\n;; - implement a simple, easy-to-understand version of the Midpoint method\n;; - make the computation more efficient\n;; - write an incremental version that can reuse prior results\n;; - wrap everything up behind a nice, exposed API\n;;\n;;\n;; ## Simple Midpoint Rule\n;;\n;; Here's an implementation of a function that can take the midpoint of a single\n;; slice:\n\n(defn ^:no-doc single-midpoint [f a b]\n  (let [width      (g/- b a)\n        half-width (g// width 2)\n        midpoint   (g/+ a half-width)]\n    (g/* width (f midpoint))))\n\n;; And a full (though inefficient) integrator using `windowed-sum`:\n\n(defn- midpoint-sum* [f a b]\n  (let [area-fn (partial single-midpoint f)]\n    (qr/windowed-sum area-fn a b)))\n\n;; Let's integrate a triangle!\n\n(comment\n  (= (* 0.5 10 10)\n     ((midpoint-sum* identity 0.0 10.0) 10)))\n;; => true\n\n;; ## Efficient Midpoint Method\n;;\n;; It turns out that we already had to implement an efficient version of\n;; `midpoint-sum` in `riemann.cljc`; the incremental version of left and right\n;; Riemann sums added the midpoints of each interval when doubling the number of\n;; slices.\n;;\n;; We can check our implementation against `qr/midpoint-sum`:\n\n(comment\n  (= ((midpoint-sum* identity 0.0 100.0) 10)\n     ((qr/midpoint-sum identity 0.0 100.0) 10)))\n\n;; We'll use `qr/midpoint-sum` in the upcoming functions.\n\n;; ## Incremental Midpoint Method\n;;\n;; Unlike the left and right Riemann sums, the Midpoint method can't reuse\n;; function evaluations when the number of slices doubles. This is because each\n;; evaluation point, on a doubling, becomes the new border between slices:\n;;\n;; n = 1 |-------x-------|\n;; n = 2 |---x---|---x---|\n;;\n;; If you /triple/ the number of slices from $n$ to $3n$, you can in fact reuse\n;; the previous $n$ evaluations:\n;;\n;; n = 1 |--------x--------|\n;; n = 3 |--x--|--x--|--x--|\n;;\n;; By scaling Sn down by a factor of 3, and adding it to a new sum that only\n;; includes the new points (using the new slice width).\n;;\n;; BTW: The only place I found this idea mentioned is in Section 4.4 of\n;; Press's [\"Numerical\n;; Recipes\"](http://phys.uri.edu/nigh/NumRec/bookfpdf/f4-4.pdf). I haven't found\n;; other references to this trick, or implementations. I'd love to hear about\n;; them (via a Github issue) if you find any!\n;;\n;; We'll follow the interface we used for `qr/Sn->S2n` and write `Sn->S3n`. This\n;; function of $f, a, b$ will return a function that performs the incremental\n;; update.\n;;\n;; The returned function generates $S3n$ across $(a, b)$ with $n$ intervals, and\n;; picking out two new points at $h \\over 6$ and $5h \\over 6$ of the way across\n;; the old interval. These are the midpoints of the two new slices with width $h\n;; \\over 3$.\n;;\n;; Sum them all up and add them to $S_n \\over 3$ to generate $S_{3n}$:\n\n(defn- Sn->S3n [f a b]\n  (let [width (- b a)]\n    (fn [Sn n]\n      (let [h        (/ width n)\n            delta    (/ h 6)\n            l-offset (+ a delta)\n            r-offset (+ a (* 5 delta))\n            fx (fn [i]\n                 (let [ih (* i h)]\n                   (+ (f (+ l-offset ih))\n                      (f (+ r-offset ih)))))]\n        (-> (+ Sn (* h (ua/sum fx 0 n)))\n            (/ 3.0))))))\n\n;; Now we can write `midpoint-sequence`, analogous to `qr/left-sequence`. This\n;; implementation reuses all the tricks from `qr/incrementalize`; this means it\n;; will be smart about using the new incremental logic any time it sees any $n$\n;; multiple of 3, just as the docstring describes.\n\n(defn midpoint-sequence\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the open interval $(a, b)$ using the Midpoint method.\n\n  ### Optional arguments:\n\n  `:n`: If `:n` is a number, returns estimates with $n, 3n, 9n, ...$ slices,\n  geometrically increasing by a factor of 3 with each estimate.\n\n  If `:n` is a sequence, the resulting sequence will hold an estimate for each\n  integer number of slices in that sequence.\n\n  `:accelerate?`: if supplied (and `n` is a number), attempts to accelerate\n  convergence using Richardson extrapolation. If `n` is a sequence this option\n  is ignored.\"\n  ([f a b] (midpoint-sequence f a b {:n 1}))\n  ([f a b {:keys [n accelerate?] :or {n 1}}]\n   (let [S      (qr/midpoint-sum f a b)\n         next-S (Sn->S3n f a b)\n         xs     (qr/incrementalize S next-S 3 n)]\n     (if (and accelerate? (number? n))\n       (pr/richardson-sequence xs 3 2 2)\n       xs))))\n\n;; The following example shows that for the sequence $2, 3, 4, 6, ...$ (used in\n;; the Bulirsch-Stoer method!), the incrementally-augmented `midpoint-sequence`\n;; only performs 253 function evaluations, vs the 315 of the non-incremental\n;; `(midpoint-sum f2 0 1)` mapped across the points.\n\n(comment\n  (let [f (fn [x] (/ 4 (+ 1 (* x x))))\n        [counter1 f1] (u/counted f)\n        [counter2 f2] (u/counted f)\n        n-seq (interleave\n               (iterate (fn [x] (* 2 x)) 2)\n               (iterate (fn [x] (* 2 x)) 3))]\n    (dorun (take 12 (midpoint-sequence f1 0 1 {:n n-seq})))\n    (dorun (take 12 (map (qr/midpoint-sum f2 0 1) n-seq)))\n    (= [253 315]\n       [@counter1 @counter2])))\n\n;; ## Final Midpoint API\n;;\n;; The final version is analogous the `qr/left-integral` and friends, including\n;; an option to `:accelerate?` the final sequence with Richardson extrapolation.\n;;\n;; I'm not sure what to call this accelerated method. Accelerating the trapezoid\n;; method in this way is called \"Romberg integration\". Using an $n$ sequence of\n;; powers of 2 and accelerating the midpoint method by a single step - taking\n;; the second column (index 1) of the Richardson tableau - produces \"Milne's\n;; method\".\n;;\n;; The ability to combine these methods makes it easy to produce powerful\n;; methods without known names. Beware, and enjoy!\n;;\n;; ### Note on Richardson Extrapolation\n;;\n;; We noted above that the the terms of the error series for the midpoint method\n;; increase as $h^2, h^4, h^6$... Because of this, we pass $p = q = 2$ into\n;; `pr/richardson-sequence` below. Additionally, `integral` hardcodes the factor\n;; of `3` and doesn't currently allow for a custom sequence of $n$. This\n;; requires passing $t = 3$ into `pr/richardson-sequence`.\n;;\n;; If you want to accelerate some other geometric sequence, call\n;; `pr/richardson-sequence` with some other value of `t.`\n;;\n;; To accelerate an arbitrary sequence of midpoint evaluations, investigate\n;; `polynomial.cljc` or `rational.cljc`. The \"Bulirsch-Stoer\" method uses either\n;; of these to extrapolate the midpoint method using a non-geometric sequence.\n\n(qc/defintegrator integral\n  \"Returns an estimate of the integral of `f` over the open interval $(a, b)$\n  using the Midpoint method with $1, 3, 9 ... 3^n$ windows for each estimate.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See [[midpoint-sequence]] for information on the optional args in `opts` that\n  customize this function's behavior.\"\n  :area-fn single-midpoint\n  :seq-fn midpoint-sequence)\n\n;; ## Next Steps\n;;\n;; If you start with the midpoint method, one single step of Richardson\n;; extrapolation (taking the second column of the Richardson tableau) is\n;; equivalent to \"Milne's rule\" (see `milne.cljc`).\n;;\n;; The full Richardson-accelerated Midpoint method is an open-interval variant\n;; of \"Romberg integration\" (see `romberg.cljc`).\n;;\n;; See the wikipedia entry on [Open Newton-Cotes\n;; Formulas](https://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas#Open_Newton%E2%80%93Cotes_formulas)\n;; for more details.\n"]}