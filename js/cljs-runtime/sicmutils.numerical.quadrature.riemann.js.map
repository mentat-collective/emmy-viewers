{"version":3,"sources":["sicmutils/numerical/quadrature/riemann.cljc"],"mappings":"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","names":["sicmutils.numerical.quadrature.riemann/windowed-sum","area-fn","a","b","n","width","grid-points","cljs.core.concat","cljs.core.range","sicmutils.util.aggregate.sum","cljs.core.map","cljs.core/rest","sicmutils.numerical.quadrature.riemann/left-sum*","f","l","r","sicmutils.numerical.quadrature.riemann/left-sum","h","fx","i","G__90341","sicmutils.numerical.quadrature.riemann/right-sum*","sicmutils.numerical.quadrature.riemann/right-sum","start","G__90345","sicmutils.numerical.quadrature.riemann/upper-sum","x__4336__auto__","y__4337__auto__","sicmutils.numerical.quadrature.riemann/lower-sum","x__4339__auto__","y__4340__auto__","p__90351","map__90352","cljs.core/--destructure-map","cljs.core.get","sicmutils.numerical.quadrature.riemann/accelerate","estimate-seq","accelerate?","and__4251__auto__","sicmutils.polynomial.richardson.richardson_sequence","sicmutils.numerical.quadrature.riemann/midpoint-sum","offset","G__90358","sicmutils.numerical.quadrature.riemann/Sn->S2n","midpoints","Sn","sicmutils.numerical.quadrature.riemann/left-sequence*","n0","first-S","steps","sicmutils.util.stream.powers","cljs.core.reductions","sicmutils.numerical.quadrature.riemann/geometric-estimate-seq","S-fn","next-S-fn","factor","var_args","G__90366","sicmutils.numerical.quadrature.riemann/left-sequence**","js/Error","sicmutils.numerical.quadrature.riemann.left_sequence_STAR__STAR_","sicmutils.numerical.quadrature.riemann/general-estimate-seq","n-seq","p__90371","vec__90372","cljs.core.nth","cache","_","cljs.core/rem","prev","cljs.core/quot","temp__5751__auto__","S-prev","cljs.core.assoc","cljs.core/second","sicmutils.numerical.quadrature.riemann/incrementalize","G__90376","sicmutils.numerical.quadrature.riemann/left-sequence","sicmutils.numerical.quadrature.riemann.left_sequence","opts","S","next-S","G__90378","sicmutils.numerical.quadrature.riemann/right-sequence","sicmutils.numerical.quadrature.riemann.right_sequence","G__90380","sicmutils.numerical.quadrature.riemann/lower-sequence","p__90381","map__90382","sicmutils.numerical.quadrature.riemann.lower_sequence","G__90385","sicmutils.numerical.quadrature.riemann/upper-sequence","p__90386","map__90388","sicmutils.numerical.quadrature.riemann.upper_sequence","sicmutils.numerical.quadrature.riemann/left-integral","sicmutils.numerical.quadrature.common/make-integrator-fn","sicmutils.numerical.quadrature.riemann/right-integral","sicmutils.numerical.quadrature.riemann/lower-integral","sicmutils.numerical.quadrature.riemann/upper-integral"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature.riemann\n  (:require [sicmutils.numerical.quadrature.common :as qc :include-macros true]\n            [sicmutils.polynomial.richardson :as pr]\n            [sicmutils.util.aggregate :as ua]\n            [sicmutils.util.stream :as us]))\n\n;; Riemann Quadrature\n;;\n;; This namespace includes functions for calculating the Riemann integral of a\n;; single-variable function. These are probably /not/ methods that you'll want\n;; to use; see the documentation and defaults in\n;; `sicmutils.numerical.quadrature` for good recommendations. But they're clear\n;; and understandable. The goal of this namespace is to lay the groundwork for\n;; visualizable routines that you can use to step toward understanding of the\n;; tougher methods.\n;;\n;; [\"Quadrature\"](https://en.wikipedia.org/wiki/Numerical_integration), in this\n;; context, means \"numerical integration\". The word is a historical term for\n;; calculating the area inside of some geometry shape. [Riemann\n;; sums](https://en.wikipedia.org/wiki/Riemann_sum) are a group of methods for\n;; numerical integration that use this strategy:\n;;\n;; - partition the area under the curve of some function $f$ into $n$ \"slices\"\n;; - generate some area estimate for each slice\n;; - add up all of the slices to form an estimate of the integral\n;; - increase the number of slices, and stop when the estimate stops changing.\n;;\n;; The Riemann integral of a function $f$ is the limit of this process as $n \\to\n;; \\infty$.\n;;\n;; How do you estimate the area of a slice? All of these methods estimate the\n;; area by forming a rectangle. For the base, use $x_r - x_l$. For the height,\n;; you might use:\n;;\n;; - the function value at the left point, $f(x_l)$ (Left Riemann sum)\n;; - the right point, $f(x_r)$ (Right Riemann sum)\n;; - the max of either $max(f(x_l), f(x_r))$ (\"upper\" Riemann sum)\n;; - the minimum, $min(f(x_l), f(x_r))$, called the \"lower\" Riemann sums\n;; - the function value at the midpoint: $f({{x_l + x_r} \\over 2})$\n;;\n;; This namespace builds up to implementations for `left-integral`,\n;; `right-integral`, `upper-integral` and `lower-integral`. `midpoint.cljc`\n;; holds an implementation of the Midpoint method.\n;;\n;; A closely related method involves forming a trapezoid for each slice. This is\n;; equivalent to averaging the left and right Riemann sums. The trapezoid method\n;; lives in `trapezoid.cljc`.\n;;\n;; ## Riemann Sum Implementation\n;;\n;; We'll start with an inefficient-but-easily-understandable version of these\n;; methods. To form a Riemann sum we need to:\n;;\n;; - partition some range $[a, b]$ into `n` slices\n;; - call some area-generating function on each slice\n;;-  add all of the resulting area estimates together\n;;\n;; `windowed-sum` implements this pattern:\n\n(defn windowed-sum\n  \"Takes:\n\n  - `area-fn`, a function of the left and right endpoints of some integration\n  slice\n  - definite integration bounds `a` and `b`\n\n  and returns a function of `n`, the number of slices to use for an integration\n  estimate.\n\n  `area-fn` should return an estimate of the area under some curve between the\n  `l` and `r` bounds it receives.\"\n  [area-fn a b]\n  (fn [n]\n    (let [width       (/ (- b a) n)\n          grid-points (concat (range a b width) [b])]\n      (ua/sum\n       (map area-fn grid-points (rest grid-points))))))\n\n;; Test this out with a function that returns `2` for every slice, and we get\n;; back an estimate (from the function returned by `windowed-sum`) of 2x the\n;; number of slices:\n\n(comment\n  (let [area-fn   (fn [_ _] 2)\n        estimator (windowed-sum area-fn 0 10)]\n    (and (= 20.0 (estimator 10))\n         (= 40.0 (estimator 20)))))\n;; => true\n\n;; Now, let's implement the four classic [\"Riemann\n;; Integral\"](https://en.wikipedia.org/wiki/Riemann_integral) methods.\n;;\n;; Let's say we want to integrate a function $f$. The left and right Riemann\n;; sums estimate a slice's area as a rectangle with:\n;;\n;; - width == $x_r - x_l$, and\n;; - height == $f(x_l)$ or $f(x_r)$, respectively.\n;;\n;; `left-sum` is simple to implement, given `windowed-sum`:\n\n#_{:clj-kondo/ignore [:unused-private-var]}\n(defn- left-sum* [f a b]\n  (-> (fn [l r] (* (f l) (- r l)))\n      (windowed-sum a b)))\n\n;; Every internal slice has the same width, so we can make the sum slightly more\n;; efficient by pulling out the constant and multiplying by it a single time.\n;;\n;; Internally, we also generate all of the internal \"left\" points directly from\n;; the slice index, instead of pre-partitioning the range. This is fine since we\n;; don't need $x_r$.\n\n(defn- left-sum\n  \"Returns a function of `n`, some number of slices of the total integration\n  range, that returns an estimate for the definite integral of $f$ over the\n  range $[a, b)$ using a left Riemann sum.\"\n  [f a b]\n  (let [width (- b a)]\n    (fn [n]\n      (let [h  (/ width n)\n            fx (fn [i] (f (+ a (* i h))))]\n        (* h (ua/sum fx 0 n))))))\n\n;; `right-sum` is almost identical, except that it uses $f(x_r)$ as the\n;; estimate of each rectangle's height:\n\n#_{:clj-kondo/ignore [:unused-private-var]}\n(defn- right-sum* [f a b]\n  (-> (fn [l r] (* (f r) (- r l)))\n      (windowed-sum a b)))\n\n;; Same trick here to get a more efficient version. This implementation also\n;; generates an internal function `fx` of the window index. The only difference\n;; from the `left-sum` implementation is an initial offset of `h`, pushing every\n;; point to the right side of the window.\n\n(defn- right-sum\n  \"Returns a function of `n`, some number of slices of the total integration\n  range, that returns an estimate for the definite integral of $f$ over the\n  range $(a, b]$ using a right Riemann sum.\"\n  [f a b]\n  (let [width (- b a)]\n    (fn [n]\n      (let [h     (/ width n)\n            start (+ a h)\n            fx    (fn [i] (f (+ start (* i h))))]\n        (* h (ua/sum fx 0 n))))))\n\n;; The upper Riemann sum generates a slice estimate by taking the maximum of\n;; $f(x_l)$ and $f(x_r)$:\n\n(defn- upper-sum\n  \"Returns an estimate for the definite integral of $f$ over the range $[a, b]$\n  using an upper Riemann sum.\n\n  This function may or may not make an evaluation at the endpoints $a$ or $b$,\n  depending on whether or not the function is increasing or decreasing at the\n  endpoints.\"\n  [f a b]\n  (-> (fn [l r] (* (- r l)\n                  (max (f l) (f r))))\n      (windowed-sum a b)))\n\n;; Similarly, the lower Riemann sum uses the /minimum/ of $f(x_l)$ and $f(x_r)$:\n\n(defn- lower-sum\n  \"Returns an estimate for the definite integral of $f$ over the range $[a, b]$\n  using a lower Riemann sum.\n\n  This function may or may not make an evaluation at the endpoints $a$ or $b$,\n  depending on whether or not the function is increasing or decreasing at the\n  endpoints.\"\n  [f a b]\n  (-> (fn [l r] (* (- r l)\n                  (min (f l) (f r))))\n      (windowed-sum a b)))\n\n;; ## Estimating Integrals with Riemann Sums\n;;\n;; Given the tools above, let's attempt to estimate the integral of $f(x) = x^2$\n;; using the left and right Riemann sum methods. (The actual equation for the\n;; integral is $x^3 \\over 3$).\n;;\n;; The functions above return functions of `n`, the number of slices. We can\n;; use `(us/powers 2)` to return a sequence of `(1, 2, 4, 8, ...)` and map the\n;; function of `n` across this sequence to obtain successively better estimates\n;; for $\\int_0^{10} x^2$. The true value is $10^3 \\over 3 = 333.333...$:\n\n(comment\n  (let [f              (fn [x] (* x x))\n        left-estimates  (map (left-sum f 0 10)\n                             (us/powers 2))\n        right-estimates (map (right-sum f 0 10)\n                             (us/powers 2))]\n    (and (= [0.0 125.0 218.75 273.4375 302.734375]\n            (take 5 left-estimates))\n\n         (= [1000.0 625.0 468.75 398.4375 365.234375]\n            (take 5 right-estimates)))))\n\n;; Both estimates are bad at 32 slices and don't seem to be getting better. Even\n;; up to $2^16 = 65,536$ slices we haven't converged, and are still far from the\n;; true estimate:\n\n(comment\n  (= {:converged? false\n      :terms-checked 16\n      :result 333.31807469949126}\n     (let [f (fn [x] (* x x))]\n       (-> (map (left-sum f 0 10)\n                (us/powers 2))\n           (us/seq-limit {:maxterms 16})))))\n\n;; This bad convergence behavior is why common wisdom states that you should\n;; never use left and right Riemann sums for real work.\n;;\n;; But maybe we can do better.\n;;\n;;\n;; ## Sequence Acceleration\n;;\n;; One answer to this problem is to use \"sequence acceleration\" via Richardson\n;; extrapolation, as described in `richardson.cljc`.\n;;\n;; `pr/richardson-sequence` takes a sequence of estimates of some function\n;; and \"accelerates\" the sequence by combining successive estimates.\n;;\n;; The estimates have to be functions of some parameter $n$ that decreases by a\n;; factor of $t$ for each new element. In the example above, $n$ doubles each\n;; time; this is equivalent to thinking about the window width $h$ halving each\n;; time, so $t = 2$.\n;;\n;; This library's functional style lets us accelerate a sequence of estimates\n;; `xs` by simply wrapping it in a call to `(pr/richardson-sequence xs 2)`.\n;; Amazing!\n;;\n;; Does Richardson extrapolation help?\n\n(comment\n  (= {:converged? true\n      :terms-checked 4\n      :result 333.3333333333333}\n\n     (let [f (fn [x] (* x x))]\n       (-> (map (left-sum f 0 10)\n                (us/powers 2))\n           (pr/richardson-sequence 2)\n           (us/seq-limit)))))\n\n;; We now converge to the actual, true value of the integral in 4 terms!\n;;\n;; This is going to be useful for each of our Riemann sums, so let's make a\n;; function that can accelerate a generic sequence of estimates. The following\n;; function takes:\n;;\n;; - the sequence of estimates, `estimate-seq`\n;; - a dictionary of \"options\"\n;;\n;; This library is going to adopt an interface that allows the user to configure\n;; a potentially very complex integration function by sending a single\n;; dictionary of options down to each of its layers. Adopting that style now is\n;; going to allow this function to grow to accomodate other methods of sequence\n;; acceleration, like polynomial or rational function extrapolation.\n;;\n;; For now, `{:accelerate? true}` configures Richardson extrapolation iff the\n;; user hasn't specified a custom sequence of integration slices using the `:n`\n;; option.\n\n(defn- accelerate\n  \"NOTE - this is only appropriate for Richardson-accelerating sequences with t=2,\n  p=q=1.\n\n  This only applies to the Riemann sequences in this namespace!\"\n  [estimate-seq {:keys [n accelerate?] :or {n 1}}]\n  (if (and accelerate? (number? n))\n    (pr/richardson-sequence estimate-seq 2 1 1)\n    estimate-seq))\n\n;; Check that this works:\n\n(comment\n  (= {:converged? true\n      :terms-checked 4\n      :result 333.3333333333333}\n\n     (let [f (fn [x] (* x x))]\n       (-> (map (left-sum f 0 10)\n                (us/powers 2))\n           (accelerate {:accelerate? true})\n           (us/seq-limit)))))\n\n;; Excellent!\n;;\n;; ## Incremental Computation\n;;\n;; The results look quite nice; but notice how much redundant computation we're\n;; doing.\n;;\n;; Consider the evaluation points of a left Riemann sum with 4 slices, next to a\n;; left sum with 8 slices:\n;;\n;; x---x---x---x----\n;; x-x-x-x-x-x-x-x--\n;;\n;; Every time we double our number of number of evaluations, half of the windows\n;; share a left endpoint. The same is true for a right sum:\n;;\n;; ----x---x---x---x\n;; --x-x-x-x-x-x-x-x\n;;\n;; In both cases, the new points are simply the /midpoints/ of the existing\n;; slices.\n;;\n;; This suggests a strategy for incrementally updating a left or right Riemann\n;; sum when doubling the number of points:\n;;\n;; - Generate a new midpoint estimate of each `n` slices\n;; - Add this estimate to the previous estimate\n;; - Divide the sum by `2` to scale each NEW slice width down by 2 (since we're\n;;   doubling the number of slices)\n;;\n;; First, implement `midpoint-sum`. This is very close to the implementation for\n;; `left-sum`; internally the function adds an offset of $h \\over 2$ to each\n;; slice before sampling its function value.\n\n(defn midpoint-sum\n  \"Returns a function of `n`, some number of slices of the total integration\n  range, that returns an estimate for the definite integral of $f$ over the\n  range $(a, b)$ using midpoint estimates.\"\n  [f a b]\n  (let [width (- b a)]\n    (fn [n]\n      (let [h      (/ width n)\n            offset (+ a (/ h 2.0))\n            fx     (fn [i] (f (+ offset (* i h))))]\n        (* h (ua/sum fx 0 n))))))\n\n;; The next function returns a function that can perform the incremental update\n;; to a left or right Riemann sum (and to a midpoint method estimate, as we'll\n;; see in `midpoint.cljc`):\n\n(defn Sn->S2n\n  \"Returns a function of:\n\n  - `Sn`: a sum estimate for `n` partitions, and\n  - `n`: the number of partitions\n\n  And returns a new estimate for $S_{2n}$ by sampling the midpoints of each\n  slice. This incremental update rule is valid for left and right Riemann sums,\n  as well as the midpoint method.\"\n  [f a b]\n  (let [midpoints (midpoint-sum f a b)]\n    (fn [Sn n]\n      (-> (+ Sn (midpoints n))\n          (/ 2.0)))))\n\n;; After using `left-sum` to generate an initial estimate, we can use `Sn->S2n`\n;; to generate all successive estimates, as long as we always double our slices.\n;; This suggests a function that takes an initial number of slices, `n0`, and\n;; then uses `reductions` to scan across `(us/powers 2 n0)` with the function\n;; returned by `Sn->S2n`:\n\n(defn- left-sequence* [f a b n0]\n  (let [first-S ((left-sum f a b) n0)\n        steps   (us/powers 2 n0)]\n    (reductions (Sn->S2n f a b) first-S steps)))\n\n;; Verify that this function returns an equivalent sequence of estimates to the\n;; non-incremental `left-sum`, when mapped across powers of 2:\n\n(comment\n  (let [f (fn [x] (* x x))]\n    (= (take 10 (left-sequence* f 0 10 1))\n       (take 10 (map (left-sum f 0 10)\n                     (us/powers 2 1))))))\n\n;; ## Generalizing the Incremental Approach\n;;\n;; We need to use the same style for `right-sum`, so let's try and extract the\n;; pattern above, of:\n;;\n;; - generating an initial estimate of `n0` slices using some function `S-fn`\n;; - refining an estimate of `n0` slices => `n0 / 2` slices using some\n;;   incremental updater, `next-S-fn`\n;;\n;; In fact, because methods like the Midpoint method from `midpoint.cljc` can\n;; only incrementally update from `n` => `n/3`, let's make the factor general\n;; too.\n;;\n;; `geometric-estimate-seq` captures the pattern above:\n\n(defn geometric-estimate-seq\n  \"Accepts:\n\n  - `S-fn`: a function of `n` that generates a numerical integral estimate from\n  `n` slices of some region, and\n  - `next-S-fn`: a function of (previous estimate, previous `n`) => new estimate\n  - `factor`: the factor by which `n` increases for successive estimates\n  - `n0`: the initial `n` to pass to `S-fn`\n\n  The new estimate returned b `next-S-fn` should be of `factor * n` slices.\"\n  [S-fn next-S-fn factor n0]\n  (let [first-S (S-fn n0)\n        steps   (us/powers factor n0)]\n    (reductions next-S-fn first-S steps)))\n\n;; And another version of `left-sequence`, implemented using the new function:\n\n#_{:clj-kondo/ignore [:unused-private-var]}\n(defn- left-sequence**\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the closed-open interval $a, b$ by taking left-Riemann sums with\n\n  n0, 2n0, 4n0, ...\n\n  slices.\"\n  ([f a b] (left-sequence** f a b 1))\n  ([f a b n0]\n   (geometric-estimate-seq (left-sum f a b)\n                           (Sn->S2n f a b)\n                           2\n                           n0)))\n\n;; ## Incremental Updates with Any Sequence\n;;\n;; What if we want to combine the ability to reuse old results with the ability\n;; to take successively refined estimates that /don't/ look like geometric\n;; series? The series 1, 2, 3... of natural numbers is an obvious choice of\n;; windows... but only the even powers are able to reuse estimates.\n;;\n;; Integration methods like the Bulirsch-Stoer approach depend on sequences like\n;; 2, 3, 4, 6...\n;;\n;; We absolutely want to be able to save potentially-expensive function\n;; evaluations.\n;;\n;; One way to do this is to memoize the function `f` that you pass in to any of\n;; the methods above.\n;;\n;; Alternatively, we could implement a version of `geometric-estimate-seq` that\n;; takes /any/ sequence of estimate,s and maintains a sort of internal\n;; memoization cache.\n;;\n;; For every `n`, check the cache for `prev == n/factor`. If it exists in the\n;; cache, use `next-S-fn`; else, use `S-fn`, just like we did in\n;; `geometric-estimate-seq` for the initial value.\n;;\n;; `general-estimate-seq` does this:\n\n(defn- general-estimate-seq\n  \"Accepts:\n\n  - `S-fn`: a function of `n` that generates a numerical integral estimate from\n  `n` slices of some region, and\n  - `next-S-fn`: a function of (previous estimate, previous `n`) => new estimate\n  - `factor`: the factor by which `next-S-fn` increases `n` in its returned estimate\n  - `n-seq`: a monotonically increasing sequence of `n` slices to use.\n\n  Returns a sequence of estimates of returned by either function for each `n` in\n  `n-seq`. Internally decides whether or not to use `S-fn` or `next-S-fn` to\n  generate successive estimates.\"\n  [S-fn next-S-fn factor n-seq]\n  (let [f (fn [[cache _] n]\n            (let [Sn (if (zero? (rem n factor))\n                       (let [prev (quot n factor)]\n                         (if-let [S-prev (get cache prev)]\n                           (next-S-fn S-prev prev)\n                           (S-fn n)))\n                       (S-fn n))]\n              [(assoc cache n Sn) Sn]))]\n    (->> (reductions f [{} nil] n-seq)\n         (map second)\n         (rest))))\n\n;; We can combine `general-estimate-seq` and `geometric-estimate-seq` into a\n;; final method that decides which implementation to call, based on the type of\n;; the `n0` argument.\n;;\n;; If it's a number, use it as the `n0` seed for a geometrically increasing\n;; series of estimates. Else, assume it's a sequence and pass it to\n;; `general-estimate-seq`.\n\n(defn incrementalize\n  \"Function that generalizes the ability to create successively-refined estimates\n  of an integral, given:\n\n  - `S-fn`: a function of `n` that generates a numerical integral estimate from\n  `n` slices of some region, and\n  - `next-S-fn`: a function of (previous estimate, previous `n`) => new estimate\n  - `factor`: the factor by which `next-S-fn` increases `n` in its returned estimate\n  - `n`: EITHER a number, or a monotonically increasing sequence of `n` slices to use.\n\n  If `n` is a sequence, returns a (lazy) sequence of estimates generated for\n  each entry in `n`.\n\n  If `n` is a number, returns a lazy sequence of estimates generated for each\n  entry in a geometrically increasing series of inputs $n, n(factor),\n  n(factor^2), ....$\n\n  Internally decides whether or not to use `S-fn` or `next-S-fn` to generate\n  successive estimates.\"\n  [S-fn next-S-fn factor n]\n  (let [f (if (number? n)\n            geometric-estimate-seq\n            general-estimate-seq)]\n    (f S-fn next-S-fn factor n)))\n\n;; ## Final Incremental Implementations\n;;\n;; We can use `incrementalize` to write our final version of `left-sequence`,\n;; along with a matching version for `right-sequence`.\n;;\n;; Notice that we're using `accelerate` from above. The interface should make\n;; more sense now:\n\n(defn left-sequence\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the closed-open interval $a, b$ by taking left-Riemann sums.\n\n  ### Optional Arguments\n\n  `:n`: If `n` is a number, returns estimates with $n, 2n, 4n, ...$ slices,\n  geometrically increasing by a factor of 2 with each estimate.\n\n  If `n` is a sequence, the resulting sequence will hold an estimate for each\n  integer number of slices in that sequence.\n\n  `:accelerate?`: if supplied (and `n` is a number), attempts to accelerate\n  convergence using Richardson extrapolation. If `n` is a sequence this option\n  is ignored.\"\n  ([f a b] (left-sequence f a b {}))\n  ([f a b opts]\n   (let [S      (left-sum f a b)\n         next-S (Sn->S2n f a b)]\n     (-> (incrementalize S next-S 2 (:n opts 1))\n         (accelerate opts)))))\n\n(defn right-sequence\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the closed-open interval $a, b$ by taking right-Riemann sums.\n\n  ### Optional Arguments\n\n  `:n`: If `n` is a number, returns estimates with $n, 2n, 4n, ...$ slices,\n  geometrically increasing by a factor of 2 with each estimate.\n\n  If `n` is a sequence, the resulting sequence will hold an estimate for each\n  integer number of slices in that sequence.\n\n  `:accelerate?`: if supplied (and `n` is a number), attempts to accelerate\n  convergence using Richardson extrapolation. If `n` is a sequence this option\n  is ignored.\"\n  ([f a b] (right-sequence f a b {}))\n  ([f a b opts]\n   (let [S      (right-sum f a b)\n         next-S (Sn->S2n f a b)]\n     (-> (incrementalize S next-S 2 (:n opts 1))\n         (accelerate opts)))))\n\n;; `lower-sequence` and `upper-sequence` are similar. They can't take advantage\n;; of any incremental speedup, so we generate a sequence of `n`s internally and\n;; map `lower-sum` and `upper-sum` directly across these.\n\n(defn lower-sequence\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the closed interval $(a, b)$ by taking lower-Riemann sums.\n\n  ### Optional Arguments\n\n  `:n`: If `n` is a number, returns estimates with $n, 2n, 4n, ...$ slices,\n  geometrically increasing by a factor of 2 with each estimate.\n\n  If `n` is a sequence, the resulting sequence will hold an estimate for each\n  integer number of slices in that sequence.\n\n  `:accelerate?`: if supplied (and `n` is a number), attempts to accelerate\n  convergence using Richardson extrapolation. If `n` is a sequence this option\n  is ignored.\"\n  ([f a b] (lower-sequence f a b {}))\n  ([f a b {:keys [n] :or {n 1} :as opts}]\n   (let [n-seq (if (number? n)\n                 (us/powers 2 n)\n                 n)]\n     (-> (map (lower-sum f a b) n-seq)\n         (accelerate opts)))))\n\n(defn upper-sequence\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the closed interval $(a, b)$ by taking upper-Riemann sums.\n\n  ### Optional Arguments\n\n  `:n`: If `n` is a number, returns estimates with $n, 2n, 4n, ...$ slices,\n  geometrically increasing by a factor of 2 with each estimate.\n\n  If `n` is a sequence, the resulting sequence will hold an estimate for each\n  integer number of slices in that sequence.\n\n  `:accelerate?`: if supplied (and `n` is a number), attempts to accelerate\n  convergence using Richardson extrapolation. If `n` is a sequence this option\n  is ignored.\"\n  ([f a b] (upper-sequence f a b {}))\n  ([f a b {:keys [n] :or {n 1} :as opts}]\n   (let [n-seq (if (number? n)\n                 (us/powers 2 n)\n                 n)]\n     (-> (map (upper-sum f a b) n-seq)\n         (accelerate opts)))))\n\n;; ## Integral API\n;;\n;; Finally, we expose four API methods for each of the {left, right, lower,\n;; upper}-Riemann sums.\n;;\n;; Each of these makes use a special `qc/defintegrator` \"macro\"; This style\n;; allows us to adopt one final improvement. If the interval $a, b$ is below\n;; some threshold, the integral API will take a single slice using the supplied\n;; `:area-fn` below and not attempt to converge. See `common.cljc` for more\n;; details.\n;;\n;; These API interfaces are necessarily limiting. They force the assumptions\n;; that you:\n;;\n;; - only want to use geometrical sequences that start with n0 = 1\n;; - only want to (optionally) accelerate using Richardson extrapolation\n;;\n;; I can imagine a better API, where it's much easier to configure generic\n;; sequence acceleration! This will almost certainly show up in the library at\n;; some point. For now, here are some notes:\n;;\n;; - Richardson extrapolation requires a geometric series of estimates. If you\n;;   want to use some /other/ geometry series with `left-sequence` or\n;;   `right-sequence`, you can still accelerate with Richardson. Just pass your\n;;   new factor as `t`.\n;;\n;; - For each of {left, right, lower, upper}-Riemann sums, the order of the\n;;   error terms is 1, 2, 3, 4..., so always provide `p=1` and `q=1` to\n;;   `richardson-sequence`. `accelerate` does this above.\n;;\n;; - If you want to use some NON-geometric seq, you'll need to use the methods\n;;   in `polynomial.cljc` and `rational.cljc`, which are more general forms of\n;;   sequence acceleration that use polynomial or rational function\n;;   extrapolation. Your sequence of `xs` for each of those methods should be\n;;   `n-seq`.\n\n(qc/defintegrator left-integral\n  \"Returns an estimate of the integral of `f` across the closed-open interval $a,\n  b$ using a left-Riemann sum with $1, 2, 4 ... 2^n$ windows for each estimate.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See `left-sequence` for information on the optional args in `opts` that\n  customize this function's behavior.\"\n  :area-fn (fn [f a b] (* (f a) (- b a)))\n  :seq-fn left-sequence)\n\n(qc/defintegrator right-integral\n  \"Returns an estimate of the integral of `f` across the closed-open interval $a,\n  b$ using a right-Riemann sum with $1, 2, 4 ... 2^n$ windows for each estimate.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See `right-sequence` for information on the optional args in `opts` that\n  customize this function's behavior.\"\n  :area-fn (fn [f a b] (* (f b) (- b a)))\n  :seq-fn right-sequence)\n\n;; upper and lower Riemann sums have the same interface; internally, they're not\n;; able to take advantage of incremental summation, since it's not possible to\n;; know in advance whether or not the left or right side of the interval should\n;; get reused.\n\n(qc/defintegrator lower-integral\n  \"Returns an estimate of the integral of `f` across the closed-open interval $a,\n  b$ using a lower-Riemann sum with $1, 2, 4 ... 2^n$ windows for each estimate.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See `lower-sequence` for information on the optional args in `opts` that\n  customize this function's behavior.\"\n  :area-fn (fn [f a b] (* (min (f a) (f b)) (- b a)))\n  :seq-fn lower-sequence)\n\n(qc/defintegrator upper-integral\n  \"Returns an estimate of the integral of `f` across the closed-open interval $a,\n  b$ using an upper-Riemann sum with $1, 2, 4 ... 2^n$ windows for each estimate.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to `us/seq-limit` to configure convergence checking.\n\n  See `upper-sequence` for information on the optional args in `opts` that\n  customize this function's behavior.\"\n  :area-fn (fn [f a b] (* (max (f a) (f b)) (- b a)))\n  :seq-fn upper-sequence)\n\n;; ## Next Steps\n;;\n;; For a discussion and implementation of the more advanced methods (the\n;; workhorse methods that you should actually use!), see `midpoint.cljc` and\n;; `trapezoid.cljc`. The midpoint method is the standard choice for open\n;; intervals, where you can't evaluate the function at its endpoints. The\n;; trapezoid method is standard for closed intervals.\n"]}