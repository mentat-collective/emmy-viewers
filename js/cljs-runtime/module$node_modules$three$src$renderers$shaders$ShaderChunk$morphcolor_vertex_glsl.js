shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$morphcolor_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\n#if defined( USE_MORPHCOLORS ) \x26\x26 defined( MORPHTARGETS_TEXTURE )\n\n\t// morphTargetBaseInfluence is set based on BufferGeometry.morphTargetsRelative value:\n\t// When morphTargetsRelative is false, this is set to 1 - sum(influences); this results in normal \x3d sum((target - base) * influence)\n\t// When morphTargetsRelative is true, this is set to 1; as a result, all morph targets are simply added to the base after weighting\n\tvColor *\x3d morphTargetBaseInfluence;\n\n\tfor ( int i \x3d 0; i \x3c MORPHTARGETS_COUNT; i ++ ) {\n\n\t\t#if defined( USE_COLOR_ALPHA )\n\n\t\t\tif ( morphTargetInfluences[ i ] !\x3d 0.0 ) vColor +\x3d getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\n\t\t#elif defined( USE_COLOR )\n\n\t\t\tif ( morphTargetInfluences[ i ] !\x3d 0.0 ) vColor +\x3d getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\n\t\t#endif\n\n\t}\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$morphcolor_vertex_glsl.js.map
