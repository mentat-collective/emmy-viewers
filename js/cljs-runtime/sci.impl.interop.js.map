{"version":3,"sources":["sci/impl/interop.cljc"],"mappings":"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","names":["sci.impl.interop/invoke-instance-field","obj","_target-class","field-name","sci.impl.interop/invoke-instance-method","method-name","args","temp__5751__auto__","method","js/Reflect.apply","cljs.core.into_array","js/Error","p__89533","vec__89534","cljs.core.nth","sci.impl.interop/get-static-field","class","field-name-sym","clojure.string/includes?","cljs.core.apply","sci.impl.interop.goog$module$goog$object.getValueByKeys","clojure.string.split","sci.impl.interop.goog$module$goog$object.get","sci.impl.interop/invoke-js-constructor","constructor","js/Reflect.construct","sci.impl.interop/invoke-constructor","p__89558","vec__89562","sci.impl.interop/invoke-static-method","field","cljs.core/not","clojure.string/ends-with?","sci.impl.interop/fully-qualify-class","ctx","sym","cljs.core/deref","env","class->opts","or__4253__auto__","ns*","cljs.core/namespace","cljs.core/contains?","cljs.core.symbol","cljs.core/name","cljs.core.get","cnn","sci.impl.utils/current-ns-name","cljs.core.get_in","sci.impl.interop/resolve-class-opts","class-opts","imports","vec__89568","_","v","cljs.core/find","temp__5753__auto__","sci.impl.interop/resolve-class"],"sourcesContent":["(ns sci.impl.interop\n  {:no-doc true}\n  #?(:clj (:import\n           [java.lang.reflect Field Modifier]\n           [sci.impl Reflector]))\n  (:require #?(:cljs [goog.object :as gobject])\n            #?(:cljs [clojure.string :as str])\n            [sci.impl.utils :as utils]))\n\n;; see https://github.com/clojure/clojure/blob/master/src/jvm/clojure/lang/Reflector.java\n;; see invokeStaticMethod, getStaticField, etc.\n\n#?(:clj (set! *warn-on-reflection* true))\n\n(defn invoke-instance-field\n  #?@(:cljs [[obj _target-class field-name]\n             ;; gobject/get didn't work here\n             (aget obj field-name)]\n      :clj\n      [[obj ^Class target-class method]\n       (let [^Field field (.getField target-class method)\n             mod (.getModifiers field)]\n         (if (and (not (Modifier/isStatic mod))\n                  (Modifier/isPublic mod))\n           (.get field obj)\n           (throw (ex-info (str \"Not found or accessible instance field: \" method) {}))))]))\n\n(defn invoke-instance-method\n  #?@(:cljs [[obj _target-class method-name args]\n             ;; gobject/get didn't work here\n             (if-let [method (aget obj method-name)]\n               ;; use Reflect rather than (.apply method ...), see https://github.com/babashka/nbb/issues/118\n               (js/Reflect.apply method obj (into-array args) #_(js-object-array args))\n               (throw (js/Error. (str \"Could not find instance method: \" method-name))))]\n      :clj\n      [[obj ^Class target-class method args]\n       (if-not target-class\n         (Reflector/invokeInstanceMethod obj method (object-array args))\n         (let [arg-count (count args)\n               methods (Reflector/getMethods target-class arg-count method false)]\n           (if (and (zero? arg-count) (.isEmpty ^java.util.List methods))\n             (invoke-instance-field obj target-class method)\n             (Reflector/invokeMatchingMethod method methods obj (object-array args)))))]))\n\n(defn get-static-field #?(:clj [[^Class class field-name-sym]]\n                          :cljs [[class field-name-sym]])\n  #?(:clj (Reflector/getStaticField class (str field-name-sym))\n     :cljs (if (str/includes? (str field-name-sym) \".\")\n             (apply gobject/getValueByKeys class (str/split (str field-name-sym) #\"\\.\"))\n             (gobject/get class field-name-sym))))\n\n#?(:cljs\n   (defn invoke-js-constructor [constructor args]\n     (js/Reflect.construct constructor (into-array args))))\n\n(defn invoke-constructor #?(:clj [^Class class args]\n                            :cljs [constructor args])\n  #?(:clj (Reflector/invokeConstructor class (object-array args))\n     :cljs (invoke-js-constructor constructor args)))\n\n(defn invoke-static-method #?(:clj [[^Class class method-name] args]\n                              :cljs [[class method-name] args])\n  #?(:clj\n     (Reflector/invokeStaticMethod class (str method-name) (object-array args))\n     :cljs (if-let [method (gobject/get class method-name)]\n             (js/Reflect.apply method class (into-array args))\n             (let [method-name (str method-name)\n                   field (get-static-field [class method-name])]\n               (cond\n                 (not field)\n                 (throw (js/Error. (str \"Could not find static method \" method-name)))\n                 (str/ends-with? method-name \".\")\n                 (invoke-js-constructor field args)\n                 :else\n                 ;; why is this here??\n                 (apply field args))))))\n\n(defn fully-qualify-class [ctx sym]\n  (let [env @(:env ctx)\n        class->opts (:class->opts env)]\n    (or #?(:clj (when (contains? class->opts sym) sym)\n           :cljs (if-let [ns* (namespace sym)]\n                   (when (identical? \"js\" ns*)\n                     (when (contains? class->opts (symbol (name sym)))\n                       sym))\n                   (when (contains? class->opts sym)\n                     sym)))\n        (or (get (:imports env) sym)\n            (let [cnn (utils/current-ns-name)]\n              (get-in env [:namespaces cnn :imports sym]))))))\n\n(defn resolve-class-opts [ctx sym]\n  (let [env @(:env ctx)\n        class->opts (:class->opts env)\n        class-opts (or #?(:clj (get class->opts sym)\n                          :cljs (if-let [ns* (namespace sym)]\n                                  (when (identical? \"js\" ns*)\n                                    (get class->opts (symbol (name sym))))\n                                  (get class->opts sym)))\n                       (let [cnn (utils/current-ns-name)\n                             imports (get-in env [:namespaces cnn :imports])]\n                         (if-let [[_ v] (find imports sym)]\n                           ;; finding a nil v means the object was unmapped\n                           (get class->opts v)\n                           (when-let [v (get-in env [:imports sym])]\n                             (get class->opts v)))))]\n    class-opts))\n\n(defn resolve-class [ctx sym]\n  (:class (resolve-class-opts ctx sym)))\n"]}