{"version":3,"sources":["pattern/syntax.cljc"],"mappings":";AAmCA;;;;mCAAA,nCAAMA,8EAGHC;AAHH,AAIE,SAAK,AAACC,4BAAYD,kBACb,gCAAA,/BAAG,AAACE,gBAAMF;;AAEjB;;;iCAAA,jCAAMG,0EAEHH;AAFH,AAGE,gEAAA,AAAA,zDAACI,6CAAEJ;;AAEL;;;;;;;;gCAAA,hCAAMK,wEAOHL;AAPH,AAQE,IAAAM,mBAAI,iBAAAC,oBAAK,AAACC,+BAAeR;AAArB,AAAA,GAAAO;AACK,wCAAA,jCAACE,8CAA4B,AAACC,eAAKV;;AADxCO;;;AAAJ,AAAA,oBAAAD;AAAAA;;AAGI,SAAK,AAACL,4BAAYD,kBACb,0EAAA,AAAA,1EAACI,6CAAE,AAACO,gBAAMX;;;AAErB;;;;;;;;gCAAA,hCAAMY,wEAOHZ;AAPH,AAQE,IAAAM,mBAAI,iBAAAC,oBAAK,AAACC,+BAAeR;AAArB,AAAA,GAAAO;AACK,wCAAA,jCAACE,gDAA8B,AAACC,eAAKV;;AAD1CO;;;AAAJ,AAAA,oBAAAD;AAAAA;;AAGI,SAAK,AAACL,4BAAYD,kBACb,0EAAA,AAAA,1EAACI,6CAAE,AAACO,gBAAMX;;;AAErB;;;;;;;;;wCAAA,xCAAMa,wFAQHb;AARH,AASE,IAAAM,mBAAI,iBAAAC,oBAAK,AAACC,+BAAeR;AAArB,AAAA,GAAAO;AACK,wCAAA,jCAACE,gDAA8B,AAACC,eAAKV;;AAD1CO;;;AAAJ,AAAA,oBAAAD;AAAAA;;AAGI,SAAK,AAACL,4BAAYD,kBACb,0EAAA,AAAA,1EAACI,6CAAE,AAACO,gBAAMX;;;AAErB;;;;;+BAAA,/BAAMc,sEAIHd;AAJH,AAKE,GAAI,AAACQ,+BAAeR;AAClBA;;AACA,OAACe,iBAAOf;;;AAEZ;;;;sCAAA,tCAAMgB,oFAGHhB;AAHH,AAIE,GAAI,AAACQ,+BAAeR;AAClB,OAACiB,+CACA,CAAA,KAAU,yEAAA,zEAACC,6CAAK,AAACR,eAAKV;;AACvB,OAACe,iBAAOf;;;AAEZ;;;;;;;;6BAAA,7BAAMmB,kEAOHnB;AAPH,AAQE,IAAMoB,gBAAc,WAAKC;AAAL,AAAA;;AAApB,AACE,GAAI,AAACb,+BAAeR;AAClBoB;;AACA,IAAAE,qBAAY,AAACE,cAAI,6CAAA,7CAACC,iDAAOzB;AAAzB,AAAA,GAAAsB;AAAA,SAAAA,LAASC;AAAT,AACE,OAACG,8CAAMC,qBAAWJ;;AAClBH;;;;AAUR;;;;gCAAA,hCAAMQ,wEAGH5B;AAHH,AAIE,SAAK,AAACC,4BAAYD,kBACb,0EAAA,AAAA,1EAACI,6CAAE,AAACO,gBAAMX;;AAGjB;;;;uCAAA,vCAAM6B,sFAGH7B;AAHH,AAIE,SAAK,AAACC,4BAAYD,kBACb,0EAAA,AAAA,1EAACI,6CAAE,AAACO,gBAAMX;;AAGjB;;;;+BAAA,/BAAM8B,sEAGH9B;AAHH,AAIE,OAACe,iBAAOf;;AAEV;;;;;;;;;;;;;;;;;;;;;;;;+BAAA,/BAAM+B,sEAuBHC,cAAQC,EAAEC;AAvBb,AAwBE,IAAAC,aAAoB,AAACI,+CACA,WAAAC,SAAmBE;AAAnB,AAAA,IAAAD,aAAAD;UAAA,AAAAJ,4CAAAK,WAAA,IAAA,jEAAMJ;cAAN,AAAAD,4CAAAK,WAAA,IAAA,rEAAUH;AAAV,AACE,oBAAI,CAACN,8CAAAA,iDAAAA,LAAQU,6BAAAA;AACX,GAAI,AAACC,uBAAOL;AAAZ,oOAAA,1IACG,AAACM,6CAAKP,IAAI,CAACJ,kCAAAA,qCAAAA,LAAES,iBAAAA;;AADhB,0SAAA,hNAEG,AAACE,oDAAKP,IAAIC,0DAAQ,CAACL,kCAAAA,qCAAAA,LAAES,iBAAAA;;;AAH1B,0FAIGL,IAAI,AAACO,6CAAKN,QAAQ,CAACL,kCAAAA,qCAAAA,LAAES,iBAAAA;;GAN3B,mFAAA,iCAAA,yCAQCR;UARrB,AAAAE,4CAAAD,WAAA,IAAA,jEAAOE;cAAP,AAAAD,4CAAAD,WAAA,IAAA,rEAAWG;AAAX,AASE,GAAI,AAACK,uBAAOL;AACVD;;AACA,OAACO,6CAAKP,IAAIC;;;AAEhB;;;;;;;;;;;;;;;;;iCAAA,jCAAMO,0EAgBH7C;AAhBH,AAiBE,yBAAA,8DAA6BkC;AAA7B,AACU,IAAMG,MAAI,AAACN,6BACAF,qCAAgBgB,+BAAgBX;AAD3C,AAEE,GAAI,AAACY,wBAAQZ;AACX,oDAAA,7CAACa,8EAAQC,cAAIX;;AACb,sBAAA,AAAA,fAACY,0FAAW,AAACvB,8CAAMwB,iBAAOb;;;AALxC,AAOE,GAAM,wBAAAc,vBAASnD;AAAS,YAAAoD,eAAA,KAAA,AAAA,2DAAA,KAAAA,eAAA,iBAAA,KAAA,IAAA,OAAA,IAAA,hCAAapD;;AAArC,GAEM,EAAI,AAAC4B,8BAAS5B,kBACV,AAAC6B,qCAAgB7B;AACrB,OAAC8B,6BAAc9B;;AAJrB,GAMM,AAACC,4BAAYD;AACb,oBAAI,iBAAAM,mBAAI,AAACD,8BAASL;AAAd,AAAA,oBAAAM;AAAAA;;AAAA,IAAAA,uBACI,AAACM,8BAASZ;AADd,AAAA,oBAAAM;AAAAA;;AAEI,OAACO,sCAAiBb;;;;AACxB,IAAAqD,aAAsBrD;IAAtBsD,aAAA,AAAA9B,cAAA6B;IAAAE,eAAA,AAAA5C,gBAAA2C;IAAAA,iBAAA,AAAAE,eAAAF;QAAAC,JAAOE;IAAPF,mBAAA,AAAA5C,gBAAA2C;IAAAA,iBAAA,AAAAE,eAAAF;UAAAC,NAASG;YAATJ,RAAeK;AAAf,AACE,GAAI,AAAC9B,qCAAgB6B;AAArB,OAAAE,iDAAA,AAAApC,cAAA,AAAAqC,sDAAA,KAAAT,eAAA,KAAA,AAAA,2EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAQ,iDAAA,AAAApC,cAAA,AAAAqC,+CAAA,KAAAT,eAAA,KAAA,AAAA,2DAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,OAAA,KAAA,IAAA,UAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,AAAAQ,iDAAA,AAAApC,cAAA,AAAAqC,sDAAA,KAAAT,eAAA,KAAA,AAAA,+EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,uCAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,KAAA,AAAAU,cAAA,AAAAF,iDAAA,AAAApC,cAAA,AAAAqC,yDAAA,KAAA,IAAA,eAAA,KAAA,IAAA,1pBACYJ,sXAAW,AAAC3B,6BAAc4B,4NAAQC;;AAC5C,IAAMD,UAAI,wEAAA,AAAAE,iDAAA,AAAApC,cAAA,AAAAqC,+CAAA,KAAAT,eAAA,KAAA,AAAA,2DAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,SAAA,KAAA,IAAA,9TAAI,AAACxB,8BAAS8B,MACZ,AAAC5B,6BAAc4B,gPACNA;AAFrB,AAAA,OAAAE,iDAAA,AAAApC,cAAA,AAAAqC,sDAAA,KAAAT,eAAA,KAAA,AAAA,2EAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,KAAA,AAAAQ,iDAAA,AAAApC,cAAA,AAAAqC,+CAAA,KAAAT,eAAA,KAAA,AAAA,2DAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,OAAA,KAAA,IAAA,UAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,aAAA,KAAA,IAAA,jIAGWK,gHAAGC,wBAAMC;;;AACxB,OAACI,mBAAmB/D;;;AAjB5B,GAmBM,AAACgE,qBAAKhE;AACN,OAACiE,wBAAWpB,+BAAgB7C;;AApBlC,AAsBYA","names":["pattern.syntax/restricted?","pattern","cljs.core/sequential?","cljs.core/count","pattern.syntax/wildcard?","cljs.core._EQ_","pattern.syntax/binding?","or__4253__auto__","and__4251__auto__","cljs.core/simple-symbol?","sicmutils.util/re-matches?","cljs.core/name","cljs.core/first","pattern.syntax/segment?","pattern.syntax/reverse-segment?","pattern.syntax/variable-name","cljs.core/second","pattern.syntax/reverse-segment-name","cljs.core.symbol","cljs.core.subs","pattern.syntax/restriction","no-constraint","_","temp__5751__auto__","fs","cljs.core/seq","cljs.core.drop","cljs.core.apply","cljs.core/every-pred","pattern.syntax/unquote?","pattern.syntax/unquote-splice?","pattern.syntax/unquoted-form","pattern.syntax/splice-reduce","splice?","f","xs","vec__96985","cljs.core.nth","acc","pending","cljs.core.reduce","p__96989","vec__96990","x","cljs.core/empty?","cljs.core.conj","pattern.syntax/compile-pattern","cljs.core/vector?","cljs.core.into","cljs.core/cat","cljs.core/cons","cljs.core/concat","cljs.core/Symbol","cljs.core/List","vec__96996","seq__96997","first__96998","cljs.core/next","k","sym","preds","cljs.core.sequence","cljs.core.concat","cljs.core/vec","compile-sequential","cljs.core/map?","sicmutils.util/map-vals"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns pattern.syntax\n  \"The syntax namespace defines the default syntax for patterns corresponding to\n  the matcher combinators defined in [[pattern.match]].\"\n  (:require [sicmutils.util :as u]))\n\n;; ### Notes\n;;\n;; The current version of the library declares the following syntax rules:\n;;\n;; - `_` is a wildcard matcher that succeeds with anything and introduces no new\n;;   bindings.\n;;\n;; - `?x` triggers an unrestricted binding match. It will match anything and\n;;   introduce a new binding from that symbol to the matched value.\n;;\n;; - `(? <binding> <predicates...>)` triggers a binding iff all of the predicate\n;;   functions appearing after the binding pass for the candidate\n;;\n;; - `(?? <binding>)` or `??x` inside of a sequence matches a _segment_ of the\n;;   list whose length isn't fixed. Segments will attempt to succed with\n;;   successively longer prefixes of the remaining items in the list.\n;;\n;; - `($$ <binding>)` or `$$x` will only match _after_ the same binding has\n;;   already succeeded with a segment. If it has, - this will match a segment\n;;   equal to the _reverse_ of the already-bound segment.\n;;\n;; - Any sequential entry, like a list or a vector, triggers a `sequence` match.\n;;   This will attempt to match a sequence, and only pass if its matcher\n;;   arguments are able to match all entries in the sequence.\n;;\n;;\n;; ## Non-Macro Syntax\n\n(defn restricted?\n  \"Returns true if `pattern` is a binding pattern with restriction predicates,\n  false otherwise.\"\n  [pattern]\n  (and (sequential? pattern)\n       (> (count pattern) 2)))\n\n(defn wildcard?\n  \"Returns true if `pattern` matches the wildcard character `_`, false otherwise.\"\n  [pattern]\n  (= pattern '_))\n\n(defn binding?\n  \"Returns true if `pattern` is a binding variable reference, false otherwise.\n\n  A binding variable is either:\n\n  - A symbol starting with a single `?` character\n  - A sequence of the form `(? <binding> ...)`.\"\n  [pattern]\n  (or (and (simple-symbol? pattern)\n           (u/re-matches? #\"^\\?[^\\?].*\" (name pattern)))\n\n      (and (sequential? pattern)\n           (= (first pattern) '?))))\n\n(defn segment?\n  \"Returns true if `pattern` is a segment variable reference, false otherwise.\n\n  A segment binding variable is either:\n\n  - A symbol starting with `??`\n  - A sequence of the form `(?? <binding>)`.\"\n  [pattern]\n  (or (and (simple-symbol? pattern)\n           (u/re-matches? #\"^\\?\\?[^\\?].*\" (name pattern)))\n\n      (and (sequential? pattern)\n           (= (first pattern) '??))))\n\n(defn reverse-segment?\n  \"Returns true if `pattern` is a reversed-segment variable reference, false\n  otherwise.\n\n  A reverse-segment binding variable is either:\n\n  - A symbol starting with `$$`\n  - A sequence of the form `(:$$ <binding>)`.\"\n  [pattern]\n  (or (and (simple-symbol? pattern)\n           (u/re-matches? #\"^\\$\\$[^\\$].*\" (name pattern)))\n\n      (and (sequential? pattern)\n           (= (first pattern) '$$))))\n\n(defn variable-name\n  \"Given a variable or segment binding form, returns the binding variable.\n\n  NOTE that [[variable-name]] will not guard against incorrect inputs.\"\n  [pattern]\n  (if (simple-symbol? pattern)\n    pattern\n    (second pattern)))\n\n(defn reverse-segment-name\n  \"Given a REVERSE-segment name, either extracts the symbol from a pattern\n  like `(:$$ x)`, or transforms symbols like `$$x` into `??x`.\"\n  [pattern]\n  (if (simple-symbol? pattern)\n    (symbol\n     (str \"??\" (subs (name pattern) 2)))\n    (second pattern)))\n\n(defn restriction\n  \"If `pattern` is a variable binding form in a pattern with restriction predicates,\n  returns a predicate that only returns true if all of the predicates pass for\n  its input, false otherwise.\n\n  If `pattern` has no restrictions or is some other input type, returns a\n  predicate that will always return `true`.\"\n  [pattern]\n  (let [no-constraint (fn [_] true)]\n    (if (simple-symbol? pattern)\n      no-constraint\n      (if-let [fs (seq (drop 2 pattern))]\n        (apply every-pred fs)\n        no-constraint))))\n\n;; ## Pattern Compilation\n;;\n;; [[compile-pattern]] below allows a macro to take a pattern form with binding\n;; symbols unquoted. The disadvantage of a macro is that a user can't usually do\n;; things like splice in bindings that are in the current scope.\n;;\n;; To fix this, we handle `unquote` and `unquote-splicing` directly.\n\n(defn unquote?\n  \"Returns true if `pattern` is a form that should be included with no quoting\n  into the returned pattern, false otherwise.\"\n  [pattern]\n  (and (sequential? pattern)\n       (= (first pattern)\n          'clojure.core/unquote)))\n\n(defn unquote-splice?\n  \"Returns true if `pattern` is a sequence form that should be spliced directly\n  into the returned pattern, false otherwise.\"\n  [pattern]\n  (and (sequential? pattern)\n       (= (first pattern)\n          'clojure.core/unquote-splicing)))\n\n(defn unquoted-form\n  \"Given a `pattern` that responds `true` to [[unquote?]] or [[unquote-splice?]],\n  returns the form from that pattern.\"\n  [pattern]\n  (second pattern))\n\n(defn splice-reduce\n  \"Helper function for reducing over a sequence that might contain forms that need\n  to be spliced into the resulting sequence. This is a sort of helper for a\n  guarded `mapcat`.\n\n  Takes a sequence `xs` and mapping function `f` and returns a sequence of\n  sequences that, if concatenated together, would be identical to\n\n  ```clojure\n  (map f xs)\n  ```\n\n  Where any `x` such that `(splice? x)` returns true would have its sequential\n  value `(f x)` spliced into the result.\n\n  For example:\n\n  ```clojure\n  (let [f (fn [x] (if (odd? x)  [x x x] x))]\n    (splice-reduce odd? f (range 5)))\n\n  ;;=> [[0] [1 1 1] [2] [3 3 3] [4]]\n  ```\"\n  [splice? f xs]\n  (let [[acc pending] (reduce\n                       (fn [[acc pending] x]\n                         (if (splice? x)\n                           (if (empty? pending)\n                             [(conj acc (f x)) []]\n                             [(conj acc pending (f x)) []])\n                           [acc (conj pending (f x))]))\n                       [[] []]\n                       xs)]\n    (if (empty? pending)\n      acc\n      (conj acc pending))))\n\n(defn compile-pattern\n  \"Given a pattern with unquoted binding forms and, potentially, `~` and `~@`\n  entries, returns a pattern appropriately quoted such that it can be evaluated\n  by the Clojure reader.\n\n  Changes:\n\n  - `(? x) => (list '? 'x)`\n  - any bare symbol is quoted\n  - Any form unquoted like `~x` is left UNquoted, even in the symbol spot of `(?\n    ~sym ...)`\n  - Any form marked `~@[1 2 3]` is spliced in directly, EVEN in the symbol spot\n    of `(? ~@sym ...)`\n\n  These rules proceed recursively down into map, vector and sequential data\n  structures. (Recursion only pushes down into values for map-shaped patterns.)\"\n  [pattern]\n  (letfn [(compile-sequential [xs]\n            (let [acc (splice-reduce\n                       unquote-splice? compile-pattern xs)]\n              (if (vector? xs)\n                (into [] cat acc)\n                (cons `list (apply concat acc)))))]\n\n    (cond (symbol? pattern) (list 'quote pattern)\n\n          (or (unquote? pattern)\n              (unquote-splice? pattern))\n          (unquoted-form pattern)\n\n          (sequential? pattern)\n          (if (or (binding? pattern)\n                  (segment? pattern)\n                  (reverse-segment? pattern))\n            (let [[k sym & preds] pattern]\n              (if (unquote-splice? sym)\n                `(list* '~k (concat ~(unquoted-form sym) [~@preds]))\n                (let [sym (if (unquote? sym)\n                            (unquoted-form sym)\n                            `(quote ~sym))]\n                  `(list '~k ~sym ~@preds))))\n            (compile-sequential pattern))\n\n          (map? pattern)\n          (u/map-vals compile-pattern pattern)\n\n          :else pattern)))\n"]}