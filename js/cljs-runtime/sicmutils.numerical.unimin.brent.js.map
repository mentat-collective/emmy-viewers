{"version":3,"sources":["sicmutils/numerical/unimin/brent.cljc"],"mappings":"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","names":["sicmutils.numerical.unimin.brent/terminate?","a","x","b","tol2","half-ab","mid","mid->x","sicmutils.generic/abs","sicmutils.numerical.unimin.brent/golden-section-step","midpoint","new-width","step","sicmutils.numerical.unimin.golden/inv-phi2","sicmutils.numerical.unimin.brent/parabola-valid?","target","p","q","inbounds?","lt-half-target?","sicmutils.numerical.unimin.brent/apply-delta","delta","tol1","x+delta","near-edge?","middle","p__102283","p__102284","p__102285","p__102286","vec__102289","cljs.core.nth","vec__102292","vec__102295","vec__102298","sicmutils.numerical.unimin.brent/update-history","xx2","fx2","x2","xx1","fx1","x1","xx","fx","xnew","fnew","cljs.core._EQ_","var_args","G__102326","sicmutils.numerical.unimin.brent/brent-min","js/Error","p__102331","map__102332","cljs.core/--destructure-map","cljs.core.get","f","sicmutils.numerical.unimin.brent.brent_min","relative-threshold","absolute-threshold","maxiter","maxfun","callback","sicmutils.generic/sqrt","sicmutils.value/machine-epsilon","cljs.core/constantly","vec__102333","vec__102336","or__4253__auto__","x__4339__auto__","y__4340__auto__","x__4336__auto__","y__4337__auto__","f-counter","sicmutils.util.counted","xmid","G__102348","vec__102350","vec__102353","G__102349","vec__102356","vec__102386","vec__102389","vec__102392","iteration","tol","converged?","cljs.core/deref","vec__102397","vec__102400","vec__102403","vec__102406","new-target","new-delta","vec__102409","sicmutils.numerical.unimin.bracket/parabolic-pieces","new-pt","xl","fl","l","xr","fr","r","sicmutils.numerical.unimin.brent/brent-max","opts","-f","cljs.core.comp","sicmutils.generic/negate","cljs.core.update"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.unimin.brent\n  \"This namespace contains an implementation of Brent's method for finding the\n  minimum of a real-valued function.\"\n  (:require [sicmutils.generic :as g]\n            [sicmutils.numbers]\n            [sicmutils.numerical.unimin.bracket :as ub]\n            [sicmutils.numerical.unimin.golden :as ug]\n            [sicmutils.util :as u]\n            [sicmutils.value :as v])\n  #?(:clj\n     (:import (org.apache.commons.math3.optim.univariate\n               BrentOptimizer\n               UnivariateObjectiveFunction\n               SearchInterval\n               UnivariatePointValuePair)\n              (org.apache.commons.math3.analysis\n               UnivariateFunction)\n              (org.apache.commons.math3.optim.nonlinear.scalar\n               GoalType)\n              (org.apache.commons.math3.optim\n               MaxEval\n               MaxIter\n               OptimizationData\n               ConvergenceChecker))))\n\n(defn- terminate?\n  \"Brent's method terminates (ie converges) when `a` and `b` are narrow enough\n  that `x` falls within `2 * tolerance` of both `a` and `b`, ie:\n\n  `max(x - a, b - x) <= 2tol`\n\n  From Numerical Recipes:\n\n  \\\"A typical ending configuration for Brent's method is that $a$ and $b$\n  are `(* 2 midpoint tol)` apart, with $x$ (the best abscissa) at the midpoint\n  of $a$ and $b$, and therefore fractionally accurate to +-tol.\\\" ~Numerical\n  Recipes, 397.\n  \"\n  [a x b tol2]\n  (let [half-ab (* 0.5 (- b a))\n        mid     (* 0.5 (+ a b))\n        mid->x  (g/abs (- x mid))]\n    (<= (+ mid->x half-ab) tol2)))\n\n(defn- golden-section-step\n  \"Returns a pair of:\n\n  - The interval width between the new `a` and `b` after the algorithm completes\n    this golden step\n  - The delta that needs to be applied to `x` to take it into the larger of the\n    two gaps between `a` and `b,` ie, to `new_x`:\n\n  `xa---------new_x<---xx------xb`\n\n  NOTE that in Brent's algorithm, a golden section step wipes out the tracked\n  history of `p/q` parabolic steps that the algorithm uses to decide between\n  parabolic and golden section steps.\n\n  The goal of the dance is to force a golden section step every $log_2((b - a) /\n  tol1)$ steps by allowing a parabolic step as long as it halves the step taken\n  two iterations ago. Without this reset the algorithm would attempt fewer\n  beneficial parabolic steps.\"\n  [a x b]\n  (let [midpoint (* 0.5 (+ a b))\n        new-width (if (>= x midpoint)\n                    (- a x)\n                    (- b x))\n        step (* ug/inv-phi2 new-width)]\n    [new-width step]))\n\n(defn- parabola-valid?\n  \"The parabolic step `p/q` is valid if the step:\n\n  - keeps the candidate point `x` inbounds, ie, `a < x + p/q < b`\n  - is at least 1/2 of `target`.\n\n  `target` is a slightly tricky quantity, and depends on the type of step taken\n  in the previous two iterations:\n\n  -  *, golden: `target` == the full `(a, b)` interval `b - a`\n  -  golden, *: `target` == the size of the step taken by the previous golden\n  - para, para: `target` == `p/q` from two steps ago\n\n  The idea is to force a golden section step every so often by narrowing the\n  allowed jump that a parabolic step is allowed to take, and then widening the\n  band to the full range whenever a golden section step occurs.\n\n  Why the step before last? Experimentally (according to Brent) it works better\n  than considering only the previous step, and aesthetically it feels right to\n  give parabolic interpolation more than one try to do a nice job.\"\n  [a x b target p q]\n  (let [inbounds? (and (> p (* q (- a x)))\n                       (< p (* q (- b x))))\n        lt-half-target? (< (g/abs p) (g/abs (* 0.5 q target)))]\n    (and inbounds? lt-half-target?)))\n\n(defn- apply-delta\n  \"Returns `x + delta`, guarding against any `delta` addition that would return a\n  value outside of `(a, b)`. Specifically guards against these two cases:\n\n  - If `x` + the supplied `delta` results in a point within 2*tol of either\n    edge, `delta` is replaced with `tol1` pointing back toward the center of the\n    interval `(a, b)`.\n\n  - If `delta < tol1`, returns `x + tol1` in the direction of `delta`, to force\n    a step of at least `tol1`.\n\n  NOTE tol2 == 2*tol1.\"\n  [a x b delta tol1 tol2]\n  (let [x+delta    (+ x delta)\n        near-edge? (or (< (- x+delta a) tol2)\n                       (< (- b x+delta) tol2))]\n    (cond near-edge?\n          (let [middle (* 0.5 (+ a b))]\n            (if (<= x middle)\n              (+ x tol1)\n              (- x tol1)))\n\n          ;; tiny delta?\n          (< (g/abs delta) tol1)\n          (if (pos? delta)\n            (+ x tol1)\n            (- x tol1))\n\n          :else x+delta)))\n\n(defn- update-history\n  \"Brent's method tracks the two best (non-candidate) points, so they can be used\n  to fit a candidate parabolic step.\n\n  This function accepts:\n\n  - `x2` and `x1`, the previous two best non-candidates;\n  - `x`, the previous candidate\n  - `new-pt` the current new point\n\n  and returns the third- and second-best points, ie, the new `[x2, x1]`.\n\n  NOTE on the implementation: the assumption is that `x2` and `x1` will be\n  initialized to `x`, and that they'll be replaced by potentially WORSE values\n  that appear for the first two steps.\n  \"\n  [[xx2 fx2 :as x2] [xx1 fx1 :as x1] [xx fx :as x] [xnew fnew]]\n  (cond (<= fnew fx)                              [x1 x]\n        (or (<= fnew fx1) (= xx1 xx))             [x1 [xnew fnew]]\n        (or (<= fnew fx2) (= xx2 xx) (= xx2 xx1)) [[xnew fnew] x1]\n        :else [x2 x1]))\n\n(defn brent-min\n  \"Find the minimum of the function f: R -> R in the interval [a,b] using Brent's\n  Method, described by Richard Brent in [Algorithms for Minimization without\n  Derivatives](https://books.google.com/books?id=AITCAgAAQBAJ&q=Brent%E2%80%99s#v=onepage&q=Parabolic&f=false).\n\n  Brent's method is a combination of a golden section search with a parabolic\n  interpolation step. Parabolic interpolation can go wild if the candidate point\n  is close to colinear with the search bounds, or of the points are too close\n  together.\n\n  Brent's method prevents this by applying an internal test that forces a golden\n  section step every so often. (If you want the details, see `parabola-valid?`\n  above.)\n\n  Supports the following optional keyword arguments:\n\n  `:callback` if supplied, the supplied fn will be invoked at each intermediate\n  point with the iteration count and the values of x and f(x) at each search\n  step.\n\n  `:relative-threshold` defaults to around 1.49e8, the sqrt of the machine\n  tolerance. You won't gain any benefit attempting to set the value less than\n  the default.\n\n  `:absolute-threshold` a smaller absolute threshold that applies when the\n  candidate minimum point is close to 0.\n\n  `:maxiter` Maximum number of iterations allowed for the minimizer. Defaults to\n  1000.\n\n  `:maxfun` Maximum number of times the function can be evaluated before\n  exiting. Defaults to `(inc maxiter)`.\n  \"\n  ([f a b] (brent-min f a b {}))\n  ([f a b {:keys [relative-threshold\n                  absolute-threshold\n                  maxiter\n                  maxfun\n                  callback]\n           :or {relative-threshold (g/sqrt v/machine-epsilon)\n                absolute-threshold 1.0e-11\n                maxiter 1000\n                callback (constantly nil)}}]\n   (let [maxfun        (or maxfun (inc maxiter))\n         [a b]         [(min a b) (max a b)]\n         [f-counter f] (u/counted f)\n         xmid          (* 0.5 (+ a b))\n         mid           [xmid (f xmid)]]\n     (loop [\n            ;; a and b bound the interval in which the minimizer is searching.\n            ;; `xx` is the current candidate point, and `fx` is its value.\n            [a [xx fx :as x] b] [a mid b]\n\n            ;; The second-best and best points considered prior to this\n            ;; iteration and its candidate point.\n            [x2 x1] [mid mid]\n\n            ;; This value is used by `parabola-valid?` to decide whether or not\n            ;; it's appropriate to proceed with the parabolic step, or fall back\n            ;; to a golden section step. `parabola-valid?`'s docstring describes\n            ;; the logic.\n            target 0\n\n            ;; step size taken by the previous iteration.\n            delta  0\n            iteration 0]\n       (let [\n             ;; The total tolerance for the algorithm, and also the minimum\n             ;; possible step to take during each iteration.\n             tol  (+ absolute-threshold (* relative-threshold (g/abs xx)))\n             tol2 (* 2 tol)\n             converged? (terminate? a xx b tol2)]\n         (callback iteration xx fx)\n         (if (or (> iteration maxiter)\n                 (> @f-counter maxfun)\n                 converged?)\n           {:result     xx\n            :value      fx\n            :iterations iteration\n            :converged? converged?\n            :fncalls    @f-counter}\n           (let [[new-target new-delta]\n                 (if (<= (g/abs target) tol)\n                   (golden-section-step a xx b)\n                   ;; If the target value is > the combined tolerance, generate\n                   ;; a parabolic interpolation using\n                   ;;\n                   ;; - the previous two best guesses WORSE than the candidate point, and\n                   ;; - the current candidate point\n                   ;;\n                   ;; `p` and `q` are the numerator and denominator of the step\n                   ;; required to move to the minimum of the interpolated\n                   ;; parabola from the current candidate `x`; ie, `x + p/q`\n                   ;; lies at the parabola's minimum.\n                   (let [[p q] (ub/parabolic-pieces x1 x x2)]\n                     ;; Only proceed with the parabolic step if the new point\n                     ;; lies inside `(a, b)` and results in a step >= 1/2\n                     ;; target. Otherwise, default to a golden section step.\n                     (if (parabola-valid? a xx b target p q)\n                       [delta (/ p q)]\n                       (golden-section-step a xx b))))\n\n                 xnew   (apply-delta a xx b new-delta tol tol2)\n                 new-pt [xnew (f xnew)]\n\n                 ;; `x` and `xnew` both lie within `(a, b)`; assign them to `l`,\n                 ;; `r` based on their ordering within the interval...\n                 [[xl fl :as l] [xr fr :as r]] (if (< xnew xx)\n                                                 [new-pt x]\n                                                 [x new-pt])]\n             ;; and then tighten the search interval down around the new\n             ;; lowest-valued point.\n             (recur (if (<= fl fr)\n                      [a l xr]\n                      [xl r b])\n                    (update-history x2 x1 x new-pt)\n                    new-target\n                    new-delta\n                    (inc iteration)))))))))\n\n(defn brent-max\n  \"For convenience, we also provide the sister-procedure for finding the maximum\n  of a unimodal function using Brent's method.\n\n  Negate the function, minimize, negate the result.\"\n  [f a b opts]\n  (let [-f (comp g/negate f)]\n    (-> (brent-min -f a b opts)\n        (update :value g/negate))))\n\n#?(:clj\n   (defn brent-min-commons\n     \"Find the minimum of the function f: R -> R in the interval [a,b] using\n  Brent's Method, described by Richard Brent in [Algorithms for Minimization\n  without\n  Derivatives](https://books.google.com/books?id=AITCAgAAQBAJ&q=Brent%E2%80%99s#v=onepage&q=Parabolic&f=false).\n\n   This method is identical to `brent-min` but uses the apache-commons\n   implementation of Brent's method. See `brent-min` for more information.\"\n     ([f a b] (brent-min-commons f a b {}))\n     ([f a b {:keys [relative-threshold\n                     absolute-threshold\n                     maxiter\n                     maxfun\n                     callback]\n              :or {relative-threshold (g/sqrt v/machine-epsilon)\n                   absolute-threshold 1.0e-11\n                   maxiter 1000\n                   callback (constantly nil)}}]\n      (let [maxfun (or maxfun (inc maxiter))\n            [f-counter f] (u/counted f)\n            o (BrentOptimizer.\n               relative-threshold\n               absolute-threshold\n               (reify ConvergenceChecker\n                 (converged [_ iter _ current]\n                   (callback iter\n                             (.getPoint ^UnivariatePointValuePair current)\n                             (.getValue ^UnivariatePointValuePair current))\n                   false)))\n            args ^\"[Lorg.apache.commons.math3.optim.OptimizationData;\"\n            (into-array OptimizationData\n                        [(UnivariateObjectiveFunction.\n                          (reify UnivariateFunction\n                            (value [_ x]\n                              (f x))))\n                         (MaxEval. maxfun)\n                         (MaxIter. maxiter)\n                         (SearchInterval. a b)\n                         GoalType/MINIMIZE])\n            p  (.optimize o args)\n            xx (.getPoint p)\n            fx (.getValue p)]\n        (callback (.getIterations o) xx fx)\n        {:result xx\n         :value fx\n         :iterations (.getIterations o)\n         :converged? true\n         :fncalls @f-counter}))))\n\n#?(:clj\n   (defn brent-max-commons\n     \"For convenience, we also provide the sister-procedure for finding the\n  maximum of a unimodal function using the apache commons implementation of\n  Brent's method.\n\n  Negate the function, minimize, negate the result.\"\n     ([f a b] (brent-max-commons f a b {}))\n     ([f a b opts]\n      (let [-f (comp g/negate f)]\n        (-> (brent-min-commons -f a b opts)\n            (update :value g/negate))))))\n"]}