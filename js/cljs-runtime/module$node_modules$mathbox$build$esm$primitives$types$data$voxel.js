shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$data$voxel=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Voxel=void 0;var UData=
function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,
key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$mathbox$build$esm$util$data"));global=require("module$node_modules$mathbox$build$esm$primitives$types$data$buffer");class Voxel extends global.Buffer{constructor(...args){super(...args);this.update=this.update.bind(this)}static initClass(){this.traits="node buffer active data source index texture voxel raw".split(" ")}init(){this.buffer=
this.spec=null;this.space={width:0,height:0,depth:0};this.used={width:0,height:0,depth:0};this.storage="voxelBuffer";this.passthrough=(emit,x,y,z)=>emit(x,y,z,0);super.init()}sourceShader(shader){const dims=this.getDimensions();this.alignShader(dims,shader);return this.buffer.shader(shader)}getDimensions(){return{items:this.items,width:this.space.width,height:this.space.height,depth:this.space.depth}}getActiveDimensions(){return{items:this.items,width:this.used.width,height:this.used.height,depth:this.used.depth*
this.buffer.getFilled()}}getRawDimensions(){return this.getDimensions()}make(){super.make();const minFilter=null!=this.minFilter?this.minFilter:this.props.minFilter,magFilter=null!=this.magFilter?this.magFilter:this.props.magFilter,type=null!=this.type?this.type:this.props.type;var {width}=this.props,{height}=this.props;const {depth}=this.props,reserveX=this.props.bufferWidth,reserveY=this.props.bufferHeight,reserveZ=this.props.bufferDepth,{channels}=this.props,{items}=this.props;width=this.spec=
{channels,items,width,height,depth};this.items=width.items;this.channels=width.channels;({data:height}=this.props);width=UData.getDimensions(height,width);({space:height}=this);height.width=Math.max(reserveX,width.width||1);height.height=Math.max(reserveY,width.height||1);height.depth=Math.max(reserveZ,width.depth||1);return this.buffer=this._renderables.make(this.storage,{width:height.width,height:height.height,depth:height.depth,channels,items,minFilter,magFilter,type})}unmake(){super.unmake();
if(this.buffer)return this.buffer.dispose(),this.buffer=this.spec=null}change(changed,touched,init){if(touched.texture||changed["buffer.channels"]||changed["buffer.items"]||changed["voxel.bufferWidth"]||changed["voxel.bufferHeight"]||changed["voxel.bufferDepth"])return this.rebuild();if(this.buffer){if(changed["voxel.width"]){const {width,bufferWidth}=this.props;this.spec.width=width;if(width>bufferWidth)return this.rebuild()}if(changed["voxel.height"]){const {height,bufferHeight}=this.props;this.spec.height=
height;if(height>bufferHeight)return this.rebuild()}if(changed["voxel.depth"]){const {depth,bufferDepth}=this.props;this.spec.depth=depth;if(depth>bufferDepth)return this.rebuild()}if(changed["data.map"]||changed["data.data"]||changed["data.resolve"]||changed["data.expr"]||init)return this.buffer.setCallback(this.emitter())}}callback(callback){return 4>=callback.length?callback:(emit,i,j,k)=>callback(emit,i,j,k,this.bufferClock,this.bufferStep)}update(){if(this.buffer){var {data}=this.props,{space,
used}=this,w=used.width,h=used.height,d=used.depth,filled=this.buffer.getFilled();this.syncBuffer(abort=>{if(null!=data){var dims=UData.getDimensions(data,this.spec);if(dims.width>space.width||dims.height>space.height||dims.depth>space.depth)return abort(),this.rebuild();used.width=dims.width;used.height=dims.height;used.depth=dims.depth;this.buffer.setActive(used.width,used.height,used.depth);"function"===typeof this.buffer.callback.rebind&&this.buffer.callback.rebind(data);return this.buffer.update()}abort=
this.spec.width||1;dims=this.spec.height||1;const depth=this.spec.depth||1;this.buffer.setActive(abort,dims,depth);const length=this.buffer.update();used.width=abort;used.height=dims;used.depth=Math.min(depth,Math.ceil(length/abort/dims));1===used.depth&&(used.height=Math.min(dims,Math.ceil(length/abort)),1===used.height&&(used.width=Math.min(abort,length)))});if(used.width!==w||used.height!==h||used.depth!==d||filled!==this.buffer.getFilled())return this.trigger({type:"source.resize"})}}}exports.Voxel=
Voxel;Voxel.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$data$voxel.js.map
