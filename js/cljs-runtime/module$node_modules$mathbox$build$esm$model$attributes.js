shadow$provide.module$node_modules$mathbox$build$esm$model$attributes=function(global,require,module,exports){function __guard__(value,transform){return"undefined"!==typeof value&&null!==value?transform(value):void 0}Object.defineProperty(exports,"__esModule",{value:!0});exports.Attributes=void 0;class Attributes{constructor(definitions,context){this.context=context;this.traits=definitions.Traits;this.types=definitions.Types;this.pending=[];this.bound=[];this.last=null}make(type){return{enum:"function"===
typeof type.enum?type.enum():void 0,type:"function"===typeof type.uniform?type.uniform():void 0,value:type.make()}}apply(object,config){return new Data(object,config,this)}bind(callback){return this.bound.push(callback)}unbind(callback){return this.bound=Array.from(this.bound).filter(cb=>cb!==callback)}queue(callback,object,key,value){this.lastObject=object;this.lastKey=key;this.lastValue=value;return this.pending.push(callback)}invoke(callback){return callback(this.context.time.clock,this.context.time.step)}compute(){if(this.bound.length)for(const cb of Array.from(this.bound))this.invoke(cb)}digest(){let calls;
if(!this.pending.length)return!1;[calls,this.pending]=Array.from([this.pending,[]]);for(const callback of Array.from(calls))callback();return!0}getTrait(name){return this.traits[name]}getLastTrigger(){return`${this.lastObject.toString()} - ${this.lastKey}=\`${this.lastValue}\``}}exports.Attributes=Attributes;const shallowCopy=function(x){const out={};for(const k in x)out[k]=x[k];return out};class Data{constructor(object$jscomp$0,config,_attributes){let key$jscomp$0;let oldComputed,oldExpr,oldOrig,
oldProps,spec$jscomp$0,{props}=config;const {traits,finals,freeform}=config,data=this;null!=object$jscomp$0.props&&null!=object$jscomp$0.expr&&null!=object$jscomp$0.orig&&null!=object$jscomp$0.computed&&null!=object$jscomp$0.attributes&&(oldProps=shallowCopy(object$jscomp$0.props),oldExpr=shallowCopy(object$jscomp$0.expr),oldOrig=object$jscomp$0.orig(),oldComputed=object$jscomp$0.computed(),null!=object$jscomp$0.attributes&&object$jscomp$0.attributes.dispose());const flattened={},originals={},mapTo=
{},get=key=>null!=(null!=data[key]?data[key].value:void 0)?null!=data[key]?data[key].value:void 0:__guard__(data[null!=mapTo[key]?mapTo[key]:key],x=>x.value),set=function(key,value,ignore,initial){let attr;key=null!=mapTo[key]?mapTo[key]:key;if(null==(attr=data[key])){if(!freeform)throw Error(`${object$jscomp$0.toString()} - Setting unknown property \`${key}={${value}}\``);attr=data[key]={short:key,type:null,last:null,value:null};validators[key]=v=>v}if(!ignore){if(_expr[key])throw Error(`${object$jscomp$0.toString()} - Can't set bound property \`${key}={${value}}\``);
if(_computed[key])throw Error(`${object$jscomp$0.toString()} - Can't set computed property \`${key}={${value}}\``);if(_finals[key])throw Error(`${object$jscomp$0.toString()} - Can't set final property \`${key}={${value}}\``);}let valid=!0;const validated=validate(key,value,attr.last,function(){valid=!1;return null});if(valid){[attr.value,attr.last]=Array.from([validated,attr.value]);const {short}=attr;flattened[short]=validated;ignore||(originals[short]=value);initial||equalors[key](attr.value,attr.last)||
change(key,value)}return valid};config=function(key,value,initial){key=null!=mapTo[key]?mapTo[key]:key;set(key,value,!0,initial);return _finals[key]=!0};const expr$jscomp$0={},_bound={},_eval={},_expr={},_computed={},_finals={},bind=function(key,expression,computed){null==computed&&(computed=!1);key=null!=mapTo[key]?mapTo[key]:key;if("function"!==typeof expression)throw Error(`${object$jscomp$0.toString()} - Expression \`${key}=>{${expr$jscomp$0}}\` is not a function`);if(_expr[key])throw Error(`${object$jscomp$0.toString()} - Property \`${key}=>{${expr$jscomp$0}}\` is already bound`);
if(_computed[key])throw Error(`${object$jscomp$0.toString()} - Property \`${key}\` is computed`);if(_finals[key])throw Error(`${object$jscomp$0.toString()} - Property \`${key}\` is final`);(computed?_computed:_expr)[key]=expression;const short=null!=data[key]?data[key].short:key;computed||(expr$jscomp$0[short]=expression);_eval[key]=expression;expression=expression.bind(object$jscomp$0);_bound[key]=function(t,d){let clock;if(clock=null!=object$jscomp$0.clock?object$jscomp$0.clock.getTime():void 0)t=
clock.clock,d=clock.step;return object$jscomp$0.set(key,expression(t,d),!0)};return _attributes.bind(_bound[key])},unbind=function(key,computed){null==computed&&(computed=!1);key=null!=mapTo[key]?mapTo[key]:key;computed=computed?_computed:_expr;if(computed[key])return _attributes.unbind(_bound[key]),delete _bound[key],delete computed[key],null!=data[key]&&(key=data[key].short),delete expr$jscomp$0[key]},evaluate=function(key,time){let left;key=null!=mapTo[key]?mapTo[key]:key;return null!=(left="function"===
typeof _eval[key]?_eval[key](time,0):void 0)?left:data[key].value};object$jscomp$0.expr=expr$jscomp$0;object$jscomp$0.props=flattened;object$jscomp$0.evaluate=function(key,time){if(null!=key)return evaluate(key,time);const out={};for(key in props)out[key]=evaluate(key,time);return out};object$jscomp$0.get=function(key){return null!=key?get(key):flattened};object$jscomp$0.set=function(key,value,ignore,initial){if("string"===typeof key)set(key,value,ignore,initial);else{initial=ignore;ignore=value;
const options=key;for(key in options)value=options[key],set(key,value,ignore,initial)}};object$jscomp$0.bind=function(key,expr,computed){if("string"===typeof key)bind(key,expr,computed);else{computed=expr;const binds=key;for(key in binds)expr=binds[key],bind(key,expr,computed)}};object$jscomp$0.unbind=function(key,computed){if("string"===typeof key)unbind(key,computed);else{computed=expr$jscomp$0;const binds=key;for(key in binds)unbind(key,computed)}};object$jscomp$0.attribute=function(key){return null!=
key?data[null!=mapTo[key]?mapTo[key]:key]:data};object$jscomp$0.orig=function(key){return null!=key?originals[null!=mapTo[key]?mapTo[key]:key]:shallowCopy(originals)};object$jscomp$0.computed=function(key){return null!=key?_computed[null!=mapTo[key]?mapTo[key]:key]:shallowCopy(_computed)};const makers={},validators={},equalors={},validate=(key,value,target,invalid)=>validators[key](value,target,invalid);object$jscomp$0.validate=function(key,value){let target;key=null!=mapTo[key]?mapTo[key]:key;const make=
makers[key];null!=make&&(target=make());return target=validate(key,value,target,function(){throw Error(`${object$jscomp$0.toString()} - Invalid value \`${key}={${value}}\``);})};let dirty=!1,changes={},touches={},changed={},touched={};const change=function(key,value){dirty||(dirty=!0,_attributes.queue(digest,object$jscomp$0,key,value));value=key.split(".")[0];changes[key]=!0;return touches[value]=!0},event={type:"change",changed:null,touched:null},digest=function(){event.changed=changes;event.touched=
touches;changes=changed;touches=touched;({changed}=event);({touched}=event);dirty=!1;for(k in changes)changes[k]=!1;for(k in touches)touches[k]=!1;event.type="change";object$jscomp$0.trigger(event);var k=[];for(const trait in event.touched)event.type=`change:${trait}`,k.push(object$jscomp$0.trigger(event));return k},shorthand=function(name){name=name.split(/\./g);const suffix=name.pop();name.pop();name.unshift(suffix);return name.reduce((a,b)=>a+b.charAt(0).toUpperCase()+b.substring(1))},addSpec=
(name,spec)=>(()=>{const result=[];for(let key in spec){let value;const type=spec[key];key=[name,key].join(".");const short=shorthand(key);data[key]={T:type,ns:name,short,enum:"function"===typeof type.enum?type.enum():void 0,type:"function"===typeof type.uniform?type.uniform():void 0,last:type.make(),value:value=type.make()};if(mapTo[short])throw Error(`${object$jscomp$0.toString()} - Duplicate property \`${short}\``);mapTo[short]=key;flattened[short]=value;makers[key]=type.make;validators[key]=null!=
type.validate?type.validate:a=>a;result.push(equalors[key]=null!=type.equals?type.equals:(a,b)=>a===b)}return result})(),list=[];for(let trait of Array.from(traits)){[trait,ns]=Array.from(trait.split(":"));const name=ns?[ns,trait].join("."):trait;spec$jscomp$0=_attributes.getTrait(trait);list.push(trait);null!=spec$jscomp$0&&addSpec(name,spec$jscomp$0)}if(null!=props)for(ns in props)spec$jscomp$0=props[ns],addSpec(ns,spec$jscomp$0);var ns=list.filter((object,i)=>list.indexOf(object)===i);object$jscomp$0.traits=
ns;null!=oldProps&&object$jscomp$0.set(oldProps,!0,!0);if(null!=finals)for(key$jscomp$0 in finals)config(key$jscomp$0,finals[key$jscomp$0],!0);null!=oldOrig&&object$jscomp$0.set(oldOrig,!1,!0);null!=oldComputed&&object$jscomp$0.bind(oldComputed,!0);null!=oldExpr&&object$jscomp$0.bind(oldExpr,!1);this.dispose=function(){for(key$jscomp$0 in _computed)unbind(key$jscomp$0,!0);for(key$jscomp$0 in _expr)unbind(key$jscomp$0,!1);props={};delete object$jscomp$0.attributes;delete object$jscomp$0.get;return delete object$jscomp$0.set};
null}}}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$model$attributes.js.map
