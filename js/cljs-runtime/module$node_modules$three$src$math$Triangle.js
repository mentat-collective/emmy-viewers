shadow$provide.module$node_modules$three$src$math$Triangle=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Triangle=void 0;var _Vector=require("module$node_modules$three$src$math$Vector3");const _v0=new _Vector.Vector3,_v1=new _Vector.Vector3,_v2=new _Vector.Vector3,_v3=new _Vector.Vector3,_vab=new _Vector.Vector3,_vac=new _Vector.Vector3,_vbc=new _Vector.Vector3,_vap=new _Vector.Vector3,_vbp=new _Vector.Vector3,_vcp=new _Vector.Vector3;class Triangle{constructor(a=
new _Vector.Vector3,b=new _Vector.Vector3,c=new _Vector.Vector3){this.a=a;this.b=b;this.c=c}static getNormal(a,b,c,target){target.subVectors(c,b);_v0.subVectors(a,b);target.cross(_v0);a=target.lengthSq();return 0<a?target.multiplyScalar(1/Math.sqrt(a)):target.set(0,0,0)}static getBarycoord(point,a,b,c,target){_v0.subVectors(c,a);_v1.subVectors(b,a);_v2.subVectors(point,a);point=_v0.dot(_v0);a=_v0.dot(_v1);b=_v0.dot(_v2);var dot11=_v1.dot(_v1);c=_v1.dot(_v2);var denom=point*dot11-a*a;if(0===denom)return target.set(-2,
-1,-1);denom=1/denom;dot11=(dot11*b-a*c)*denom;point=(point*c-a*b)*denom;return target.set(1-dot11-point,point,dot11)}static containsPoint(point,a,b,c){this.getBarycoord(point,a,b,c,_v3);return 0<=_v3.x&&0<=_v3.y&&1>=_v3.x+_v3.y}static getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3);target.set(0,0);target.addScaledVector(uv1,_v3.x);target.addScaledVector(uv2,_v3.y);target.addScaledVector(uv3,_v3.z);return target}static isFrontFacing(a,b,c,direction){_v0.subVectors(c,
b);_v1.subVectors(a,b);return 0>_v0.cross(_v1).dot(direction)?!0:!1}set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);return this}setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this}setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this}clone(){return(new this.constructor).copy(this)}copy(triangle){this.a.copy(triangle.a);
this.b.copy(triangle.b);this.c.copy(triangle.c);return this}getArea(){_v0.subVectors(this.c,this.b);_v1.subVectors(this.a,this.b);return.5*_v0.cross(_v1).length()}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target)}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target)}getUV(point,
uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target)}containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c)}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction)}intersectsBox(box){return box.intersectsTriangle(this)}closestPointToPoint(p,target){const a=this.a;var b=this.b,c=this.c;_vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);var d1=_vab.dot(_vap),d2=_vac.dot(_vap);if(0>=d1&&0>=d2)return target.copy(a);
_vbp.subVectors(p,b);const d3=_vab.dot(_vbp),d4=_vac.dot(_vbp);if(0<=d3&&d4<=d3)return target.copy(b);var w=d1*d4-d3*d2;if(0>=w&&0<=d1&&0>=d3)return b=d1/(d1-d3),target.copy(a).addScaledVector(_vab,b);_vcp.subVectors(p,c);p=_vab.dot(_vcp);const d6=_vac.dot(_vcp);if(0<=d6&&p<=d6)return target.copy(c);d1=p*d2-d1*d6;if(0>=d1&&0<=d2&&0>=d6)return w=d2/(d2-d6),target.copy(a).addScaledVector(_vac,w);d2=d3*d6-p*d4;if(0>=d2&&0<=d4-d3&&0<=p-d6)return _vbc.subVectors(c,b),w=(d4-d3)/(d4-d3+(p-d6)),target.copy(b).addScaledVector(_vbc,
w);c=1/(d2+d1+w);b=d1*c;w*=c;return target.copy(a).addScaledVector(_vab,b).addScaledVector(_vac,w)}equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c)}}exports.Triangle=Triangle}
//# sourceMappingURL=module$node_modules$three$src$math$Triangle.js.map
