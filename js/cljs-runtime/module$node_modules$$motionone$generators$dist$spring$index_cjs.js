shadow$provide.module$node_modules$$motionone$generators$dist$spring$index_cjs=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});var utils=require("module$node_modules$$motionone$utils$dist$index_cjs"),defaults=require("module$node_modules$$motionone$generators$dist$spring$defaults_cjs"),utils$1=require("module$node_modules$$motionone$generators$dist$spring$utils_cjs"),hasReachedTarget=require("module$node_modules$$motionone$generators$dist$utils$has_reached_target_cjs"),
velocity=require("module$node_modules$$motionone$generators$dist$utils$velocity_cjs");exports.spring=({stiffness=defaults.defaults.stiffness,damping=defaults.defaults.damping,mass=defaults.defaults.mass,from=0,to=1,velocity:velocity$1=0,restSpeed=2,restDistance=.5}={})=>{velocity$1=velocity$1?utils.time.s(velocity$1):0;const state={done:!1,hasReachedTarget:!1,current:from,target:to},initialDelta=to-from,undampedAngularFreq=Math.sqrt(stiffness/mass)/1E3,dampingRatio=utils$1.calcDampingRatio(stiffness,
damping,mass);let resolveSpring;if(1>dampingRatio){const angularFreq=undampedAngularFreq*Math.sqrt(1-dampingRatio*dampingRatio);resolveSpring=t=>to-Math.exp(-dampingRatio*undampedAngularFreq*t)*((-velocity$1+dampingRatio*undampedAngularFreq*initialDelta)/angularFreq*Math.sin(angularFreq*t)+initialDelta*Math.cos(angularFreq*t))}else resolveSpring=t=>to-Math.exp(-undampedAngularFreq*t)*(initialDelta+(-velocity$1+undampedAngularFreq*initialDelta)*t);return t=>{state.current=resolveSpring(t);t=0===t?
velocity$1:velocity.calcGeneratorVelocity(resolveSpring,t,state.current);const isBelowDisplacementThreshold=Math.abs(to-state.current)<=restDistance;state.done=Math.abs(t)<=restSpeed&&isBelowDisplacementThreshold;state.hasReachedTarget=hasReachedTarget.hasReachedTarget(from,to,state.current);return state}}}
//# sourceMappingURL=module$node_modules$$motionone$generators$dist$spring$index_cjs.js.map
