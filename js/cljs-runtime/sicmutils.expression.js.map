{"version":3,"sources":["sicmutils/expression.cljc"],"mappings":"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","names":["sicmutils.expression/abstract-types","cljs.core/PROTOCOL_SENTINEL","this__4491__auto__","writer__4492__auto__","opt__4493__auto__","cljs.core/-write","sicmutils.expression/Literal","sicmutils.expression/->Literal","type","expression","m","_","cljs.core._EQ_","sicmutils.value/number?","sicmutils.value/zero?","sicmutils.value/one?","sicmutils.value/exact?","sicmutils.value/freeze","cljs.core.pr_str","this","meta","b","and__4251__auto__","sicmutils.value/=","cljs.core/-compare","writer","sicmutils.expression/make-literal","expr","sicmutils.expression/literal-apply","op","args","cljs.core/cons","cljs.core/seq","sicmutils.expression/literal?","x","sicmutils.expression/abstract?","cljs.core/contains?","sicmutils.expression/literal-type","sicmutils.expression/fmap","f","e","G__95584","sicmutils.expression/expression-of","sicmutils.expression/variables-in","cljs.core/Symbol","xs","cljs.core/rest","cljs.core/tree-seq","cljs.core/sequential?","cljs.core.into","cljs.core.filter","cljs.core/symbol?","sicmutils.expression/evaluate","sym->var","sym->f","node","vec__95599","seq__95600","first__95601","cljs.core/first","cljs.core/next","f-sym","temp__5751__auto__","cljs.core.apply","cljs.core.mapv","walk","sicmutils.util/illegal","var_args","G__95607","sicmutils.expression/substitute","js/Error","old","new","sicmutils.expression.substitute","s-map","p1__95604#","clojure.walk/postwalk-replace","sicmutils.expression/compare","l","r","lseq?","rseq?","rsym?","rstr?","l-empty?","cljs.core/empty?","r-empty?","raw-comp","cljs.core/Delay","cljs.core/compare","cljs.core/hash","cljs.core/deref","sicmutils.value/real?","n1","cljs.core/count","n2","head-compare","G__95621","G__95622","sicmutils.expression/sorted?","cljs.core/every?","p__95627","vec__95628","cljs.core.nth","cljs.core.partition","sicmutils.expression/sort","cljs.core.sort","G__95632","sicmutils.expression/expression->stream","stream","sicmutils.generic/simplify","cljs.pprint.write","options","opt-seq","cljs.core.assoc","cljs.core/concat","simple","cljs.pprint/write","sicmutils.expression/expression->string","sicmutils.expression/print-expression","cljs.pprint.pprint","sicmutils.expression/pe"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.expression\n  \"This namespace contains a number of functions and utilities for manipulating\n  and comparing raw symbolic expression trees.\n\n  Also included is an implementation of a [[Literal]] type that forms the basis\n  for [[sicmutils.abstract.number/literal-number]].\"\n  (:refer-clojure :exclude [sorted? compare sort])\n  (:require [clojure.core :as core]\n            [clojure.pprint :as pp]\n            [clojure.walk :as w]\n            [sicmutils.generic :as g]\n            [sicmutils.util :as u]\n            [sicmutils.value :as v])\n  #?(:clj\n     (:import (clojure.lang IObj))))\n\n(def ^{:doc \"These keywords reference 'abstract' types that stand in for some\n  concrete data type in the system.\"}\n  abstract-types\n  #{::numeric\n    ::vector\n    ::abstract-down\n    ::abstract-matrix})\n\n;; A Literal is a container type for literal expressions, abstract structures\n;; that stand in for some other type. The canonical example is a symbolic\n;; expression built out of Lisp data structures.\n;;\n;; Currently we only support these, but this type will be able to handle the\n;; other abstract structures referenced in [[abstract-types]].\n\n(deftype Literal [type expression m]\n  v/Numerical\n  (numerical? [_] (= type ::numeric))\n\n  v/Value\n  (zero? [_]\n    (and (v/number? expression)\n         (v/zero? expression)))\n\n  (one? [_]\n    (and (v/number? expression)\n         (v/one? expression)))\n\n  (identity? [_]\n    (and (v/number? expression)\n         (v/one? expression)))\n\n  (zero-like [_] 0)\n  (one-like [_] 1)\n  (identity-like [_] 1)\n  (exact? [_]\n    (and (v/number? expression)\n         (v/exact? expression)))\n  (freeze [_] (v/freeze expression))\n  (kind [_] type)\n\n  Object\n  (toString [_] (pr-str expression))\n  #?(:cljs\n     (valueOf [this]\n              (cond (number? expression)   expression\n                    (v/number? expression) (.valueOf expression)\n                    :else this)))\n  #?(:clj\n     (equals [_ b]\n             (if (instance? Literal b)\n               (let [b ^Literal b]\n                 (and (= type (.-type b))\n                      (v/= expression (.-expression b))\n                      (= m (.-m b))))\n               (v/= expression b))))\n\n  #?@(:clj\n      [IObj\n       (meta [_] m)\n       (withMeta [_ meta] (Literal. type expression meta))\n\n       Comparable\n       (compareTo [_ b]\n                  (if (instance? Literal b)\n                    (v/compare expression (.-expression ^Literal b))\n                    (v/compare expression b)))]\n\n      :cljs\n      [IMeta\n       (-meta [_] m)\n\n       IWithMeta\n       (-with-meta [_ meta] (Literal. type expression meta))\n\n       IEquiv\n       (-equiv [_ b]\n               (if (instance? Literal b)\n                 (let [b ^Literal b]\n                   (and (= type (.-type b))\n                        (v/= expression (.-expression b))\n                        (= m (.-m b))))\n                 (v/= expression b)))\n\n       IComparable\n       (-compare [_ b]\n                 (if (instance? Literal b)\n                   (-compare expression (.-expression ^Literal b))\n                   (-compare expression b)))\n\n       IPrintWithWriter\n       (-pr-writer\n        [_ writer _]\n        (-write writer (str expression)))]))\n\n#?(:clj\n   (defmethod print-method Literal [^Literal s w]\n     (print-method (.-expression s) w)))\n\n(defn make-literal\n  \"Constructs a [[Literal]] instance with the supplied type and an empty metadata\n  map out of the literal form `expr`.\"\n  [type expr]\n  (->Literal type expr nil))\n\n(defn literal-apply\n  \"Similar to [[make-literal]], but accepts:\n\n  - some operation\n  - the arguments to which it applies\n\n  Similar to `clojure.core/apply`.\n\n  For example:\n\n  ```clojure\n  (literal-apply ::numeric 'cos [1 2 3])\n  ;;=> (cos 1 2 3)\n  ```\"\n  [type op args]\n  (make-literal type (cons op (seq args))))\n\n(defn literal?\n  \"Returns true if `x` is a [[Literal]] instance, false otherwise.\"\n  [x]\n  (instance? Literal x))\n\n(defn abstract?\n  \"Returns true if `x` is both a [[Literal]] and has a type specified\n  in [[abstract-types]], false otherwise.\"\n  [x]\n  (and (literal? x)\n       (contains? abstract-types\n                  (.-type ^Literal x))))\n\n(defn literal-type\n  \"If `x` is a [[Literal]] instance, returns its type. Else, returns nil.\"\n  [x]\n  (when (literal? x)\n    (.-type ^Literal x)))\n\n(defn fmap\n  \"Returns a [[Literal]] generated by applying `f` to the expression part of\n  `e`.\n\n  [[literal-type]] and [[meta]] will return the same thing for `e` and the\n  return value.\"\n  [f ^Literal e]\n  (->Literal (.-type e)\n             (f (.-expression e))\n             (.-m e)))\n\n(defn expression-of\n  \"If the supplied argument is a [[Literal]] (or a symbol, interpreted elsewhere\n  as a numerical literal expression), returns the wrapped expression (or the\n  symbol).\n\n  Else, returns `expr`.\"\n  [expr]\n  (if (literal? expr)\n    (.-expression ^Literal expr)\n    expr))\n\n;; ## Expression Walking\n\n(defn variables-in\n  \"Return the set of 'variables' (e.g. symbols) found in `expr`.\n\n  `expr` is either a symbol, a [[Literal]] instance or some sequence\n  representing a symbolic expression.\"\n  [expr]\n  (cond (symbol? expr) #{expr}\n        (literal? expr) (recur (expression-of expr))\n        :else (let [xs (rest (tree-seq sequential? seq expr))]\n                (into #{} (filter symbol?) xs))))\n\n(defn evaluate\n  \"Walk the unwrapped expression `expr` in postorder, replacing symbols found\n  there with their values in the `sym->var` mapping, if present.\n\n  `sym->f` is used for elements in function application position (first of a\n  sequence).\"\n  [expr sym->var sym->f]\n  (letfn [(walk [node]\n            (cond (symbol? node) (sym->var node node)\n                  (sequential? node)\n                  (let [[f-sym & args] node]\n                    (if-let [f (sym->f f-sym)]\n                      ;; NOTE: without `mapv` (ie, with `map` and a lazy\n                      ;; sequence), we were getting heisenbugs in the rational\n                      ;; function simplifier, and `mismatched-arity` notes.\n                      (apply f (mapv walk args))\n                      (u/illegal (str \"Missing fn for symbol - \" f-sym))))\n                  :else node))]\n    (walk\n     (expression-of expr))))\n\n(defn substitute\n  \"Returns a form similar to `expr`, with all instances of `old` replaced by\n  `new`. Substitution occurs\n  in [postwalk](https://clojuredocs.org/clojure.walk/postwalk) order.\n\n  NOTE that this now works for expressions too.\"\n  ([expr old new]\n   (substitute expr {old new}))\n  ([expr s-map]\n   (if (literal? expr)\n     (fmap #(substitute % s-map) expr)\n     (w/postwalk-replace s-map expr))))\n\n(defn compare\n  \"Comparator for expressions. The rule is that types have the following ordering:\n\n  - empty sequence is < anything (except another empty seq)\n  - real < symbol < string < sequence\n  - sequences compare element-by-element\n\n  Any types _not_ in this list compare with the other type using hashes.\"\n  [l r]\n  (let [lseq?    (sequential? l)\n        rseq?    (sequential? r)\n        rsym?    (symbol? r)\n        rstr?    (string? r)\n        l-empty? (and lseq? (empty? l))\n        r-empty? (and rseq? (empty? r))\n        raw-comp (delay (core/compare (hash l) (hash r)))]\n\n    (cond (and l-empty? r-empty?) 0\n          l-empty?                -1\n          r-empty?                1\n          (v/real? l) (cond (v/real? r) (core/compare l r)\n                            (or rsym? rstr? rseq?)\n                            -1\n                            :else @raw-comp)\n          (v/real? r) 1\n\n          (symbol? l) (cond rsym? (core/compare l r)\n                            (or rstr? rseq?) -1\n                            :else @raw-comp)\n          rsym? 1\n\n          (string? l) (cond rstr? (core/compare l r)\n                            rseq? -1\n                            :else @raw-comp)\n          rstr? 1\n\n          lseq? (if rseq?\n                  (let [n1 (count l)\n                        n2 (count r)]\n                    (cond (< n1 n2) -1\n                          (< n2 n1) 1\n                          :else (let [head-compare (compare\n                                                    (first l) (first r))]\n                                  (if (zero? head-compare)\n                                    (recur (rest l) (rest r))\n                                    head-compare))))\n                  @raw-comp)\n          rseq? 1\n\n          :else @raw-comp)))\n\n(defn sorted? [xs]\n  (or (not (sequential? xs))\n      (every? (fn [[l r]]\n                (<= (compare l r) 0))\n              (partition 2 1 xs))))\n\n(defn sort [xs]\n  (if (sequential? xs)\n    (core/sort compare xs)\n    xs))\n\n;; ## Printing\n\n(defn expression->stream\n  \"Renders an expression through the simplifier and onto the stream.\"\n  ([expr stream]\n   (-> (g/simplify expr)\n       (pp/write :stream stream)))\n  ([expr stream options]\n   (let [opt-seq (->> (assoc options :stream stream)\n                      (apply concat))\n         simple (g/simplify expr)]\n     (apply pp/write simple opt-seq))))\n\n(defn expression->string\n  \"Returns a string representation of a frozen, simplified version of the supplied\n  expression `expr`.\"\n  [expr]\n  (pr-str\n   (v/freeze (g/simplify expr))))\n\n(defn print-expression [expr]\n  (pp/pprint\n   (v/freeze (g/simplify expr))))\n\n(def pe print-expression)\n"]}