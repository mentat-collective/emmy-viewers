shadow$provide.module$node_modules$three$src$math$Quaternion=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Quaternion=void 0;var MathUtils=function(obj,nodeInterop){if(!nodeInterop&&
obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,
key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$three$src$math$MathUtils"));class Quaternion{constructor(x=0,y=0,z=0,w=1){this._x=x;this._y=y;this._z=z;this._w=w}static slerp(qa,qb,qm,t){console.warn("THREE.Quaternion: Static .slerp() has been deprecated. Use qm.slerpQuaternions( qa, qb, t ) instead.");return qm.slerpQuaternions(qa,qb,t)}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){let x0=src0[srcOffset0+
0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2];src0=src0[srcOffset0+3];srcOffset0=src1[srcOffset1+0];const y1=src1[srcOffset1+1],z1=src1[srcOffset1+2];src1=src1[srcOffset1+3];if(0===t)dst[dstOffset+0]=x0,dst[dstOffset+1]=y0,dst[dstOffset+2]=z0,dst[dstOffset+3]=src0;else if(1===t)dst[dstOffset+0]=srcOffset0,dst[dstOffset+1]=y1,dst[dstOffset+2]=z1,dst[dstOffset+3]=src1;else{if(src0!==src1||x0!==srcOffset0||y0!==y1||z0!==z1){srcOffset1=1-t;var cos=x0*srcOffset0+y0*y1+z0*z1+src0*src1,dir=0<=cos?1:-1,
sqrSin=1-cos*cos;sqrSin>Number.EPSILON&&(sqrSin=Math.sqrt(sqrSin),cos=Math.atan2(sqrSin,cos*dir),srcOffset1=Math.sin(srcOffset1*cos)/sqrSin,t=Math.sin(t*cos)/sqrSin);dir*=t;x0=x0*srcOffset1+srcOffset0*dir;y0=y0*srcOffset1+y1*dir;z0=z0*srcOffset1+z1*dir;src0=src0*srcOffset1+src1*dir;srcOffset1===1-t&&(t=1/Math.sqrt(x0*x0+y0*y0+z0*z0+src0*src0),x0*=t,y0*=t,z0*=t,src0*=t)}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=src0}}static multiplyQuaternionsFlat(dst,dstOffset,src0,
srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2];src0=src0[srcOffset0+3];srcOffset0=src1[srcOffset1];const y1=src1[srcOffset1+1],z1=src1[srcOffset1+2];src1=src1[srcOffset1+3];dst[dstOffset]=x0*src1+src0*srcOffset0+y0*z1-z0*y1;dst[dstOffset+1]=y0*src1+src0*y1+z0*srcOffset0-x0*z1;dst[dstOffset+2]=z0*src1+src0*z1+x0*y1-y0*srcOffset0;dst[dstOffset+3]=src0*src1-x0*srcOffset0-y0*y1-z0*z1;return dst}get x(){return this._x}set x(value){this._x=value;this._onChangeCallback()}get y(){return this._y}set y(value){this._y=
value;this._onChangeCallback()}get z(){return this._z}set z(value){this._z=value;this._onChangeCallback()}get w(){return this._w}set w(value){this._w=value;this._onChangeCallback()}set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this}setFromEuler(euler,update){if(!euler||
!euler.isEuler)throw Error("THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.");var x=euler._x,y=euler._y,z=euler._z;euler=euler._order;var cos=Math.cos;const sin=Math.sin,c1=cos(x/2),c2=cos(y/2);cos=cos(z/2);x=sin(x/2);y=sin(y/2);z=sin(z/2);switch(euler){case "XYZ":this._x=x*c2*cos+c1*y*z;this._y=c1*y*cos-x*c2*z;this._z=c1*c2*z+x*y*cos;this._w=c1*c2*cos-x*y*z;break;case "YXZ":this._x=x*c2*cos+c1*y*z;this._y=c1*y*cos-x*c2*z;this._z=c1*c2*z-x*y*cos;this._w=
c1*c2*cos+x*y*z;break;case "ZXY":this._x=x*c2*cos-c1*y*z;this._y=c1*y*cos+x*c2*z;this._z=c1*c2*z+x*y*cos;this._w=c1*c2*cos-x*y*z;break;case "ZYX":this._x=x*c2*cos-c1*y*z;this._y=c1*y*cos+x*c2*z;this._z=c1*c2*z-x*y*cos;this._w=c1*c2*cos+x*y*z;break;case "YZX":this._x=x*c2*cos+c1*y*z;this._y=c1*y*cos+x*c2*z;this._z=c1*c2*z-x*y*cos;this._w=c1*c2*cos-x*y*z;break;case "XZY":this._x=x*c2*cos-c1*y*z;this._y=c1*y*cos-x*c2*z;this._z=c1*c2*z+x*y*cos;this._w=c1*c2*cos+x*y*z;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+
euler)}!1!==update&&this._onChangeCallback();return this}setFromAxisAngle(axis,angle){angle/=2;const s=Math.sin(angle);this._x=axis.x*s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(angle);this._onChangeCallback();return this}setFromRotationMatrix(m){var te=m.elements,m11=te[0];m=te[4];const m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6];te=te[10];const trace=m11+m22+te;0<trace?(m11=.5/Math.sqrt(trace+1),this._w=.25/m11,this._x=(m32-m23)*m11,this._y=(m13-m31)*m11,this._z=(m21-m)*
m11):m11>m22&&m11>te?(m11=2*Math.sqrt(1+m11-m22-te),this._w=(m32-m23)/m11,this._x=.25*m11,this._y=(m+m21)/m11,this._z=(m13+m31)/m11):m22>te?(m11=2*Math.sqrt(1+m22-m11-te),this._w=(m13-m31)/m11,this._x=(m+m21)/m11,this._y=.25*m11,this._z=(m23+m32)/m11):(m11=2*Math.sqrt(1+te-m11-m22),this._w=(m21-m)/m11,this._x=(m13+m31)/m11,this._y=(m23+m32)/m11,this._z=.25*m11);this._onChangeCallback();return this}setFromUnitVectors(vFrom,vTo){let r=vFrom.dot(vTo)+1;r<Number.EPSILON?(r=0,Math.abs(vFrom.x)>Math.abs(vFrom.z)?
(this._x=-vFrom.y,this._y=vFrom.x,this._z=0):(this._x=0,this._y=-vFrom.z,this._z=vFrom.y)):(this._x=vFrom.y*vTo.z-vFrom.z*vTo.y,this._y=vFrom.z*vTo.x-vFrom.x*vTo.z,this._z=vFrom.x*vTo.y-vFrom.y*vTo.x);this._w=r;return this.normalize()}angleTo(q){return 2*Math.acos(Math.abs(MathUtils.clamp(this.dot(q),-1,1)))}rotateTowards(q,step){const angle=this.angleTo(q);if(0===angle)return this;this.slerp(q,Math.min(1,step/angle));return this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){this._x*=
-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this}dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let l=this.length();0===l?(this._z=this._y=this._x=0,this._w=1):(l=1/l,this._x*=l,this._y*=l,this._z*=l,this._w*=l);this._onChangeCallback();return this}multiply(q,p){return void 0!==p?(console.warn("THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead."),
this.multiplyQuaternions(q,p)):this.multiplyQuaternions(this,q)}premultiply(q){return this.multiplyQuaternions(q,this)}multiplyQuaternions(a,b){const qax=a._x,qay=a._y,qaz=a._z;a=a._w;const qbx=b._x,qby=b._y,qbz=b._z;b=b._w;this._x=qax*b+a*qbx+qay*qbz-qaz*qby;this._y=qay*b+a*qby+qaz*qbx-qax*qbz;this._z=qaz*b+a*qbz+qax*qby-qay*qbx;this._w=a*b-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this}slerp(qb,t){if(0===t)return this;if(1===t)return this.copy(qb);const x=this._x,y=this._y,z=this._z,
w=this._w;var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;0>cosHalfTheta?(this._w=-qb._w,this._x=-qb._x,this._y=-qb._y,this._z=-qb._z,cosHalfTheta=-cosHalfTheta):this.copy(qb);if(1<=cosHalfTheta)return this._w=w,this._x=x,this._y=y,this._z=z,this;qb=1-cosHalfTheta*cosHalfTheta;if(qb<=Number.EPSILON)return cosHalfTheta=1-t,this._w=cosHalfTheta*w+t*this._w,this._x=cosHalfTheta*x+t*this._x,this._y=cosHalfTheta*y+t*this._y,this._z=cosHalfTheta*z+t*this._z,this.normalize(),this._onChangeCallback(),this;
qb=Math.sqrt(qb);const halfTheta=Math.atan2(qb,cosHalfTheta);cosHalfTheta=Math.sin((1-t)*halfTheta)/qb;t=Math.sin(t*halfTheta)/qb;this._w=w*cosHalfTheta+this._w*t;this._x=x*cosHalfTheta+this._x*t;this._y=y*cosHalfTheta+this._y*t;this._z=z*cosHalfTheta+this._z*t;this._onChangeCallback();return this}slerpQuaternions(qa,qb,t){return this.copy(qa).slerp(qb,t)}random(){var u1=Math.random();const sqrt1u1=Math.sqrt(1-u1);u1=Math.sqrt(u1);const u2=2*Math.PI*Math.random(),u3=2*Math.PI*Math.random();return this.set(sqrt1u1*
Math.cos(u2),u1*Math.sin(u3),u1*Math.cos(u3),sqrt1u1*Math.sin(u2))}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w}fromArray(array,offset=0){this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array}fromBufferAttribute(attribute,
index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this}_onChange(callback){this._onChangeCallback=callback;return this}_onChangeCallback(){}}exports.Quaternion=Quaternion;Quaternion.prototype.isQuaternion=!0}
//# sourceMappingURL=module$node_modules$three$src$math$Quaternion.js.map
