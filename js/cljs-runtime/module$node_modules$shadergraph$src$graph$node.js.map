{
"version":3,
"file":"module$node_modules$shadergraph$src$graph$node.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/shadergraph/src/graph/node.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$shadergraph$src$graph$node\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Node = void 0;\n\nvar _graph = require(\"./graph\");\n\nvar _outlet = require(\"./outlet\");\n\n/*\n * decaffeinate suggestions:\n * DS101: Remove unnecessary use of Array.from\n * DS102: Remove unnecessary code created because of implicit returns\n * DS206: Consider reworking classes to avoid initClass\n * DS207: Consider shorter variations of null checks\n * Full docs: https://github.com/decaffeinate/decaffeinate/blob/master/docs/suggestions.md\n */\n\n/*\n Node in graph.\n*/\nclass Node {\n  static initClass() {\n    this.index = 0;\n  }\n\n  static id(_name) {\n    return ++Node.index;\n  }\n\n  constructor(owner, outlets) {\n    this.owner = owner;\n    this.graph = null;\n    this.inputs = [];\n    this.outputs = [];\n    this.all = [];\n    this.outlets = null;\n    this.id = Node.id();\n    this.setOutlets(outlets);\n  } // Retrieve input\n\n\n  getIn(name) {\n    return Array.from(this.inputs).filter(outlet => outlet.name === name)[0];\n  } // Retrieve output\n\n\n  getOut(name) {\n    return Array.from(this.outputs).filter(outlet => outlet.name === name)[0];\n  } // Retrieve by name\n\n\n  get(name) {\n    return this.getIn(name) || this.getOut(name);\n  } // Set new outlet definition\n\n\n  setOutlets(outlets) {\n    if (outlets != null) {\n      // First init\n      let outlet;\n\n      if (this.outlets == null) {\n        this.outlets = {};\n\n        for (outlet of Array.from(outlets)) {\n          if (!(outlet instanceof _outlet.Outlet)) {\n            outlet = _outlet.Outlet.make(outlet);\n          }\n\n          this._add(outlet);\n        }\n\n        return;\n      } // Return new/old outlet matching hash key\n\n\n      const hash = (outlet // Match by name, direction and type.\n      ) => [outlet.name, outlet.inout, outlet.type].join(\"-\"); // Build hash of new outlets\n\n\n      const match = {};\n\n      for (outlet of Array.from(outlets)) {\n        match[hash(outlet)] = true;\n      } // Remove missing outlets, record matches\n\n\n      for (let key in this.outlets) {\n        outlet = this.outlets[key];\n        key = hash(outlet);\n\n        if (match[key]) {\n          match[key] = outlet;\n        } else {\n          this._remove(outlet);\n        }\n      } // Insert new outlets\n\n\n      for (outlet of Array.from(outlets)) {\n        // Find match by hash\n        const existing = match[hash(outlet)];\n\n        if (existing instanceof _outlet.Outlet) {\n          // Update existing outlets in place to retain connections.\n          this._morph(existing, outlet);\n        } else {\n          // Spawn new outlet\n          if (!(outlet instanceof _outlet.Outlet)) {\n            outlet = _outlet.Outlet.make(outlet);\n          }\n\n          this._add(outlet);\n        }\n      }\n\n      this;\n    }\n\n    return this.outlets;\n  } // Connect to the target node by matching up inputs and outputs.\n\n\n  connect(node, empty, force) {\n    let dest, dests, hint, source, type;\n    const outlets = {};\n    const hints = {};\n\n    const typeHint = outlet => type + \"/\" + outlet.hint; // Hash the types/hints of available target outlets.\n\n\n    for (dest of Array.from(node.inputs)) {\n      // Only autoconnect if not already connected\n      let list;\n\n      if (!force && dest.input) {\n        continue;\n      } // Match outlets by type/name hint, then type/position key\n\n\n      ({\n        type\n      } = dest);\n      hint = typeHint(dest);\n\n      if (!hints[hint]) {\n        hints[hint] = dest;\n      }\n\n      outlets[type] = list = outlets[type] || [];\n      list.push(dest);\n    } // Available source outlets\n\n\n    let sources = this.outputs; // Ignore connected source if only matching empties.\n\n    sources = sources.filter(outlet => !(empty && outlet.output.length)); // Match hints first\n\n    for (source of Array.from(sources.slice())) {\n      // Match outlets by type and name\n      ({\n        type\n      } = source);\n      hint = typeHint(source);\n      dests = outlets[type]; // Connect if found\n\n      if (dest = hints[hint]) {\n        source.connect(dest); // Remove from potential set\n\n        delete hints[hint];\n        dests.splice(dests.indexOf(dest), 1);\n        sources.splice(sources.indexOf(source), 1);\n      }\n    } // Match what's left\n\n\n    if (!sources.length) {\n      return this;\n    }\n\n    for (source of Array.from(sources.slice())) {\n      ({\n        type\n      } = source);\n      dests = outlets[type]; // Match outlets by type and order\n\n      if (dests && dests.length) {\n        // Link up and remove from potential set\n        source.connect(dests.shift());\n      }\n    }\n\n    return this;\n  } // Disconnect entire node\n\n\n  disconnect(_node) {\n    let outlet;\n\n    for (outlet of Array.from(this.inputs)) {\n      outlet.disconnect();\n    }\n\n    for (outlet of Array.from(this.outputs)) {\n      outlet.disconnect();\n    }\n\n    return this;\n  } // Return hash key for outlet\n\n\n  _key(outlet) {\n    return [outlet.name, outlet.inout].join(\"-\");\n  } // Add outlet object to node\n\n\n  _add(outlet) {\n    const key = this._key(outlet); // Sanity checks\n\n\n    if (outlet.node) {\n      throw new Error(\"Adding outlet to two nodes at once.\");\n    }\n\n    if (this.outlets[key]) {\n      throw new Error(`Adding two identical outlets to same node. (${key})`);\n    } // Link back outlet\n\n\n    outlet.node = this; // Add to name hash and inout list\n\n    if (outlet.inout === _graph.Graph.IN) {\n      this.inputs.push(outlet);\n    }\n\n    if (outlet.inout === _graph.Graph.OUT) {\n      this.outputs.push(outlet);\n    }\n\n    this.all.push(outlet);\n    return this.outlets[key] = outlet;\n  } // Morph outlet to other\n\n\n  _morph(existing, outlet) {\n    let key = this._key(outlet);\n\n    delete this.outlets[key];\n    existing.morph(outlet);\n    key = this._key(outlet);\n    return this.outlets[key] = outlet;\n  } // Remove outlet object from node.\n\n\n  _remove(outlet) {\n    const key = this._key(outlet); // Sanity checks\n\n\n    if (outlet.node !== this) {\n      throw new Error(\"Removing outlet from wrong node.\");\n    } // Disconnect outlet.\n\n\n    outlet.disconnect(); // Unlink outlet.\n\n    outlet.node = null; // Remove from name list and inout list.\n\n    delete this.outlets[key];\n\n    if (outlet.inout === _graph.Graph.IN) {\n      this.inputs.splice(this.inputs.indexOf(outlet), 1);\n    }\n\n    if (outlet.inout === _graph.Graph.OUT) {\n      this.outputs.splice(this.outputs.indexOf(outlet), 1);\n    }\n\n    this.all.splice(this.all.indexOf(outlet), 1);\n    return this;\n  }\n\n}\n\nexports.Node = Node;\nNode.initClass();\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","Node","_graph","_outlet","initClass","index","id","_name","constructor","owner","outlets","graph","inputs","outputs","all","setOutlets","getIn","name","Array","from","filter","outlet","getOut","get","Outlet","make","_add","match","inout","type","join","key","_remove","existing","_morph","connect","node","empty","force","dest","source","hints","input","hint","list","push","sources","output","length","slice","dests","splice","indexOf","shift","disconnect","_node","_key","Error","Graph","IN","OUT","morph"]
}
