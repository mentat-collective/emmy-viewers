shadow$provide.module$node_modules$shadergraph$src$block$callback=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Callback=void 0;var _graph=require("module$node_modules$shadergraph$src$graph$index");global=require("module$node_modules$shadergraph$src$block$block");class Callback extends global.Block{constructor(graph){super(!0);this.graph=graph;this.construct()}refresh(){super.refresh();return delete this.subroutine}clone(){return new Callback(this.graph)}makeOutlets(){let outlet$jscomp$0;
this.make();const outlets=[];let ins=[],outs=[];const handle=(outlet,list)=>{if(outlet.meta.callback){if(outlet.inout===_graph.Graph.IN)return list=outlet.dupe(),null==list.meta.child&&(list.meta.child=outlet),outlet.meta.parent=list,outlets.push(list)}else return list.push(outlet.type)};for(outlet$jscomp$0 of Array.from(this.graph.inputs()))handle(outlet$jscomp$0,ins);for(outlet$jscomp$0 of Array.from(this.graph.outputs()))handle(outlet$jscomp$0,outs);ins=ins.join(",");outs=outs.join(",");outlets.push({name:"callback",
type:`(${ins})(${outs})`,inout:_graph.Graph.OUT,meta:{callback:!0,def:this.subroutine.main}});return outlets}make(){return this.subroutine=this.graph.compile(this.namespace)}export(layout,depth){if(layout.visit(this.namespace,depth))return this._link(this.subroutine,layout,depth),this.graph.export(layout,depth)}call(program,depth){return this._require(this.subroutine,program,depth)}callback(layout,depth,name,external,outlet){this._include(this.subroutine,layout,depth);return this._callback(this.subroutine,
layout,depth,name,external,outlet)}}exports.Callback=Callback}
//# sourceMappingURL=module$node_modules$shadergraph$src$block$callback.js.map
