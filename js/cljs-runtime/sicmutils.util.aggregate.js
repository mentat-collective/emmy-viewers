goog.provide('sicmutils.util.aggregate');
/**
 * Sums either:
 * 
 *   - a series `xs` of numbers, or
 *   - the result of mapping function `f` to `(range low high)`
 * 
 *   Using the generic [[sicmutils.generic/+]] function.
 */
sicmutils.util.aggregate.generic_sum = sicmutils.algebra.fold.fold__GT_sum_fn.cljs$core$IFn$_invoke$arity$1(sicmutils.generic._PLUS_);
/**
 * Fold used to aggregate values encountered by [[sum]] or [[fold]].
 * 
 *   Rebind this value to change the behavior of [[sum]] or [[fold]].
 * 
 *   Defaults to [[sicmutils.algebra.fold/kahan-babushka-neumaier-fold]].
 */
sicmutils.util.aggregate._STAR_fold_STAR_ = sicmutils.algebra.fold.kahan_babushka_neumaier;
/**
 * Takes either:
 * 
 *   - a series `xs` of numbers
 *   - A transformation function `f`, an inclusive-lower bound `low` and
 *  exclusive-upper bound `upper`
 * 
 *   And returns the result of aggregating either `xs` or `(map f (range low
 *   high))` using the fold dynamically bound to [[*fold*]].
 * 
 *   Use `binding` to substitute in a different fold:
 * 
 *   ```clj
 *   (require '[sicmutils.algebra.fold :as af])
 * 
 *   (binding [*fold* (af/join af/kahan af/min af/max)]
 *  (sum inc 0 10))
 *   ;;=> [55.0 1 10]
 *   ```
 */
sicmutils.util.aggregate.sum = (function sicmutils$util$aggregate$sum(var_args){
var G__95765 = arguments.length;
switch (G__95765) {
case 1:
return sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 3:
return sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$1 = (function (xs){
return sicmutils.util.aggregate._STAR_fold_STAR_.call(null,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(sicmutils.util.aggregate._STAR_fold_STAR_,sicmutils.util.aggregate._STAR_fold_STAR_.call(null),xs));
}));

(sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$3 = (function (f,low,high){
var xs = cljs.core.range.cljs$core$IFn$_invoke$arity$2(low,high);
return cljs.core.transduce.cljs$core$IFn$_invoke$arity$3(cljs.core.map.cljs$core$IFn$_invoke$arity$1(f),sicmutils.util.aggregate._STAR_fold_STAR_,xs);
}));

(sicmutils.util.aggregate.sum.cljs$lang$maxFixedArity = 3);

/**
 * Takes either:
 * 
 *   - a series `xs` of numbers
 *   - A transformation function `f`, an inclusive-lower bound `low` and
 *  exclusive-upper bound `upper`
 * 
 *   And returns a lazy sequence of all intermediate values seen while aggregating
 *   either `xs` or `(map f (range low high))` using the fold dynamically bound
 *   to [[*fold*]].
 * 
 *   Use `binding` to substitute in a different fold:
 * 
 *   ```clj
 *   (require '[sicmutils.algebra.fold :as af])
 * 
 *   (binding [*fold* (af/join af/kahan af/min af/max)]
 *  (scan inc 0 3))
 *   ;;=> ([1.0 1 1] [3.0 1 2] [6.0 1 3])
 *   ```
 */
sicmutils.util.aggregate.scan = (function sicmutils$util$aggregate$scan(var_args){
var G__95770 = arguments.length;
switch (G__95770) {
case 1:
return sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 3:
return sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$1 = (function (xs){
return cljs.core.map.cljs$core$IFn$_invoke$arity$2(sicmutils.util.aggregate._STAR_fold_STAR_,cljs.core.rest(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(sicmutils.util.aggregate._STAR_fold_STAR_,sicmutils.util.aggregate._STAR_fold_STAR_.call(null),xs)));
}));

(sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$3 = (function (f,low,high){
return sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,cljs.core.range.cljs$core$IFn$_invoke$arity$2(low,high)));
}));

(sicmutils.util.aggregate.scan.cljs$lang$maxFixedArity = 3);

/**
 * Dynamically bindable size below which [[pairwise-sum]] will defer
 *   to [[sum]] to aggregate values.
 */
sicmutils.util.aggregate._STAR_cutoff_STAR_ = (128);
/**
 * Given a vector of numbers, returns the [pairwise
 *   summation](https://en.wikipedia.org/wiki/Pairwise_summation) of the vector
 *   generated by arranging the vector into a binary tree and summing leaves
 *   together all the way up to the root.
 * 
 *   If `xs` is /not/ a vector, [[pairwise-sum]] will realize all elements into a
 *   vector before operating.
 * 
 *   If the initial vector, or some recursive slice, reaches a count
 *   <= [[*cutoff*]], [[pairwise-sum]] defers to `(reduce + xs)`.
 * 
 *   ### Performance Discussion
 * 
 *   [[pairwise-sum]] is perhaps 10% faster than [[sum]]
 *   with [[sicmutils.algebra.fold/kbn]] bound to [[*fold*]], but has poorer bounds
 *   on its error growth. Instead of having roughly constant error regardless of
 *   the size of the input, in the worst case its accumulated error grows with
 *   $O(\log n)$.
 * 
 *   This improvement is due to the fact that [[pairwise-sum]] tends to add up
 *   numbers of similar magnitude, instead of adding deltas into a progressively
 *   larger sum.
 * 
 *   This implementation was inspired by the `pairwiseSum` implementation in
 *   the [`math-functions`](https://hackage.haskell.org/package/math-functions-0.3.4.2/docs/src/Numeric.Sum.html#pairwiseSum)
 *   Haskell package. The notes above were adapted from that function's docs.
 */
sicmutils.util.aggregate.pairwise_sum = (function sicmutils$util$aggregate$pairwise_sum(var_args){
var G__95796 = arguments.length;
switch (G__95796) {
case 1:
return sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 3:
return sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$1 = (function (xs){
var f = (function sicmutils$util$aggregate$f(v){
var n = cljs.core.count(v);
if((n <= sicmutils.util.aggregate._STAR_cutoff_STAR_)){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,v);
} else {
var split_idx = (n >> (1));
var l = cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(v,(0),split_idx);
var r = cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(v,split_idx);
return (sicmutils$util$aggregate$f(l) + sicmutils$util$aggregate$f(r));
}
});
return f(((cljs.core.vector_QMARK_(xs))?xs:cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,xs)));
}));

(sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$3 = (function (f,low,high){
return sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$1(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(f,cljs.core.range.cljs$core$IFn$_invoke$arity$2(low,high)));
}));

(sicmutils.util.aggregate.pairwise_sum.cljs$lang$maxFixedArity = 3);

/**
 * If `stop?` is false, returns `f`. Else, returns a binary reducing function that
 *   returns a `reduced` value if its left argument returns `true` for `stop?`,
 *   else aggregates with `f`.
 */
sicmutils.util.aggregate.combiner = (function sicmutils$util$aggregate$combiner(f,stop_QMARK_){
if(cljs.core.truth_(stop_QMARK_)){
return (function (l,r){
if(cljs.core.truth_((stop_QMARK_.cljs$core$IFn$_invoke$arity$1 ? stop_QMARK_.cljs$core$IFn$_invoke$arity$1(l) : stop_QMARK_.call(null,l)))){
return cljs.core.reduced(l);
} else {
return (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(l,r) : f.call(null,l,r));
}
});
} else {
return f;
}
});
/**
 * Accepts a binary (associative) aggregation function `plus` and an identity
 *   element `id` and returns a multi-arity function that will combine its
 *   arguments via `plus`. A 0-arity call returns `id`.
 * 
 *   optionally takes an `annihilate?` function that should return true for any `x`
 *   such that `(plus x <any>) == x`.
 * 
 *   If the `annihilate?` function is supplied, then if the aggregation produces a
 *   value that returns `(annihilate? true)` at any point, the reduction will
 *   return immediately.
 */
sicmutils.util.aggregate.monoid = (function sicmutils$util$aggregate$monoid(var_args){
var G__95802 = arguments.length;
switch (G__95802) {
case 2:
return sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
case 3:
return sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$2 = (function (plus,id){
return sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$3(plus,id,null);
}));

(sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$3 = (function (plus,id,annihilate_QMARK_){
var acc = sicmutils.util.aggregate.combiner(plus,annihilate_QMARK_);
return (function() {
var G__95839 = null;
var G__95839__0 = (function (){
return id;
});
var G__95839__1 = (function (x){
return x;
});
var G__95839__2 = (function (x,y){
return (plus.cljs$core$IFn$_invoke$arity$2 ? plus.cljs$core$IFn$_invoke$arity$2(x,y) : plus.call(null,x,y));
});
var G__95839__3 = (function() { 
var G__95840__delegate = function (x,y,more){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(acc,x,cljs.core.cons(y,more));
};
var G__95840 = function (x,y,var_args){
var more = null;
if (arguments.length > 2) {
var G__95841__i = 0, G__95841__a = new Array(arguments.length -  2);
while (G__95841__i < G__95841__a.length) {G__95841__a[G__95841__i] = arguments[G__95841__i + 2]; ++G__95841__i;}
  more = new cljs.core.IndexedSeq(G__95841__a,0,null);
} 
return G__95840__delegate.call(this,x,y,more);};
G__95840.cljs$lang$maxFixedArity = 2;
G__95840.cljs$lang$applyTo = (function (arglist__95842){
var x = cljs.core.first(arglist__95842);
arglist__95842 = cljs.core.next(arglist__95842);
var y = cljs.core.first(arglist__95842);
var more = cljs.core.rest(arglist__95842);
return G__95840__delegate(x,y,more);
});
G__95840.cljs$core$IFn$_invoke$arity$variadic = G__95840__delegate;
return G__95840;
})()
;
G__95839 = function(x,y,var_args){
var more = var_args;
switch(arguments.length){
case 0:
return G__95839__0.call(this);
case 1:
return G__95839__1.call(this,x);
case 2:
return G__95839__2.call(this,x,y);
default:
var G__95843 = null;
if (arguments.length > 2) {
var G__95844__i = 0, G__95844__a = new Array(arguments.length -  2);
while (G__95844__i < G__95844__a.length) {G__95844__a[G__95844__i] = arguments[G__95844__i + 2]; ++G__95844__i;}
G__95843 = new cljs.core.IndexedSeq(G__95844__a,0,null);
}
return G__95839__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__95843);
}
throw(new Error('Invalid arity: ' + arguments.length));
};
G__95839.cljs$lang$maxFixedArity = 2;
G__95839.cljs$lang$applyTo = G__95839__3.cljs$lang$applyTo;
G__95839.cljs$core$IFn$_invoke$arity$0 = G__95839__0;
G__95839.cljs$core$IFn$_invoke$arity$1 = G__95839__1;
G__95839.cljs$core$IFn$_invoke$arity$2 = G__95839__2;
G__95839.cljs$core$IFn$_invoke$arity$variadic = G__95839__3.cljs$core$IFn$_invoke$arity$variadic;
return G__95839;
})()
}));

(sicmutils.util.aggregate.monoid.cljs$lang$maxFixedArity = 3);

/**
 * Similar to [[monoid]] for types with invertible elements. Accepts:
 * 
 *   - binary `minus` and (associative) `plus` functions
 *   - a unary `negate` function
 *   - an element `id` that obeys `(plus id other) == (plus other id) == other`
 *   - optionally, an `annihilate?` function that should return true for any `x`
 *  such that `(plus x <any>) == x`.
 * 
 *   And returns a function that will SUBTRACT elements. Given `x`, `y`, `z`, for
 *   example, the returned function will return `(- x y z)`, implemented as `(minus
 *   x (plus y z))`
 * 
 *   If the `annihilate?` function is supplied, then if the aggregation produces a
 *   value that returns `(annihilate? true)` at any point, the reduction will
 *   return immediately.
 */
sicmutils.util.aggregate.group = (function sicmutils$util$aggregate$group(var_args){
var G__95804 = arguments.length;
switch (G__95804) {
case 4:
return sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));

break;
case 5:
return sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$4 = (function (minus,plus,invert,id){
return sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$5(minus,plus,invert,id,null);
}));

(sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$5 = (function (minus,plus,invert,id,annihilate_QMARK_){
var acc = sicmutils.util.aggregate.combiner(plus,annihilate_QMARK_);
return (function() {
var G__95847 = null;
var G__95847__0 = (function (){
return id;
});
var G__95847__1 = (function (x){
return (invert.cljs$core$IFn$_invoke$arity$1 ? invert.cljs$core$IFn$_invoke$arity$1(x) : invert.call(null,x));
});
var G__95847__2 = (function (x,y){
return (minus.cljs$core$IFn$_invoke$arity$2 ? minus.cljs$core$IFn$_invoke$arity$2(x,y) : minus.call(null,x,y));
});
var G__95847__3 = (function() { 
var G__95848__delegate = function (x,y,more){
var G__95818 = x;
var G__95819 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(acc,y,more);
return (minus.cljs$core$IFn$_invoke$arity$2 ? minus.cljs$core$IFn$_invoke$arity$2(G__95818,G__95819) : minus.call(null,G__95818,G__95819));
};
var G__95848 = function (x,y,var_args){
var more = null;
if (arguments.length > 2) {
var G__95849__i = 0, G__95849__a = new Array(arguments.length -  2);
while (G__95849__i < G__95849__a.length) {G__95849__a[G__95849__i] = arguments[G__95849__i + 2]; ++G__95849__i;}
  more = new cljs.core.IndexedSeq(G__95849__a,0,null);
} 
return G__95848__delegate.call(this,x,y,more);};
G__95848.cljs$lang$maxFixedArity = 2;
G__95848.cljs$lang$applyTo = (function (arglist__95850){
var x = cljs.core.first(arglist__95850);
arglist__95850 = cljs.core.next(arglist__95850);
var y = cljs.core.first(arglist__95850);
var more = cljs.core.rest(arglist__95850);
return G__95848__delegate(x,y,more);
});
G__95848.cljs$core$IFn$_invoke$arity$variadic = G__95848__delegate;
return G__95848;
})()
;
G__95847 = function(x,y,var_args){
var more = var_args;
switch(arguments.length){
case 0:
return G__95847__0.call(this);
case 1:
return G__95847__1.call(this,x);
case 2:
return G__95847__2.call(this,x,y);
default:
var G__95851 = null;
if (arguments.length > 2) {
var G__95852__i = 0, G__95852__a = new Array(arguments.length -  2);
while (G__95852__i < G__95852__a.length) {G__95852__a[G__95852__i] = arguments[G__95852__i + 2]; ++G__95852__i;}
G__95851 = new cljs.core.IndexedSeq(G__95852__a,0,null);
}
return G__95847__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__95851);
}
throw(new Error('Invalid arity: ' + arguments.length));
};
G__95847.cljs$lang$maxFixedArity = 2;
G__95847.cljs$lang$applyTo = G__95847__3.cljs$lang$applyTo;
G__95847.cljs$core$IFn$_invoke$arity$0 = G__95847__0;
G__95847.cljs$core$IFn$_invoke$arity$1 = G__95847__1;
G__95847.cljs$core$IFn$_invoke$arity$2 = G__95847__2;
G__95847.cljs$core$IFn$_invoke$arity$variadic = G__95847__3.cljs$core$IFn$_invoke$arity$variadic;
return G__95847;
})()
}));

(sicmutils.util.aggregate.group.cljs$lang$maxFixedArity = 5);

/**
 * NOTE that the returned function recurs on increasing indices internally instead
 *   of walking through the lists directly. This method of traversing vectors is
 *   more efficient, and this function is called so often that the performance gain
 *   is worth it, and reads almost like the explicit sequence traversal.
 */
sicmutils.util.aggregate.merge_fn = (function sicmutils$util$aggregate$merge_fn(compare,add,zero_QMARK_,make){
return (function() {
var G__95857 = null;
var G__95857__0 = (function (){
return cljs.core.PersistentVector.EMPTY;
});
var G__95857__1 = (function (xs){
return xs;
});
var G__95857__2 = (function (xs,ys){
var i = cljs.core.long$((0));
var j = cljs.core.long$((0));
var result = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);
while(true){
var x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(xs,i,null);
var y = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(ys,j,null);
if(cljs.core.not(x)){
return cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.persistent_BANG_(result),cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(ys,j));
} else {
if(cljs.core.not(y)){
return cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.persistent_BANG_(result),cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(xs,i));
} else {
var vec__95829 = x;
var x_tags = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95829,(0),null);
var x_coef = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95829,(1),null);
var vec__95832 = y;
var y_tags = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95832,(0),null);
var y_coef = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95832,(1),null);
var compare_flag = (compare.cljs$core$IFn$_invoke$arity$2 ? compare.cljs$core$IFn$_invoke$arity$2(x_tags,y_tags) : compare.call(null,x_tags,y_tags));
if(cljs.core.truth_((zero_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zero_QMARK_.cljs$core$IFn$_invoke$arity$1(compare_flag) : zero_QMARK_.call(null,compare_flag)))){
var sum = (add.cljs$core$IFn$_invoke$arity$2 ? add.cljs$core$IFn$_invoke$arity$2(x_coef,y_coef) : add.call(null,x_coef,y_coef));
var G__95860 = (i + (1));
var G__95861 = (j + (1));
var G__95862 = (cljs.core.truth_((zero_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zero_QMARK_.cljs$core$IFn$_invoke$arity$1(sum) : zero_QMARK_.call(null,sum)))?result:cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(result,(make.cljs$core$IFn$_invoke$arity$2 ? make.cljs$core$IFn$_invoke$arity$2(x_tags,sum) : make.call(null,x_tags,sum))));
i = G__95860;
j = G__95861;
result = G__95862;
continue;
} else {
if((compare_flag < (0))){
var G__95863 = (i + (1));
var G__95864 = j;
var G__95865 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(result,x);
i = G__95863;
j = G__95864;
result = G__95865;
continue;
} else {
var G__95866 = i;
var G__95867 = (j + (1));
var G__95868 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(result,y);
i = G__95866;
j = G__95867;
result = G__95868;
continue;

}
}

}
}
break;
}
});
G__95857 = function(xs,ys){
switch(arguments.length){
case 0:
return G__95857__0.call(this);
case 1:
return G__95857__1.call(this,xs);
case 2:
return G__95857__2.call(this,xs,ys);
}
throw(new Error('Invalid arity: ' + arguments.length));
};
G__95857.cljs$core$IFn$_invoke$arity$0 = G__95857__0;
G__95857.cljs$core$IFn$_invoke$arity$1 = G__95857__1;
G__95857.cljs$core$IFn$_invoke$arity$2 = G__95857__2;
return G__95857;
})()
});

//# sourceMappingURL=sicmutils.util.aggregate.js.map
