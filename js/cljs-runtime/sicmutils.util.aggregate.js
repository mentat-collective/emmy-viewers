goog.provide('sicmutils.util.aggregate');
/**
 * Sums either:
 * 
 *   - a series `xs` of numbers, or
 *   - the result of mapping function `f` to `(range low high)`
 * 
 *   Using the generic [[sicmutils.generic/+]] function.
 */
sicmutils.util.aggregate.generic_sum = sicmutils.algebra.fold.fold__GT_sum_fn.cljs$core$IFn$_invoke$arity$1(sicmutils.generic._PLUS_);
/**
 * Fold used to aggregate values encountered by [[sum]] or [[fold]].
 * 
 *   Rebind this value to change the behavior of [[sum]] or [[fold]].
 * 
 *   Defaults to [[sicmutils.algebra.fold/kahan-babushka-neumaier-fold]].
 */
sicmutils.util.aggregate._STAR_fold_STAR_ = sicmutils.algebra.fold.kahan_babushka_neumaier;
/**
 * Takes either:
 * 
 *   - a series `xs` of numbers
 *   - A transformation function `f`, an inclusive-lower bound `low` and
 *  exclusive-upper bound `upper`
 * 
 *   And returns the result of aggregating either `xs` or `(map f (range low
 *   high))` using the fold dynamically bound to [[*fold*]].
 * 
 *   Use `binding` to substitute in a different fold:
 * 
 *   ```clj
 *   (require '[sicmutils.algebra.fold :as af])
 * 
 *   (binding [*fold* (af/join af/kahan af/min af/max)]
 *  (sum inc 0 10))
 *   ;;=> [55.0 1 10]
 *   ```
 */
sicmutils.util.aggregate.sum = (function sicmutils$util$aggregate$sum(var_args){
var G__95713 = arguments.length;
switch (G__95713) {
case 1:
return sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 3:
return sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$1 = (function (xs){
return sicmutils.util.aggregate._STAR_fold_STAR_.call(null,cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(sicmutils.util.aggregate._STAR_fold_STAR_,sicmutils.util.aggregate._STAR_fold_STAR_.call(null),xs));
}));

(sicmutils.util.aggregate.sum.cljs$core$IFn$_invoke$arity$3 = (function (f,low,high){
var xs = cljs.core.range.cljs$core$IFn$_invoke$arity$2(low,high);
return cljs.core.transduce.cljs$core$IFn$_invoke$arity$3(cljs.core.map.cljs$core$IFn$_invoke$arity$1(f),sicmutils.util.aggregate._STAR_fold_STAR_,xs);
}));

(sicmutils.util.aggregate.sum.cljs$lang$maxFixedArity = 3);

/**
 * Takes either:
 * 
 *   - a series `xs` of numbers
 *   - A transformation function `f`, an inclusive-lower bound `low` and
 *  exclusive-upper bound `upper`
 * 
 *   And returns a lazy sequence of all intermediate values seen while aggregating
 *   either `xs` or `(map f (range low high))` using the fold dynamically bound
 *   to [[*fold*]].
 * 
 *   Use `binding` to substitute in a different fold:
 * 
 *   ```clj
 *   (require '[sicmutils.algebra.fold :as af])
 * 
 *   (binding [*fold* (af/join af/kahan af/min af/max)]
 *  (scan inc 0 3))
 *   ;;=> ([1.0 1 1] [3.0 1 2] [6.0 1 3])
 *   ```
 */
sicmutils.util.aggregate.scan = (function sicmutils$util$aggregate$scan(var_args){
var G__95716 = arguments.length;
switch (G__95716) {
case 1:
return sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 3:
return sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$1 = (function (xs){
return cljs.core.map.cljs$core$IFn$_invoke$arity$2(sicmutils.util.aggregate._STAR_fold_STAR_,cljs.core.rest(cljs.core.reductions.cljs$core$IFn$_invoke$arity$3(sicmutils.util.aggregate._STAR_fold_STAR_,sicmutils.util.aggregate._STAR_fold_STAR_.call(null),xs)));
}));

(sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$3 = (function (f,low,high){
return sicmutils.util.aggregate.scan.cljs$core$IFn$_invoke$arity$1(cljs.core.map.cljs$core$IFn$_invoke$arity$2(f,cljs.core.range.cljs$core$IFn$_invoke$arity$2(low,high)));
}));

(sicmutils.util.aggregate.scan.cljs$lang$maxFixedArity = 3);

/**
 * Dynamically bindable size below which [[pairwise-sum]] will defer
 *   to [[sum]] to aggregate values.
 */
sicmutils.util.aggregate._STAR_cutoff_STAR_ = (128);
/**
 * Given a vector of numbers, returns the [pairwise
 *   summation](https://en.wikipedia.org/wiki/Pairwise_summation) of the vector
 *   generated by arranging the vector into a binary tree and summing leaves
 *   together all the way up to the root.
 * 
 *   If `xs` is /not/ a vector, [[pairwise-sum]] will realize all elements into a
 *   vector before operating.
 * 
 *   If the initial vector, or some recursive slice, reaches a count
 *   <= [[*cutoff*]], [[pairwise-sum]] defers to `(reduce + xs)`.
 * 
 *   ### Performance Discussion
 * 
 *   [[pairwise-sum]] is perhaps 10% faster than [[sum]]
 *   with [[sicmutils.algebra.fold/kbn]] bound to [[*fold*]], but has poorer bounds
 *   on its error growth. Instead of having roughly constant error regardless of
 *   the size of the input, in the worst case its accumulated error grows with
 *   $O(\log n)$.
 * 
 *   This improvement is due to the fact that [[pairwise-sum]] tends to add up
 *   numbers of similar magnitude, instead of adding deltas into a progressively
 *   larger sum.
 * 
 *   This implementation was inspired by the `pairwiseSum` implementation in
 *   the [`math-functions`](https://hackage.haskell.org/package/math-functions-0.3.4.2/docs/src/Numeric.Sum.html#pairwiseSum)
 *   Haskell package. The notes above were adapted from that function's docs.
 */
sicmutils.util.aggregate.pairwise_sum = (function sicmutils$util$aggregate$pairwise_sum(var_args){
var G__95722 = arguments.length;
switch (G__95722) {
case 1:
return sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$1((arguments[(0)]));

break;
case 3:
return sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$1 = (function (xs){
var f = (function sicmutils$util$aggregate$f(v){
var n = cljs.core.count(v);
if((n <= sicmutils.util.aggregate._STAR_cutoff_STAR_)){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$2(cljs.core._PLUS_,v);
} else {
var split_idx = (n >> (1));
var l = cljs.core.subvec.cljs$core$IFn$_invoke$arity$3(v,(0),split_idx);
var r = cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(v,split_idx);
return (sicmutils$util$aggregate$f(l) + sicmutils$util$aggregate$f(r));
}
});
return f(((cljs.core.vector_QMARK_(xs))?xs:cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.PersistentVector.EMPTY,xs)));
}));

(sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$3 = (function (f,low,high){
return sicmutils.util.aggregate.pairwise_sum.cljs$core$IFn$_invoke$arity$1(cljs.core.mapv.cljs$core$IFn$_invoke$arity$2(f,cljs.core.range.cljs$core$IFn$_invoke$arity$2(low,high)));
}));

(sicmutils.util.aggregate.pairwise_sum.cljs$lang$maxFixedArity = 3);

/**
 * If `stop?` is false, returns `f`. Else, returns a binary reducing function that
 *   returns a `reduced` value if its left argument returns `true` for `stop?`,
 *   else aggregates with `f`.
 */
sicmutils.util.aggregate.combiner = (function sicmutils$util$aggregate$combiner(f,stop_QMARK_){
if(cljs.core.truth_(stop_QMARK_)){
return (function (l,r){
if(cljs.core.truth_((stop_QMARK_.cljs$core$IFn$_invoke$arity$1 ? stop_QMARK_.cljs$core$IFn$_invoke$arity$1(l) : stop_QMARK_.call(null,l)))){
return cljs.core.reduced(l);
} else {
return (f.cljs$core$IFn$_invoke$arity$2 ? f.cljs$core$IFn$_invoke$arity$2(l,r) : f.call(null,l,r));
}
});
} else {
return f;
}
});
/**
 * Accepts a binary (associative) aggregation function `plus` and an identity
 *   element `id` and returns a multi-arity function that will combine its
 *   arguments via `plus`. A 0-arity call returns `id`.
 * 
 *   optionally takes an `annihilate?` function that should return true for any `x`
 *   such that `(plus x <any>) == x`.
 * 
 *   If the `annihilate?` function is supplied, then if the aggregation produces a
 *   value that returns `(annihilate? true)` at any point, the reduction will
 *   return immediately.
 */
sicmutils.util.aggregate.monoid = (function sicmutils$util$aggregate$monoid(var_args){
var G__95731 = arguments.length;
switch (G__95731) {
case 2:
return sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$2((arguments[(0)]),(arguments[(1)]));

break;
case 3:
return sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$3((arguments[(0)]),(arguments[(1)]),(arguments[(2)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$2 = (function (plus,id){
return sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$3(plus,id,null);
}));

(sicmutils.util.aggregate.monoid.cljs$core$IFn$_invoke$arity$3 = (function (plus,id,annihilate_QMARK_){
var acc = sicmutils.util.aggregate.combiner(plus,annihilate_QMARK_);
return (function() {
var G__95755 = null;
var G__95755__0 = (function (){
return id;
});
var G__95755__1 = (function (x){
return x;
});
var G__95755__2 = (function (x,y){
return (plus.cljs$core$IFn$_invoke$arity$2 ? plus.cljs$core$IFn$_invoke$arity$2(x,y) : plus.call(null,x,y));
});
var G__95755__3 = (function() { 
var G__95756__delegate = function (x,y,more){
return cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(acc,x,cljs.core.cons(y,more));
};
var G__95756 = function (x,y,var_args){
var more = null;
if (arguments.length > 2) {
var G__95757__i = 0, G__95757__a = new Array(arguments.length -  2);
while (G__95757__i < G__95757__a.length) {G__95757__a[G__95757__i] = arguments[G__95757__i + 2]; ++G__95757__i;}
  more = new cljs.core.IndexedSeq(G__95757__a,0,null);
} 
return G__95756__delegate.call(this,x,y,more);};
G__95756.cljs$lang$maxFixedArity = 2;
G__95756.cljs$lang$applyTo = (function (arglist__95758){
var x = cljs.core.first(arglist__95758);
arglist__95758 = cljs.core.next(arglist__95758);
var y = cljs.core.first(arglist__95758);
var more = cljs.core.rest(arglist__95758);
return G__95756__delegate(x,y,more);
});
G__95756.cljs$core$IFn$_invoke$arity$variadic = G__95756__delegate;
return G__95756;
})()
;
G__95755 = function(x,y,var_args){
var more = var_args;
switch(arguments.length){
case 0:
return G__95755__0.call(this);
case 1:
return G__95755__1.call(this,x);
case 2:
return G__95755__2.call(this,x,y);
default:
var G__95759 = null;
if (arguments.length > 2) {
var G__95760__i = 0, G__95760__a = new Array(arguments.length -  2);
while (G__95760__i < G__95760__a.length) {G__95760__a[G__95760__i] = arguments[G__95760__i + 2]; ++G__95760__i;}
G__95759 = new cljs.core.IndexedSeq(G__95760__a,0,null);
}
return G__95755__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__95759);
}
throw(new Error('Invalid arity: ' + arguments.length));
};
G__95755.cljs$lang$maxFixedArity = 2;
G__95755.cljs$lang$applyTo = G__95755__3.cljs$lang$applyTo;
G__95755.cljs$core$IFn$_invoke$arity$0 = G__95755__0;
G__95755.cljs$core$IFn$_invoke$arity$1 = G__95755__1;
G__95755.cljs$core$IFn$_invoke$arity$2 = G__95755__2;
G__95755.cljs$core$IFn$_invoke$arity$variadic = G__95755__3.cljs$core$IFn$_invoke$arity$variadic;
return G__95755;
})()
}));

(sicmutils.util.aggregate.monoid.cljs$lang$maxFixedArity = 3);

/**
 * Similar to [[monoid]] for types with invertible elements. Accepts:
 * 
 *   - binary `minus` and (associative) `plus` functions
 *   - a unary `negate` function
 *   - an element `id` that obeys `(plus id other) == (plus other id) == other`
 *   - optionally, an `annihilate?` function that should return true for any `x`
 *  such that `(plus x <any>) == x`.
 * 
 *   And returns a function that will SUBTRACT elements. Given `x`, `y`, `z`, for
 *   example, the returned function will return `(- x y z)`, implemented as `(minus
 *   x (plus y z))`
 * 
 *   If the `annihilate?` function is supplied, then if the aggregation produces a
 *   value that returns `(annihilate? true)` at any point, the reduction will
 *   return immediately.
 */
sicmutils.util.aggregate.group = (function sicmutils$util$aggregate$group(var_args){
var G__95733 = arguments.length;
switch (G__95733) {
case 4:
return sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$4((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]));

break;
case 5:
return sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$5((arguments[(0)]),(arguments[(1)]),(arguments[(2)]),(arguments[(3)]),(arguments[(4)]));

break;
default:
throw (new Error(["Invalid arity: ",cljs.core.str.cljs$core$IFn$_invoke$arity$1(arguments.length)].join('')));

}
});

(sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$4 = (function (minus,plus,invert,id){
return sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$5(minus,plus,invert,id,null);
}));

(sicmutils.util.aggregate.group.cljs$core$IFn$_invoke$arity$5 = (function (minus,plus,invert,id,annihilate_QMARK_){
var acc = sicmutils.util.aggregate.combiner(plus,annihilate_QMARK_);
return (function() {
var G__95763 = null;
var G__95763__0 = (function (){
return id;
});
var G__95763__1 = (function (x){
return (invert.cljs$core$IFn$_invoke$arity$1 ? invert.cljs$core$IFn$_invoke$arity$1(x) : invert.call(null,x));
});
var G__95763__2 = (function (x,y){
return (minus.cljs$core$IFn$_invoke$arity$2 ? minus.cljs$core$IFn$_invoke$arity$2(x,y) : minus.call(null,x,y));
});
var G__95763__3 = (function() { 
var G__95764__delegate = function (x,y,more){
var G__95734 = x;
var G__95735 = cljs.core.reduce.cljs$core$IFn$_invoke$arity$3(acc,y,more);
return (minus.cljs$core$IFn$_invoke$arity$2 ? minus.cljs$core$IFn$_invoke$arity$2(G__95734,G__95735) : minus.call(null,G__95734,G__95735));
};
var G__95764 = function (x,y,var_args){
var more = null;
if (arguments.length > 2) {
var G__95768__i = 0, G__95768__a = new Array(arguments.length -  2);
while (G__95768__i < G__95768__a.length) {G__95768__a[G__95768__i] = arguments[G__95768__i + 2]; ++G__95768__i;}
  more = new cljs.core.IndexedSeq(G__95768__a,0,null);
} 
return G__95764__delegate.call(this,x,y,more);};
G__95764.cljs$lang$maxFixedArity = 2;
G__95764.cljs$lang$applyTo = (function (arglist__95769){
var x = cljs.core.first(arglist__95769);
arglist__95769 = cljs.core.next(arglist__95769);
var y = cljs.core.first(arglist__95769);
var more = cljs.core.rest(arglist__95769);
return G__95764__delegate(x,y,more);
});
G__95764.cljs$core$IFn$_invoke$arity$variadic = G__95764__delegate;
return G__95764;
})()
;
G__95763 = function(x,y,var_args){
var more = var_args;
switch(arguments.length){
case 0:
return G__95763__0.call(this);
case 1:
return G__95763__1.call(this,x);
case 2:
return G__95763__2.call(this,x,y);
default:
var G__95770 = null;
if (arguments.length > 2) {
var G__95771__i = 0, G__95771__a = new Array(arguments.length -  2);
while (G__95771__i < G__95771__a.length) {G__95771__a[G__95771__i] = arguments[G__95771__i + 2]; ++G__95771__i;}
G__95770 = new cljs.core.IndexedSeq(G__95771__a,0,null);
}
return G__95763__3.cljs$core$IFn$_invoke$arity$variadic(x,y, G__95770);
}
throw(new Error('Invalid arity: ' + arguments.length));
};
G__95763.cljs$lang$maxFixedArity = 2;
G__95763.cljs$lang$applyTo = G__95763__3.cljs$lang$applyTo;
G__95763.cljs$core$IFn$_invoke$arity$0 = G__95763__0;
G__95763.cljs$core$IFn$_invoke$arity$1 = G__95763__1;
G__95763.cljs$core$IFn$_invoke$arity$2 = G__95763__2;
G__95763.cljs$core$IFn$_invoke$arity$variadic = G__95763__3.cljs$core$IFn$_invoke$arity$variadic;
return G__95763;
})()
}));

(sicmutils.util.aggregate.group.cljs$lang$maxFixedArity = 5);

/**
 * NOTE that the returned function recurs on increasing indices internally instead
 *   of walking through the lists directly. This method of traversing vectors is
 *   more efficient, and this function is called so often that the performance gain
 *   is worth it, and reads almost like the explicit sequence traversal.
 */
sicmutils.util.aggregate.merge_fn = (function sicmutils$util$aggregate$merge_fn(compare,add,zero_QMARK_,make){
return (function() {
var G__95772 = null;
var G__95772__0 = (function (){
return cljs.core.PersistentVector.EMPTY;
});
var G__95772__1 = (function (xs){
return xs;
});
var G__95772__2 = (function (xs,ys){
var i = cljs.core.long$((0));
var j = cljs.core.long$((0));
var result = cljs.core.transient$(cljs.core.PersistentVector.EMPTY);
while(true){
var x = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(xs,i,null);
var y = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(ys,j,null);
if(cljs.core.not(x)){
return cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.persistent_BANG_(result),cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(ys,j));
} else {
if(cljs.core.not(y)){
return cljs.core.into.cljs$core$IFn$_invoke$arity$2(cljs.core.persistent_BANG_(result),cljs.core.subvec.cljs$core$IFn$_invoke$arity$2(xs,i));
} else {
var vec__95743 = x;
var x_tags = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95743,(0),null);
var x_coef = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95743,(1),null);
var vec__95746 = y;
var y_tags = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95746,(0),null);
var y_coef = cljs.core.nth.cljs$core$IFn$_invoke$arity$3(vec__95746,(1),null);
var compare_flag = (compare.cljs$core$IFn$_invoke$arity$2 ? compare.cljs$core$IFn$_invoke$arity$2(x_tags,y_tags) : compare.call(null,x_tags,y_tags));
if(cljs.core.truth_((zero_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zero_QMARK_.cljs$core$IFn$_invoke$arity$1(compare_flag) : zero_QMARK_.call(null,compare_flag)))){
var sum = (add.cljs$core$IFn$_invoke$arity$2 ? add.cljs$core$IFn$_invoke$arity$2(x_coef,y_coef) : add.call(null,x_coef,y_coef));
var G__95773 = (i + (1));
var G__95774 = (j + (1));
var G__95775 = (cljs.core.truth_((zero_QMARK_.cljs$core$IFn$_invoke$arity$1 ? zero_QMARK_.cljs$core$IFn$_invoke$arity$1(sum) : zero_QMARK_.call(null,sum)))?result:cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(result,(make.cljs$core$IFn$_invoke$arity$2 ? make.cljs$core$IFn$_invoke$arity$2(x_tags,sum) : make.call(null,x_tags,sum))));
i = G__95773;
j = G__95774;
result = G__95775;
continue;
} else {
if((compare_flag < (0))){
var G__95776 = (i + (1));
var G__95777 = j;
var G__95778 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(result,x);
i = G__95776;
j = G__95777;
result = G__95778;
continue;
} else {
var G__95779 = i;
var G__95780 = (j + (1));
var G__95781 = cljs.core.conj_BANG_.cljs$core$IFn$_invoke$arity$2(result,y);
i = G__95779;
j = G__95780;
result = G__95781;
continue;

}
}

}
}
break;
}
});
G__95772 = function(xs,ys){
switch(arguments.length){
case 0:
return G__95772__0.call(this);
case 1:
return G__95772__1.call(this,xs);
case 2:
return G__95772__2.call(this,xs,ys);
}
throw(new Error('Invalid arity: ' + arguments.length));
};
G__95772.cljs$core$IFn$_invoke$arity$0 = G__95772__0;
G__95772.cljs$core$IFn$_invoke$arity$1 = G__95772__1;
G__95772.cljs$core$IFn$_invoke$arity$2 = G__95772__2;
return G__95772;
})()
});

//# sourceMappingURL=sicmutils.util.aggregate.js.map
