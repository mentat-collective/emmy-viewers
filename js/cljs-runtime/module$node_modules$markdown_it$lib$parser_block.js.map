{
"version":3,
"file":"module$node_modules$markdown_it$lib$parser_block.js",
"lineCount":5,
"mappings":"AAAAA,cAAA,CAAA,gDAAA,CAAqE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAgC7GC,QAASA,YAAW,EAAG,CAMrB,IAAKC,CAAAA,KAAL,CAAa,IAAIC,KAEjB,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBC,MAAOC,CAAAA,MAA3B,CAAmCF,CAAA,EAAnC,CACE,IAAKF,CAAAA,KAAMK,CAAAA,IAAX,CAAgBF,MAAA,CAAOD,CAAP,CAAA,CAAU,CAAV,CAAhB,CAA8BC,MAAA,CAAOD,CAAP,CAAA,CAAU,CAAV,CAA9B,CAA4C,CAAEI,IAA0BC,CAApBJ,MAAA,CAAOD,CAAP,CAAA,CAAU,CAAV,CAAoBK,EAAJ,EAAIA,EAAAA,KAArB,EAAP,CAA5C,CATmB,CAvBvB,IAAIN,MAAkBL,OAAA,CAAQ,2CAAR,CAAtB,CAGIO,OAAS,CAGX,CAAE,OAAF,CAAgBP,OAAA,CAAQ,uDAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAArD,CAHW,CAIX,CAAE,MAAF,CAAgBA,OAAA,CAAQ,sDAAR,CAAhB,CAJW;AAKX,CAAE,OAAF,CAAgBA,OAAA,CAAQ,uDAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAA4B,YAA5B,CAA0C,MAA1C,CAArD,CALW,CAMX,CAAE,YAAF,CAAgBA,OAAA,CAAQ,4DAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAA4B,YAA5B,CAA0C,MAA1C,CAArD,CANW,CAOX,CAAE,IAAF,CAAgBA,OAAA,CAAQ,oDAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAA4B,YAA5B,CAA0C,MAA1C,CAArD,CAPW,CAQX,CAAE,MAAF,CAAgBA,OAAA,CAAQ,sDAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAA4B,YAA5B,CAArD,CARW,CASX,CAAE,WAAF,CAAgBA,OAAA,CAAQ,2DAAR,CAAhB,CATW;AAUX,CAAE,YAAF,CAAgBA,OAAA,CAAQ,4DAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAA4B,YAA5B,CAArD,CAVW,CAWX,CAAE,SAAF,CAAgBA,OAAA,CAAQ,yDAAR,CAAhB,CAAqD,CAAE,WAAF,CAAe,WAAf,CAA4B,YAA5B,CAArD,CAXW,CAYX,CAAE,UAAF,CAAgBA,OAAA,CAAQ,0DAAR,CAAhB,CAZW,CAaX,CAAE,WAAF,CAAgBA,OAAA,CAAQ,2DAAR,CAAhB,CAbW,CAoCbG,YAAYS,CAAAA,SAAUC,CAAAA,QAAtB,CAAiCC,QAAS,CAACC,KAAD,CAAQC,SAAR,CAAmBC,OAAnB,CAA4B,CAQpE,IARoE,IAC5DX,CAD4D,CAEhEY,MAAQ,IAAKd,CAAAA,KAAMe,CAAAA,QAAX,CAAoB,EAApB,CAFwD;AAGhEC,IAAMF,KAAMV,CAAAA,MAHoD,CAIhEa,KAAOL,SAJyD,CAKhEM,cAAgB,CAAA,CALgD,CAMhEC,WAAaR,KAAMS,CAAAA,EAAGC,CAAAA,OAAQF,CAAAA,UAElC,CAAOF,IAAP,CAAcJ,OAAd,CAAA,CAAuB,CACrBF,KAAMM,CAAAA,IAAN,CAAaA,IAAb,CAAoBN,KAAMW,CAAAA,cAAN,CAAqBL,IAArB,CACpB,IAAIA,IAAJ,EAAYJ,OAAZ,CAAuB,KAIvB,IAAIF,KAAMY,CAAAA,MAAN,CAAaN,IAAb,CAAJ,CAAyBN,KAAMa,CAAAA,SAA/B,CAA4C,KAI5C,IAAIb,KAAMc,CAAAA,KAAV,EAAmBN,UAAnB,CAA+B,CAC7BR,KAAMM,CAAAA,IAAN,CAAaJ,OACb,MAF6B,CAY/B,IAAKX,CAAL,CAAS,CAAT,CAAYA,CAAZ,CAAgBc,GAAhB,EACEU,EAAAA,SAAAA,CAAKZ,KAAA,CAAMZ,CAAN,CAAA,CAASS,KAAT,CAAgBM,IAAhB,CAAsBJ,OAAtB,CAA+B,CAAA,CAA/B,CAALa,CADF,CAAqBxB,CAAA,EAArB,EAOAS,KAAMgB,CAAAA,KAAN,CAAc,CAACT,aAGXP,MAAMiB,CAAAA,OAAN,CAAcjB,KAAMM,CAAAA,IAApB,CAA2B,CAA3B,CAAJ,GACEC,aADF,CACkB,CAAA,CADlB,CAIAD,KAAA,CAAON,KAAMM,CAAAA,IAETA,KAAJ,CAAWJ,OAAX,EAAsBF,KAAMiB,CAAAA,OAAN,CAAcX,IAAd,CAAtB,GACEC,aAEA,CAFgB,CAAA,CAEhB,CADAD,IAAA,EACA,CAAAN,KAAMM,CAAAA,IAAN,CAAaA,IAHf,CAtCqB,CAR6C,CA4DtElB;WAAYS,CAAAA,SAAUqB,CAAAA,KAAtB,CAA8BC,QAAS,CAACC,GAAD,CAAMX,EAAN,CAAUY,GAAV,CAAeC,SAAf,CAA0B,CAG1DF,GAAL,GAEApB,GAEA,CAFQ,IAAI,IAAKuB,CAAAA,KAAT,CAAeH,GAAf,CAAoBX,EAApB,CAAwBY,GAAxB,CAA6BC,SAA7B,CAER,CAAA,IAAKxB,CAAAA,QAAL,CAAcE,GAAd,CAAqBA,GAAMM,CAAAA,IAA3B,CAAiCN,GAAMwB,CAAAA,OAAvC,CAJA,CAH+D,CAWjEpC,YAAYS,CAAAA,SAAU0B,CAAAA,KAAtB,CAA8BtC,OAAA,CAAQ,6DAAR,CAG9BC,OAAOC,CAAAA,OAAP,CAAiBC,WA1H4F;",
"sources":["node_modules/markdown-it/lib/parser_block.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$parser_block\"] = function(global,require,module,exports) {\n/** internal\n * class ParserBlock\n *\n * Block-level tokenizer.\n **/\n'use strict';\n\n\nvar Ruler           = require('./ruler');\n\n\nvar _rules = [\n  // First 2 params - rule name & source. Secondary array - list of rules,\n  // which can be terminated by this one.\n  [ 'table',      require('./rules_block/table'),      [ 'paragraph', 'reference' ] ],\n  [ 'code',       require('./rules_block/code') ],\n  [ 'fence',      require('./rules_block/fence'),      [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'blockquote', require('./rules_block/blockquote'), [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'hr',         require('./rules_block/hr'),         [ 'paragraph', 'reference', 'blockquote', 'list' ] ],\n  [ 'list',       require('./rules_block/list'),       [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'reference',  require('./rules_block/reference') ],\n  [ 'html_block', require('./rules_block/html_block'), [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'heading',    require('./rules_block/heading'),    [ 'paragraph', 'reference', 'blockquote' ] ],\n  [ 'lheading',   require('./rules_block/lheading') ],\n  [ 'paragraph',  require('./rules_block/paragraph') ]\n];\n\n\n/**\n * new ParserBlock()\n **/\nfunction ParserBlock() {\n  /**\n   * ParserBlock#ruler -> Ruler\n   *\n   * [[Ruler]] instance. Keep configuration of block rules.\n   **/\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1], { alt: (_rules[i][2] || []).slice() });\n  }\n}\n\n\n// Generate tokens for input range\n//\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var ok, i,\n      rules = this.ruler.getRules(''),\n      len = rules.length,\n      line = startLine,\n      hasEmptyLines = false,\n      maxNesting = state.md.options.maxNesting;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n    if (line >= endLine) { break; }\n\n    // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n    if (state.sCount[line] < state.blkIndent) { break; }\n\n    // If nesting level exceeded - skip tail to the end. That's not ordinary\n    // situation and we should not care about content.\n    if (state.level >= maxNesting) {\n      state.line = endLine;\n      break;\n    }\n\n    // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n      if (ok) { break; }\n    }\n\n    // set state.tight if we had an empty line before current tag\n    // i.e. latest empty line should not count\n    state.tight = !hasEmptyLines;\n\n    // paragraph might \"eat\" one newline after it in nested lists\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++;\n      state.line = line;\n    }\n  }\n};\n\n\n/**\n * ParserBlock.parse(str, md, env, outTokens)\n *\n * Process input string and push block tokens into `outTokens`\n **/\nParserBlock.prototype.parse = function (src, md, env, outTokens) {\n  var state;\n\n  if (!src) { return; }\n\n  state = new this.State(src, md, env, outTokens);\n\n  this.tokenize(state, state.line, state.lineMax);\n};\n\n\nParserBlock.prototype.State = require('./rules_block/state_block');\n\n\nmodule.exports = ParserBlock;\n\n};"],
"names":["shadow$provide","global","require","module","exports","ParserBlock","ruler","Ruler","i","_rules","length","push","alt","slice","prototype","tokenize","ParserBlock.prototype.tokenize","state","startLine","endLine","rules","getRules","len","line","hasEmptyLines","maxNesting","md","options","skipEmptyLines","sCount","blkIndent","level","ok","tight","isEmpty","parse","ParserBlock.prototype.parse","src","env","outTokens","State","lineMax"]
}
