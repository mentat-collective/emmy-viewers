shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$cube_uv_reflection_fragment_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection \x3d abs( direction );\n\n\t\tfloat face \x3d - 1.0;\n\n\t\tif ( absDirection.x \x3e absDirection.z ) {\n\n\t\t\tif ( absDirection.x \x3e absDirection.y )\n\n\t\t\t\tface \x3d direction.x \x3e 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface \x3d direction.y \x3e 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z \x3e absDirection.y )\n\n\t\t\t\tface \x3d direction.z \x3e 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface \x3d direction.y \x3e 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face \x3d\x3d 0.0 ) {\n\n\t\t\tuv \x3d vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face \x3d\x3d 1.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face \x3d\x3d 2.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face \x3d\x3d 3.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face \x3d\x3d 4.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv \x3d vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face \x3d getFace( direction );\n\n\t\tfloat filterInt \x3d max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt \x3d max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize \x3d exp2( mipInt );\n\n\t\tvec2 uv \x3d getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\n\t\tif ( face \x3e 2.0 ) {\n\n\t\t\tuv.y +\x3d faceSize;\n\n\t\t\tface -\x3d 3.0;\n\n\t\t}\n\n\t\tuv.x +\x3d face * faceSize;\n\n\t\tuv.x +\x3d filterInt * 3.0 * cubeUV_minTileSize;\n\n\t\tuv.y +\x3d 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\n\t\tuv.x *\x3d CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *\x3d CUBEUV_TEXEL_HEIGHT;\n\n\t\t#ifdef texture2DGradEXT\n\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb; // disable anisotropic filtering\n\n\t\t#else\n\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\n\t\t#endif\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip \x3d 0.0;\n\n\t\tif ( roughness \x3e\x3d cubeUV_r1 ) {\n\n\t\t\tmip \x3d ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\n\t\t} else if ( roughness \x3e\x3d cubeUV_r4 ) {\n\n\t\t\tmip \x3d ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\n\t\t} else if ( roughness \x3e\x3d cubeUV_r5 ) {\n\n\t\t\tmip \x3d ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\n\t\t} else if ( roughness \x3e\x3d cubeUV_r6 ) {\n\n\t\t\tmip \x3d ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\n\t\t} else {\n\n\t\t\tmip \x3d - 2.0 * log2( 1.16 * roughness ); // 1.16 \x3d 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip \x3d clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\n\t\tfloat mipF \x3d fract( mip );\n\n\t\tfloat mipInt \x3d floor( mip );\n\n\t\tvec3 color0 \x3d bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF \x3d\x3d 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 \x3d bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$cube_uv_reflection_fragment_glsl.js.map
