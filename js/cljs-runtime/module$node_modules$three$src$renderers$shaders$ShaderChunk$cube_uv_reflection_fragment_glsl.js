shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$cube_uv_reflection_fragment_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\n#ifdef ENVMAP_TYPE_CUBE_UV\n\n\t#define cubeUV_maxMipLevel 8.0\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_maxTileSize 256.0\n\t#define cubeUV_minTileSize 16.0\n\n\t// These shader functions convert between the UV coordinates of a single face of\n\t// a cubemap, the 0-5 integer index of a cube face, and the direction vector for\n\t// sampling a textureCube (not generally normalized ).\n\n\tfloat getFace( vec3 direction ) {\n\n\t\tvec3 absDirection \x3d abs( direction );\n\n\t\tfloat face \x3d - 1.0;\n\n\t\tif ( absDirection.x \x3e absDirection.z ) {\n\n\t\t\tif ( absDirection.x \x3e absDirection.y )\n\n\t\t\t\tface \x3d direction.x \x3e 0.0 ? 0.0 : 3.0;\n\n\t\t\telse\n\n\t\t\t\tface \x3d direction.y \x3e 0.0 ? 1.0 : 4.0;\n\n\t\t} else {\n\n\t\t\tif ( absDirection.z \x3e absDirection.y )\n\n\t\t\t\tface \x3d direction.z \x3e 0.0 ? 2.0 : 5.0;\n\n\t\t\telse\n\n\t\t\t\tface \x3d direction.y \x3e 0.0 ? 1.0 : 4.0;\n\n\t\t}\n\n\t\treturn face;\n\n\t}\n\n\t// RH coordinate system; PMREM face-indexing convention\n\tvec2 getUV( vec3 direction, float face ) {\n\n\t\tvec2 uv;\n\n\t\tif ( face \x3d\x3d 0.0 ) {\n\n\t\t\tuv \x3d vec2( direction.z, direction.y ) / abs( direction.x ); // pos x\n\n\t\t} else if ( face \x3d\x3d 1.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y\n\n\t\t} else if ( face \x3d\x3d 2.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z\n\n\t\t} else if ( face \x3d\x3d 3.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x\n\n\t\t} else if ( face \x3d\x3d 4.0 ) {\n\n\t\t\tuv \x3d vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y\n\n\t\t} else {\n\n\t\t\tuv \x3d vec2( direction.x, direction.y ) / abs( direction.z ); // neg z\n\n\t\t}\n\n\t\treturn 0.5 * ( uv + 1.0 );\n\n\t}\n\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\n\t\tfloat face \x3d getFace( direction );\n\n\t\tfloat filterInt \x3d max( cubeUV_minMipLevel - mipInt, 0.0 );\n\n\t\tmipInt \x3d max( mipInt, cubeUV_minMipLevel );\n\n\t\tfloat faceSize \x3d exp2( mipInt );\n\n\t\tfloat texelSize \x3d 1.0 / ( 3.0 * cubeUV_maxTileSize );\n\n\t\tvec2 uv \x3d getUV( direction, face ) * ( faceSize - 1.0 ) + 0.5;\n\n\t\tif ( face \x3e 2.0 ) {\n\n\t\t\tuv.y +\x3d faceSize;\n\n\t\t\tface -\x3d 3.0;\n\n\t\t}\n\n\t\tuv.x +\x3d face * faceSize;\n\n\t\tif ( mipInt \x3c cubeUV_maxMipLevel ) {\n\n\t\t\tuv.y +\x3d 2.0 * cubeUV_maxTileSize;\n\n\t\t}\n\n\t\tuv.y +\x3d filterInt * 2.0 * cubeUV_minTileSize;\n\n\t\tuv.x +\x3d 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );\n\n\t\tuv *\x3d texelSize;\n\n\t\treturn texture2D( envMap, uv ).rgb;\n\n\t}\n\n\t// These defines must match with PMREMGenerator\n\n\t#define r0 1.0\n\t#define v0 0.339\n\t#define m0 - 2.0\n\t#define r1 0.8\n\t#define v1 0.276\n\t#define m1 - 1.0\n\t#define r4 0.4\n\t#define v4 0.046\n\t#define m4 2.0\n\t#define r5 0.305\n\t#define v5 0.016\n\t#define m5 3.0\n\t#define r6 0.21\n\t#define v6 0.0038\n\t#define m6 4.0\n\n\tfloat roughnessToMip( float roughness ) {\n\n\t\tfloat mip \x3d 0.0;\n\n\t\tif ( roughness \x3e\x3d r1 ) {\n\n\t\t\tmip \x3d ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;\n\n\t\t} else if ( roughness \x3e\x3d r4 ) {\n\n\t\t\tmip \x3d ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;\n\n\t\t} else if ( roughness \x3e\x3d r5 ) {\n\n\t\t\tmip \x3d ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;\n\n\t\t} else if ( roughness \x3e\x3d r6 ) {\n\n\t\t\tmip \x3d ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;\n\n\t\t} else {\n\n\t\t\tmip \x3d - 2.0 * log2( 1.16 * roughness ); // 1.16 \x3d 1.79^0.25\n\t\t}\n\n\t\treturn mip;\n\n\t}\n\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\n\t\tfloat mip \x3d clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );\n\n\t\tfloat mipF \x3d fract( mip );\n\n\t\tfloat mipInt \x3d floor( mip );\n\n\t\tvec3 color0 \x3d bilinearCubeUV( envMap, sampleDir, mipInt );\n\n\t\tif ( mipF \x3d\x3d 0.0 ) {\n\n\t\t\treturn vec4( color0, 1.0 );\n\n\t\t} else {\n\n\t\t\tvec3 color1 \x3d bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\n\t\t}\n\n\t}\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$cube_uv_reflection_fragment_glsl.js.map
