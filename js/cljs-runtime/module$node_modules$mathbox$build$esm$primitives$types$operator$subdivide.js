shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$operator$subdivide=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Subdivide=void 0;
var UGLSL=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,
key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$mathbox$build$esm$util$glsl"));global=require("module$node_modules$mathbox$build$esm$primitives$types$operator$operator");class Subdivide extends global.Operator{static initClass(){this.traits="node bind operator source index subdivide".split(" ")}indexShader(shader){shader.pipe(this.indexer);return super.indexShader(shader)}sourceShader(shader){return shader.pipe(this.operator)}getDimensions(){return this._resample(this.bind.source.getDimensions())}getActiveDimensions(){return this._resample(this.bind.source.getActiveDimensions())}getFutureDimensions(){return this._resample(this.bind.source.getFutureDimensions())}getIndexDimensions(){return this._resample(this.bind.source.getIndexDimensions())}_resample(dims){const r=
this.resampled;dims.items--;dims.width--;dims.height--;dims.depth--;null!=r.items&&(dims.items*=r.items);null!=r.width&&(dims.width*=r.width);null!=r.height&&(dims.height*=r.height);null!=r.depth&&(dims.depth*=r.depth);dims.items++;dims.width++;dims.height++;dims.depth++;return dims}make(){super.make();if(null!=this.bind.source){var {lerp}=this.props,{items,width,height,depth}=this.props;this.resampled={};null!=items&&(this.resampled.items=items);null!=width&&(this.resampled.width=width);null!=height&&
(this.resampled.height=height);null!=depth&&(this.resampled.depth=depth);var operator=this._shaders.shader(),indexer=this._shaders.shader(),uniforms={resampleFactor:this._attributes.make(this._types.vec4(0,0,0,0)),subdivideBevel:this.node.attributes["subdivide.bevel"]};this.resampleFactor=uniforms.resampleFactor;this.resampleBias=uniforms.resampleBias;null!=items||null!=width||null!=height||null!=depth?(operator.pipe("resample.relative",uniforms),indexer.pipe("resample.relative",uniforms)):(operator.pipe(UGLSL.identity("vec4")),
indexer.pipe(UGLSL.identity("vec4")));var sampler=this.bind.source.sourceShader(this._shaders.shader());lerp=lerp?".lerp":"";var iterable=["width","height","depth","items"];for(let i=0;i<iterable.length;i++){const key=iterable[i],id=`subdivide.${key}${lerp}`;null!=this.props[key]&&(sampler=this._shaders.shader().require(sampler),sampler.pipe(id,uniforms))}operator.pipe(sampler);this.operator=operator;return this.indexer=indexer}}unmake(){super.unmake();return this.operator=null}resize(){if(null!=
this.bind.source){var dims=this.bind.source.getActiveDimensions(),target=this.getActiveDimensions(),axis=key=>Math.max(1,dims[key]-1)/Math.max(1,target[key]-1),rw=axis("width"),rh=axis("height"),rd=axis("depth");axis=axis("items");this.resampleFactor.value.set(rw,rh,rd,axis);return super.resize()}}change(changed,touched,_init){if(touched.operator||touched.subdivide)return this.rebuild()}}exports.Subdivide=Subdivide;Subdivide.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$operator$subdivide.js.map
