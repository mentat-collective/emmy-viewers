{
"version":3,
"file":"module$node_modules$$motionone$dom$dist$gestures$scroll$offsets$index_cjs.js",
"lineCount":4,
"mappings":"AAAAA,cAAA,CAAA,yEAAA,CAA8F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGtIC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIC,MAAQN,OAAA,CAAQ,qDAAR,CAAZ,CACIO,MAAQP,OAAA,CAAQ,2EAAR,CADZ,CAEIQ,QAAUR,OAAA,CAAQ,6EAAR,CAFd,CAGIS,OAAST,OAAA,CAAQ,4EAAR,CAEb;MAAMU,MAAQ,CAAEC,EAAG,CAAL,CAAQC,EAAG,CAAX,CA+CdV,QAAQW,CAAAA,cAAR,CA9CAA,QAAuB,CAACC,SAAD,CAAYC,IAAZ,CAAkBC,OAAlB,CAA2B,CAC9C,IAAI,CAAE,OAAQC,gBAAA,CAAmBT,OAAQU,CAAAA,YAAaC,CAAAA,GAAlD,CAAA,CAA0DH,OAC9D,OAAM,CAAEI,MAAA,CAASN,SAAX,CAAsBO,IAAA,CAAO,GAA7B,CAAA,CAAqCL,OACrCM,QAAAA,CAAuB,GAAT,GAAAD,IAAA,CAAe,QAAf,CAA0B,OAC9C,OAAME,QAAUH,MAAA,GAAWN,SAAX,CAAuBP,KAAMiB,CAAAA,SAAN,CAAgBJ,MAAhB,CAAwBN,SAAxB,CAAvB,CAA4DJ,KAA5E,CAMMe,WAAaL,MAAA,GAAWN,SAAX,CACb,CAAEY,MAAOZ,SAAUa,CAAAA,WAAnB,CAAgCC,OAAQd,SAAUe,CAAAA,YAAlD,CADa,CAEb,CAAEH,MAAON,MAAOU,CAAAA,WAAhB,CAA6BF,OAAQR,MAAOW,CAAAA,YAA5C,CACAC,UAAAA,CAAgB,CAClBN,MAAOZ,SAAUgB,CAAAA,WADC,CAElBF,OAAQd,SAAUiB,CAAAA,YAFA,CAQtBhB;IAAA,CAAKM,IAAL,CAAWZ,CAAAA,MAAOwB,CAAAA,MAAlB,CAA2B,CAK3B,KAAIC,WAAa,CAACnB,IAAA,CAAKM,IAAL,CAAWc,CAAAA,WAC7B,OAAMC,WAAanB,gBAAiBgB,CAAAA,MACpC,KAAK,IAAII,EAAI,CAAb,CAAgBA,CAAhB,CAAoBD,UAApB,CAAgCC,CAAA,EAAhC,CAAqC,CACjC,MAAMC,SAAW7B,MAAO8B,CAAAA,aAAP,CAAqBtB,gBAAA,CAAiBoB,CAAjB,CAArB,CAA0CL,SAAA,CAAcV,OAAd,CAA1C,CAAsEG,UAAA,CAAWH,OAAX,CAAtE,CAA+FC,OAAA,CAAQF,IAAR,CAA/F,CACZa,WAAL,EAAmBI,QAAnB,GAAgCvB,IAAA,CAAKM,IAAL,CAAWmB,CAAAA,mBAAX,CAA+BH,CAA/B,CAAhC,GACIH,UADJ,CACiB,CAAA,CADjB,CAGAnB,KAAA,CAAKM,IAAL,CAAWZ,CAAAA,MAAX,CAAkB4B,CAAlB,CAAA,CAAuBC,QALU,CAWjCJ,UAAJ,GACInB,IAAA,CAAKM,IAAL,CAAWc,CAAAA,WACX,CADyB7B,KAAM6B,CAAAA,WAAN,CAAkB7B,KAAMmC,CAAAA,aAAN,CAAoBL,UAApB,CAAlB,CAAmDrB,IAAA,CAAKM,IAAL,CAAWZ,CAAAA,MAA9D,CACzB,CAAAM,IAAA,CAAKM,IAAL,CAAWmB,CAAAA,mBAAX,CAAiC,CAAC,GAAGzB,IAAA,CAAKM,IAAL,CAAWZ,CAAAA,MAAf,CAFrC,CAIAM;IAAA,CAAKM,IAAL,CAAWqB,CAAAA,QAAX,CAAsB3B,IAAA,CAAKM,IAAL,CAAWc,CAAAA,WAAX,CAAuBpB,IAAA,CAAKM,IAAL,CAAWsB,CAAAA,OAAlC,CA3CwB,CAXoF;",
"sources":["node_modules/@motionone/dom/dist/gestures/scroll/offsets/index.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$motionone$dom$dist$gestures$scroll$offsets$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\nvar inset = require('./inset.cjs.js');\nvar presets = require('./presets.cjs.js');\nvar offset = require('./offset.cjs.js');\n\nconst point = { x: 0, y: 0 };\nfunction resolveOffsets(container, info, options) {\n    let { offset: offsetDefinition = presets.ScrollOffset.All } = options;\n    const { target = container, axis = \"y\" } = options;\n    const lengthLabel = axis === \"y\" ? \"height\" : \"width\";\n    const inset$1 = target !== container ? inset.calcInset(target, container) : point;\n    /**\n     * Measure the target and container. If they're the same thing then we\n     * use the container's scrollWidth/Height as the target, from there\n     * all other calculations can remain the same.\n     */\n    const targetSize = target === container\n        ? { width: container.scrollWidth, height: container.scrollHeight }\n        : { width: target.clientWidth, height: target.clientHeight };\n    const containerSize = {\n        width: container.clientWidth,\n        height: container.clientHeight,\n    };\n    /**\n     * Reset the length of the resolved offset array rather than creating a new one.\n     * TODO: More reusable data structures for targetSize/containerSize would also be good.\n     */\n    info[axis].offset.length = 0;\n    /**\n     * Populate the offset array by resolving the user's offset definition into\n     * a list of pixel scroll offets.\n     */\n    let hasChanged = !info[axis].interpolate;\n    const numOffsets = offsetDefinition.length;\n    for (let i = 0; i < numOffsets; i++) {\n        const offset$1 = offset.resolveOffset(offsetDefinition[i], containerSize[lengthLabel], targetSize[lengthLabel], inset$1[axis]);\n        if (!hasChanged && offset$1 !== info[axis].interpolatorOffsets[i]) {\n            hasChanged = true;\n        }\n        info[axis].offset[i] = offset$1;\n    }\n    /**\n     * If the pixel scroll offsets have changed, create a new interpolator function\n     * to map scroll value into a progress.\n     */\n    if (hasChanged) {\n        info[axis].interpolate = utils.interpolate(utils.defaultOffset(numOffsets), info[axis].offset);\n        info[axis].interpolatorOffsets = [...info[axis].offset];\n    }\n    info[axis].progress = info[axis].interpolate(info[axis].current);\n}\n\nexports.resolveOffsets = resolveOffsets;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","utils","inset","presets","offset","point","x","y","resolveOffsets","container","info","options","offsetDefinition","ScrollOffset","All","target","axis","lengthLabel","inset$1","calcInset","targetSize","width","scrollWidth","height","scrollHeight","clientWidth","clientHeight","containerSize","length","hasChanged","interpolate","numOffsets","i","offset$1","resolveOffset","interpolatorOffsets","defaultOffset","progress","current"]
}
