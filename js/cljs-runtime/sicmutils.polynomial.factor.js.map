{"version":3,"sources":["sicmutils/polynomial/factor.cljc"],"mappings":"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","names":["sicmutils.polynomial.factor/split-polynomial","p","tracker","const","final","cljs.core/peek","sicmutils.value/number?","cljs.core.into","cljs.core.subvec","cljs.core.conj","cljs.core/pop","m","h","old-s","old-m","sicmutils.value/one?","answer","gg","sicmutils.polynomial.gcd/gcd-Dp","new-s","sicmutils.polynomial/evenly-divide","sicmutils.polynomial.gcd/gcd","new-m","facts","doublefacts","singlefacts","sicmutils.polynomial/mul","sicmutils.polynomial.factor/factors->expression","factors","expt","sicmutils.numsymb/symbolic-operator","cljs.core/cons","cljs.core.map_indexed","i","f","sicmutils.polynomial.factor/simplify-product","pattern.rule.rule_simplifier","sicmutils.simplify.rules.associative","sicmutils.simplify.rules.unary_elimination","sicmutils.simplify.rules/constant-elimination","pattern.rule/rule*","pattern.rule.pattern_STAR_","cljs.core/List","G__100766","r__20948__auto__","or__4253__auto__","pattern.consequence/succeed","pattern.rule/=>","var_args","G__100778","sicmutils.polynomial.factor/poly->factored-expression","js/Error","vars","sicmutils.polynomial.factor.poly__GT_factored_expression","cljs.core/identity","simplify","e100785","cljs.core.map","factor","G__100794","sicmutils.polynomial/->expression","G__100798","_","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","G__100787","G__100803","sicmutils.polynomial.factor/factor-expression","expr","sicmutils.polynomial.factor.factor_expression","p1__100799#","p2__100800#","unwrapped","sicmutils.expression/expression-of","cont","sicmutils.polynomial.expression__GT_","sicmutils.polynomial.factor/analyzer","symgen","sicmutils.expression.analyze/monotonic-symbol-generator","js/sicmutils","js/sicmutils.polynomial","js/sicmutils.polynomial.factor","js/sicmutils.polynomial.factor.t_sicmutils$polynomial$factor100805","sicmutils.polynomial.factor/t_sicmutils$polynomial$factor100805","_100807","meta100806","cljs.core/PROTOCOL_SENTINEL","this__4491__auto__","writer__4492__auto__","opt__4493__auto__","cljs.core/-write","sicmutils.polynomial.factor/->t_sicmutils$polynomial$factor100805","v-compare","o","sicmutils.polynomial/analyzer","sicmutils.expression.analyze.make_analyzer","sicmutils.polynomial.factor/factor","sicmutils.expression.analyze/default-simplifier","sicmutils.polynomial.factor/process-sqrt","fact-exp","G__100814","cljs.core/first","sicmutils.numsymb/operands","*","sqrt","even?","n","sicmutils.value/native-integral?","cljs.core/even?","sicmutils.numsymb/product?","odds","evens","cljs.core/empty?","cljs.core._EQ_","cljs.core.sequence","cljs.core/seq","cljs.core.concat","sicmutils.util.logic.assume_BANG_","G__100841","G__100842","vec__100843","seq__100844","first__100845","cljs.core/next","more","sicmutils.numsymb/expt?","vec__100846","cljs.core.nth","b","e","power","cljs.core/quot","G__100849","G__100850","sicmutils.polynomial.factor/root-out-squares","clojure.walk/prewalk","t","sicmutils.numsymb/sqrt?"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.polynomial.factor\n  \"This namespace contains functions for factoring polynomials and symbolic\n  expressions.\"\n  (:require [clojure.walk :as w]\n            [pattern.rule :as r :refer [=> rule-simplifier] :include-macros true]\n            [sicmutils.expression :as x]\n            [sicmutils.expression.analyze :as a]\n            [sicmutils.numsymb :as sym]\n            [sicmutils.polynomial :as poly]\n            [sicmutils.polynomial.gcd :refer [gcd gcd-Dp]]\n            [sicmutils.simplify.rules :as rules]\n            [sicmutils.util.logic :as ul]\n            [sicmutils.value :as v]\n            [taoensso.timbre :as log])\n  #?(:clj\n     (:import (java.util.concurrent TimeoutException))))\n\n(defn split-polynomial\n  \"Given a [[Polynomial]] `p`, returns a sequence of factors of in order of\n  increasing power.\n\n  The first element is a constant factor, the next is a factor with power 1, and\n  so on.\"\n  [p]\n  (letfn [(answer [tracker const]\n            (let [final (peek tracker)]\n              (if (v/number? final)\n                (into [final] (subvec (conj (pop tracker) 1) 1))\n                (into [const] (subvec tracker 1)))))]\n    (loop [m 0\n           h p\n           tracker []\n           old-s p\n           old-m 1]\n      (if (v/one? m)\n        (answer tracker h)\n        (let [gg (gcd-Dp h)\n              new-s (poly/evenly-divide h (gcd h gg))\n              new-m (gcd gg new-s)\n\n              ;; facts gets all the factors that were completely removed last\n              ;; step, i.e. all those that were to the 1 or 2 power. The first\n              ;; loop through will get a totally wrong `facts`, but its gcd with\n              ;; the initial old-m=1 will be 1, so it won't result in incorrect\n              ;; doublefacts or singlefacts.\n              facts (poly/evenly-divide old-s new-s)\n\n              ;; doublefacts gets all the factors which were to the power x > 1,\n              ;; x <= 2, (ergo x=2), in the last step.\n              doublefacts (gcd facts old-m)\n\n              ;; takes out p = all factors only to the 1st power.\n              singlefacts (poly/evenly-divide new-s new-m)]\n          (recur new-m\n                 ;; the following has all factors to the 1 or 2 power\n                 ;; completely removed, others now to the power-2.\n                 (poly/evenly-divide h (poly/mul new-m new-s))\n\n                 ;; tracker of the form\n                 ;;  h(vi) = (* (exponent (get tracker k) k))\n                 (conj tracker doublefacts singlefacts)\n                 new-s\n                 new-m))))))\n\n;; ## Symbolic Expression Factoring\n\n(defn ^:no-doc factors->expression\n  \"Given some sequence of polynomial factors ordered by increasing power,\n  symbolically evaluates each power and generates a symbolic expression\n  representing the product of all factors.\n\n  For example:\n\n  ```clojure\n  (factors->expression ['c 'x 'y 1 'z])\n  ;;=> (* c x (expt y 2) (expt z 4))\n  ```\"\n  [factors]\n  (let [expt (sym/symbolic-operator 'expt)]\n    (cons '* (map-indexed\n              (fn [i f]\n                (if (zero? i)\n                  f\n                  (expt f i)))\n              factors))))\n\n(def ^{:private true\n       :doc \"Simplifier that flattens nested products, converts singleton calls\n  like `(* x) => x`, and squashes no-argument products like `(*)` into a\n  constant `1`.\"}\n  simplify-product\n  (rule-simplifier\n   (rules/associative '*)\n   (rules/unary-elimination '*)\n   (rules/constant-elimination '* 1)\n   (r/rule (*) => 1)))\n\n(defn poly->factored-expression\n  \"Given a polynomial `p`, and a sequence of variables `vars` (one for each\n  indeterminate in `p`), returns a symbolic expression representing the product\n  of all factors of `p`.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.\"\n  ([p vars]\n   (poly->factored-expression p vars identity))\n  ([p vars simplify]\n   (try\n     (let [factors (map (fn [factor]\n                          (simplify\n                           (poly/->expression factor vars)))\n                        (split-polynomial p))]\n       (simplify-product\n        (factors->expression factors)))\n     ;; NOTE: This is not an ideal, principled approach for a timeout failure.\n     ;; Think through how this should be handled if it comes up.\n     (catch #?(:clj TimeoutException :cljs js/Error) _\n       (log/warn\n        (str \"Factorization choked! Simplifying the unfactored polynomial.\"))\n       (simplify-product\n        (poly/->expression p vars))))))\n\n#?(:clj\n   (alter-var-root #'poly->factored-expression memoize))\n\n(defn factor-expression\n  \"Given some symbolic expression containing only polynomial operations, returns a\n  factored version of the expression with basic simplifications applied.\n\n  Optionally accepts a `simplify` function that will be called on each factor of\n  exponent 0, 1, 2 etc. Defaults to `identity`.\n\n  NOTE prefer [[factor]], as [[factor]] can handle expressions with\n  non-polynomial operations. The trigonometric functions, for example.\"\n  ([expr]\n   (factor-expression expr identity))\n  ([expr simplify]\n   (let [unwrapped (x/expression-of expr)\n         cont #(poly->factored-expression %1 %2 simplify)]\n     (poly/expression-> unwrapped cont))))\n\n(def ^{:doc \"Expression analyzer, identical to [[polynomial/analyzer]] except\n  the symbolic expressions returned are in factored form.\"}\n  analyzer\n  (let [symgen (a/monotonic-symbol-generator \"-f-\")]\n    (-> (reify a/ICanonicalize\n          (expression-> [_ expr cont v-compare]\n            (poly/expression-> expr cont v-compare))\n          (->expression [_ p vars]\n            (poly->factored-expression p vars))\n          (known-operation? [_ o]\n            (a/known-operation? poly/analyzer o)))\n        (a/make-analyzer symgen))))\n\n(def ^{:doc \"Accepts a single symbolic expression and returns a factored version\n of that expression.\n\n Differs from [[factor-expression]] in that it can handle any expression, not\n just expressions limited to polynomial operations.\"\n       :arglists '([expr])}\n  factor\n  (a/default-simplifier analyzer))\n\n;; ## Square Root Simplification\n\n(defn- process-sqrt\n  \"Given an unwrapped symbolic expression of the form `(sqrt x)`, returns a new,\n  unsimplified symbolic expression with any even power removed from underneath\n  the square root.\n\n  For example:\n\n  ```clojure\n  (process-sqrt\n    '(sqrt (* x (expt y 2) (expt z 4))))\n  ;;=> (* (sqrt x) y (expt z 2))\n  ```\"\n  [expr]\n  (let [fact-exp (factor (first (sym/operands expr)))\n        expt  (sym/symbolic-operator 'expt)\n        *     (sym/symbolic-operator '*)\n        sqrt  (sym/symbolic-operator 'sqrt)\n        even? (fn [n]\n                (and (v/native-integral? n)\n                     (even? n)))]\n    (loop [factors (if (sym/product? fact-exp)\n                     (sym/operands fact-exp)\n                     [fact-exp])\n           odds  1\n           evens 1]\n      (if (empty? factors)\n        (do (when-not (= evens 1)\n              (ul/assume! `(~'non-negative? ~evens)\n                          'root-out-squares))\n            (* (sqrt odds) evens))\n        (let [[f & more] factors]\n          (if (sym/expt? f)\n            (let [[b e] (sym/operands f)]\n              (if-not (even? e)\n                (recur more\n                       (* f odds)\n                       evens)\n                (recur more\n                       odds\n                       (let [power (quot e 2)]\n                         (cond (> power 1) (* evens (expt b power))\n                               (= power 1) (* evens b)\n                               :else evens)))))\n            (recur more\n                   (* f odds)\n                   evens)))))))\n\n(defn root-out-squares\n  \"Given an unwrapped symbolic expression, returns a new symbolic expression with\n  any perfect square (exponent with an even power) removed from underneath any\n  `sqrt` that appears in the expression.\n\n  To use [[root-out-squares]] with a wrapped symbolic expression,\n  use [[sicmutils.expression/fmap]].\"\n  [expr]\n  (w/prewalk\n   (fn [t]\n     (if (sym/sqrt? t)\n       (process-sqrt t)\n       t))\n   expr))\n"]}