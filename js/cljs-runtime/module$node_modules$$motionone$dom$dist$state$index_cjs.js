shadow$provide.module$node_modules$$motionone$dom$dist$state$index_cjs=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});var tslib=require("module$node_modules$tslib$tslib"),heyListen=require("module$node_modules$hey_listen$dist$index"),utils=require("module$node_modules$$motionone$utils$dist$index_cjs"),animateStyle=require("module$node_modules$$motionone$dom$dist$animate$animate_style_cjs"),style=require("module$node_modules$$motionone$dom$dist$animate$style_cjs"),
options=require("module$node_modules$$motionone$dom$dist$animate$utils$options_cjs"),hasChanged=require("module$node_modules$$motionone$dom$dist$state$utils$has_changed_cjs"),resolveVariant=require("module$node_modules$$motionone$dom$dist$state$utils$resolve_variant_cjs"),schedule=require("module$node_modules$$motionone$dom$dist$state$utils$schedule_cjs");global=require("module$node_modules$$motionone$dom$dist$state$gestures$in_view_cjs");module=require("module$node_modules$$motionone$dom$dist$state$gestures$hover_cjs");
var press=require("module$node_modules$$motionone$dom$dist$state$gestures$press_cjs"),events=require("module$node_modules$$motionone$dom$dist$state$utils$events_cjs");const gestures={inView:global.inView,hover:module.hover,press:press.press},stateTypes=["initial","animate",...Object.keys(gestures),"exit"],mountedStates=new WeakMap;exports.createMotionState=function(options$1={},parent){let element,depth=parent?parent.getDepth()+1:0;const activeStates={initial:!0,animate:!0},gestureSubscriptions={},
context={};for(const name of stateTypes)context[name]="string"===typeof options$1[name]?options$1[name]:null===parent||void 0===parent?void 0:parent.getContext()[name];parent=!1===options$1.initial?"animate":"initial";parent=resolveVariant.resolveVariant(options$1[parent]||context[parent],options$1.variants)||{};let target=tslib.__rest(parent,["transition"]);const baseTarget=Object.assign({},target),setGesture=(name,isActive)=>()=>{activeStates[name]=isActive;schedule.scheduleAnimation(state)},updateGestureSubscriptions=
()=>{for(const name in gestures){const isGestureActive=gestures[name].isActive(options$1),remove=gestureSubscriptions[name];isGestureActive&&!remove?gestureSubscriptions[name]=gestures[name].subscribe(element,{enable:setGesture(name,!0),disable:setGesture(name,!1)},options$1):!isGestureActive&&remove&&(remove(),delete gestureSubscriptions[name])}},state={update:newOptions=>{element&&(options$1=newOptions,updateGestureSubscriptions(),schedule.scheduleAnimation(state))},setActive:(name,isActive)=>{element&&
(activeStates[name]=isActive,schedule.scheduleAnimation(state))},animateUpdates:function*(){var _a$jscomp$0,_b;const prevTarget=target;target={};const animationOptions={};for(const name of stateTypes){if(!activeStates[name])continue;const variant=resolveVariant.resolveVariant(options$1[name]);if(variant)for(const key in variant)"transition"!==key&&(target[key]=variant[key],animationOptions[key]=options.getOptions(null!==(_b=null!==(_a$jscomp$0=variant.transition)&&void 0!==_a$jscomp$0?_a$jscomp$0:
options$1.transition)&&void 0!==_b?_b:{},key))}const animationFactories=[];(new Set([...Object.keys(target),...Object.keys(prevTarget)])).forEach(key=>{var _a;void 0===target[key]&&(target[key]=baseTarget[key]);hasChanged.hasChanged(prevTarget[key],target[key])&&(null!==(_a=baseTarget[key])&&void 0!==_a?_a:baseTarget[key]=style.style.get(element,key),animationFactories.push(animateStyle.animateStyle(element,key,target[key],animationOptions[key])))});yield;_a$jscomp$0=animationFactories.map(factory=>
factory()).filter(Boolean);if(_a$jscomp$0.length){var animationTarget=target;element.dispatchEvent(events.motionEvent("motionstart",animationTarget));Promise.all(_a$jscomp$0.map(animation=>animation.finished)).then(()=>{element.dispatchEvent(events.motionEvent("motioncomplete",animationTarget))}).catch(utils.noop)}},getDepth:()=>depth,getTarget:()=>target,getOptions:()=>options$1,getContext:()=>context,mount:newElement=>{heyListen.invariant(!!newElement,"Animation state must be mounted with valid Element");
element=newElement;mountedStates.set(element,state);updateGestureSubscriptions();return()=>{mountedStates.delete(element);schedule.unscheduleAnimation(state);for(const key in gestureSubscriptions)gestureSubscriptions[key]()}},isMounted:()=>!!element};return state};exports.mountedStates=mountedStates}
//# sourceMappingURL=module$node_modules$$motionone$dom$dist$state$index_cjs.js.map
