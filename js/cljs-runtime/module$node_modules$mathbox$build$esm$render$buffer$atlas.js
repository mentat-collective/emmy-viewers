shadow$provide.module$node_modules$mathbox$build$esm$render$buffer$atlas=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function __guard__(value,transform){return"undefined"!==typeof value&&null!==value?transform(value):
void 0}Object.defineProperty(exports,"__esModule",{value:!0});exports.Atlas=void 0;var UGLSL=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,
key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$mathbox$build$esm$util$glsl")),_backedtexture=require("module$node_modules$mathbox$build$esm$render$buffer$texture$backedtexture"),_datatexture=require("module$node_modules$mathbox$build$esm$render$buffer$texture$datatexture");
global=require("module$node_modules$mathbox$build$esm$render$renderable");var _Vector=require("module$node_modules$three$src$math$Vector2");class Atlas extends global.Renderable{constructor(renderer,shaders,options,build){null==build&&(build=!0);super(renderer,shaders);null==this.width&&(this.width=options.width||512);null==this.height&&(this.height=options.height||512);null==this.channels&&(this.channels=options.channels||4);null==this.backed&&(this.backed=options.backed||!1);this.samples=this.width*
this.height;build&&this.build(options)}shader(shader){shader.pipe("map.2d.data",this.uniforms);shader.pipe("sample.2d",this.uniforms);4>this.channels&&shader.pipe(UGLSL.swizzleVec4(["0000","x000","xw00","xyz0"][this.channels]));return shader}build(options){let klass;this.klass=klass=this.backed?_backedtexture.BackedTexture:_datatexture.DataTexture;this.texture=new klass(this.renderer,this.width,this.height,this.channels,options);this.uniforms={dataPointer:{type:"v2",value:new _Vector.Vector2(0,0)}};
this._adopt(this.texture.uniforms);return this.reset()}reset(){this.rows=[];return this.bottom=0}resize(width,height){if(!this.backed)throw Error("Cannot resize unbacked texture atlas");2048<width&&2048<height?console.warn(`Giant text atlas ${width}x${height}.`):console.info(`Resizing text atlas ${width}x${height}.`);this.texture.resize(width,height);this.width=width;this.height=height;return this.samples=width*height}collapse(row){let left;const {rows}=this;rows.splice(rows.indexOf(row),1);this.bottom=
null!=(left=__guard__(rows[rows.length-1],x=>x.bottom))?left:0;if(this.last===row)return this.last=null}allocate(key,width,height,emit){const w=this.width,h=this.height,max=2*height;if(width>w)return this.resize(2*w,2*h),this.last=null,this.allocate(key,width,height,emit);let row=this.last;if(null!=row&&row.height>=height&&row.height<max&&row.width+width<=w)row.append(key,width,height,emit);else{var bottom=0,index=-1,top=0;for(let i=0;i<this.rows.length;i++)if(row=this.rows[i],row.top-bottom>=height&&
0>index&&(index=i,top=bottom),{bottom}=row,row.height>=height&&row.height<max&&row.width+width<=w){row.append(key,width,height,emit);this.last=row;return}if(0<=index)row=new Row(top,height),this.rows.splice(index,0,row);else{top=bottom;bottom+=height;if(bottom>=h)return this.resize(2*w,2*h),this.last=null,this.allocate(key,width,height,emit);row=new Row(top,height);this.rows.push(row);this.bottom=bottom}row.append(key,width,height,emit);this.last=row}}read(){return this.texture.textureObject}write(data,
x,y,w,h){return this.texture.write(data,x,y,w,h)}dispose(){this.texture.dispose();this.data=null;return super.dispose()}}exports.Atlas=Atlas;class Row{constructor(top,height){this.top=top;this.bottom=top+height;this.width=0;this.height=height;this.alive=0;this.keys=[]}append(key,width,height,emit){height=this.width;const y=this.top;this.alive++;this.width+=width;this.keys.push(key);return emit(this,height,y)}}}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$render$buffer$atlas.js.map
