shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$present$present=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Present=void 0;global=require("module$node_modules$mathbox$build$esm$primitives$types$base$parent");class Present extends global.Parent{static initClass(){this.traits=["node","present"]}init(){}make(){this.nodes=[];this.steps=[];this.length=0;this.last=[];this.index=0;this.dirty=[];this._listen("root","root.update",
this.update);return this._compute("present.length",()=>this.length)}adopt(controller){const {node}=controller;0>this.nodes.indexOf(controller)&&this.nodes.push(node);return this.dirty.push(controller)}unadopt(controller){this.nodes=this.nodes.filter(x=>x!==controller);return this.dirty.push(controller)}update(){if(this.dirty.length){for(const controller of Array.from(this.dirty))this.slideReset(controller);[this.steps,this.indices]=Array.from(this.process(this.nodes));this.length=this.steps.length;
this.index=null;this.go(this.props.index);return this.dirty=[]}}slideLatch(controller,enabled,step){return controller.slideLatch(enabled,step)}slideStep(controller,index,step){return controller.slideStep(this.mapIndex(controller,index),step)}slideRelease(controller,_step){return controller.slideRelease()}slideReset(controller){return controller.slideReset()}mapIndex(controller,index){return index-this.indices[controller.node._id]}process(nodes$jscomp$0){const parents=(map=>el=>{let ref,ref1;const result=
[];for(;el&&([el,ref]=Array.from(ref1=[map(el),el]),ref1);)result.push(ref);return result})(function(el){return el.parent.traits.hash.present?null:el.parent}),isSlide=el=>0<=nodes$jscomp$0.indexOf(el),finalize=step=>step.sort((a,b)=>a.order-b.order);return function(lists){let step$jscomp$0;const [relative,absolute]=Array.from(lists),indices={};let steps=[];lists=function(step,index){let node;const {props}=node=step[0];var parent=step[1];const parentIndex=null!=parent?indices[parent._id]:0;parent=
null!=props.from?parentIndex+props.from:index-props.early;index=null!=props.to?parentIndex+props.to:index+props.steps+props.late;parent=Math.max(0,parent);index=Math.min(100,index);null==indices[node._id]&&(indices[node._id]=parent);for(let i=parent,end=index,asc=parent<=end;asc?i<end:i>end;asc?i++:i--)steps[i]=(null!=steps[i]?steps[i]:steps[i]=[]).concat(step);return props.steps};let i$jscomp$0=0;for(step$jscomp$0 of Array.from(relative))i$jscomp$0+=lists(step$jscomp$0,i$jscomp$0);for(step$jscomp$0 of Array.from(absolute))lists(step$jscomp$0,
0);steps=(()=>{const result$jscomp$0=[];for(step$jscomp$0 of Array.from(steps)){var JSCompiler_temp_const=result$jscomp$0,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push,JSCompiler_inline_result;if(JSCompiler_inline_result=step$jscomp$0){const result=[];for(let i=0;i<JSCompiler_inline_result.length;i++){const node=JSCompiler_inline_result[i];JSCompiler_inline_result.indexOf(node)===i&&result.push(node)}JSCompiler_inline_result=result}else JSCompiler_inline_result=[];JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,
finalize(JSCompiler_inline_result))}return result$jscomp$0})();return[steps,indices]}(function(steps){const relative=[],absolute=[];for(const step of Array.from(steps))(null!=step[0].props.steps?relative:absolute).push(step);return[relative,absolute]}((paths=>paths.sort(function(a,b){const c=a.length,d=b.length;let e=Math.min(c,d);for(let i=1,end=e,asc=1<=end;asc?i<=end:i>=end;asc?i++:i--){const nodeA=a[c-i],nodeB=b[d-i],f=nodeA.props.order,g=nodeB.props.order;if(null!=f||null!=g){if(null!=f&&null!=
g&&0!==(e=f-g))return e;if(null!=f)return-1;if(null!=g)return 1}if(nodeB.order!==nodeA.order)return nodeB.order-nodeA.order}e=c-d;return 0!==e?e:0}))((nodes=>Array.from(nodes).map(el=>parents(el).filter(isSlide)))(nodes$jscomp$0))))}go(index){var left;let node;index=Math.max(0,Math.min(this.length+1,+index||0));const active=null!=(left=this.steps[index-1])?left:[];left=this.props.directed?index-this.index:1;this.index=index;const enter=(()=>{const result=[];for(node of Array.from(active))0>this.last.indexOf(node)&&
result.push(node);return result})(),exit=(()=>{const result1=[];for(node of Array.from(this.last))0>active.indexOf(node)&&result1.push(node);return result1})(),stay=(()=>{const result2=[];for(node of Array.from(active))0>enter.indexOf(node)&&0>exit.indexOf(node)&&result2.push(node);return result2})(),ascend=nodes=>nodes.sort((a,b)=>a.order-b.order),descend=nodes=>nodes.sort((a,b)=>b.order-a.order);for(node of Array.from(ascend(enter)))this.slideLatch(node.controller,!0,left);for(node of Array.from(ascend(stay)))this.slideLatch(node.controller,
null,left);for(node of Array.from(ascend(exit)))this.slideLatch(node.controller,!1,left);for(node of Array.from(enter))this.slideStep(node.controller,index,left);for(node of Array.from(stay))this.slideStep(node.controller,index,left);for(node of Array.from(exit))this.slideStep(node.controller,index,left);for(node of Array.from(descend(enter)))this.slideRelease(node.controller);for(node of Array.from(descend(stay)))this.slideRelease(node.controller);for(node of Array.from(descend(exit)))this.slideRelease(node.controller);
this.last=active}change(changed,touched,init){if(changed["present.index"]||init)return this.go(this.props.index)}}exports.Present=Present;Present.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$present$present.js.map
