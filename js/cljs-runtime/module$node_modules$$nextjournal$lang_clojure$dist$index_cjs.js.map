{
"version":3,
"file":"module$node_modules$$nextjournal$lang_clojure$dist$index_cjs.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,4DAAA,CAAiF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGzHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAAEG,MAAO,CAAA,CAAT,CAA7C,CAEIC,OAAAA,CAAeN,OAAA,CAAQ,+DAAR,CACfO,OAAAA,CAAYP,OAAA,CAAQ,qDAAR,CAChB,KAAIQ,SAAWR,OAAA,CAAQ,yDAAR,CAMf,OAAM,CAAES,IAAF,CAAA,CAAWH,MAAaI,CAAAA,KAA9B,CAGMC,gBAAkBH,QAASI,CAAAA,UAAWC,CAAAA,MAApB,CAA2B,CAC/CC,OAAQR,MAAaQ,CAAAA,MAAOC,CAAAA,SAApB,CAA8B,CAClCL,MAAO,CAACH,MAAUS,CAAAA,SAAV,CAAoB,CAAEC,GAAIV,MAAUW,CAAAA,IAAKC,CAAAA,OAArB;AACpBC,QAASb,MAAUW,CAAAA,IAAKC,CAAAA,OADJ,CAEpB,kBAAmBZ,MAAUW,CAAAA,IAAKC,CAAAA,OAFd,CAGpB,iBAAkBZ,MAAUW,CAAAA,IAAKG,CAAAA,UAAf,CAA0Bd,MAAUW,CAAAA,IAAKI,CAAAA,YAAzC,CAHE,CAMpBC,QAAShB,MAAUW,CAAAA,IAAKM,CAAAA,IANJ,CAOpB,gBAAiBjB,MAAUW,CAAAA,IAAKO,CAAAA,QAPZ,CAQpB,WAAYlB,MAAUW,CAAAA,IAAKQ,CAAAA,OARP,CASpBC,OAAQpB,MAAUW,CAAAA,IAAKU,CAAAA,MATH,CAUpBC,cAAetB,MAAUW,CAAAA,IAAKY,CAAAA,MAVV,CAWpB,QAAYvB,MAAUW,CAAAA,IAAKY,CAAAA,MAXP,CAYpBC,QAASxB,MAAUW,CAAAA,IAAKM,CAAAA,IAZJ,CAapBQ,IAAKzB,MAAUW,CAAAA,IAAKe,CAAAA,IAbA,CAcpBC,YAAa3B,MAAUW,CAAAA,IAAKiB,CAAAA,WAdR,CAepBC,OAAQ7B,MAAUW,CAAAA,IAAKmB,CAAAA,MAfH,CAApB,CAAD,CAgBH7B,QAAS8B,CAAAA,cAAeC,CAAAA,GAAxB,CAA6BC,QAAD,EAChBC,OAAD,EAAa,CAChB,IAAI,CAAaC,IAAb,CAAA,CAAoDD,OACxD,OAAID,SAASG,CAAAA,IAAT,CAAclC,IAAd,CAAJ;CAEQmC,OACJ,CADiBH,OAAQI,CAAAA,MAAR,CAAeH,IAAKI,CAAAA,UAAWC,CAAAA,EAA/B,CACjB,CAAI,MAAJ,EAAcP,QAASQ,CAAAA,IAAvB,EAA+B,CAAC,IAAD,CAAO,SAAP,CAAkB,UAAlB,CAA8BC,CAAAA,QAA9B,CAAuCP,IAAKI,CAAAA,UAAWI,CAAAA,WAAYC,CAAAA,IAAKH,CAAAA,IAAxE,CAA/B,CACWJ,OADX,CACwB,CADxB,CAIWA,OAPf,EAWW,CAbK,CADxB,CAhBG,CAkCHpC,QAAS4C,CAAAA,YAAab,CAAAA,GAAtB,CAA0B,CAAE,CAAC,iBAAD,EAAqB/B,QAAS6C,CAAAA,UAAhC,CAA1B,CAlCG,CAD2B,CAA9B,CADuC,CAsC/CC,aAAc,CAAEC,cAAe,CAAEC,KAAM,IAAR,CAAjB,CAtCiC,CAA3B,CA4CxBtD,QAAQuD,CAAAA,OAAR,CAJAA,QAAgB,EAAG,CACf,MAAO,KAAIjD,QAASkD,CAAAA,eAAb,CAA6B/C,eAA7B,CADQ,CAKnBT,QAAQS,CAAAA,eAAR,CAA0BA,eA7D+F;",
"sources":["node_modules/@nextjournal/lang-clojure/dist/index.cjs"],
"sourcesContent":["shadow$provide[\"module$node_modules$$nextjournal$lang_clojure$dist$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar lezerClojure = require('@nextjournal/lezer-clojure');\nvar highlight = require('@lezer/highlight');\nvar language = require('@codemirror/language');\n\n/**\nA language provider based on the [Lezer Clojure](https://github.com/nextjournal/lezer-clojure), extended with\nhighlighting and indentation information.\n*/\nconst { coll } = lezerClojure.props;\n// debug\n// const nodeText = (state, node: SyntaxNode) => { return state.doc.sliceString(node.from, node.to) }\nconst clojureLanguage = language.LRLanguage.define({\n    parser: lezerClojure.parser.configure({\n        props: [highlight.styleTags({ NS: highlight.tags.keyword,\n                DefLike: highlight.tags.keyword,\n                \"Operator/Symbol\": highlight.tags.keyword,\n                \"VarName/Symbol\": highlight.tags.definition(highlight.tags.variableName),\n                // Symbol: tags.keyword,\n                // \"'\": tags.keyword, // quote\n                Boolean: highlight.tags.atom,\n                \"DocString/...\": highlight.tags.emphasis,\n                \"Discard!\": highlight.tags.comment,\n                Number: highlight.tags.number,\n                StringContent: highlight.tags.string,\n                \"\\\"\\\\\\\"\\\"\": highlight.tags.string,\n                Keyword: highlight.tags.atom,\n                Nil: highlight.tags.null,\n                LineComment: highlight.tags.lineComment,\n                RegExp: highlight.tags.regexp }),\n            language.indentNodeProp.add((nodeType) => {\n                return (context) => {\n                    let { pos, unit, node, state, baseIndent, textAfter } = context;\n                    if (nodeType.prop(coll)) {\n                        // same behaviour as in clojure-mode: args after operator are always 2-units indented\n                        let parentBase = context.column(node.firstChild.to); // column at the right of parent opening-(\n                        if (\"List\" == nodeType.name && [\"NS\", \"DefLike\", \"Operator\"].includes(node.firstChild.nextSibling.type.name)) {\n                            return parentBase + 1;\n                        }\n                        else {\n                            return parentBase;\n                        }\n                    }\n                    else {\n                        return 0;\n                    }\n                };\n            }),\n            language.foldNodeProp.add({ [\"Vector Map List\"]: language.foldInside })]\n    }),\n    languageData: { commentTokens: { line: \";;\" } }\n});\nfunction clojure() {\n    return new language.LanguageSupport(clojureLanguage);\n}\n\nexports.clojure = clojure;\nexports.clojureLanguage = clojureLanguage;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","lezerClojure","highlight","language","coll","props","clojureLanguage","LRLanguage","define","parser","configure","styleTags","NS","tags","keyword","DefLike","definition","variableName","Boolean","atom","emphasis","comment","Number","number","StringContent","string","Keyword","Nil","null","LineComment","lineComment","RegExp","regexp","indentNodeProp","add","nodeType","context","node","prop","parentBase","column","firstChild","to","name","includes","nextSibling","type","foldNodeProp","foldInside","languageData","commentTokens","line","clojure","LanguageSupport"]
}
