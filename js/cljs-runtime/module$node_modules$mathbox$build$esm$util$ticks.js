shadow$provide.module$node_modules$mathbox$build$esm$util$ticks=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.make=exports.log=exports.linear=void 0;const linear=function(min,max,n,unit,base,factor,start,end,zero,nice){let i,f;null==nice&&(nice=!0);n||(n=10);unit||(unit=1);base||(base=10);factor||(factor=1);const ideal=(max-min)/n;if(!nice)return max=(()=>{let asc,end1;const result=[];i=0;end1=n;for(asc=0<=end1;asc?i<=end1:i>=end1;asc?i++:i--)result.push(min+
i*ideal);return result})(),start||max.shift(),end||max.pop(),zero||(max=max.filter(x=>0!==x)),max;unit||(unit=1);base||(base=10);const ref$jscomp$0=unit*Math.pow(base,Math.floor(Math.log(ideal/unit)/Math.log(base))),factors=0===base%2?[base/2,1,.5]:0===base%3?[base/3,1,1/3]:[1];unit=(()=>{const result1=[];for(f of Array.from(factors))result1.push(ref$jscomp$0*f);return result1})();let distance=Infinity,step$jscomp$0=unit.reduce(function(ref,step){f=step/ideal;const d=Math.max(f,1/f);return d<distance?
(distance=d,step):ref},ref$jscomp$0);step$jscomp$0*=factor;min=Math.ceil(min/step$jscomp$0+ +!start)*step$jscomp$0;max=(Math.floor(max/step$jscomp$0)-+!end)*step$jscomp$0;n=Math.ceil((max-min)/step$jscomp$0);max=(()=>{let asc1,end2;const result2=[];i=0;end2=n;for(asc1=0<=end2;asc1?i<=end2:i>=end2;asc1?i++:i--)result2.push(min+i*step$jscomp$0);return result2})();zero||(max=max.filter(x=>0!==x));return max};exports.linear=linear;const log=function(_min,_max,_n,_unit,_base,_bias,_start,_end,_zero,_nice){throw Error("Log ticks not yet implemented.");
};exports.log=log;exports.make=function(type,min,max,n,unit,base,bias,start,end,zero,nice){switch(type){case 0:return linear(min,max,n,unit,base,bias,start,end,zero,nice);case 1:return log(min,max,n,unit,base,bias,start,end,zero,nice)}}}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$util$ticks.js.map
