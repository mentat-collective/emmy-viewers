shadow$provide.module$node_modules$mathbox$build$esm$shaders$glsl$ticks_position=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="uniform float worldUnit;\nuniform float focusDepth;\nuniform float tickSize;\nuniform float tickEpsilon;\nuniform vec3  tickNormal;\nuniform vec2  tickStrip;\n\nvec4 getSample(vec4 xyzw);\n\nvec3 transformPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut);\n\nvec3 getTickPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut) {\n  float epsilon \x3d tickEpsilon;\n\n  // determine tick direction\n  float leftX  \x3d max(tickStrip.x, xyzw.y - 1.0);\n  float rightX \x3d min(tickStrip.y, xyzw.y + 1.0);\n  \n  vec4 left    \x3d getSample(vec4(leftX,  xyzw.zw, 0.0));\n  vec4 right   \x3d getSample(vec4(rightX, xyzw.zw, 0.0));\n  vec4 diff    \x3d right - left;\n\n  vec3 normal  \x3d cross(normalize(diff.xyz + vec3(diff.w)), tickNormal);\n  float bias   \x3d max(0.0, 1.0 - length(normal) * 2.0);\n       normal  \x3d mix(normal, tickNormal.yzx, bias * bias);\n  \n  // transform (point) and (point + delta)\n  vec4 center  \x3d getSample(vec4(xyzw.yzw, 0.0));\n  vec4 delta   \x3d vec4(normal, 0.0) * epsilon;\n\n  vec4 a \x3d center;\n  vec4 b \x3d center + delta;\n\n  vec4 _;\n  vec3 c \x3d transformPosition(a, stpqIn, stpqOut);\n  vec3 d \x3d transformPosition(b, stpqIn, _);\n  \n  // sample on either side to create line\n  float line \x3d xyzw.x - .5;\n  vec3  mid  \x3d c;\n  vec3  side \x3d normalize(d - c);\n\n  return mid + side * line * tickSize * worldUnit * focusDepth;\n}\n"}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$shaders$glsl$ticks_position.js.map
