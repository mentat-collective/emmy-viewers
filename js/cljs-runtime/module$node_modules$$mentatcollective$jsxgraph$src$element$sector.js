shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$element$sector=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _jxg=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg")),_geometry=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$geometry")),_math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),
_statistics=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$statistics")),_coords=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coords")),_constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants")),_type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type"));_jxg.default.createSector=function(board,parents,attributes){var type=
"invalid";type=["center","radiusPoint","anglePoint"];if(parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE&&(_type.default.isArray(parents[2])||_type.default.isNumber(parents[2]))&&(_type.default.isArray(parents[3])||_type.default.isNumber(parents[3]))&&(_type.default.isNumber(parents[4])||_type.default.isFunction(parents[4])||_type.default.isString(parents[4])))type="2lines";else{var v=_type.default.providePoints(board,parents,
attributes,"sector",type);if(!1===v)throw Error("JSXGraph: Can't create Sector with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.");type="3points"}var attr=_type.default.copyAttributes(attributes,board.options,"sector");var el=board.create("curve",[[0],[0]],attr);el.type=_constants.default.OBJECT_TYPE_SECTOR;el.elType="sector";el.autoRadius=function(){var r1=20/el.board.unitX,r2=Infinity,r3=50/el.board.unitX;_type.default.isPoint(el.center)&&(r2=.3333*
el.center.Dist(el.point2));return Math.max(r1,Math.min(r2,r3))};if("2lines"===type)el.Radius=function(){var r=_type.default.evaluate(parents[4]);return"auto"===r?this.autoRadius():r},el.line1=board.select(parents[0]),el.line2=board.select(parents[1]),el.line1.addChild(el),el.line2.addChild(el),el.setParents(parents),el.point1={visProp:{}},el.point2={visProp:{}},el.point3={visProp:{}},attributes=_geometry.default.meetLineLine(el.line1.stdform,el.line2.stdform,0,board),_type.default.isArray(parents[2])?
(2===parents[2].length&&(parents[2]=[1].concat(parents[2])),v=_geometry.default.projectPointToLine({coords:{usrCoords:parents[2]}},el.line1,board),v=_statistics.default.subtract(v.usrCoords,attributes.usrCoords),el.direction1=0<=_math.default.innerProduct(v,[0,el.line1.stdform[2],-el.line1.stdform[1]],3)?1:-1):el.direction1=0<=parents[2]?1:-1,_type.default.isArray(parents[3])?(2===parents[3].length&&(parents[3]=[1].concat(parents[3])),v=_geometry.default.projectPointToLine({coords:{usrCoords:parents[3]}},
el.line2,board),v=_statistics.default.subtract(v.usrCoords,attributes.usrCoords),el.direction2=0<=_math.default.innerProduct(v,[0,el.line2.stdform[2],-el.line2.stdform[1]],3)?1:-1):el.direction2=0<=parents[3]?1:-1,el.updateDataArray=function(){var l1=this.line1;var l2=this.line2;var B=_math.default.crossProduct(l1.stdform,l2.stdform);Math.abs(B[0])>_math.default.eps*_math.default.eps&&(B[1]/=B[0],B[2]/=B[0],B[0]/=B[0]);var r=this.direction1*this.Radius();l1=_statistics.default.add(B,[0,r*l1.stdform[2],
-r*l1.stdform[1]]);r=this.direction2*this.Radius();r=_statistics.default.add(B,[0,r*l2.stdform[2],-r*l2.stdform[1]]);this.point2.coords=new _coords.default(_constants.default.COORDS_BY_USER,l1,el.board);this.point1.coords=new _coords.default(_constants.default.COORDS_BY_USER,B,el.board);this.point3.coords=new _coords.default(_constants.default.COORDS_BY_USER,r,el.board);Math.abs(l1[0])<_math.default.eps||Math.abs(B[0])<_math.default.eps||Math.abs(r[0])<_math.default.eps?(this.dataX=[NaN],this.dataY=
[NaN]):(B=_geometry.default.bezierArc(l1,B,r,!0,1),this.dataX=B[0],this.dataY=B[1],this.bezierDegree=3)},el.methodMap=_jxg.default.deepCopy(el.methodMap,{radius:"Radius",getRadius:"Radius",setRadius:"setRadius"});else if("3points"===type){el.point1=v[0];el.point2=v[1];el.point3=v[2];for(attr=0;3>attr;attr++)_type.default.exists(v[attr]._is_new)?(el.addChild(v[attr]),delete v[attr]._is_new):v[attr].addChild(el);el.useDirection=attributes.usedirection;el.setParents(v);_type.default.exists(v[3])&&(el.point4=
v[3],el.point4.addChild(el));el.methodMap=_jxg.default.deepCopy(el.methodMap,{arc:"arc",center:"center",radiuspoint:"radiuspoint",anglepoint:"anglepoint",radius:"Radius",getRadius:"Radius",setRadius:"setRadius"});el.updateDataArray=function(){var ar=this.point2;var B=this.point1,C=this.point3,sgn=1;var p1c=_type.default.evaluate(this.visProp.selection);if(ar.isReal&&B.isReal&&C.isReal){var det=_geometry.default.rad(ar,B,C);if("minor"===p1c&&det>Math.PI||"major"===p1c&&det<Math.PI)sgn=-1;if(this.useDirection&&
_type.default.exists(this.point4)){det=this.point2.coords.usrCoords;p1c=this.point4.coords.usrCoords;var p2c=this.point3.coords.usrCoords;det=(det[1]-p2c[1])*(det[2]-p1c[2])-(det[2]-p2c[2])*(det[1]-p1c[1]);0<=det&&(C=this.point2,ar=this.point3)}ar=ar.coords.usrCoords;B=B.coords.usrCoords;C=C.coords.usrCoords;ar=_geometry.default.bezierArc(ar,B,C,!0,sgn);this.dataX=ar[0];this.dataY=ar[1];this.bezierDegree=3}else this.dataX=[NaN],this.dataY=[NaN]};el.Radius=function(){return this.point2.Dist(this.point1)};
attr=_type.default.copyAttributes(attributes,board.options,"sector","arc");attr.withLabel=!1;attr.name+="_arc";el.arc=board.create("arc",[el.point1,el.point2,el.point3],attr);el.addChild(el.arc)}el.center=el.point1;el.radiuspoint=el.point2;el.anglepoint=el.point3;el.hasPointCurve=function(x,y){y=new _coords.default(_constants.default.COORDS_BY_SCREEN,[x,y],this.board);var r=this.Radius();var alpha=this.center.coords.distance(_constants.default.COORDS_BY_USER,y);x=_type.default.evaluate(this.visProp.selection);
if(_type.default.isObject(_type.default.evaluate(this.visProp.precision))){var beta=this.board._inputDevice;beta=_type.default.evaluate(this.visProp.precision[beta])}else beta=this.board.options.precision.hasPoint;beta/=Math.min(this.board.unitX,this.board.unitY);if(r=Math.abs(alpha-r)<beta){y=_geometry.default.rad(this.point2,this.center,y.usrCoords.slice(1));alpha=0;beta=_geometry.default.rad(this.point2,this.center,this.point3);if("minor"===x&&beta>Math.PI||"major"===x&&beta<Math.PI)alpha=beta,
beta=2*Math.PI;if(y<alpha||y>beta)r=!1}return r};el.hasPointSector=function(x,y){var angle=new _coords.default(_constants.default.COORDS_BY_SCREEN,[x,y],this.board);x=this.Radius();x=this.point1.coords.distance(_constants.default.COORDS_BY_USER,angle)<x;y=_type.default.evaluate(this.visProp.selection);if(x){angle=_geometry.default.rad(this.radiuspoint,this.center,angle.usrCoords.slice(1));var alpha=0;var beta=_geometry.default.rad(this.radiuspoint,this.center,this.anglepoint);if("minor"===y&&beta>
Math.PI||"major"===y&&beta<Math.PI)alpha=beta,beta=2*Math.PI;if(angle<alpha||angle>beta)x=!1}return x};el.hasPoint=function(x,y){return _type.default.evaluate(this.visProp.highlightonsector)||_type.default.evaluate(this.visProp.hasinnerpoints)?this.hasPointSector(x,y):this.hasPointCurve(x,y)};el.getTextAnchor=function(){return this.point1.coords};el.getLabelAnchor=function(){var vecx=_geometry.default.rad(this.point2,this.point1,this.point3);var vec=13/this.board.unitX;var dy=13/this.board.unitY,
p2c=this.point2.coords.usrCoords,pmc=this.point1.coords.usrCoords;var coords=p2c[1]-pmc[1];var len=p2c[2]-pmc[2];var vp_s=_type.default.evaluate(this.visProp.selection);p2c=this.label?this.label.visProp:this.visProp.label;if("minor"===vp_s&&vecx>Math.PI||"major"===vp_s&&vecx<Math.PI)vecx=-(2*Math.PI-vecx);coords=new _coords.default(_constants.default.COORDS_BY_USER,[pmc[1]+Math.cos(.5*vecx)*coords-Math.sin(.5*vecx)*len,pmc[2]+Math.sin(.5*vecx)*coords+Math.cos(.5*vecx)*len],this.board);vecx=coords.usrCoords[1]-
pmc[1];coords=coords.usrCoords[2]-pmc[2];len=Math.sqrt(vecx*vecx+coords*coords);vec=[pmc[1]+vecx*(len+vec)/len,pmc[2]+coords*(len+dy)/len];p2c.position=_geometry.default.calcLabelQuadrant(_geometry.default.rad([1,0],[0,0],vec));return new _coords.default(_constants.default.COORDS_BY_USER,vec,this.board)};el.setRadius=function(val){el.Radius=function(){var r=_type.default.evaluate(val);return"auto"===r?this.autoRadius():r}};el.getRadius=function(){_jxg.default.deprecated("Sector.getRadius()","Sector.Radius()");
return this.Radius()};"3points"===type&&(el.setPositionDirectly=function(method,coords,oldcoords){coords=new _coords.default(method,coords,this.board);method=new _coords.default(method,oldcoords,this.board);if(!el.point1.draggable()||!el.point2.draggable()||!el.point3.draggable())return this;method=_statistics.default.subtract(coords.usrCoords,method.usrCoords);this.board.create("transform",method.slice(1),{type:"translate"}).applyOnce([el.point1,el.point2,el.point3]);return this});el.prepareUpdate().update();
return el};_jxg.default.registerElement("sector",_jxg.default.createSector);_jxg.default.createCircumcircleSector=function(board,parents,attributes){var points=_type.default.providePoints(board,parents,attributes,"point");if(!1===points)throw Error("JSXGraph: Can't create circumcircle sector with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.");parents=board.create("circumcenter",points.slice(0,3),attr);parents.dump=!1;var attr=_type.default.copyAttributes(attributes,
board.options,"circumcirclesector");board=board.create("sector",[parents,points[0],points[2],points[1]],attr);board.elType="circumcirclesector";board.setParents(points);board.center=parents;board.subs={center:parents};return board};_jxg.default.registerElement("circumcirclesector",_jxg.default.createCircumcircleSector);_jxg.default.createMinorSector=function(board,parents,attributes){attributes.selection="minor";return _jxg.default.createSector(board,parents,attributes)};_jxg.default.registerElement("minorsector",
_jxg.default.createMinorSector);_jxg.default.createMajorSector=function(board,parents,attributes){attributes.selection="major";return _jxg.default.createSector(board,parents,attributes)};_jxg.default.registerElement("majorsector",_jxg.default.createMajorSector);_jxg.default.createAngle=function(board,parents,attributes){var type$jscomp$0="invalid";if(parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE&&parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE&&(_type.default.isArray(parents[2])||
_type.default.isNumber(parents[2]))&&(_type.default.isArray(parents[3])||_type.default.isNumber(parents[3])))type$jscomp$0="2lines";else{var points=_type.default.providePoints(board,parents,attributes,"point");if(!1===points)throw Error("JSXGraph: Can't create angle with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"' and '"+typeof parents[2]+"'.");type$jscomp$0="3points"}var attr=_type.default.copyAttributes(attributes,board.options,"angle");_type.default.exists(attr.name)&&""!==
attr.name||(attr.name=board.generateName({type:_constants.default.OBJECT_TYPE_ANGLE}));var radius=_type.default.exists(attr.radius)?attr.radius:0;if("2lines"===type$jscomp$0){parents.push(radius);var el=board.create("sector",parents,attr);el.updateDataArraySector=el.updateDataArray;el.setAngle=function(val){};el.free=function(val){}}else el=board.create("sector",[points[1],points[0],points[2]],attr),el.arc.visProp.priv=!0,el.point=el.point2=el.radiuspoint=points[0],el.pointsquare=el.point3=el.anglepoint=
points[2],el.Radius=function(){var r=_type.default.evaluate(radius);return"auto"===r?el.autoRadius():r},el.updateDataArraySector=function(){var A=this.point2,B=this.point1,C=this.point3,r=this.Radius(),d=B.Dist(A),sgn=1,vp_s=_type.default.evaluate(this.visProp.selection);var phi=_geometry.default.rad(A,B,C);if("minor"===vp_s&&phi>Math.PI||"major"===vp_s&&phi<Math.PI)sgn=-1;A=A.coords.usrCoords;B=B.coords.usrCoords;C=C.coords.usrCoords;A=[1,B[1]+(A[1]-B[1])*r/d,B[2]+(A[2]-B[2])*r/d];C=[1,B[1]+(C[1]-
B[1])*r/d,B[2]+(C[2]-B[2])*r/d];A=_geometry.default.bezierArc(A,B,C,!0,sgn);this.dataX=A[0];this.dataY=A[1];this.bezierDegree=3},el.setAngle=function(val){var p=this.anglepoint,q=this.radiuspoint;if(p.draggable()){var t1=this.board.create("transform",[val,this.center],{type:"rotate"});p.addTransform(q,t1);t1.update();p.moveTo(_math.default.matVecMult(t1.matrix,q.coords.usrCoords));t1=_type.default.isFunction(val)?function(){return 2*Math.PI-val()}:function(){return 2*Math.PI-val};var t2=this.board.create("transform",
[t1,this.center],{type:"rotate"});p.coords.on("update",function(){t2.update();q.moveTo(_math.default.matVecMult(t2.matrix,p.coords.usrCoords))});p.setParents(q)}return this},el.free=function(){var p=this.anglepoint;0<p.transformations.length&&(p.transformations.pop(),p.isDraggable=!0,p.parents=[],p.coords.off("update"));return this},el.setParents(points);_type.default.exists(el.visProp.text)&&el.label.setText(_type.default.evaluate(el.visProp.text));el.elType="angle";el.type=_constants.default.OBJECT_TYPE_ANGLE;
el.subs={};el.updateDataArraySquare=function(){var r=this.Radius();"2lines"===type$jscomp$0&&this.updateDataArraySector();var A=this.point2;var B=this.point1;var C=this.point3;A=A.coords.usrCoords;B=B.coords.usrCoords;C=C.coords.usrCoords;var d1=_geometry.default.distance(A,B,3);var d2=_geometry.default.distance(C,B,3);A=[1,B[1]+(A[1]-B[1])*r/d1,B[2]+(A[2]-B[2])*r/d1];C=[1,B[1]+(C[1]-B[1])*r/d2,B[2]+(C[2]-B[2])*r/d2];r=_math.default.crossProduct(C,B);d1=[-A[1]*r[1]-A[2]*r[2],A[0]*r[1],A[0]*r[2]];
r=_math.default.crossProduct(A,B);r=_math.default.crossProduct(d1,[-C[1]*r[1]-C[2]*r[2],C[0]*r[1],C[0]*r[2]]);r[1]/=r[0];r[2]/=r[0];this.dataX=[B[1],A[1],r[1],C[1],B[1]];this.dataY=[B[2],A[2],r[2],C[2],B[2]];this.bezierDegree=1};el.updateDataArrayNone=function(){this.dataX=[NaN];this.dataY=[NaN];this.bezierDegree=1};el.updateDataArray=function(){var type=_type.default.evaluate(this.visProp.type),deg=_geometry.default.trueAngle(this.point2,this.point1,this.point3),vp_s=_type.default.evaluate(this.visProp.selection);
if("minor"===vp_s&&180<deg||"major"===vp_s&&180>deg)deg=360-deg;Math.abs(deg-90)<_type.default.evaluate(this.visProp.orthosensitivity)+_math.default.eps&&(type=_type.default.evaluate(this.visProp.orthotype));"none"===type?this.updateDataArrayNone():"square"===type?this.updateDataArraySquare():"sector"===type?this.updateDataArraySector():"sectordot"===type&&(this.updateDataArraySector(),this.dot.visProp.visible||this.dot.setAttribute({visible:!0}));(!this.visProp.visible||"sectordot"!==type&&this.dot.visProp.visible)&&
this.dot.setAttribute({visible:!1})};attributes=_type.default.copyAttributes(attributes,board.options,"angle","dot");el.dot=board.create("point",[function(){if(_type.default.exists(el.dot)&&!el.dot.visProp.visible)return[0,0];var A=el.point2.coords.usrCoords;var B=el.point1.coords.usrCoords;var r=el.Radius();var d=_geometry.default.distance(A,B,3);var a2=_geometry.default.rad(el.point2,el.point1,el.point3);var co=_type.default.evaluate(el.visProp.selection);if("minor"===co&&a2>Math.PI||"major"===
co&&a2<Math.PI)a2=-(2*Math.PI-a2);a2*=.5;co=Math.cos(a2);a2=Math.sin(a2);A=[1,B[1]+(A[1]-B[1])*r/d,B[2]+(A[2]-B[2])*r/d];return _math.default.matVecMult([[1,0,0],[B[1]-.5*B[1]*co+.5*B[2]*a2,.5*co,.5*-a2],[B[2]-.5*B[1]*a2-.5*B[2]*co,.5*a2,.5*co]],A)}],attributes);el.dot.dump=!1;el.subs.dot=el.dot;if("2lines"===type$jscomp$0)for(attributes=0;2>attributes;attributes++)board.select(parents[attributes]).addChild(el.dot);else for(attributes=0;3>attributes;attributes++)board.select(points[attributes]).addChild(el.dot);
el.getLabelAnchor=function(){var dx=12;var co=_type.default.evaluate(el.visProp.selection);var l_vp=this.label?this.label.visProp:this.visProp.label;_type.default.exists(this.label.visProp.fontSize)&&(dx=_type.default.evaluate(this.label.visProp.fontSize));dx/=this.board.unitX;var vec=el.point2.coords.usrCoords;var B=el.point1.coords.usrCoords;var r=el.Radius();var d=_geometry.default.distance(vec,B,3);var a2=_geometry.default.rad(el.point2,el.point1,el.point3);if("minor"===co&&a2>Math.PI||"major"===
co&&a2<Math.PI)a2=-(2*Math.PI-a2);a2*=.5;co=Math.cos(a2);a2=Math.sin(a2);vec=[1,B[1]+(vec[1]-B[1])*r/d,B[2]+(vec[2]-B[2])*r/d];vec=_math.default.matVecMult([[1,0,0],[B[1]-.5*B[1]*co+.5*B[2]*a2,.5*co,.5*-a2],[B[2]-.5*B[1]*a2-.5*B[2]*co,.5*a2,.5*co]],vec);vec[1]/=vec[0];vec[2]/=vec[0];vec[0]/=vec[0];d=_geometry.default.distance(vec,B,3);vec=[vec[0],B[1]+(vec[1]-B[1])*(r+dx)/d,B[2]+(vec[2]-B[2])*(r+dx)/d];l_vp.position=_geometry.default.calcLabelQuadrant(_geometry.default.rad([1,0],[0,0],vec));return new _coords.default(_constants.default.COORDS_BY_USER,
vec,this.board)};el.Value=function(){return _geometry.default.rad(this.point2,this.point1,this.point3)};el.methodMap=_type.default.deepCopy(el.methodMap,{Value:"Value",setAngle:"setAngle",free:"free"});return el};_jxg.default.registerElement("angle",_jxg.default.createAngle);_jxg.default.createNonreflexAngle=function(board,parents,attributes){attributes.selection="minor";board=_jxg.default.createAngle(board,parents,attributes);board.Value=function(){var v=_geometry.default.rad(this.point2,this.point1,
this.point3);return v<Math.PI?v:2*Math.PI-v};return board};_jxg.default.registerElement("nonreflexangle",_jxg.default.createNonreflexAngle);_jxg.default.createReflexAngle=function(board,parents,attributes){attributes.selection="major";board=_jxg.default.createAngle(board,parents,attributes);board.Value=function(){var v=_geometry.default.rad(this.point2,this.point1,this.point3);return v>=Math.PI?v:2*Math.PI-v};return board};_jxg.default.registerElement("reflexangle",_jxg.default.createReflexAngle);
exports.default={createSector:_jxg.default.createSector,createCircumcircleSector:_jxg.default.createCircumcircleSector,createMinorSector:_jxg.default.createMinorSector,createMajorSector:_jxg.default.createMajorSector,createAngle:_jxg.default.createAngle,createReflexAngle:_jxg.default.createReflexAngle,createNonreflexAngle:_jxg.default.createNonreflexAngle}}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$element$sector.js.map
