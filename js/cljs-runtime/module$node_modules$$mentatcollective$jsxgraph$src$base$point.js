shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$base$point=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _jxg=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg")),_options=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$options")),_math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),
_geometry=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$geometry")),_constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants"));global=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$element"));var _type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type")),_coordselement=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coordselement"));
_jxg.default.Point=function(board,coordinates,attributes){this.constructor(board,attributes,_constants.default.OBJECT_TYPE_POINT,_constants.default.OBJECT_CLASS_POINT);this.element=this.board.select(attributes.anchor);this.coordsConstructor(coordinates);this.elType="point";this.id=this.board.setId(this,"P");this.board.renderer.drawPoint(this);this.board.finalizeAdding(this);this.createGradient();this.createLabel()};_jxg.default.Point.prototype=new global.default;_type.default.copyPrototypeMethods(_jxg.default.Point,
_coordselement.default,"coordsConstructor");_jxg.default.extend(_jxg.default.Point.prototype,{hasPoint:function(x,y){var coordsScr=this.coords.scrCoords,unit=_type.default.evaluate(this.visProp.sizeunit);if(_type.default.isObject(_type.default.evaluate(this.visProp.precision))){var r=this.board._inputDevice;var prec=_type.default.evaluate(this.visProp.precision[r])}else prec=this.board.options.precision.hasPoint;r=parseFloat(_type.default.evaluate(this.visProp.size));"user"===unit&&(r*=Math.sqrt(this.board.unitX*
this.board.unitY));r+=.5*parseFloat(_type.default.evaluate(this.visProp.strokewidth));r<prec&&(r=prec);return Math.abs(coordsScr[1]-x)<r+2&&Math.abs(coordsScr[2]-y)<r+2},update:function(fromParent){if(!this.needsUpdate)return this;this.updateCoords(fromParent);_type.default.evaluate(this.visProp.trace)&&this.cloneToBackground(!0);return this},updateTransform:function(fromParent){if(0===this.transformations.length||null===this.baseElement)return this;this===this.baseElement?(fromParent=this.transformations[0].apply(this.baseElement,
"self"),this.coords.setCoordinates(_constants.default.COORDS_BY_USER,fromParent)):fromParent=this.transformations[0].apply(this.baseElement);this.coords.setCoordinates(_constants.default.COORDS_BY_USER,fromParent);for(fromParent=1;fromParent<this.transformations.length;fromParent++)this.coords.setCoordinates(_constants.default.COORDS_BY_USER,this.transformations[fromParent].apply(this));return this},updateRenderer:function(){this.updateRendererGeneric("updatePoint");return this},bounds:function(){return this.coords.usrCoords.slice(1).concat(this.coords.usrCoords.slice(1))},
makeIntersection:function(el1,el2,i,j){el1=this.board.select(el1);el2=this.board.select(el2);var func=_geometry.default.intersectionFunction(this.board,el1,el2,i,j,_type.default.evaluate(this.visProp.alwaysintersect));this.addConstraint([func]);try{el1.addChild(this),el2.addChild(this)}catch(e){throw Error("JSXGraph: Can't create 'intersection' with parent types '"+typeof el1+"' and '"+typeof el2+"'.");}this.type=_constants.default.OBJECT_TYPE_INTERSECTION;this.elType="intersection";this.parents=
[el1.id,el2.id,i,j];this.generatePolynomial=function(){var poly1=el1.generatePolynomial(this),poly2=el2.generatePolynomial(this);return 0===poly1.length||0===poly2.length?[]:[poly1[0],poly2[0]]};this.prepareUpdate().update()},setStyle:function(i){this.visProp.face="cross cross cross circle circle circle circle square square square plus plus plus".split(" ")[i];this.visProp.size=[2,3,4,1,2,3,4,2,3,4,2,3,4][i];this.board.renderer.changePointStyle(this);return this},normalizeFace:function(s){_jxg.default.deprecated("Point.normalizeFace()",
"JXG.normalizePointFace()");return _options.default.normalizePointFace(s)},face:function(f){_jxg.default.deprecated("Point.face()","Point.setAttribute()");this.setAttribute({face:f})},size:function(s){_jxg.default.deprecated("Point.size()","Point.setAttribute()");this.setAttribute({size:s})},isOn:function(el,tol){tol=tol||_math.default.eps;if(_type.default.isPoint(el))return this.Dist(el)<tol;if(el.elementClass===_constants.default.OBJECT_CLASS_LINE){if("segment"!==el.elType||_type.default.evaluate(this.visProp.alwaysintersect))return _geometry.default.distPointLine(this.coords.usrCoords,
el.stdform)<tol;var arr=_jxg.default.Math.Geometry.projectCoordsToSegment(this.coords.usrCoords,el.point1.coords.usrCoords,el.point2.coords.usrCoords);if(0<=arr[1]&&1>=arr[1]&&_geometry.default.distPointLine(this.coords.usrCoords,el.stdform)<tol)return!0}else{if(el.elementClass===_constants.default.OBJECT_CLASS_CIRCLE)return _type.default.evaluate(el.visProp.hasinnerpoints)?this.Dist(el.center)<el.Radius()+tol:Math.abs(this.Dist(el.center)-el.Radius())<tol;if(el.elementClass===_constants.default.OBJECT_CLASS_CURVE)return el=
_geometry.default.projectPointToCurve(this,el,this.board)[0],_geometry.default.distance(this.coords.usrCoords,el.usrCoords,3)<tol;if(el.type===_constants.default.OBJECT_TYPE_POLYGON){if(_type.default.evaluate(el.visProp.hasinnerpoints)&&el.pnpoly(this.coords.usrCoords[1],this.coords.usrCoords[2],_jxg.default.COORDS_BY_USER))return!0;arr=_geometry.default.projectCoordsToPolygon(this.coords.usrCoords,el);return _geometry.default.distance(this.coords.usrCoords,arr,3)<tol}if(el.type===_constants.default.OBJECT_TYPE_TURTLE)return el=
_geometry.default.projectPointToTurtle(this,el,this.board),_geometry.default.distance(this.coords.usrCoords,el.usrCoords,3)<tol}return!1},cloneToBackground:function(){var copy={};copy.id=this.id+"T"+this.numTraces;this.numTraces+=1;copy.coords=this.coords;copy.visProp=_type.default.deepCopy(this.visProp,this.visProp.traceattributes,!0);copy.visProp.layer=this.board.options.layer.trace;copy.elementClass=_constants.default.OBJECT_CLASS_POINT;copy.board=this.board;_type.default.clearVisPropOld(copy);
copy.visPropCalc={visible:_type.default.evaluate(copy.visProp.visible)};this.board.renderer.drawPoint(copy);this.traces[copy.id]=copy.rendNode;return this}});_jxg.default.createPoint=function(board,parents,attributes){attributes=_type.default.copyAttributes(attributes,board.options,"point");board=_coordselement.default.create(_jxg.default.Point,board,parents,attributes);if(!board)throw Error("JSXGraph: Can't create point with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent types: [x,y], [z,x,y], [element,transformation]");
return board};_jxg.default.createGlider=function(board,parents,attributes){var attr=_type.default.copyAttributes(attributes,board.options,"glider");attributes=1===parents.length?[0,0]:parents.slice(0,2);board=board.create("point",attributes,attr);board.makeGlider(parents[parents.length-1]);return board};_jxg.default.createIntersectionPoint=function(board,parents,attributes){var attr=_type.default.copyAttributes(attributes,board.options,"intersection");parents.push(0,0);var el1=board.select(parents[0]);
var el2=board.select(parents[1]);attributes=parents[2]||0;var j=parents[3]||0;var el=board.create("point",[0,0,0],attr);board=_geometry.default.intersectionFunction(board,el1,el2,attributes,j,el.visProp.alwaysintersect);el.addConstraint([board]);try{el1.addChild(el),el2.addChild(el)}catch(e){throw Error("JSXGraph: Can't create 'intersection' with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.");}el.type=_constants.default.OBJECT_TYPE_INTERSECTION;el.elType="intersection";el.setParents([el1.id,
el2.id]);el.intersectionNumbers=[attributes,j];el.getParents=function(){return this.parents.concat(this.intersectionNumbers)};el.generatePolynomial=function(){var poly1=el1.generatePolynomial(el),poly2=el2.generatePolynomial(el);return 0===poly1.length||0===poly2.length?[]:[poly1[0],poly2[0]]};return el};_jxg.default.createOtherIntersectionPoint=function(board,parents,attributes){if(3!==parents.length||!_type.default.isPoint(parents[2])||parents[0].elementClass!==_constants.default.OBJECT_CLASS_LINE&&
parents[0].elementClass!==_constants.default.OBJECT_CLASS_CIRCLE||parents[1].elementClass!==_constants.default.OBJECT_CLASS_LINE&&parents[1].elementClass!==_constants.default.OBJECT_CLASS_CIRCLE)throw Error("JSXGraph: Can't create 'other intersection point' with parent types '"+typeof parents[0]+"',  '"+typeof parents[1]+"'and  '"+typeof parents[2]+"'.\nPossible parent types: [circle|line,circle|line,point]");var el1=board.select(parents[0]);var el2=board.select(parents[1]);var other=board.select(parents[2]);
var el=board.create("point",[function(){var c=_geometry.default.meet(el1.stdform,el2.stdform,0,el1.board);return Math.abs(other.X()-c.usrCoords[1])>_math.default.eps||Math.abs(other.Y()-c.usrCoords[2])>_math.default.eps||Math.abs(other.Z()-c.usrCoords[0])>_math.default.eps?c:_geometry.default.meet(el1.stdform,el2.stdform,1,el1.board)}],attributes);el.type=_constants.default.OBJECT_TYPE_INTERSECTION;el.elType="otherintersection";el.setParents([el1.id,el2.id,other]);el1.addChild(el);el2.addChild(el);
el.generatePolynomial=function(){var poly1=el1.generatePolynomial(el),poly2=el2.generatePolynomial(el);return 0===poly1.length||0===poly2.length?[]:[poly1[0],poly2[0]]};return el};_jxg.default.createPolePoint=function(board,parents,attributes){if(1<parents.length){var firstParentIsConic=parents[0].type===_constants.default.OBJECT_TYPE_CONIC||parents[0].elementClass===_constants.default.OBJECT_CLASS_CIRCLE;var secondParentIsConic=parents[1].type===_constants.default.OBJECT_TYPE_CONIC||parents[1].elementClass===
_constants.default.OBJECT_CLASS_CIRCLE;var firstParentIsLine=parents[0].elementClass===_constants.default.OBJECT_CLASS_LINE;var secondParentIsLine=parents[1].elementClass===_constants.default.OBJECT_CLASS_LINE}if(2!==parents.length||!(firstParentIsConic&&secondParentIsLine||firstParentIsLine&&secondParentIsConic))throw Error("JSXGraph: Can't create 'pole point' with parent types '"+typeof parents[0]+"' and '"+typeof parents[1]+"'.\nPossible parent type: [conic|circle,line], [line,conic|circle]");
if(secondParentIsLine){var el1=board.select(parents[0]);var el2=board.select(parents[1])}else el1=board.select(parents[1]),el2=board.select(parents[0]);board=board.create("point",[function(){var q=el1.quadraticform,s=el2.stdform.slice(0,3);return[_jxg.default.Math.Numerics.det([s,q[1],q[2]]),_jxg.default.Math.Numerics.det([q[0],s,q[2]]),_jxg.default.Math.Numerics.det([q[0],q[1],s])]}],attributes);board.elType="polepoint";board.setParents([el1.id,el2.id]);el1.addChild(board);el2.addChild(board);return board};
_jxg.default.registerElement("point",_jxg.default.createPoint);_jxg.default.registerElement("glider",_jxg.default.createGlider);_jxg.default.registerElement("intersection",_jxg.default.createIntersectionPoint);_jxg.default.registerElement("otherintersection",_jxg.default.createOtherIntersectionPoint);_jxg.default.registerElement("polepoint",_jxg.default.createPolePoint);exports.default={Point:_jxg.default.Point,createPoint:_jxg.default.createPoint,createGlider:_jxg.default.createGlider,createIntersection:_jxg.default.createIntersectionPoint,
createOtherIntersection:_jxg.default.createOtherIntersectionPoint,createPolePoint:_jxg.default.createPolePoint}}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$base$point.js.map
