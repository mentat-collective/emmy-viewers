shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$lights_lambert_vertex_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\nvec3 diffuse \x3d vec3( 1.0 );\n\nGeometricContext geometry;\ngeometry.position \x3d mvPosition.xyz;\ngeometry.normal \x3d normalize( transformedNormal );\ngeometry.viewDir \x3d ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( -mvPosition.xyz );\n\nGeometricContext backGeometry;\nbackGeometry.position \x3d geometry.position;\nbackGeometry.normal \x3d -geometry.normal;\nbackGeometry.viewDir \x3d geometry.viewDir;\n\nvLightFront \x3d vec3( 0.0 );\nvIndirectFront \x3d vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack \x3d vec3( 0.0 );\n\tvIndirectBack \x3d vec3( 0.0 );\n#endif\n\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n\nvIndirectFront +\x3d getAmbientLightIrradiance( ambientLightColor );\n\nvIndirectFront +\x3d getLightProbeIrradiance( lightProbe, geometry.normal );\n\n#ifdef DOUBLE_SIDED\n\n\tvIndirectBack +\x3d getAmbientLightIrradiance( ambientLightColor );\n\n\tvIndirectBack +\x3d getLightProbeIrradiance( lightProbe, backGeometry.normal );\n\n#endif\n\n#if NUM_POINT_LIGHTS \x3e 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tgetPointLightInfo( pointLights[ i ], geometry, directLight );\n\n\t\tdotNL \x3d dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse \x3d directLight.color;\n\n\t\tvLightFront +\x3d saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack +\x3d saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_SPOT_LIGHTS \x3e 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tgetSpotLightInfo( spotLights[ i ], geometry, directLight );\n\n\t\tdotNL \x3d dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse \x3d directLight.color;\n\n\t\tvLightFront +\x3d saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack +\x3d saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_DIR_LIGHTS \x3e 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tgetDirectionalLightInfo( directionalLights[ i ], geometry, directLight );\n\n\t\tdotNL \x3d dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse \x3d directLight.color;\n\n\t\tvLightFront +\x3d saturate( dotNL ) * directLightColor_Diffuse;\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvLightBack +\x3d saturate( - dotNL ) * directLightColor_Diffuse;\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if NUM_HEMI_LIGHTS \x3e 0\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\tvIndirectFront +\x3d getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t#ifdef DOUBLE_SIDED\n\n\t\t\tvIndirectBack +\x3d getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry.normal );\n\n\t\t#endif\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$lights_lambert_vertex_glsl.js.map
