{"version":3,"sources":["sicmutils/calculus/vector_field.cljc"],"mappings":"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","names":["cljs.core.derive","sicmutils.calculus.vector-field/vector-field?","vf","sicmutils.operator/operator?","sicmutils.operator/context","cljs.core._EQ_","var_args","G__101430","sicmutils.calculus.vector-field/procedure->vector-field","js/Error","f","sicmutils.calculus.vector_field.procedure__GT_vector_field","name","context","sicmutils.calculus.vector-field/vf:zero?","sicmutils.calculus.vector-field/vf:zero-like","sicmutils.operator.make_operator","sicmutils.calculus.vector-field/vector-field-procedure","component-fns","coordinate-system","sicmutils.function$.compose","sicmutils.generic._STAR_","G__101432","sicmutils.calculus.derivative/D","sicmutils.calculus.manifold/point","sicmutils.calculus.manifold/chart","G__101434","sicmutils.calculus.vector-field/components->vector-field","components","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","sicmutils.calculus.vector_field.components__GT_vector_field","vfp","sicmutils.function/memoize","cljs.core.comp","sicmutils.calculus.vector-field/vector-field->components","G__101439","sicmutils.calculus.vector-field/vf:zero","_","sicmutils.calculus.manifold/zero-manifold-function","op","sicmutils.operator/procedure","sicmutils.calculus.vector-field/literal-vector-field","sym","n","sicmutils.calculus.manifold/manifold","domain","sicmutils.structure/up*","cljs.core.repeat","range","sicmutils.abstract$.function$.literal_function","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.calculus.vector-field/coordinate-basis-vector-field-procedure","seq101441","G__101442","cljs.core/first","cljs.core/next","self__4851__auto__","indices","G__101445","fexpr__101444","cljs.core.apply","sicmutils.calculus.derivative/partial","sicmutils.calculus.vector-field/coordinate-basis-vector-field","seq101446","G__101447","G__101448","sicmutils.calculus.vector-field/coordinate-name->vf-name","cljs.core.symbol","sicmutils.calculus.vector-field/coordinate-system->vector-basis","sicmutils.structure/transpose","sicmutils.structure/map-chain","c-name","chain","vf-name","sicmutils.calculus.manifold/coordinate-prototype","sicmutils.calculus.vector-field/basis-components->vector-field","vector-basis","sicmutils.structure/compatible-for-contraction?","applied","point","cljs.core.map","component","basis-element","sicmutils.value/freeze","cljs.core/flatten","sicmutils.calculus.vector-field/vector-field->basis-components","dual-basis","sicmutils.structure.mapr","w","sicmutils.calculus.vector-field/coordinatize","x","b","G__101454","fexpr__101455","coordinatized-v","sicmutils.operator/name","sicmutils.calculus.vector-field/evolution","order","delta-t","vector-field","manifold-fn","manifold-point","fexpr__101457","fexpr__101458","sicmutils.generic/exp","sicmutils.series/sum"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.calculus.vector-field\n  \"This namespace implements a vector field operator and a number of functions for\n  creating and working with vector fields.\n\n  A vector field is an operator that takes a smooth real-valued function of a\n  manifold and produces a new function on the manifold which computes the\n  directional derivative of the given function at each point of the manifold.\"\n  (:require [sicmutils.abstract.function :as af]\n            [sicmutils.calculus.derivative :as deriv :refer [D]]\n            [sicmutils.calculus.manifold :as m]\n            [sicmutils.function :as f]\n            [sicmutils.generic :as g]\n            [sicmutils.operator :as o]\n            [sicmutils.series :as series]\n            [sicmutils.structure :as s]\n            [sicmutils.value :as v]))\n\n;; ## Vector Fields\n;;\n;; A vector field is an operator that takes a smooth real-valued function of a\n;; manifold and produces a new function on the manifold which computes the\n;; directional derivative of the given function at each point of the manifold.\n;;\n;; As with other differential operators such as D, a vector-field operator\n;; multiplies by composition. Like D it takes the given function to another\n;; function of a point.\n\n(derive ::vector-field ::o/operator)\n\n(declare vf:zero? vf:zero-like)\n\n(defn vector-field?\n  \"Returns true if the supplied argument `vf` is a vector field operator, false\n  otherwise.\"\n  [vf]\n  (and (o/operator? vf)\n       (-> (o/context vf)\n           (:subtype)\n           (= ::vector-field))))\n\n(defn ^:no-doc procedure->vector-field\n  \"Accepts a function `f` and an optional symbolic `name`, and returns a vector\n  field, ie, a subtype of [[sicmutils.operator/Operator]].\n\n  `f` should be a function from a smooth real-valued function `g` of a manifold\n  to a new function on the manifold which computes the directional derivative of\n  `g` at each point of the manifold.\"\n  ([f]\n   (procedure->vector-field f 'unnamed-vector-field))\n  ([f name]\n   (let [context {:subtype ::vector-field\n                  :zero? vf:zero?\n                  :zero-like vf:zero-like\n                  :arguments [::v/function]}]\n     (o/make-operator f name context))))\n\n(defn ^:no-doc vector-field-procedure\n  \"Takes:\n\n  - an `up` tuple, `components`, of the functions that each return the\n    corresponding component of the vector field relative to `coordinate-system`\n  - the `coordinate-system`\n\n  And returns a procedure (not yet an operator!) that takes a smooth real-valued\n  function of manifold points and produces a NEW function that computes the\n  directional derivative of the given function at each point of the manifold.\"\n  [component-fns coordinate-system]\n  (fn [f]\n    (f/compose\n     (g/* (D (f/compose f (m/point coordinate-system)))\n          component-fns)\n     (m/chart coordinate-system))))\n\n(defn components->vector-field\n  \"Takes:\n\n  - an `up` tuple of the functions that each return the corresponding component\n  of the vector field relative `coordinate-system`\n  - the `coordinate-system`\n  - optionally, a symbolic name for the vector field operator\n\n  And returns a vector field.\n\n  A vector field is an operator that takes a smooth real-valued function of\n  manifold points and produces a NEW function that computes the directional\n  derivative of the given function at each point of the manifold.\"\n  ([components coordinate-system]\n   (let [name `(~'vector-field ~components)]\n     (components->vector-field\n      components coordinate-system name)))\n  ([components coordinate-system name]\n   (let [vfp (vector-field-procedure components coordinate-system)]\n     (-> (f/memoize\n          (comp f/memoize vfp))\n         (procedure->vector-field name)))))\n\n;; We can extract the components function for a vector field, given a coordinate\n;; system.\n\n(defn vector-field->components\n  \"Given a vector field `vf` and a `coordinate-system`, returns a function from\n  the coordinate representation of a manifold point to a coordinate\n  representation of the coordinatized components of the vector field at that\n  point.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (let [f (literal-vector-field 'f R2-rect)]\n        ((vector-field->components f R2-rect)\n         (up 'x0 'y0))))\n\n  ;;=> (up (f\u21910 (up x0 y0))\n  ;;       (f\u21911 (up x0 y0)))\n  ```\"\n  [vf coordinate-system]\n  {:pre [(vector-field? vf)]}\n  (f/compose (vf (m/chart coordinate-system))\n             (m/point coordinate-system)))\n\n;; ## API\n\n(defn vf:zero\n  \"Returns a vector field that returns, for any supplied function `f`, a manifold\n  function [[manifold/zero-manifold-function]] that maps every input manifold\n  `point` to the scalar value 0.\"\n  [_]\n  m/zero-manifold-function)\n\n(defn- vf:zero-like\n  \"Given some vector field `vf`, returns a vector field with the same context and\n  its procedure replaced by `vf:zero`.\n\n  The returned vector field responds `true` to `v/zero?`.\"\n  [vf]\n  {:pre [(vector-field? vf)]}\n  (o/make-operator vf:zero\n                   'vf:zero\n\t                 (o/context vf)))\n\n(defn- vf:zero?\n  \"Returns true if the supplied vector field `vf` is a vector field with a\n  procedure equal to `vf:zero`, false otherwise.\"\n  [op]\n  (and (vector-field? op)\n       (= (o/procedure op) vf:zero)))\n\n(defn literal-vector-field\n  \"Given a symbolic name `sym` and a `coordinate-system`, returns a vector field\n  consisting of literal real-valued functions from the coordinate system's\n  dimension for each coordinate component.\n\n  These functions are passed to [[components->vector-field]], along with the\n  supplied `coordinate-system` and symbolic name `sym`.\n\n  For coordinate systems of dimension 1, `literal-vector-field`'s component\n  functions will accept a single non-structural argument.\"\n  [sym coordinate-system]\n  (let [n      (:dimension\n                (m/manifold coordinate-system))\n        domain (if (= n 1) 0 (s/up* (repeat n 0)))\n        range  (if (= n 1) [0] domain)]\n    (-> (af/literal-function sym domain range)\n        (components->vector-field coordinate-system sym))))\n\n;; For any coordinate system we can make a coordinate basis.\n\n(defn- coordinate-basis-vector-field-procedure\n  [coordinate-system & indices]\n  (fn [f]\n    (f/compose\n     ((apply deriv/partial indices)\n      (f/compose f (m/point coordinate-system)))\n     (m/chart coordinate-system))))\n\n(defn coordinate-basis-vector-field\n  \"Given some `coordinate-system`, a symbolic `name` and a sequence of indices\n  into the structure of the coordinate system's representation,\n\n  returns a vector field that takes a function and returns a new function that\n  computes the partial derivative of that function with respect to the supplied\n  `indices` into `coordinate-system`.\n\n  To compute the full Jacobian, pass no indices.\"\n  [coordinate-system name & indices]\n  (let [vfp (apply coordinate-basis-vector-field-procedure\n                   coordinate-system indices)]\n    (-> (f/memoize\n         (comp f/memoize vfp))\n        (procedure->vector-field name))))\n\n(defn ^:no-doc coordinate-name->vf-name\n  \"From the name `n` of a coordinate, produce the name of the coordinate basis\n  vector field (as a symbol)\"\n  [n]\n  (symbol (str \"d:d\" n)))\n\n(defn coordinate-system->vector-basis\n  \"Given some `coordinate-system`, returns a structure of\n  `coordinate-basis-vector-field` instances. The vector field at each structural\n  spot takes a function and computes its directional derivative with respect to\n  that coordinate.\n\n  When applied as a function, the structure behaves equivalently to\n\n  ```clojure\n  (coordinate-basis-vector-field <coordinate-system> 'ignored-name)\n  ```\n\n  With no indices supplied.\"\n  [coordinate-system]\n  (s/transpose\n   (s/map-chain\n    (fn [c-name chain _]\n      (let [vf-name (coordinate-name->vf-name c-name)]\n        (apply coordinate-basis-vector-field\n               coordinate-system vf-name chain)))\n    (m/coordinate-prototype coordinate-system))))\n\n(defn basis-components->vector-field\n  \"Given a structure of `components` and and a matching `vector-basis` (of\n  identical structure with orientations flipped), returns a new vector field\n  generated contracting by these two structures together.\n\n  The returned vector field passes its input function to the operator generated\n  by this contraction.\n\n  For example:\n\n  ```clojure\n  (let-coordinates [[x y] R2-rect]\n    (basis-components->vector-field\n     (up x y)\n     (coordinate-system->vector-basis R2-rect)))\n  ;; => (+ (* x d:dx) (* y d:dy))\n  ```\n\n  NOTE:\n  - This is for any basis, not just a coordinate basis\n  - The `components` are evaluated at a manifold point, not its coordinates\n  - Given a dual basis, you can retrieve the original components\n    with [[vector-field->basis-components]]\"\n  [components vector-basis]\n  {:pre [(s/compatible-for-contraction? components\n                                        vector-basis)]}\n  (let [op (fn [f]\n             (let [applied (vector-basis f)]\n               (fn [point]\n                 (g/* (applied point)\n\t                    (components point)))))\n        name `(~'+ ~@(map (fn [component basis-element]\n\t\t                        `(~'*\n                              ~(v/freeze component)\n\t\t                          ~(v/freeze basis-element)))\n\t                        (flatten components)\n\t                        (flatten vector-basis)))]\n    (procedure->vector-field op name)))\n\n;; And the inverse:\n\n(defn vector-field->basis-components\n  \"Given a vector field `vf` generated from [[basis-components->vector-field]] and\n  a dual basis, returns the original basis components.\n\n  NOTE: You can generate a dual basis with [[basis/vector-basis->dual-basis]].\n\n  Here's an example of how to use this function to round trip a structure of\n  basis components:\n\n  ```clojure\n  (let [basis (coordinate-system->vector-basis coordsys)\n        dual  (basis/vector-basis->dual basis coordsys)]\n    (= basis-components\n       (-> basis-components\n           (basis-components->vector-field basis)\n           (vector-field->basis-components dual))))\n  ```\"\n  [vf dual-basis]\n  (s/mapr (fn [w] (w vf))\n          dual-basis))\n\n(defn coordinatize\n  \"Returns an operator that acts as a coordinate version of the supplied vector\n  field `vf` with respect to `coordinate-system`.\n\n  The returned operator takes a function and returns a new function that takes\n  directional derivatives of coordinate representations of manifold points, with\n  respect to `coordinate-system`.\"\n  [vf coordinate-system]\n  (letfn [(coordinatized-v [f]\n            (fn [x]\n              (let [b (f/compose\n                       (vf (m/chart coordinate-system))\n                       (m/point coordinate-system))]\n                (g/* ((D f) x) (b x)))))]\n    (o/make-operator\n     coordinatized-v\n     `(~'coordinatized ~(o/name vf)))))\n\n(defn evolution\n  \"We can use the coordinatized vector field to build an evolution along an\n  integral curve.\n\n  NOTE: I don't see how this has anything to do with [[coordinatize]]!\"\n  [order]\n  (fn [delta-t vector-field]\n    (fn [manifold-fn]\n      (fn [manifold-point]\n        (-> (((g/exp (g/* delta-t vector-field))\n              manifold-fn)\n             manifold-point)\n            (series/sum order))))))\n"]}