shadow$provide.module$node_modules$shadergraph$src$linker$link=function(global,require,module$jscomp$0,exports$jscomp$0){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;
if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,
desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}Object.defineProperty(exports$jscomp$0,"__esModule",{value:!0});exports$jscomp$0.link=void 0;var Graph=_interopRequireWildcard(require("module$node_modules$shadergraph$src$graph$index")),Priority=_interopRequireWildcard(require("module$node_modules$shadergraph$src$linker$priority"));exports$jscomp$0.link=function(language,links,modules,exported){let includes=[];const symbols=[],externals={},uniforms=
{},attributes={},varyings={},library={},adopt=function(namespace,code,priority){const record=library[namespace];return null!=record?record.priority=Priority.max(record.priority,priority):library[namespace]={code,priority}},include=function(node,module,priority){let key;priority=Priority.make(priority);for(var ns in module.library){var lib=module.library[ns];adopt(ns,lib.code,Priority.nest(priority,lib.priority))}adopt(module.namespace,module.body,priority);for(key in module.uniforms)priority=module.uniforms[key],
uniforms[key]=priority;for(key in module.varyings)priority=module.varyings[key],varyings[key]=priority;for(key in module.attributes)priority=module.attributes[key],attributes[key]=priority;priority=[];for(key of Array.from(module.symbols)){ns=module.externals[key];{lib=node;var name=ns.name;const outlet=lib.get(name);if(!outlet)throw Error(`Unable to link program. Unlinked callback \`${name}\` on \`${null!=(null!=lib.owner.snippet?lib.owner.snippet._name:void 0)?null!=lib.owner.snippet?lib.owner.snippet._name:
void 0:lib.owner.namespace}\``);lib=outlet.inout===Graph.IN?null===outlet.input:outlet.inout===Graph.OUT?0===outlet.output.length:void 0}lib?(externals[key]=ns,priority.push(symbols.push(key))):priority.push(void 0)}return priority};return function(){var exports=language.links(links);const header=[];null!=exports.defs&&header.push(exports.defs);null!=exports.bodies&&header.push(exports.bodies);for(const m of Array.from(modules))include(m.node,m.module,m.priority);includes=(()=>{const result=[];for(const ns in library)result.push(library[ns]);
return result})().sort((a,b)=>Priority.compare(a.priority,b.priority)).map(x=>x.code);exports=language.lines(includes);exports=language.defuse(exports);header.length&&(exports=[language.lines(header),exports].join("\n"));exports=language.hoist(exports);exports=language.dedupe(exports);return{namespace:exported.main.name,code:exports,main:exported.main,entry:exported.main.name,externals,uniforms,attributes,varyings}}()}}
//# sourceMappingURL=module$node_modules$shadergraph$src$linker$link.js.map
