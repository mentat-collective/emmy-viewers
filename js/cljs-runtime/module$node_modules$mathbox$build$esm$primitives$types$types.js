shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$types=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;
if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,
desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}function __range__(left,right,inclusive){const range=[],ascending=left<right;for(right=inclusive?ascending?right+1:right-1:right;ascending?left<right:left>right;ascending?left++:left--)range.push(left);return range}function __guardMethod__(obj,methodName,transform){if("undefined"!==typeof obj&&null!==obj&&"function"===typeof obj[methodName])return transform(obj,methodName)}Object.defineProperty(exports,
"__esModule",{value:!0});exports.Types=void 0;var UData=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$data")),UJS=_interopRequireWildcard(require("module$node_modules$mathbox$build$esm$util$js")),_constants=require("module$node_modules$three$src$constants"),_Color=require("module$node_modules$three$src$math$Color"),_Matrix=require("module$node_modules$three$src$math$Matrix3"),_Matrix2=require("module$node_modules$three$src$math$Matrix4"),_Quaternion=require("module$node_modules$three$src$math$Quaternion"),
_Vector=require("module$node_modules$three$src$math$Vector2"),_Vector2=require("module$node_modules$three$src$math$Vector3"),_Vector3=require("module$node_modules$three$src$math$Vector4");const Types=function(types){for(const k in types)types[k]=(type=>function(){const t=type.apply(type,arguments);null==t.validate&&(t.validate=v=>null!=v);null==t.equals&&(t.equals=(a,b)=>a===b);null==t.clone&&(t.clone=function(v){let left;return null!=(left=__guardMethod__(v,"clone",o=>o.clone()))?left:v});return t})(types[k]);
return types}({array(type,size,value$jscomp$0=null){const lerp=type.lerp?function(a,b,target,f){const l=Math.min(a.length,b.length);for(let i=0,end=l,asc=0<=end;asc?i<end:i>end;asc?i++:i--)target[i]=type.lerp(a[i],b[i],target[i],f);return target}:void 0,op$jscomp$0=type.op?function(a,b,target,op){const l=Math.min(a.length,b.length);for(let i=0,end=l,asc=0<=end;asc?i<end:i>end;asc?i++:i--)target[i]=type.op(a[i],b[i],target[i],op);return target}:void 0;null==value$jscomp$0||value$jscomp$0 instanceof
Array||(value$jscomp$0=[value$jscomp$0]);return{uniform(){if(type.uniform)return type.uniform()+"v"},make(){return null!=value$jscomp$0?value$jscomp$0.slice():size?__range__(0,size,!1).map(_i=>type.make()):[]},validate(value,target,invalid){value instanceof Array||(value=[value]);var l=target.length=size?size:value.length;for(let i=0,end=l,asc=0<=end;asc?i<end:i>end;asc?i++:i--)l=null!=value[i]?value[i]:type.make(),target[i]=type.validate(l,target[i],invalid);return target},equals(a,b){var al=a.length;
const bl=b.length;if(al!==bl)return!1;al=Math.min(al,bl);for(let i=0,end=al,asc=0<=end;asc?i<end:i>end;asc?i++:i--)if("function"!==typeof type.equals||!type.equals(a[i],b[i]))return!1;return!0},lerp,op:op$jscomp$0,clone(v){return Array.from(v).map(x=>type.clone(x))}}},letters(type,size,value$jscomp$0=null){if(null!=value$jscomp$0){value$jscomp$0===""+value$jscomp$0&&(value$jscomp$0=value$jscomp$0.split(""));for(let i=0;i<value$jscomp$0.length;i++){const v=value$jscomp$0[i];value$jscomp$0[i]=type.validate(v,
v)}}const array=Types.array(type,size,value$jscomp$0);return{uniform(){return array.uniform()},make(){return array.make()},validate(value,target,invalid){value===""+value&&(value=value.split(""));return array.validate(value,target,invalid)},equals(a,b){return array.equals(a,b)},clone:array.clone}},nullable(type,make){null==make&&(make=!1);let value$jscomp$0=make?type.make():null;return{make(){return value$jscomp$0},validate(value,target,invalid){if(null===value)return value;null===target&&(target=
type.make());return type.validate(value,target,invalid)},uniform(){return"function"===typeof type.uniform?type.uniform():void 0},equals(a,b){let left;const an=null===a,bn=null===b;return an&&bn?!0:an^bn?!1:null!=(left="function"===typeof type.equals?type.equals(a,b):void 0)?left:a===b},lerp:type.lerp?function(a,b,target,f){if(null===a||null===b)return.5>f?a:b;null==target&&(target=type.make());value$jscomp$0=type.lerp(a,b,target,f);return target}:void 0,op:type.op?function(a,b,target,op){if(null===
a||null===b)return null;null==target&&(target=type.make());return value$jscomp$0=type.op(a,b,target,op)}:void 0,emitter:type.emitter?function(expr1,expr2){return null==expr2?expr1:null==expr1?expr2:type.emitter(expr1,expr2)}:void 0}},enum(value$jscomp$0,keys,map){let key;null==keys&&(keys=[]);null==map&&(map={});let i=0;const values={};for(key of Array.from(keys))key!==+key&&null==map[key]&&(map[key]=i++);for(key of Array.from(keys))key===+key&&(values[key]=key);for(key in map)i=map[key],values[i]=
!0;null==values[value$jscomp$0]&&(value$jscomp$0=map[value$jscomp$0]);return{enum(){return map},make(){return value$jscomp$0},validate(value,target,invalid){value=values[value]?value:map[value];return null!=value?value:invalid()}}},enumber(value$jscomp$0,keys,map){null==map&&(map={});const _enum=Types.enum(value$jscomp$0,keys,map);return{enum:_enum.enum,uniform(){return"f"},make(){let left;return null!=(left=_enum.make())?left:+value$jscomp$0},validate(value,target,invalid){return value===+value?
value:_enum.validate(value,target,invalid)},op(a,b,target,op){return op(a,b)}}},select(value$jscomp$0){null==value$jscomp$0&&(value$jscomp$0="\x3c");value$jscomp$0;return{make(){return value$jscomp$0},validate(value,target,invalid){return"string"===typeof value||"object"===typeof value?value:invalid()}}},bool(value$jscomp$0){value$jscomp$0=!!value$jscomp$0;return{uniform(){return"f"},make(){return value$jscomp$0},validate(value,_target,_invalid){return!!value}}},int(value$jscomp$0){null==value$jscomp$0&&
(value$jscomp$0=0);value$jscomp$0=+Math.round(value$jscomp$0);return{uniform(){return"i"},make(){return value$jscomp$0},validate(value,target,invalid){let x;return value!==(x=+value)?invalid():Math.round(x)||0},op(a,b,target,op){return op(a,b)}}},round(value$jscomp$0){null==value$jscomp$0&&(value$jscomp$0=0);value$jscomp$0=+Math.round(value$jscomp$0);return{uniform(){return"f"},make(){return value$jscomp$0},validate(value,target,invalid){let x;return value!==(x=+value)?invalid():Math.round(x)||0},
op(a,b,target,op){return op(a,b)}}},number(value$jscomp$0){null==value$jscomp$0&&(value$jscomp$0=0);return{uniform(){return"f"},make(){return+value$jscomp$0},validate(value,target,invalid){let x;return value!==(x=+value)?invalid():x||0},op(a,b,target,op){return op(a,b)}}},positive(type,strict){null==strict&&(strict=!1);return{uniform:type.uniform,make:type.make,validate(value,target,invalid){value=type.validate(value,target,invalid);return 0>value||strict&&0>=value?invalid():value},op(a,b,target,
op){return op(a,b)}}},string(value$jscomp$0){null==value$jscomp$0&&(value$jscomp$0="");return{make(){return""+value$jscomp$0},validate(value,target,invalid){let x;return value!==(x=""+value)?invalid():x}}},func(){return{make(){return function(){}},validate(value,target,invalid){return"function"===typeof value?value:invalid()}}},emitter(){return{make(){return emit=>emit(1,1,1,1)},validate(value,target,invalid){return"function"===typeof value?value:invalid()},emitter(a,b){return UData.getLerpEmitter(a,
b)}}},object(value$jscomp$0){return{make(){return null!=value$jscomp$0?value$jscomp$0:{}},validate(value,target,invalid){return"object"===typeof value?value:invalid()},clone(v){return JSON.parse(JSON.stringify(v))}}},timestamp(value$jscomp$0=null){"string"===typeof value$jscomp$0&&(value$jscomp$0=Date.parse(value$jscomp$0));return{uniform(){return"f"},make(){return null!=value$jscomp$0?value$jscomp$0:+new Date},validate(value,target,invalid){value=Date.parse(value);return value!==+value?invalid():
value},op(a,b,target,op){return op(a,b)}}},vec2(x,y){null==x&&(x=0);null==y&&(y=0);const defaults=[x,y];return{uniform(){return"v2"},make(){return new _Vector.Vector2(x,y)},validate(value,target,invalid){value===+value&&(value=[value]);if(value instanceof _Vector.Vector2)target.copy(value);else if(value instanceof Array)value=value.concat(defaults.slice(value.length)),target.set.apply(target,value);else if(null!=value)target.set(null!=value.x?value.x:x,null!=value.y?value.y:y);else return invalid();
return target},equals(a,b){return a.x===b.x&&a.y===b.y},op(a,b,target,op){target.x=op(a.x,b.x);target.y=op(a.y,b.y);return target}}},ivec2(x,y){null==x&&(x=0);null==y&&(y=0);x=Types.vec2(x,y);const {validate}=x;x.validate=function(value,target,invalid){validate(value,target,invalid);target.x=Math.round(target.x);target.y=Math.round(target.y);return target};return x},vec3(x,y,z){null==x&&(x=0);null==y&&(y=0);null==z&&(z=0);const defaults=[x,y,z];return{uniform(){return"v3"},make(){return new _Vector2.Vector3(x,
y,z)},validate(value,target,invalid){value===+value&&(value=[value]);if(value instanceof _Vector2.Vector3)target.copy(value);else if(value instanceof Array)value=value.concat(defaults.slice(value.length)),target.set.apply(target,value);else if(null!=value)target.set(null!=value.x?value.x:x,null!=value.y?value.y:y,null!=value.z?value.z:z);else return invalid();return target},equals(a,b){return a.x===b.x&&a.y===b.y&&a.z===b.z},op(a,b,target,op){target.x=op(a.x,b.x);target.y=op(a.y,b.y);target.z=op(a.z,
b.z);return target}}},ivec3(x,y,z){null==x&&(x=0);null==y&&(y=0);null==z&&(z=0);x=Types.vec3(x,y,z);const {validate}=x;x.validate=function(value,target,invalid){validate(value,target,invalid);target.x=Math.round(target.x);target.y=Math.round(target.y);target.z=Math.round(target.z);return target};return x},vec4(x,y,z,w){null==x&&(x=0);null==y&&(y=0);null==z&&(z=0);null==w&&(w=0);const defaults=[x,y,z,w];return{uniform(){return"v4"},make(){return new _Vector3.Vector4(x,y,z,w)},validate(value,target,
invalid){value===+value&&(value=[value]);if(value instanceof _Vector3.Vector4)target.copy(value);else if(value instanceof Array)value=value.concat(defaults.slice(value.length)),target.set.apply(target,value);else if(null!=value)target.set(null!=value.x?value.x:x,null!=value.y?value.y:y,null!=value.z?value.z:z,null!=value.w?value.w:w);else return invalid();return target},equals(a,b){return a.x===b.x&&a.y===b.y&&a.z===b.z&&a.w===b.w},op(a,b,target,op){target.x=op(a.x,b.x);target.y=op(a.y,b.y);target.z=
op(a.z,b.z);target.w=op(a.w,b.w);return target}}},ivec4(x,y,z,w){null==x&&(x=0);null==y&&(y=0);null==z&&(z=0);null==w&&(w=0);x=Types.vec4(x,y,z,w);const {validate}=x;x.validate=function(value,target,invalid){validate(value,target,invalid);target.x=Math.round(target.x);target.y=Math.round(target.y);target.z=Math.round(target.z);target.w=Math.round(target.w);return target};return x},mat3(n11,n12,n13,n21,n22,n23,n31,n32,n33){null==n11&&(n11=1);null==n12&&(n12=0);null==n13&&(n13=0);null==n21&&(n21=0);
null==n22&&(n22=1);null==n23&&(n23=0);null==n31&&(n31=0);null==n32&&(n32=0);null==n33&&(n33=1);const defaults=[n11,n12,n13,n21,n22,n23,n31,n32,n33];return{uniform(){return"m4"},make(){const m=new _Matrix.Matrix3;m.set(n11,n12,n13,n21,n22,n23,n31,n32,n33);return m},validate(value,target,invalid){if(value instanceof _Matrix.Matrix3)target.copy(value);else if(value instanceof Array)value=value.concat(defaults.slice(value.length)),target.set.apply(target,value);else return invalid();return target}}},
mat4(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){null==n11&&(n11=1);null==n12&&(n12=0);null==n13&&(n13=0);null==n14&&(n14=0);null==n21&&(n21=0);null==n22&&(n22=1);null==n23&&(n23=0);null==n24&&(n24=0);null==n31&&(n31=0);null==n32&&(n32=0);null==n33&&(n33=1);null==n34&&(n34=0);null==n41&&(n41=0);null==n42&&(n42=0);null==n43&&(n43=0);null==n44&&(n44=1);const defaults=[n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44];return{uniform(){return"m4"},make(){const m=new _Matrix2.Matrix4;
m.set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44);return m},validate(value,target,invalid){if(value instanceof _Matrix2.Matrix4)target.copy(value);else if(value instanceof Array)value=value.concat(defaults.slice(value.length)),target.set.apply(target,value);else return invalid();return target}}},quat(x,y,z,w){null==x&&(x=0);null==y&&(y=0);null==z&&(z=0);null==w&&(w=1);const vec4=Types.vec4(x,y,z,w);return{uniform(){return"v4"},make(){return new _Quaternion.Quaternion},validate(value,
target,invalid){value instanceof _Quaternion.Quaternion?target.copy(value):target=vec4.validate(value,target,invalid);target.normalize();return target},equals(a,b){return a.x===b.x&&a.y===b.y&&a.z===b.z&&a.w===b.w},op(a,b,target,op){target.x=op(a.x,b.x);target.y=op(a.y,b.y);target.z=op(a.z,b.z);target.w=op(a.w,b.w);target.normalize();return target},lerp(a,b,target,f){target.slerpQuaternions?target.slerpQuaternions(a,b,f):_Quaternion.Quaternion.slerp(a,b,target,f);return target}}},color(r,g,b$jscomp$0){null==
r&&(r=.5);null==g&&(g=.5);null==b$jscomp$0&&(b$jscomp$0=.5);const defaults=[r,g,b$jscomp$0];return{uniform(){return"c"},make(){return new _Color.Color(r,g,b$jscomp$0)},validate(value,target,invalid){value===""+value?value=(new _Color.Color).setStyle(value):value===+value&&(value=new _Color.Color(value));if(value instanceof _Color.Color)target.copy(value);else if(value instanceof Array)value=value.concat(defaults.slice(value.length)),target.setRGB.apply(target,value);else if(null!=value)target.set(null!=
value.r?value.r:r,null!=value.g?value.g:g,null!=value.b?value.b:b$jscomp$0);else return invalid();return target},equals(a,b){return a.r===b.r&&a.g===b.g&&a.b===b.b},op(a,b,target,op){target.r=op(a.r,b.r);target.g=op(a.g,b.g);target.b=op(a.b,b.b);return target}}},axis(value$jscomp$0,allowZero){let v;null==value$jscomp$0&&(value$jscomp$0=1);null==allowZero&&(allowZero=!1);const map={x:1,y:2,z:3,w:4,W:1,H:2,D:3,I:4,zero:0,null:0,width:1,height:2,depth:3,items:4},range=allowZero?[0,1,2,3,4]:[1,2,3,4];
null!=(v=map[value$jscomp$0])&&(value$jscomp$0=v);return{make(){return value$jscomp$0},validate(value,target,invalid){let left;null!=(v=map[value])&&(value=v);value=null!=(left=Math.round(value))?left:0;return Array.from(range).includes(value)?value:invalid()}}},transpose(order){null==order&&(order=[1,2,3,4]);const looseArray=Types.letters(Types.axis(null,!1),0,order),axesArray=Types.letters(Types.axis(null,!1),4,order);return{make(){return axesArray.make()},validate(value,target,invalid){let temp=
[1,2,3,4];looseArray.validate(value,temp,invalid);4>temp.length&&(value=[1,2,3,4].filter(x=>-1===temp.indexOf(x)),temp=temp.concat(value));return 0>Array.from(temp).map((letter,i)=>temp.indexOf(letter)===i).indexOf(!1)?axesArray.validate(temp,target,invalid):invalid()},equals:axesArray.equals,clone:axesArray.clone}},swizzle(order,size=null){null==order&&(order=[1,2,3,4]);null==size&&(size=order.length);order=order.slice(0,size);const looseArray=Types.letters(Types.axis(null,!1),0,order),axesArray=
Types.letters(Types.axis(null,!0),size,order);return{make(){return axesArray.make()},validate(value,target,invalid){let temp=order.slice();looseArray.validate(value,temp,invalid);temp.length<size&&(temp=temp.concat([0,0,0,0]).slice(0,size));return axesArray.validate(temp,target,invalid)},equals:axesArray.equals,clone:axesArray.clone}},classes(){const stringArray=Types.array(Types.string());return{make(){return stringArray.make()},validate(value,target,invalid){value===""+value&&(value=value.split(" "));
value=value.filter(x=>!!x.length);return stringArray.validate(value,target,invalid)},equals:stringArray.equals,clone:stringArray.clone}},blending(value){null==value&&(value="normal");return Types.enum(value,"no normal add subtract multiply custom".split(" "))},filter(value){null==value&&(value="nearest");return Types.enum(value,[],{nearest:_constants.NearestFilter,nearestMipMapNearest:_constants.NearestMipMapNearestFilter,nearestMipMapLinear:_constants.NearestMipMapLinearFilter,linear:_constants.LinearFilter,
linearMipMapNearest:_constants.LinearMipMapNearestFilter,linearMipmapLinear:_constants.LinearMipMapLinearFilter})},type(value){null==value&&(value="unsignedByte");return Types.enum(value,[],{unsignedByte:_constants.UnsignedByteType,byte:_constants.ByteType,short:_constants.ShortType,unsignedShort:_constants.UnsignedShortType,int:_constants.IntType,unsignedInt:_constants.UnsignedIntType,float:_constants.FloatType})},scale(value){null==value&&(value="linear");return Types.enum(value,["linear","log"])},
mapping(value){null==value&&(value="relative");return Types.enum(value,["relative","absolute"])},indexing(value){null==value&&(value="original");return Types.enum(value,["original","final"])},shape(value){null==value&&(value="circle");return Types.enum(value,"circle square diamond up down left right".split(" "))},join(value){null==value&&(value="miter");return Types.enum(value,["miter","round","bevel"])},stroke(value){null==value&&(value="solid");return Types.enum(value,["solid","dotted","dashed"])},
vertexPass(value){null==value&&(value="view");return Types.enum(value,["data","view","world","eye"])},fragmentPass(value){null==value&&(value="light");return Types.enum(value,["color","light","rgba"])},ease(value){null==value&&(value="linear");return Types.enum(value,["linear","cosine","binary","hold"])},fit(value){null==value&&(value="contain");return Types.enum(value,["x","y","contain","cover"])},anchor(value){null==value&&(value="middle");return Types.enumber(value,[],{first:1,middle:0,last:-1})},
transitionState(value){null==value&&(value="enter");return Types.enumber(value,[],{enter:-1,visible:0,exit:1})},font(value$jscomp$0){null==value$jscomp$0&&(value$jscomp$0="sans-serif");const parse=UJS.parseQuoted;value$jscomp$0 instanceof Array||(value$jscomp$0=parse(value$jscomp$0));const stringArray=Types.array(Types.string(),0,value$jscomp$0);return{make(){return stringArray.make()},validate(value,target,invalid){try{value instanceof Array||(value=parse(value))}catch(error){return invalid()}value=
value.filter(x=>!!x.length);return stringArray.validate(value,target,invalid)},equals:stringArray.equals,clone:stringArray.clone}},data(value$jscomp$0){null==value$jscomp$0&&(value$jscomp$0=[]);return{make(){return[]},validate(value,target,invalid){return value instanceof Array?value:null!=(null!=value?value.length:void 0)?value:invalid()},emitter(a,b){return UData.getLerpThunk(a,b)}}}});exports.Types=Types}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$types.js.map
