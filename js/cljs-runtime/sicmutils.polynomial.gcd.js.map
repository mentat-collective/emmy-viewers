{"version":3,"sources":["sicmutils/polynomial/gcd.cljc"],"mappings":"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","names":["sicmutils.polynomial.gcd/*poly-gcd-time-limit*","sicmutils.polynomial.gcd/*clock*","sicmutils.polynomial.gcd/*poly-gcd-cache-enable*","sicmutils.polynomial.gcd/*poly-gcd-debug*","sicmutils.polynomial.gcd/gcd-memo","cljs.core.atom","sicmutils.polynomial.gcd/gcd-cache-hit","sicmutils.polynomial.gcd/gcd-cache-miss","sicmutils.polynomial.gcd/gcd-trivial-constant","sicmutils.polynomial.gcd/gcd-monomials","sicmutils.polynomial.gcd/gcd-stats","memo-count","cljs.core/deref","cljs.core/count","hits","misses","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","goog.string/format","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.polynomial.gcd/dbg","seq100441","G__100442","cljs.core/first","cljs.core/next","G__100444","self__4851__auto__","level","where","xs","cljs.core.map","cljs.core/str","xs'","cljs.core.into","xs-s","clojure.string.join","prefix","cljs.core.apply","cljs.core.repeat","sicmutils.polynomial.gcd/time-expired?","and__4251__auto__","vec__100482","cljs.core.nth","ticks","units","sicmutils.util.stopwatch.elapsed","sicmutils.polynomial.gcd/maybe-bail-out!","description","s","sicmutils.util.stopwatch/repr","sicmutils.util/timeout-ex","sicmutils.polynomial.gcd/with-limited-time","timeout","thunk","*poly-gcd-time-limit*-orig-val__100487","*clock*-orig-val__100488","*poly-gcd-time-limit*-temp-val__100489","*clock*-temp-val__100490","sicmutils.util.stopwatch/stopwatch","sicmutils.polynomial.gcd/cached","f","u","v","temp__5751__auto__","g","G__100496","fexpr__100495","cljs.core.swap_BANG_","cljs.core/inc","result","cljs.core/assoc","G__100505","sicmutils.polynomial.gcd/cont->","args-arr__4885__auto__","argseq__4886__auto__","p__100519","vec__100525","p__100532","vec__100533","p__100542","vec__100551","p__100562","vec__100565","seq100501","G__100502","G__100503","G__100504","f1","f2","more","G__100568","G__100569","G__100570","u'","v'","sicmutils.polynomial.gcd/terms->sort+unsort","terms","cljs.core/identity","sicmutils.polynomial.exponent/->sort+unsort","cljs.core.transduce","sicmutils.polynomial.impl/exponents","sicmutils.polynomial.exponent/lcm","sicmutils.polynomial.gcd/with-optimized-variable-order","continue","sicmutils.polynomial/multivariate?","vec__100589","l-terms","sicmutils.polynomial/polynomial?","sicmutils.polynomial/bare-terms","r-terms","sort","unsort","G__100592","G__100593","sicmutils.polynomial.map_exponents","sicmutils.polynomial.gcd/->content+primitive","p","gcd","coeffs","sicmutils.polynomial/coefficients","cljs.core._EQ_","content","primitive","sicmutils.polynomial/map-coefficients","_","sicmutils.value/one?","p1__100594#","sicmutils.generic/exact-divide","sicmutils.polynomial.gcd/with-content-removed","vec__100595","vec__100598","ku","pu","kv","pv","d","sicmutils.polynomial.constant","sicmutils.polynomial/scale-l","sicmutils.polynomial.gcd/with-trivial-constant-gcd-check","js/Error","u-vars","cljs.core.reduce","cljs.core/into","cljs.core.comp","sicmutils.util/keyset","v-vars","cljs.core/empty?","clojure.set.intersection","cljs.core.concat","sicmutils.polynomial.gcd/->gcd","binary-gcd","sicmutils.util.aggregate.monoid","sicmutils.polynomial.gcd/primitive-gcd","l","r","sicmutils.value/number?","sicmutils.generic/gcd","sicmutils.polynomial.gcd/gcd-poly-number","n","sicmutils.polynomial/coeff?","sicmutils.polynomial.gcd/trivial-gcd","sicmutils.value/zero?","sicmutils.generic/abs","sicmutils.polynomial/abs","sicmutils.polynomial.gcd/monomial-gcd","m","sicmutils.polynomial/monomial?","vec__100601","mono-expts","mono-coeff","expts","sicmutils.polynomial.exponent/gcd","coeff","sicmutils.polynomial/terms->polynomial","sicmutils.polynomial/bare-arity","sicmutils.polynomial.impl.make_term","sicmutils.polynomial.gcd/euclidean-gcd","or__4253__auto__","vec__100608","sicmutils.polynomial/pseudo-remainder","vec__100611","prim","sicmutils.polynomial.gcd/univariate-gcd","sicmutils.polynomial/univariate?","sicmutils.polynomial.gcd.cont__GT_","G__100621","sicmutils.polynomial.gcd/full-gcd","sicmutils.polynomial.gcd.full_gcd","arity","sicmutils.polynomial/check-same-arity","rec","next-gcd","sicmutils.polynomial/with-lower-arity","sicmutils.polynomial.gcd.dbg","attempt","sicmutils.polynomial.gcd/classical-gcd","sicmutils.polynomial.gcd/gcd-dispatch","sicmutils.polynomial.gcd/gcd","sicmutils.polynomial.gcd/lcm","sicmutils.polynomial/mul","sicmutils.polynomial/evenly-divide","sicmutils.generic/lcm","sicmutils.polynomial.gcd/gcd-Dp","cljs.core.halt_when","sicmutils.polynomial/partial-derivatives","sicmutils.polynomial/defbinary"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.polynomial.gcd\n  (:require [clojure.set :as cs]\n            [clojure.string :as string]\n            #?(:cljs [goog.string :refer [format]])\n            [sicmutils.generic :as g]\n            [sicmutils.polynomial :as p]\n            [sicmutils.polynomial.exponent :as xpt]\n            [sicmutils.polynomial.impl :as pi]\n            [sicmutils.util :as u]\n            [sicmutils.util.aggregate :as ua]\n            [sicmutils.util.stopwatch :as us]\n            [sicmutils.value :as v]\n            [taoensso.timbre :as log]))\n\n;; ## Multivariate Polynomial GCD\n;;\n;; This namespace contains functions for calculating the greatest common divisor\n;; of multivariate `p/Polynomial` instances.\n;;\n;; This namespace will eventually dispatch between a sparse GCD algorithm and\n;; Euclid's; for now it only contains a \"classical\" implementation of Euclid's\n;; algorithm.\n\n(def ^{:dynamic true\n       :doc \"Pair of the form [number\n  Keyword], where keyword is one of the supported units from\n  [[sicmutils.util.stopwatch]]. If Euclidean GCD takes longer than this time\n  limit, the system will bail out by throwing an exception.\"}\n  *poly-gcd-time-limit*\n  [1000 :millis])\n\n(def ^:dynamic *clock* nil)\n\n(def ^{:dynamic true\n       :doc \"When true, multivariate GCD will cache each recursive step in the\n  Euclidean GCD algorithm, and attempt to shortcut out on a successful cache\n  hit. True by default.\"}\n  *poly-gcd-cache-enable*\n  true)\n\n(def ^{:dynamic true\n       :doc \"When true, multivariate GCD will log each `u` and `v` input and the\n  result of each step, along with the recursive level of the logged GCD\n  computation. False by default.\"}\n  *poly-gcd-debug*\n  false)\n\n;; Stateful instances required for GCD memoization and stats tracking.\n\n(def ^:private gcd-memo (atom {}))\n(def ^:private gcd-cache-hit (atom 0))\n(def ^:private gcd-cache-miss (atom 0))\n(def ^:private gcd-trivial-constant (atom 0))\n(def ^:private gcd-monomials (atom 0))\n\n;; ## Stats, Debugging\n;;\n;; This first block of functions provides utilities for logging statistics on\n;; the GCD search, as well as for limiting the time of attempts with a time\n;; limit and stopwatch.\n\n(defn gcd-stats\n  \"When called, logs statistics about the GCD memoization cache, and the number of\n  times the system has encountered monomial or other trivial GCDs. \"\n  []\n  (let [memo-count (count @gcd-memo)]\n    (when (> memo-count 0)\n      (let [hits   @gcd-cache-hit\n            misses @gcd-cache-miss]\n        (log/info\n         (format \"GCD cache hit rate %.2f%% (%d entries)\"\n                 (* 100 (/ (float hits) (+ hits misses)))\n                 memo-count)))))\n\n  (log/info\n   (format \"GCD triv %d mono %d\"\n           @gcd-trivial-constant\n           @gcd-monomials)))\n\n(defn- dbg\n  \"Generates a DEBUG logging statement guarded by the [[*poly-gcd-debug*]] dynamic\n  variable.\"\n  [level where & xs]\n  (when *poly-gcd-debug*\n    (let [xs     (map str xs)\n          xs'    (into [where level] xs)\n          xs-s   (string/join \" \" xs')\n          prefix (apply str (repeat level \"  \"))]\n      (log/debug prefix xs-s))))\n\n(defn time-expired?\n  \"Returns true if the [[*clock*]] dynamic variable contains a Stopwatch with an\n  elapsed time that's passed the limit allowed by the\n  dynamic [[*poly-gcd-time-limit*]], false otherwise.\"\n  []\n  (and *clock*\n       (let [[ticks units] *poly-gcd-time-limit*]\n         (> (us/elapsed *clock* units) ticks))))\n\n(defn- maybe-bail-out!\n  \"When called, if [[time-expired?]] returns `true`, logs a warning and throws a\n  TimeoutException, signaling that the GCD process has gone on past its allowed\n  time limit.\"\n  [description]\n  (when (time-expired?)\n    (let [s (format \"Timed out: %s after %s\" description (us/repr *clock*))]\n      (log/warn s)\n      (u/timeout-ex s))))\n\n(defn with-limited-time\n  \"Given an explicit `timeout` and a no-argument function `thunk`, calls `thunk`\n  in a context where [[*poly-gcd-time-limit*]] is dynamically bound to\n  `timeout`. Calling [[time-expired?]] or [[maybe-bail-out!]] inside `thunk`\n  will signal failure appropriately if `thunk` has taken longer than `timeout`.\"\n  [timeout thunk]\n  (binding [*poly-gcd-time-limit* timeout\n            *clock* (us/stopwatch)]\n    (thunk)))\n\n(defn- cached\n  \"Attempts to call `f` with arguments `u` and `v`, but only after checking that\n  `[u v]` is not present in the global GCD memoization cache. If not, calls `(f\n  u v)` and registers the result in [[gcd-memo]] before returning the result.\n\n  Use the [[*poly-gcd-cache-enable*]] dynamic variable to turn the cache on and\n  off.\"\n  [f u v]\n  (if-let [g (and *poly-gcd-cache-enable*\n                  (@gcd-memo [u v]))]\n    (do (swap! gcd-cache-hit inc)\n        g)\n    (let [result (f u v)]\n      (when *poly-gcd-cache-enable*\n        (swap! gcd-cache-miss inc)\n        (swap! gcd-memo assoc [u v] result))\n      result)))\n\n;; Continuations\n;;\n;; The GCD implementation below uses a continuation-passing style to apply\n;; transformations to each polynomial that make the process more efficient.\n;; First, a few helper functions, and then a number of continuations used to\n;; compute GCDs.\n\n(defn- cont->\n  \"Takes two polynomials `u` and `v` and any number of 'continuation' functions,\n  and returns the result of threading `u` and `v` through all continuation\n  functions.\n\n  Each function, except the last, should have signature `[p q k]`, where `p` and\n  `q` are polynomials and k is a continuation of the same type.\n\n  The last function should have signature `[p q]` without a continuation\n  argument.\n\n  For example, the following forms are equivalent:\n\n  ```clojure\n  (cont-> u v f1 f2 f3)\n  (f1 u v (fn [u' v']\n            (f2 u' v' f3)))\n  ```\"\n  ([[u v]] [u v])\n  ([[u v] f]\n   (f u v))\n  ([[u v] f1 f2]\n   (f1 u v f2))\n  ([[u v] f1 f2 & more]\n   (f1 u v\n       (fn [u' v']\n         (apply cont-> [u' v'] f2 more)))))\n\n(defn- terms->sort+unsort\n  \"Given a sequence of polynomial terms, returns a pair of functions of one\n  polynomial argument that respectively sort and unsort the variables in the\n  polynomial by increasing degree.\"\n  [terms]\n  (if (<= (count terms) 1)\n    [identity identity]\n    (xpt/->sort+unsort\n     (transduce (map pi/exponents)\n                xpt/lcm\n                terms))))\n\n(defn- with-optimized-variable-order\n  \"Accepts two polynomials `u` and `v` and calls `continuation` with the variable\n  indices in each polynomial rearranged to make GCD go faster. Undoes the\n  rearrangement on return.\n\n  When passed either non-polynomials or univariate polynomials,\n  returns `(continue u v)` unchanged.\n\n  Variables are sorted by increasing degree, where the degree is considered\n  across terms of both `u` and `v`. Discussed in ['Evaluation of the Heuristic\n  Polynomial\n  GCD'](https://people.eecs.berkeley.edu/~fateman/282/readings/liao.pdf) by Liao\n  and Fateman [1995].\"\n  [u v continue]\n  (if (or (p/multivariate? u)\n          (p/multivariate? v))\n    (let [l-terms (if (p/polynomial? u) (p/bare-terms u) [])\n          r-terms (if (p/polynomial? v) (p/bare-terms v) [])\n          [sort unsort] (terms->sort+unsort\n                         (into l-terms r-terms))]\n      (->> (continue\n            (p/map-exponents sort u)\n            (p/map-exponents sort v))\n           (p/map-exponents unsort)))\n    (continue u v)))\n\n(defn ->content+primitive\n  \"Given some polynomial `p`, and a multi-arity `gcd` function for its\n  coefficients, returns a pair of the polynomial's content and primitive.\n\n  The 'content' of a polynomial is the greatest common divisor of its\n  coefficients. The 'primitive part' of a polynomial is the quotient of the\n  polynomial by its content.\n\n  See Wikipedia's ['Primitive Part and\n  Content'](https://en.wikipedia.org/wiki/Primitive_part_and_content) page for\n  more details. \"\n  [p gcd]\n  (let [coeffs (p/coefficients p)]\n    (if (= 1 (count coeffs))\n      (let [content   (first coeffs)\n            primitive (p/map-coefficients (fn [_] 1) p)]\n        [content primitive])\n      (let [content   (apply gcd coeffs)\n            primitive (if (v/one? content)\n                        p\n                        (p/map-coefficients\n                         #(g/exact-divide % content) p))]\n        [content primitive]))))\n\n(defn- with-content-removed\n  \"Given a multi-arity `gcd` routine, returns a function of polynomials `u` and\n  `v` and a continuation `continue`.\n\n  The returned function calls the `continue` continuation with the [primitive\n  parts](https://en.wikipedia.org/wiki/Primitive_part_and_content) of `u` and\n  `v` respectively.\n\n  On return, [[with-content-removed]]'s returned function scales the result back\n  up by the `gcd` of the contents of `u` and `v` (ie, the greatest common\n  divisor across the coefficients of both polynomials).\n\n  [[with-content-removed]] is intended for use with multivariate polynomials. In\n  this case, `u` and `v` are considered to be univariate polynomials with\n  polynomial coefficients.\"\n  [gcd]\n  (fn [u v continue]\n    (let [[ku pu] (->content+primitive u gcd)\n          [kv pv] (->content+primitive v gcd)\n          d       (gcd ku kv)\n          result  (continue pu pv)\n          result  (if (p/polynomial? result)\n                    result\n                    (p/constant 1 result))]\n      (p/scale-l d result))))\n\n(defn- with-trivial-constant-gcd-check\n  \"Given a multi-arity `gcd` routine, returns a function of polynomials `u` and\n  `v` and a continuation `continue`.\n\n  This function determines whether or not `u` and `v` have any variables in\n  common. If they don't, then it's not possible for any common divisor to share\n  variables; the function returns the `gcd` of the coefficients of `u` and `v`.\n\n  If they do, the function returns `(continue u v)`.\"\n  [gcd]\n  (fn [u v continue]\n    {:pre [(p/polynomial? u)\n           (p/polynomial? v)]}\n    (let [u-vars (reduce into (map (comp u/keyset pi/exponents)\n                                   (p/bare-terms u)))\n          v-vars (reduce into (map (comp u/keyset pi/exponents)\n                                   (p/bare-terms v)))]\n      (if (empty? (cs/intersection u-vars v-vars))\n        (do (swap! gcd-trivial-constant inc)\n            (apply gcd\n                   (concat (p/coefficients u)\n                           (p/coefficients v))))\n        (continue u v)))))\n\n;; ## Basic GCD for Coefficients, Monomials\n;;\n;; Now we come to the GCD routines. There are a few here, to handle simple cases\n;; like dividing a monomial into a larger polynomial, or taking the GCD of\n;; sequences of coefficients.\n\n(defn- ->gcd\n  \"Given a `binary-gcd` function for computing greatest common divisors, returns a\n  multi-arity function that returns `0` when called with no arguments, and\n  reduces multiple arguments with `binary-gcd`, aborting if any `one?` is\n  reached.\n\n  NOTE: This is only appropriate if you don't expect rational coefficients; the\n  GCD of 1 and a rational number IS that other number, so the `v/one?` guard is\n  not appropriate.\"\n  [binary-gcd]\n  (ua/monoid binary-gcd 0 v/one?))\n\n(def ^:no-doc primitive-gcd\n  (->gcd (fn [l r]\n           (if (and (v/number? l)\n                    (v/number? r))\n             (g/gcd l r)\n             1))))\n\n;; The GCD of a sequence of integers is the simplest case; simply reduce across\n;; the sequence using `g/gcd`. The next-easiest case is the GCD of a coefficient\n;; and a polynomial.\n\n(defn- gcd-poly-number\n  \"Returns the GCD of some polynomial `p` and a non-polynomial `n`; this is simply\n  the GCD of `n` and all coefficients of `p`.\"\n  [p n]\n  {:pre [(p/polynomial? p)\n         (p/coeff? n)]}\n  (apply primitive-gcd n (p/coefficients p)))\n\n;; Wih these two in hand, there are a few trivial cases that are nice to catch\n;; before dispatching more heavyweight routines.\n\n(defn trivial-gcd\n  \"Given two polynomials `u` and `v`, attempts to return the greatest common\n  divisor of `u` and `v` by testing for trivial cases. If no trivial case\n  applies, returns `nil`.\"\n  [u v]\n  (cond (v/zero? u) (g/abs v)\n        (v/zero? v) (g/abs u)\n        (p/coeff? u) (if (p/coeff? v)\n                       (primitive-gcd u v)\n                       (gcd-poly-number v u))\n        (p/coeff? v) (gcd-poly-number u v)\n        (= u v) (p/abs u)\n        :else nil))\n\n;; Next, the case of the GCD of polynomials. If one of the sides is a monomial,\n;; the GCD is easy.\n;;\n;; For example, $3xy$ divides $6xy^2 + 9x$ trivially; the GCD is $3x$.\n;;\n;; See the docstring below for a description.\n\n(defn ^:no-doc monomial-gcd\n  \"Returns the greatest common divisor of some monomial `m` and a polynomial `p`.\n  The GCD of these two inputs is a monomial (or bare coefficient) with:\n\n  - coefficient portion equal to the GCD of the coefficient of both sides\n  - power product equal to the GCD of the power products of all `p` terms with\n    the power product of `m`\"\n  [m p]\n  {:pre [(p/monomial? m)\n         (p/polynomial? p)]}\n  (let [[mono-expts mono-coeff] (nth (p/bare-terms m) 0)\n        expts (transduce (map pi/exponents)\n                         xpt/gcd\n                         mono-expts\n                         (p/bare-terms p))\n        coeff (gcd-poly-number p mono-coeff)]\n    (swap! gcd-monomials inc)\n    (p/terms->polynomial (p/bare-arity m)\n                         [(pi/make-term expts coeff)])))\n\n;; The next-toughest case is the GCD of two univariate polynomials. The\n;; 'classical' way to do this is with the [Euclidean\n;; algorithm](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Euclidean_algorithm)\n;; for univariate polynomials. This method can be extended to multivariate\n;; polynomials by using [[p/lower-arity]] to push all but the first variable\n;; into the coefficients, and passing a `gcd` argument to [[euclidean-gcd]] that\n;; will recursively do the same until we hit bottom, at a univariate polynomial\n;; with non-polynomial coefficients.\n\n(defn- euclidean-gcd\n  \"Given some multivariate `gcd` function, returns a function of polynomials `u`\n  and `v` that returns greatest common divisor of `u` and `v` using\n  the [Euclidean algorithm for multivariate\n  polynomials](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Euclidean_algorithm).\n\n  `u` and `v` are assumed to be either non-polynomial coefficients or univariate\n  polynomials. To use [[euclidean-gcd]] for multivariate polynomials, convert\n  the polynomial to univariate first using [[p/lower-arity]] recursively.\"\n  [gcd]\n  (fn [u v]\n    (maybe-bail-out! \"euclid inner loop\")\n    (or (trivial-gcd u v)\n        (let [[r _] (p/pseudo-remainder u v)]\n          (if (v/zero? r)\n            (g/abs v)\n            (let [[_ prim] (->content+primitive r gcd)]\n              (recur v prim)))))))\n\n;; The next function pairs [[euclidean-gcd]] with one of our continuations from\n;; above; [[with-content-removed]] removes the initial greatest common divisor\n;; of the coefficients of `u` and `v` before calling [[euclidean-gcd]], to keep\n;; the size of the coefficients small.\n\n(defn univariate-gcd\n  \"Given two univariate polynomials `u` and `v`, returns the greatest common\n  divisor of `u` and `v` calculated using Knuth's algorithm 4.6.1E.\"\n  [u v]\n  {:pre [(p/univariate? u)\n         (p/univariate? v)]}\n  (cont-> [u v]\n          (with-content-removed primitive-gcd)\n          (euclidean-gcd primitive-gcd)))\n\n;; [[full-gcd]] extends [[univariate-gcd]] by using [[p/with-lower-arity]]\n;; and [[with-content-removed]] to recursively handle the first, principal\n;; variable using [[euclidean-gcd]], but passing a recursive call\n;; to [[full-gcd]] that the functions will use to handle their\n;; coefficients (which are polynomials of one less arity!)\n\n(defn full-gcd\n  \"Given two polynomials `u` and `v` (potentially multivariate) with\n  non-polynomial coefficients, returns the greatest common divisor of `u` and\n  `v` calculated using a multivariate extension of Knuth's algorithm 4.6.1E.\n\n  Optionally takes a debugging `level`. To see the debugging logs generated over\n  the course of the run, set [[*poly-gcd-debug*]] to true.\n\n  NOTE: [[full-gcd]] Internally checks that it hasn't run out a stopwatch set\n  with [[with-limited-time]]; you can wrap a call to [[full-gcd]] in this\n  function to limit its execution time.\n\n  For example, this form will throw a TimeoutException after 1 second:\n\n  ```clojure\n  (with-limited-time [1 :seconds]\n    (fn [] (full-gcd u v)))\n  ```\"\n  ([u v] (full-gcd 0 u v))\n  ([level u v]\n   (letfn [(attempt [u v]\n             (or (trivial-gcd u v)\n                 (let [arity (p/check-same-arity u v)]\n                   (cond (p/monomial? u) (monomial-gcd u v)\n                         (p/monomial? v) (monomial-gcd v u)\n                         (= arity 1) (univariate-gcd u v)\n                         :else\n                         (let [rec (fn [u v]\n                                     (full-gcd (inc level) u v))\n                               next-gcd (->gcd rec)]\n                           (maybe-bail-out! \"full-gcd\")\n                           (cont-> [u v]\n                                   p/with-lower-arity\n                                   (with-content-removed next-gcd)\n                                   (euclidean-gcd next-gcd)))))))]\n     (dbg level \"full-gcd\" u v)\n     (let [result (cached attempt u v)]\n       (dbg level \"<-\" result)\n       result))))\n\n(defn classical-gcd\n  \"Higher-level wrapper around [[full-gcd]] that:\n\n  - optimizes the case where `u` and `v` share no variables\n  - sorts the variables in `u` and `v` in order of increasing degree\n\n  before attempting [[full-gcd]]. See [[full-gcd]] for a full description.\"\n  [u v]\n  (cont-> [u v]\n          (with-trivial-constant-gcd-check primitive-gcd)\n          with-optimized-variable-order\n          full-gcd))\n\n(defn- gcd-dispatch\n  \"Dispatches to [[classical-gcd]] with an enforced time limit\n  of [[*poly-gcd-time-limit*]].\n\n  NOTE this function is the place to add support for other GCD methods, like\n  sparse polynomial GCD, that are coming down the pipe.\"\n  [u v]\n  (or (trivial-gcd u v)\n      (with-limited-time *poly-gcd-time-limit*\n        (fn [] (classical-gcd u v)))))\n\n(def\n  ^{:doc \"Returns the greatest common divisor of `u` and `v`, calculated by a\n  multivariate extension to the [Euclidean algorithm for multivariate\n  polynomials](https://en.wikipedia.org/wiki/Polynomial_greatest_common_divisor#Euclidean_algorithm).\n\n  `u` and `v` can be polynomials or non-polynomials coefficients.\"\n    :arglists '([]\n                [u]\n                [u v]\n                [u v & more])}\n  gcd\n  (ua/monoid gcd-dispatch 0))\n\n(defn lcm\n  \"Returns the least common multiple of (possibly polynomial) arguments `u` and\n  `v`, using [[gcd]] to calculate the gcd portion of\n\n  ```\n  (/ (g/abs (* u v))\n     (gcd u v))\n  ```\"\n  [u v]\n  (if (or (p/polynomial? u)\n          (p/polynomial? v))\n    (let [g (gcd-dispatch u v)]\n      (p/abs\n       (p/mul (p/evenly-divide u g) v)))\n    (g/lcm u v)))\n\n(defn gcd-Dp\n  \"Returns the greatest common divisor of all partial derivatives of the\n  polynomial `p` using binary applications of the [[gcd]] algorithm between each\n  partial derivative.\n\n  This algorithm assumes that all coefficients are integral, and halts when it\n  encounters a result that responds true to [[sicmutils.value/one?]].\n\n  If a non-[[p/Polynomial]] is supplied, returns 1.\"\n  [p]\n  (if (p/polynomial? p)\n    (transduce (halt-when v/one?)\n               gcd\n               (p/partial-derivatives p))\n    1))\n\n;; ## Generic GCD Installation\n;;\n;; The following block installs appropriate GCD and LCM routines between\n;; polynomial and coefficient instances.\n\n(p/defbinary g/lcm lcm)\n\n(defmethod g/gcd [::p/polynomial ::p/polynomial] [u v]\n  (gcd-dispatch u v))\n\n(defmethod g/gcd [::p/polynomial ::p/coeff] [u v]\n  (if (v/zero? v)\n    u\n    (gcd-poly-number u v)))\n\n(defmethod g/gcd [::p/coeff ::p/polynomial] [u v]\n  (if (v/zero? u)\n    v\n    (gcd-poly-number v u)))\n"]}