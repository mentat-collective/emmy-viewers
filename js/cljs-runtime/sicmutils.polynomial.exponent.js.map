{"version":3,"sources":["sicmutils/polynomial/exponent.cljc"],"mappings":"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","names":["cljs.core/sorted-map","sicmutils.polynomial.exponent/make","sicmutils.polynomial.exponent/empty","sicmutils.polynomial.exponent/dense->exponents","idx->pow","cljs.core/reduce-kv","acc","i","x","cljs.core.assoc","sicmutils.polynomial.exponent/mul","l","r","cljs.core.merge_with","cljs.core/+","sicmutils.polynomial.exponent/div","sicmutils.util/map-vals","cljs.core/-","var_args","G__97044","sicmutils.polynomial.exponent/gcd","js/Error","l'","cljs.core/select-keys","cljs.core/keys","r'","cljs.core/min","G__97046","sicmutils.polynomial.exponent/lcm","cljs.core/max","sicmutils.polynomial.exponent/every-power?","f","m","cljs.core/every?","cljs.core/vals","sicmutils.polynomial.exponent/assoc","n","cljs.core.dissoc","G__97056","sicmutils.polynomial.exponent/lower","expts","sicmutils.polynomial.exponent.lower","k","v","G__97058","sicmutils.polynomial.exponent/raise","sicmutils.polynomial.exponent.raise","G__97060","sicmutils.polynomial.exponent/monomial-degree","cljs.core.apply","sicmutils.polynomial.exponent/->sort+unsort","indices","cljs.core.range","cljs.core/count","order","cljs.core.into","cljs.core.sort_by","m'","cljs.core.mapcat","temp__5753__auto__","G__97062","sort","unsort","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.polynomial.exponent/lex-order","p__97066","map__97067","cljs.core/--destructure-map","cljs.core.get","seq97063","G__97064","cljs.core/first","cljs.core/next","G__97065","self__4851__auto__","xs","ys","reverse?","cljs.core/vec","cljs.core/rseq","cljs.core/long","cljs.core.nth","y","cljs.core/not","bit","cljs.core/compare","xv","yv","cljs.core._EQ_","sicmutils.polynomial.exponent/graded-lex-order","xd","sicmutils.polynomial.exponent.monomial_degree","yd","sicmutils.polynomial.exponent/graded-reverse-lex-order","sicmutils.polynomial.exponent.lex_order"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns ^:no-doc sicmutils.polynomial.exponent\n  \"This namespace provides an implementation of a sparse representation of the\n  exponent portion of a term of a polynomial, sometimes called a 'monomial'.\"\n  (:refer-clojure :exclude [empty assoc])\n  (:require [clojure.core :as core]\n            [sicmutils.util :as u]))\n\n;; ## Sparse Monomial Exponents\n;;\n;; This namespace is used by `sicmutils.polynomial.impl` and\n;; `sicmutils.polynomial` to implement a full polynomial data structure.\n;;\n;; Polynomials are sums of monomial terms; a monomial is a pair of some non-zero\n;; coefficient and a product of some number of variables, each raised to some\n;; power.\n;;\n;; We represent the exponents of a monomial with an ordered mapping of variable\n;; index => the exponent of that variable. $x^2z^3$ is represented as `{0 2, 2\n;; 3}`, for example. Polynomials are linear combinations of the exponents.\n;;\n;; ## Constructors\n\n(def ^{:doc \"Accepts alternating pairs of integers representing <indeterminate\n index>, <exponent value> and returns a `sorted-map` representing the exponent\n portion of a polynomial term.\"\n       :arglists '([& i-expt-pairs])}\n  make\n  #'sorted-map)\n\n(def ^{:doc \"Singleton instance of an empty exponent map.\"}\n  empty\n  (make))\n\n(defn dense->exponents\n  \"Accepts a sequence of pairs of indeterminate index => power, and returns a\n  sparse representation the exponents portion of a monomial.\n\n  For example:\n\n  ```clojure\n  (dense->exponents [1 4 0 0 2])\n  ;;=> {0 1, 1 4, 4 2}\n  ```\"\n  [idx->pow]\n  (reduce-kv (fn [acc i x]\n               (if (zero? x)\n                 acc\n                 (core/assoc acc i x)))\n             empty\n             idx->pow))\n\n(defn mul\n  \"Returns a new exponent vector generated by multiplying all terms in exponent\n  vectors `l` and `r`.\"\n  [l r]\n  (merge-with + l r))\n\n(defn div\n  \"Returns a new exponent vector generated by dividing terms in exponent vector\n  `l` by terms in `r`.\"\n  [l r]\n  (dense->exponents\n   (merge-with + l (u/map-vals - r))))\n\n(defn gcd\n  \"Returns the exponent vector that is the greatest common divisor of the exponent\n  vectors `l` and `r`.\n\n  Calling [[gcd]] with a single argument acts as identity.\"\n  ([l] l)\n  ([l r]\n   (let [l' (select-keys l (keys r))\n         r' (select-keys r (keys l))]\n     (merge-with min l' r'))))\n\n(defn lcm\n  \"Returns the exponent vector that is the least common multiple of the exponent\n  vectors `l` and `r`.\n\n  Calling [[lcm]] with no arguments returns the empty exponent vector; calling\n  with a single argument acts as identity.\"\n  ([] empty)\n  ([l] l)\n  ([l r]\n   (merge-with max l r)))\n\n(defn every-power?\n  \"Returns true if `f` returns true for every positive non-zero exponent in the\n  supplied exponent vector `m`, false otherwise.\n\n  Defaults to `true` if `m` is empty.\"\n  [f m]\n  (every? f (vals m)))\n\n(defn assoc\n  \"Replaces the entry for variable `x` in the exponents vector `m` with power `n`.\n  If `n` is zero, removes `x`'s entry from the returned exponent vector.\"\n  [m x n]\n  (if (zero? n)\n    (dissoc m x)\n    (core/assoc m x n)))\n\n(defn lower\n  \"Given some exponent vector `expts`, and an optional variable index\n  `i` (defaults to `0`), returns a new exponent vector with:\n\n  - the `i`th variable's entry removed\n  - decremented index for each variable with index > `i`.\n\n  For example:\n\n  ```clojure\n  (lower {0 3, 1 2, 4 4})\n  ;;=> {0 2, 3 4}\n\n  (lower {0 3, 1 2, 4 4} 1)\n  ;;=> {0 3, 3 4}\n  ```\"\n  ([expts]\n   (lower expts 0))\n  ([expts i]\n   (reduce-kv (fn [acc k v]\n                (if (> k i)\n                  (core/assoc acc (dec k) v)\n                  (core/assoc acc k v)))\n              empty\n              (dissoc expts i))))\n\n(defn raise\n  \"Given some exponent vector `expts`, an optional variable index `i` (defaults to\n  `0`) and an optional exponent power `n` (defaults to `0`), returns a new\n  exponent vector with:\n\n  - incremented indices for each variable with index >= `i`\n  - a new `i`th variable created with power `n`\n\n  For example:\n\n  ```clojure\n  (raise {0 3, 1 2, 4 4})\n  ;;=> {1 3, 2 2, 5 4}\n\n  (raise {0 3, 1 2, 4 4} 1)\n  ;;=> {0 3, 2 2, 5 4}\n\n  (raise {0 3, 1 2, 4 4} 1)\n  ;;=> {0 3, 1 10, 2 2, 5 4}\n  ```\"\n  ([expts]\n   (raise expts 0 0))\n  ([expts i]\n   (raise expts i 0))\n  ([expts i n]\n   (let [m (reduce-kv (fn [acc k v]\n                        (if (>= k i)\n                          (core/assoc acc (inc k) v)\n                          (core/assoc acc k v)))\n                      empty\n                      expts)]\n     (if (zero? n)\n       m\n       (core/assoc m i n)))))\n\n(defn monomial-degree\n  \"Returns the [monomial degree](https://en.wikipedia.org/wiki/Monomial#Degree) of\n  the exponent vector `m`, ie, the sum of the powers of all variables in `m`.\n\n  If the optional `i` is supplied, returns the degree of the `i`th variable, ie,\n  the entry for `i` in `m`, defaulting to `0`.\"\n  ([m]\n   (apply + (vals m)))\n  ([m i]\n   (m i 0)))\n\n(defn ->sort+unsort\n  \"Given a power product `m`, returns a pair of `sort` and `unsort` functions of a\n  single power product argument.\n\n  `sort` rearranges the indices of its argument to match the order of increasing\n  variable degree in `m`. `unsort` undoes this transformation.\"\n  [m]\n  (let [indices (range (count m))\n        order (into [] (sort-by m (keys m)))]\n    (letfn [(sort [m']\n              (into empty\n                    (mapcat (fn [i]\n                              (when-let [v (m' (order i))]\n                                [[i v]])))\n                    indices))\n            (unsort [m']\n              (into empty\n                    (mapcat (fn [i]\n                              (when-let [v (m' i)]\n                                [[(order i) v]])))\n                    indices))]\n      [sort unsort])))\n\n;; ## Monomial Orderings\n;;\n;; This section implements a number of [Monomial\n;; orderings](https://en.wikipedia.org/wiki/Monomial_order) that are useful for\n;; making various polynomial algorithms efficient.\n;;\n;; Each of the following functions matches Java's \"comparator\" interface:\n\n;; - If the left argument is greater than the right argument, the function\n;;   returns a negative number\n;; - equal values return `0`\n;; - if the right value is greater, returns a positive number\n\n(defn lex-order\n  \"Comparator that responds based on the [lexicographic\n  order](https://en.wikipedia.org/wiki/Monomial_order#Lexicographic_order), or\n  'lex order', of the exponent vectors `xs` and `ys`. Accepts any sequence of\n  pairs of the form `[variable, power]` for `xs` and `ys`.\n\n  Lex order first compares the power of variable `0`, then, in case of equality,\n  variable `1` and so on. If all powers match, returns `0`.\n\n  If `:reverse? true` is passed, the inputs are compared in reverse lexicographic order.\n\n  Reverse here means two things:\n\n  1. the variables are considered in reverse order; the variable with the\n     largest index is compared first, then the next-largest, and on down the line.\n  2. The _smaller_ exponent is grevlex-greater in this comparison.\"\n  ([xs ys & {:keys [reverse?]}]\n   (let [xs (vec (if reverse? (rseq xs) xs))\n         ys (vec (if reverse? (rseq ys) ys))]\n     (loop [i (long 0)]\n       (let [x (nth xs i nil)\n             y (nth ys i nil)]\n         (cond (and (not x) (not y)) 0\n               (not x) -1\n               (not y)  1\n               :else (let [bit (compare (nth x 0) (nth y 0))]\n                       (cond (zero? bit)\n                             (let [xv (nth x 1)\n                                   yv (nth y 1)]\n                               (if (= xv yv)\n                                 (recur (inc i))\n                                 (if reverse?\n                                   (- yv xv)\n                                   (- xv yv))))\n                             (neg? bit) 1\n                             :else -1))))))))\n\n(defn graded-lex-order\n  \"Comparator that responds based on the [graded lexicographic\n  order](https://en.wikipedia.org/wiki/Monomial_order#Graded_lexicographic_order),\n  or 'grlex order', of the exponent vectors `xs` and `ys`. Accepts any sequence\n  of pairs of the form `[variable, power]` for `xs` and `ys`.\n\n  grlex order first compares the total degree of `xs` and `ys`, and falls back\n  to [[lex-order]] in case of a tie. See [[lex-order]] for details on this\n  case.\"\n  [xs ys]\n  (let [xd (monomial-degree xs)\n        yd (monomial-degree ys)]\n    (if (= xd yd)\n      (lex-order xs ys)\n      (- xd yd))))\n\n(defn graded-reverse-lex-order\n  \"Comparator that responds based on the [graded reverse lexicographic\n  order](https://en.wikipedia.org/wiki/Monomial_order#Graded_reverse_lexicographic_order),\n  or 'grevlex order', of the exponent vectors `xs` and `ys`. Accepts any\n  sequence of pairs of the form `[variable, power]` for `xs` and `ys`.\n\n  grevlex order first compares the total degree of `xs` and `ys`, and falls back\n  to reverse [[lex-order]] in case of a tie. Reverse here means two things:\n\n  1. the variables are considered in reverse order; the variable with the\n     largest index is compared first, then the next-largest, and on down the line.\n  2. The _smaller_ exponent is grevlex-greater in this comparison.\"\n  [xs ys]\n  (let [xd (monomial-degree xs)\n        yd (monomial-degree ys)]\n    (if (= xd yd)\n      (lex-order xs ys :reverse? true)\n      (- xd yd))))\n"]}