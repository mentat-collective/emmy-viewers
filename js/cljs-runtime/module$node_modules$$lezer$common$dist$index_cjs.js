shadow$provide.module$node_modules$$lezer$common$dist$index_cjs=function(global,require,module,exports){function checkSide(side,pos,from,to){switch(side){case -2:return from<pos;case -1:return to>=pos&&from<pos;case 0:return from<pos&&to>pos;case 1:return from<=pos&&to>pos;case 2:return to>pos;case 4:return!0}}function enterUnfinishedNodesBefore(node,pos){for(pos=node.childBefore(pos);pos;){let last=pos.lastChild;if(!last||last.to!=pos.to)break;last.type.isError&&last.from==last.to?(node=pos,pos=
last.prevSibling):pos=last}return node}function resolveNode(node,pos,side,overlays){for(var _a;node.from==node.to||(1>side?node.from>=pos:node.from>pos)||(-1<side?node.to<=pos:node.to<pos);){var parent$jscomp$0=!overlays&&node instanceof TreeNode&&0>node.index?null:node.parent;if(!parent$jscomp$0)return node;node=parent$jscomp$0}parent$jscomp$0=overlays?0:exports.IterMode.IgnoreOverlays;if(overlays)for(let scan=node,parent=scan.parent;parent;scan=parent,parent=scan.parent)scan instanceof TreeNode&&
0>scan.index&&(null===(_a=parent.enter(pos,side,parent$jscomp$0))||void 0===_a?void 0:_a.from)!=scan.from&&(node=parent);for(;;){overlays=node.enter(pos,side,parent$jscomp$0);if(!overlays)return node;node=overlays}}function getChildren(node,type,before,after){node=node.cursor();let result=[];if(!node.firstChild())return result;if(null!=before)for(;!node.type.is(before);)if(!node.nextSibling())return result;for(;;){if(null!=after&&node.type.is(after))return result;node.type.is(type)&&result.push(node.node);
if(!node.nextSibling())return null==after?result:[]}}function matchNodeContext(node,context,i=context.length-1){for(node=node.parent;0<=i;node=node.parent){if(!node)return!1;if(!node.type.isAnonymous){if(context[i]&&context[i]!=node.name)return!1;i--}}return!0}function hasChild(tree){return tree.children.some(ch=>ch instanceof TreeBuffer||!ch.type.isAnonymous||hasChild(ch))}function buildTree(data){function takeNode(parentStart,minPos$jscomp$0,children,positions,inRepeat){let {id,start,end,size}=
cursor;for(var lookAheadAtStart=lookAhead;0>size;){cursor.next();if(-1==size){children.push(reused[id]);positions.push(start-parentStart);return}if(-3==size){contextHash=id;return}if(-4==size){lookAhead=id;return}throw new RangeError(`Unrecognized record size: ${size}`);}var type=types[id],startPos$jscomp$0=start-parentStart,JSCompiler_temp;if(JSCompiler_temp=end-start<=maxBufferLength){var buffer=cursor.pos-minPos$jscomp$0;minPos$jscomp$0=cursor.fork();var start$jscomp$0=JSCompiler_temp=0;let skip=
0,minStart=minPos$jscomp$0.end-maxBufferLength,result={size:0,start:0,skip:0};a:for(let minPos=minPos$jscomp$0.pos-buffer;minPos$jscomp$0.pos>minPos;){let nodeSize=minPos$jscomp$0.size;if(minPos$jscomp$0.id==inRepeat&&0<=nodeSize){result.size=JSCompiler_temp;result.start=start$jscomp$0;result.skip=skip;skip+=4;JSCompiler_temp+=4;minPos$jscomp$0.next();continue}let startPos=minPos$jscomp$0.pos-nodeSize;if(0>nodeSize||startPos<minPos||minPos$jscomp$0.start<minStart)break;let localSkipped=minPos$jscomp$0.id>=
minRepeatType?4:0,nodeStart=minPos$jscomp$0.start;for(minPos$jscomp$0.next();minPos$jscomp$0.pos>startPos;){if(0>minPos$jscomp$0.size)if(-3==minPos$jscomp$0.size)localSkipped+=4;else break a;else minPos$jscomp$0.id>=minRepeatType&&(localSkipped+=4);minPos$jscomp$0.next()}start$jscomp$0=nodeStart;JSCompiler_temp+=nodeSize;skip+=localSkipped}if(0>inRepeat||JSCompiler_temp==buffer)result.size=JSCompiler_temp,result.start=start$jscomp$0,result.skip=skip;JSCompiler_temp=buffer=4<result.size?result:void 0}if(JSCompiler_temp){startPos$jscomp$0=
new Uint16Array(buffer.size-buffer.skip);type=cursor.pos-buffer.size;for(lookAheadAtStart=startPos$jscomp$0.length;cursor.pos>type;)lookAheadAtStart=copyToBuffer(buffer.start,startPos$jscomp$0,lookAheadAtStart);type=new TreeBuffer(startPos$jscomp$0,end-buffer.start,nodeSet);startPos$jscomp$0=buffer.start-parentStart}else{buffer=cursor.pos-size;cursor.next();parentStart=[];inRepeat=[];minPos$jscomp$0=id>=minRepeatType?id:-1;JSCompiler_temp=0;for(start$jscomp$0=end;cursor.pos>buffer;)0<=minPos$jscomp$0&&
cursor.id==minPos$jscomp$0&&0<=cursor.size?(cursor.end<=start$jscomp$0-maxBufferLength&&(makeRepeatLeaf(parentStart,inRepeat,start,JSCompiler_temp,cursor.end,start$jscomp$0,minPos$jscomp$0,lookAheadAtStart),JSCompiler_temp=parentStart.length,start$jscomp$0=cursor.end),cursor.next()):takeNode(start,buffer,parentStart,inRepeat,minPos$jscomp$0);0<=minPos$jscomp$0&&0<JSCompiler_temp&&JSCompiler_temp<parentStart.length&&makeRepeatLeaf(parentStart,inRepeat,start,JSCompiler_temp,start,start$jscomp$0,minPos$jscomp$0,
lookAheadAtStart);parentStart.reverse();inRepeat.reverse();-1<minPos$jscomp$0&&0<JSCompiler_temp?(lookAheadAtStart=makeBalanced(type),type=balanceRange(type,parentStart,inRepeat,0,parentStart.length,0,end-start,lookAheadAtStart,lookAheadAtStart)):type=makeTree(type,parentStart,inRepeat,end-start,lookAheadAtStart-end)}children.push(type);positions.push(startPos$jscomp$0)}function makeBalanced(type){return(children,positions,length)=>{let lookAhead=0,lastI=children.length-1,last,lookAheadProp;if(0<=
lastI&&(last=children[lastI])instanceof Tree){if(!lastI&&last.type==type&&last.length==length)return last;if(lookAheadProp=last.prop(NodeProp.lookAhead))lookAhead=positions[lastI]+last.length+lookAheadProp}return makeTree(type,children,positions,length,lookAhead)}}function makeRepeatLeaf(children,positions,base,i,from,to,type,lookAhead){let localChildren=[],localPositions=[];for(;children.length>i;)localChildren.push(children.pop()),localPositions.push(positions.pop()+base-from);children.push(makeTree(nodeSet.types[type],
localChildren,localPositions,to-from,lookAhead-to));positions.push(from-base)}function makeTree(type,children,positions,length,lookAhead=0,props){if(contextHash){let pair=[NodeProp.contextHash,contextHash];props=props?[pair].concat(props):[pair]}25<lookAhead&&(lookAhead=[NodeProp.lookAhead,lookAhead],props=props?[lookAhead].concat(props):[lookAhead]);return new Tree(type,children,positions,length,props)}function copyToBuffer(bufferStart,buffer,index){let {id,start,end,size}=cursor;cursor.next();if(0<=
size&&id<minRepeatType){let startIndex=index;if(4<size){let endPos=cursor.pos-(size-4);for(;cursor.pos>endPos;)index=copyToBuffer(bufferStart,buffer,index)}buffer[--index]=startIndex;buffer[--index]=end-bufferStart;buffer[--index]=start-bufferStart;buffer[--index]=id}else-3==size?contextHash=id:-4==size&&(lookAhead=id);return index}var _a;let {buffer:buffer$jscomp$0,nodeSet,maxBufferLength=1024,reused=[],minRepeatType=nodeSet.types.length}=data,cursor=Array.isArray(buffer$jscomp$0)?new FlatBufferCursor(buffer$jscomp$0,
buffer$jscomp$0.length):buffer$jscomp$0,types=nodeSet.types,contextHash=0,lookAhead=0,children$jscomp$0=[],positions$jscomp$0=[];for(;0<cursor.pos;)takeNode(data.start||0,data.bufferStart||0,children$jscomp$0,positions$jscomp$0,-1);let length$jscomp$0=null!==(_a=data.length)&&void 0!==_a?_a:children$jscomp$0.length?positions$jscomp$0[0]+children$jscomp$0[0].length:0;return new Tree(types[data.topID],children$jscomp$0.reverse(),positions$jscomp$0.reverse(),length$jscomp$0)}function nodeSize(balanceType,
node){if(!balanceType.isAnonymous||node instanceof TreeBuffer||node.type!=balanceType)return 1;let size=nodeSizeCache.get(node);if(null==size){size=1;for(let child of node.children){if(child.type!=balanceType||!(child instanceof Tree)){size=1;break}size+=nodeSize(balanceType,child)}nodeSizeCache.set(node,size)}return size}function balanceRange(balanceType,children$jscomp$0,positions$jscomp$0,from$jscomp$0,to$jscomp$0,start,length,mkTop,mkTree){function divide(children,positions,from,to,offset){for(;from<
to;){let groupFrom=from;var groupStart=positions[from];let groupSize=nodeSize(balanceType,children[from]);for(from++;from<to;from++){let nextSize=nodeSize(balanceType,children[from]);if(groupSize+nextSize>=maxChild)break;groupSize+=nextSize}if(from==groupFrom+1){if(groupSize>maxChild){groupStart=children[groupFrom];divide(groupStart.children,groupStart.positions,0,groupStart.children.length,positions[groupFrom]+offset);continue}localChildren.push(children[groupFrom])}else localChildren.push(balanceRange(balanceType,
children,positions,groupFrom,from,groupStart,positions[from-1]+children[from-1].length-groupStart,null,mkTree));localPositions.push(groupStart+offset-start)}}let total=0;for(let i=from$jscomp$0;i<to$jscomp$0;i++)total+=nodeSize(balanceType,children$jscomp$0[i]);let maxChild=Math.ceil(1.5*total/8),localChildren=[],localPositions=[];divide(children$jscomp$0,positions$jscomp$0,from$jscomp$0,to$jscomp$0,0);return(mkTop||mkTree)(localChildren,localPositions,length)}function checkCover(covered,from,to){for(let range of covered){if(range.from>=
to)break;if(range.to>from)return range.from<=from&&range.to>=to?2:1}return 0}function sliceBuf(buf,startI,endI,nodes,positions,off){if(startI<endI){let from=buf.buffer[startI+1];nodes.push(buf.slice(startI,endI,from,buf.buffer[endI-2]));positions.push(from-off)}}function materialize(cursor){function split(startI,endI,type,innerOffset,length){let i=startI;for(;b[i+2]+off<=node.from;)i=b[i+3];let children=[],positions=[];sliceBuf(buf,startI,i,children,positions,innerOffset);startI=b[i+1];let to=b[i+
2];children.push(startI+off==node.from&&to+off==node.to&&b[i]==node.type.id?node.toTree():split(i+4,b[i+3],buf.set.types[b[i]],startI,to-startI));positions.push(startI-innerOffset);sliceBuf(buf,b[i+3],endI,children,positions,innerOffset);return new Tree(type,children,positions,length)}let {node}=cursor,depth=0;do cursor.parent(),depth++;while(!cursor.tree);var i$jscomp$0=0;let base=cursor.tree,off=0;for(;!(off=base.positions[i$jscomp$0]+cursor.from,off<=node.from&&off+base.children[i$jscomp$0].length>=
node.to);i$jscomp$0++);let buf=base.children[i$jscomp$0],b=buf.buffer;base.children[i$jscomp$0]=split(0,b.length,NodeType.none,0,buf.length);for(i$jscomp$0=0;i$jscomp$0<=depth;i$jscomp$0++)cursor.childAfter(node.from)}function punchRanges(outer,ranges){let copy=null,current=ranges;for(let i=1,j=0;i<outer.length;i++){let gapFrom=outer[i-1].to,gapTo=outer[i].from;for(;j<current.length;j++){let r=current[j];if(r.from>=gapTo)break;r.to<=gapFrom||(copy||(current=copy=ranges.slice()),r.from<gapFrom?(copy[j]=
new Range(r.from,gapFrom),r.to>gapTo&&copy.splice(j+1,0,new Range(gapTo,r.to))):r.to>gapTo?copy[j--]=new Range(gapTo,r.to):copy.splice(j--,1))}}return current}function findCoverChanges(a,b,from,to){let iA=0,iB=0,inA=!1,inB=!1;var pos=-1E9;let result=[];for(;;){let nextA=iA==a.length?1E9:inA?a[iA].to:a[iA].from,nextB=iB==b.length?1E9:inB?b[iB].to:b[iB].from;if(inA!=inB){pos=Math.max(pos,from);let end=Math.min(nextA,nextB,to);pos<end&&result.push(new Range(pos,end))}pos=Math.min(nextA,nextB);if(1E9==
pos)break;nextA==pos&&(inA?(inA=!1,iA++):inA=!0);nextB==pos&&(inB?(inB=!1,iB++):inB=!0)}return result}function enterFragments(mounts,ranges){let result=[];for(let {pos:pos$jscomp$0,mount,frag}of mounts){mounts=pos$jscomp$0+(mount.overlay?mount.overlay[0].from:0);var endPos=mounts+mount.tree.length,from=Math.max(frag.from,mounts);let to=Math.min(frag.to,endPos);if(mount.overlay){endPos=mount.overlay.map(r=>new Range(r.from+pos$jscomp$0,r.to+pos$jscomp$0));endPos=findCoverChanges(ranges,endPos,from,
to);for(let i=0,pos=from;;i++){let end=(from=i==endPos.length)?to:endPos[i].from;end>pos&&result.push(new TreeFragment(pos,end,mount.tree,-mounts,frag.from>=pos||frag.openStart,frag.to<=end||frag.openEnd));if(from)break;pos=endPos[i].to}}else result.push(new TreeFragment(from,to,mount.tree,-mounts,frag.from>=mounts||frag.openStart,frag.to<=endPos||frag.openEnd))}return result}Object.defineProperty(exports,"__esModule",{value:!0});let nextPropID=0;class Range{constructor(from,to){this.from=from;this.to=
to}}class NodeProp{constructor(config={}){this.id=nextPropID++;this.perNode=!!config.perNode;this.deserialize=config.deserialize||(()=>{throw Error("This node type doesn't define a deserialize function");})}add(match){if(this.perNode)throw new RangeError("Can't add per-node props to node types");"function"!=typeof match&&(match=NodeType.match(match));return type=>{type=match(type);return void 0===type?null:[this,type]}}}NodeProp.closedBy=new NodeProp({deserialize:str=>str.split(" ")});NodeProp.openedBy=
new NodeProp({deserialize:str=>str.split(" ")});NodeProp.group=new NodeProp({deserialize:str=>str.split(" ")});NodeProp.contextHash=new NodeProp({perNode:!0});NodeProp.lookAhead=new NodeProp({perNode:!0});NodeProp.mounted=new NodeProp({perNode:!0});class MountedTree{constructor(tree,overlay,parser){this.tree=tree;this.overlay=overlay;this.parser=parser}}const noProps=Object.create(null);class NodeType{constructor(name,props,id,flags=0){this.name=name;this.props=props;this.id=id;this.flags=flags}static define(spec){let props=
spec.props&&spec.props.length?Object.create(null):noProps,type=new NodeType(spec.name||"",props,spec.id,(spec.top?1:0)|(spec.skipped?2:0)|(spec.error?4:0)|(null==spec.name?8:0));if(spec.props)for(let src of spec.props)if(Array.isArray(src)||(src=src(type)),src){if(src[0].perNode)throw new RangeError("Can't store a per-node prop on a node type");props[src[0].id]=src[1]}return type}prop(prop){return this.props[prop.id]}get isTop(){return 0<(this.flags&1)}get isSkipped(){return 0<(this.flags&2)}get isError(){return 0<
(this.flags&4)}get isAnonymous(){return 0<(this.flags&8)}is(name){if("string"==typeof name){if(this.name==name)return!0;let group=this.prop(NodeProp.group);return group?-1<group.indexOf(name):!1}return this.id==name}static match(map){let direct=Object.create(null);for(let prop in map)for(let name of prop.split(" "))direct[name]=map[prop];return node=>{for(let groups=node.prop(NodeProp.group),i=-1;i<(groups?groups.length:0);i++){let found=direct[0>i?node.name:groups[i]];if(found)return found}}}}NodeType.none=
new NodeType("",Object.create(null),0,8);class NodeSet{constructor(types){this.types=types;for(let i=0;i<types.length;i++)if(types[i].id!=i)throw new RangeError("Node type ids should correspond to array positions when creating a node set");}extend(...props){let newTypes=[];for(let type of this.types){let newProps=null;for(let source of props){let add=source(type);add&&(newProps||(newProps=Object.assign({},type.props)),newProps[add[0].id]=add[1])}newTypes.push(newProps?new NodeType(type.name,newProps,
type.id,type.flags):type)}return new NodeSet(newTypes)}}const CachedNode=new WeakMap,CachedInnerNode=new WeakMap;exports.IterMode=void 0;(function(IterMode){IterMode[IterMode.ExcludeBuffers=1]="ExcludeBuffers";IterMode[IterMode.IncludeAnonymous=2]="IncludeAnonymous";IterMode[IterMode.IgnoreMounts=4]="IgnoreMounts";IterMode[IterMode.IgnoreOverlays=8]="IgnoreOverlays"})(exports.IterMode||(exports.IterMode={}));class Tree{constructor(type,children,positions,length,props){this.type=type;this.children=
children;this.positions=positions;this.length=length;this.props=null;if(props&&props.length){this.props=Object.create(null);for(let [prop,value]of props)this.props["number"==typeof prop?prop:prop.id]=value}}toString(){var mounted=this.prop(NodeProp.mounted);if(mounted&&!mounted.overlay)return mounted.tree.toString();mounted="";for(let ch of this.children){let str=ch.toString();str&&(mounted&&(mounted+=","),mounted+=str)}return this.type.name?(/\W/.test(this.type.name)&&!this.type.isError?JSON.stringify(this.type.name):
this.type.name)+(mounted.length?"("+mounted+")":""):mounted}cursor(mode=0){return new TreeCursor(this.topNode,mode)}cursorAt(pos,side=0,mode){mode=CachedNode.get(this)||this.topNode;mode=new TreeCursor(mode);mode.moveTo(pos,side);CachedNode.set(this,mode._tree);return mode}get topNode(){return new TreeNode(this,0,0,null)}resolve(pos,side=0){pos=resolveNode(CachedNode.get(this)||this.topNode,pos,side,!1);CachedNode.set(this,pos);return pos}resolveInner(pos,side=0){pos=resolveNode(CachedInnerNode.get(this)||
this.topNode,pos,side,!0);CachedInnerNode.set(this,pos);return pos}iterate(spec){let {enter,leave,from=0,to=this.length}=spec;for(spec=this.cursor((spec.mode||0)|exports.IterMode.IncludeAnonymous);;){let entered=!1;if(spec.from<=to&&spec.to>=from&&(spec.type.isAnonymous||!1!==enter(spec))){if(spec.firstChild())continue;entered=!0}for(;;){entered&&leave&&!spec.type.isAnonymous&&leave(spec);if(spec.nextSibling())break;if(!spec.parent())return;entered=!0}}}prop(prop){return prop.perNode?this.props?this.props[prop.id]:
void 0:this.type.prop(prop)}get propValues(){let result=[];if(this.props)for(let id in this.props)result.push([+id,this.props[id]]);return result}balance(config={}){return 8>=this.children.length?this:balanceRange(NodeType.none,this.children,this.positions,0,this.children.length,0,this.length,(children,positions,length)=>new Tree(this.type,children,positions,length,this.propValues),config.makeTree||((children,positions,length)=>new Tree(NodeType.none,children,positions,length)))}static build(data){return buildTree(data)}}
Tree.empty=new Tree(NodeType.none,[],[],0);class FlatBufferCursor{constructor(buffer,index){this.buffer=buffer;this.index=index}get id(){return this.buffer[this.index-4]}get start(){return this.buffer[this.index-3]}get end(){return this.buffer[this.index-2]}get size(){return this.buffer[this.index-1]}get pos(){return this.index}next(){this.index-=4}fork(){return new FlatBufferCursor(this.buffer,this.index)}}class TreeBuffer{constructor(buffer,length,set){this.buffer=buffer;this.length=length;this.set=
set}get type(){return NodeType.none}toString(){let result=[];for(let index=0;index<this.buffer.length;)result.push(this.childString(index)),index=this.buffer[index+3];return result.join(",")}childString(index){let endIndex=this.buffer[index+3];var type=this.set.types[this.buffer[index]];let result=type.name;/\W/.test(result)&&!type.isError&&(result=JSON.stringify(result));index+=4;if(endIndex==index)return result;for(type=[];index<endIndex;)type.push(this.childString(index)),index=this.buffer[index+
3];return result+"("+type.join(",")+")"}findChild(startIndex,endIndex,dir,pos,side){let {buffer}=this,pick=-1;for(;startIndex!=endIndex&&!(checkSide(side,pos,buffer[startIndex+1],buffer[startIndex+2])&&(pick=startIndex,0<dir));startIndex=buffer[startIndex+3]);return pick}slice(startI,endI,from,to){let b=this.buffer,copy=new Uint16Array(endI-startI);for(let i=startI,j=0;i<endI;)copy[j++]=b[i++],copy[j++]=b[i++]-from,copy[j++]=b[i++]-from,copy[j++]=b[i++]-startI;return new TreeBuffer(copy,to-from,this.set)}}
class TreeNode{constructor(_tree,from,index,_parent){this._tree=_tree;this.from=from;this.index=index;this._parent=_parent}get type(){return this._tree.type}get name(){return this._tree.type.name}get to(){return this.from+this._tree.length}nextChild(i,dir,pos,side,mode=0){for(let parent=this;;){for(let {children,positions}=parent._tree,e=0<dir?children.length:-1;i!=e;i+=dir){let next=children[i],start=positions[i]+parent.from;if(checkSide(side,pos,start,start+next.length))if(next instanceof TreeBuffer){if(mode&
exports.IterMode.ExcludeBuffers)continue;let index=next.findChild(0,next.buffer.length,dir,pos-start,side);if(-1<index)return new BufferNode(new BufferContext(parent,next,i,start),null,index)}else if(mode&exports.IterMode.IncludeAnonymous||!next.type.isAnonymous||hasChild(next)){let mounted;if(!(mode&exports.IterMode.IgnoreMounts)&&next.props&&(mounted=next.prop(NodeProp.mounted))&&!mounted.overlay)return new TreeNode(mounted.tree,start,i,parent);i=new TreeNode(next,start,i,parent);return mode&exports.IterMode.IncludeAnonymous||
!i.type.isAnonymous?i:i.nextChild(0>dir?next.children.length-1:0,dir,pos,side)}}if(mode&exports.IterMode.IncludeAnonymous||!parent.type.isAnonymous)return null;i=0<=parent.index?parent.index+dir:0>dir?-1:parent._parent._tree.children.length;parent=parent._parent;if(!parent)return null}}get firstChild(){return this.nextChild(0,1,0,4)}get lastChild(){return this.nextChild(this._tree.children.length-1,-1,0,4)}childAfter(pos){return this.nextChild(0,1,pos,2)}childBefore(pos){return this.nextChild(this._tree.children.length-
1,-1,pos,-2)}enter(pos,side,mode=0){let mounted;if(!(mode&exports.IterMode.IgnoreOverlays)&&(mounted=this._tree.prop(NodeProp.mounted))&&mounted.overlay){let rPos=pos-this.from;for(let {from,to}of mounted.overlay)if((0<side?from<=rPos:from<rPos)&&(0>side?to>=rPos:to>rPos))return new TreeNode(mounted.tree,mounted.overlay[0].from+this.from,-1,this)}return this.nextChild(0,1,pos,side,mode)}nextSignificantParent(){let val=this;for(;val.type.isAnonymous&&val._parent;)val=val._parent;return val}get parent(){return this._parent?
this._parent.nextSignificantParent():null}get nextSibling(){return this._parent&&0<=this.index?this._parent.nextChild(this.index+1,1,0,4):null}get prevSibling(){return this._parent&&0<=this.index?this._parent.nextChild(this.index-1,-1,0,4):null}cursor(mode=0){return new TreeCursor(this,mode)}get tree(){return this._tree}toTree(){return this._tree}resolve(pos,side=0){return resolveNode(this,pos,side,!1)}resolveInner(pos,side=0){return resolveNode(this,pos,side,!0)}enterUnfinishedNodesBefore(pos){return enterUnfinishedNodesBefore(this,
pos)}getChild(type,before=null,after=null){type=getChildren(this,type,before,after);return type.length?type[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}toString(){return this._tree.toString()}get node(){return this}matchContext(context){return matchNodeContext(this,context)}}class BufferContext{constructor(parent,buffer,index,start){this.parent=parent;this.buffer=buffer;this.index=index;this.start=start}}class BufferNode{constructor(context,_parent,
index){this.context=context;this._parent=_parent;this.index=index;this.type=context.buffer.set.types[context.buffer.buffer[index]]}get name(){return this.type.name}get from(){return this.context.start+this.context.buffer.buffer[this.index+1]}get to(){return this.context.start+this.context.buffer.buffer[this.index+2]}child(dir,pos,side){let {buffer}=this.context;dir=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,pos-this.context.start,side);return 0>dir?null:new BufferNode(this.context,
this,dir)}get firstChild(){return this.child(1,0,4)}get lastChild(){return this.child(-1,0,4)}childAfter(pos){return this.child(1,pos,2)}childBefore(pos){return this.child(-1,pos,-2)}enter(pos,side,mode=0){if(mode&exports.IterMode.ExcludeBuffers)return null;({buffer:mode}=this.context);pos=mode.findChild(this.index+4,mode.buffer[this.index+3],0<side?1:-1,pos-this.context.start,side);return 0>pos?null:new BufferNode(this.context,this,pos)}get parent(){return this._parent||this.context.parent.nextSignificantParent()}externalSibling(dir){return this._parent?
null:this.context.parent.nextChild(this.context.index+dir,dir,0,4)}get nextSibling(){let {buffer}=this.context,after=buffer.buffer[this.index+3];return after<(this._parent?buffer.buffer[this._parent.index+3]:buffer.buffer.length)?new BufferNode(this.context,this._parent,after):this.externalSibling(1)}get prevSibling(){let {buffer}=this.context,parentStart=this._parent?this._parent.index+4:0;return this.index==parentStart?this.externalSibling(-1):new BufferNode(this.context,this._parent,buffer.findChild(parentStart,
this.index,-1,0,4))}cursor(mode=0){return new TreeCursor(this,mode)}get tree(){return null}toTree(){let children=[],positions=[],{buffer}=this.context,startI=this.index+4,endI=buffer.buffer[this.index+3];endI>startI&&(children.push(buffer.slice(startI,endI,buffer.buffer[this.index+1],buffer.buffer[this.index+2])),positions.push(0));return new Tree(this.type,children,positions,this.to-this.from)}resolve(pos,side=0){return resolveNode(this,pos,side,!1)}resolveInner(pos,side=0){return resolveNode(this,
pos,side,!0)}enterUnfinishedNodesBefore(pos){return enterUnfinishedNodesBefore(this,pos)}toString(){return this.context.buffer.childString(this.index)}getChild(type,before=null,after=null){type=getChildren(this,type,before,after);return type.length?type[0]:null}getChildren(type,before=null,after=null){return getChildren(this,type,before,after)}get node(){return this}matchContext(context){return matchNodeContext(this,context)}}class TreeCursor{constructor(node,mode=0){this.mode=mode;this.buffer=null;
this.stack=[];this.index=0;this.bufferNode=null;if(node instanceof TreeNode)this.yieldNode(node);else{this._tree=node.context.parent;this.buffer=node.context;for(mode=node._parent;mode;mode=mode._parent)this.stack.unshift(mode.index);this.bufferNode=node;this.yieldBuf(node.index)}}get name(){return this.type.name}yieldNode(node){if(!node)return!1;this._tree=node;this.type=node.type;this.from=node.from;this.to=node.to;return!0}yieldBuf(index,type){this.index=index;let {start,buffer}=this.buffer;this.type=
type||buffer.set.types[buffer.buffer[index]];this.from=start+buffer.buffer[index+1];this.to=start+buffer.buffer[index+2];return!0}yield(node){if(!node)return!1;if(node instanceof TreeNode)return this.buffer=null,this.yieldNode(node);this.buffer=node.context;return this.yieldBuf(node.index,node.type)}toString(){return this.buffer?this.buffer.buffer.childString(this.index):this._tree.toString()}enterChild(dir,pos,side){if(!this.buffer)return this.yield(this._tree.nextChild(0>dir?this._tree._tree.children.length-
1:0,dir,pos,side,this.mode));let {buffer}=this.buffer;dir=buffer.findChild(this.index+4,buffer.buffer[this.index+3],dir,pos-this.buffer.start,side);if(0>dir)return!1;this.stack.push(this.index);return this.yieldBuf(dir)}firstChild(){return this.enterChild(1,0,4)}lastChild(){return this.enterChild(-1,0,4)}childAfter(pos){return this.enterChild(1,pos,2)}childBefore(pos){return this.enterChild(-1,pos,-2)}enter(pos,side,mode=this.mode){return this.buffer?mode&exports.IterMode.ExcludeBuffers?!1:this.enterChild(1,
pos,side):this.yield(this._tree.enter(pos,side,mode))}parent(){if(!this.buffer)return this.yieldNode(this.mode&exports.IterMode.IncludeAnonymous?this._tree._parent:this._tree.parent);if(this.stack.length)return this.yieldBuf(this.stack.pop());let parent=this.mode&exports.IterMode.IncludeAnonymous?this.buffer.parent:this.buffer.parent.nextSignificantParent();this.buffer=null;return this.yieldNode(parent)}sibling(dir){if(!this.buffer)return this._tree._parent?this.yield(0>this._tree.index?null:this._tree._parent.nextChild(this._tree.index+
dir,dir,0,4,this.mode)):!1;let {buffer}=this.buffer,d=this.stack.length-1;if(0>dir){var parentStart=0>d?0:this.stack[d]+4;if(this.index!=parentStart)return this.yieldBuf(buffer.findChild(parentStart,this.index,-1,0,4))}else if(parentStart=buffer.buffer[this.index+3],parentStart<(0>d?buffer.buffer.length:buffer.buffer[this.stack[d]+3]))return this.yieldBuf(parentStart);return 0>d?this.yield(this.buffer.parent.nextChild(this.buffer.index+dir,dir,0,4,this.mode)):!1}nextSibling(){return this.sibling(1)}prevSibling(){return this.sibling(-1)}atLastNode(dir){var index,
parent;({buffer:parent}=this);if(parent){if(0<dir){if(this.index<parent.buffer.buffer.length)return!1}else for(index=0;index<this.index;index++)if(parent.buffer.buffer[index+3]<this.index)return!1;({index,parent}=parent)}else({index,_parent:parent}=this._tree);for(;parent;{index,_parent:parent}=parent)if(-1<index)for(let i=index+dir,e=0>dir?-1:parent._tree.children.length;i!=e;i+=dir)if(index=parent._tree.children[i],this.mode&exports.IterMode.IncludeAnonymous||index instanceof TreeBuffer||!index.type.isAnonymous||
hasChild(index))return!1;return!0}move(dir,enter){if(enter&&this.enterChild(dir,0,4))return!0;for(;;){if(this.sibling(dir))return!0;if(this.atLastNode(dir)||!this.parent())return!1}}next(enter=!0){return this.move(1,enter)}prev(enter=!0){return this.move(-1,enter)}moveTo(pos,side=0){for(;(this.from==this.to||(1>side?this.from>=pos:this.from>pos)||(-1<side?this.to<=pos:this.to<pos))&&this.parent(););for(;this.enterChild(1,pos,side););return this}get node(){if(!this.buffer)return this._tree;var cache=
this.bufferNode;let result=null,depth=0;if(cache&&cache.context==this.buffer)a:for(let index=this.index,d=this.stack.length;0<=d;){for(let c=cache;c;c=c._parent)if(c.index==index){if(index==this.index)return c;result=c;depth=d+1;break a}index=this.stack[--d]}for(cache=depth;cache<this.stack.length;cache++)result=new BufferNode(this.buffer,result,this.stack[cache]);return this.bufferNode=new BufferNode(this.buffer,result,this.index)}get tree(){return this.buffer?null:this._tree._tree}iterate(enter,
leave){for(let depth=0;;){let mustLeave=!1;if(this.type.isAnonymous||!1!==enter(this)){if(this.firstChild()){depth++;continue}this.type.isAnonymous||(mustLeave=!0)}for(;;){mustLeave&&leave&&leave(this);if(this.nextSibling())break;if(!depth)return;this.parent();depth--;mustLeave=!0}}}matchContext(context){if(!this.buffer)return matchNodeContext(this.node,context);let {buffer}=this.buffer,{types}=buffer.set;for(let i=context.length-1,d=this.stack.length-1;0<=i;d--){if(0>d)return matchNodeContext(this.node,
context,i);let type=types[buffer.buffer[this.stack[d]]];if(!type.isAnonymous){if(context[i]&&context[i]!=type.name)return!1;i--}}return!0}}const nodeSizeCache=new WeakMap;class NodeWeakMap{constructor(){this.map=new WeakMap}setBuffer(buffer,index,value){let inner=this.map.get(buffer);inner||this.map.set(buffer,inner=new Map);inner.set(index,value)}getBuffer(buffer,index){return(buffer=this.map.get(buffer))&&buffer.get(index)}set(node,value){node instanceof BufferNode?this.setBuffer(node.context.buffer,
node.index,value):node instanceof TreeNode&&this.map.set(node.tree,value)}get(node){return node instanceof BufferNode?this.getBuffer(node.context.buffer,node.index):node instanceof TreeNode?this.map.get(node.tree):void 0}cursorSet(cursor,value){cursor.buffer?this.setBuffer(cursor.buffer.buffer,cursor.index,value):this.map.set(cursor.tree,value)}cursorGet(cursor){return cursor.buffer?this.getBuffer(cursor.buffer.buffer,cursor.index):this.map.get(cursor.tree)}}class TreeFragment{constructor(from,to,
tree,offset,openStart=!1,openEnd=!1){this.from=from;this.to=to;this.tree=tree;this.offset=offset;this.open=(openStart?1:0)|(openEnd?2:0)}get openStart(){return 0<(this.open&1)}get openEnd(){return 0<(this.open&2)}static addTree(tree,fragments=[],partial=!1){partial=[new TreeFragment(0,tree.length,tree,0,!1,partial)];for(let f of fragments)f.to>tree.length&&partial.push(f);return partial}static applyChanges(fragments,changes,minGap=128){if(!changes.length)return fragments;let result=[],fI=1,nextF=
fragments.length?fragments[0]:null;for(let cI=0,pos=0,off=0;;cI++){let nextC=cI<changes.length?changes[cI]:null,nextPos=nextC?nextC.fromA:1E9;if(nextPos-pos>=minGap)for(;nextF&&nextF.from<nextPos;){let cut=nextF;if(pos>=cut.from||nextPos<=cut.to||off){let fFrom=Math.max(cut.from,pos)-off,fTo=Math.min(cut.to,nextPos)-off;cut=fFrom>=fTo?null:new TreeFragment(fFrom,fTo,cut.tree,cut.offset+off,0<cI,!!nextC)}cut&&result.push(cut);if(nextF.to>nextPos)break;nextF=fI<fragments.length?fragments[fI++]:null}if(!nextC)break;
pos=nextC.toA;off=nextC.toA-nextC.toB}return result}}class Parser{startParse(input,fragments,ranges){"string"==typeof input&&(input=new StringInput(input));ranges=ranges?ranges.length?ranges.map(r=>new Range(r.from,r.to)):[new Range(0,0)]:[new Range(0,input.length)];return this.createParse(input,fragments||[],ranges)}parse(input,fragments,ranges){for(input=this.startParse(input,fragments,ranges);;)if(fragments=input.advance())return fragments}}class StringInput{constructor(string){this.string=string}get length(){return this.string.length}chunk(from){return this.string.slice(from)}get lineChunks(){return!1}read(from,
to){return this.string.slice(from,to)}}class InnerParse{constructor(parser,parse,overlay,target,ranges){this.parser=parser;this.parse=parse;this.overlay=overlay;this.target=target;this.ranges=ranges}}class ActiveOverlay{constructor(parser,predicate,mounts,index,start,target,prev){this.parser=parser;this.predicate=predicate;this.mounts=mounts;this.index=index;this.start=start;this.target=target;this.prev=prev;this.depth=0;this.ranges=[]}}const stoppedInner=new NodeProp({perNode:!0});class MixedParse{constructor(base,
nest,input,fragments,ranges){this.nest=nest;this.input=input;this.fragments=fragments;this.ranges=ranges;this.inner=[];this.innerDone=0;this.stoppedAt=this.baseTree=null;this.baseParse=base}advance(){if(this.baseParse){var done=this.baseParse.advance();if(!done)return null;this.baseParse=null;this.baseTree=done;this.startInner();if(null!=this.stoppedAt)for(var inner of this.inner)inner.parse.stopAt(this.stoppedAt)}if(this.innerDone==this.inner.length)return done=this.baseTree,null!=this.stoppedAt&&
(done=new Tree(done.type,done.children,done.positions,done.length,done.propValues.concat([[stoppedInner,this.stoppedAt]]))),done;done=this.inner[this.innerDone];if(inner=done.parse.advance()){this.innerDone++;let props=Object.assign(Object.create(null),done.target.props);props[NodeProp.mounted.id]=new MountedTree(inner,done.overlay,done.parser);done.target.props=props}return null}get parsedPos(){if(this.baseParse)return 0;let pos=this.input.length;for(let i=this.innerDone;i<this.inner.length;i++)this.inner[i].ranges[0].from<
pos&&(pos=Math.min(pos,this.inner[i].parse.parsedPos));return pos}stopAt(pos){this.stoppedAt=pos;if(this.baseParse)this.baseParse.stopAt(pos);else for(let i=this.innerDone;i<this.inner.length;i++)this.inner[i].parse.stopAt(pos)}startInner(){let fragmentCursor=new FragmentCursor(this.fragments),overlay=null,covered=null,cursor=new TreeCursor(new TreeNode(this.baseTree,this.ranges[0].from,0,null),exports.IterMode.IncludeAnonymous|exports.IterMode.IgnoreMounts);a:for(let nest,isCovered;null==this.stoppedAt||
cursor.from<this.stoppedAt;){var enter=!0;let range;if(fragmentCursor.hasNode(cursor)){if(overlay&&(enter=overlay.mounts.find(m=>m.frag.from<=cursor.from&&m.frag.to>=cursor.to&&m.mount.overlay)))for(let r$jscomp$0 of enter.mount.overlay){let from=r$jscomp$0.from+enter.pos,to=r$jscomp$0.to+enter.pos;from>=cursor.from&&to<=cursor.to&&!overlay.ranges.some(r=>r.from<to&&r.to>from)&&overlay.ranges.push({from,to})}enter=!1}else if(covered&&(isCovered=checkCover(covered.ranges,cursor.from,cursor.to)))enter=
2!=isCovered;else if(!cursor.type.isAnonymous&&cursor.from<cursor.to&&(nest=this.nest(cursor,this.input))){cursor.tree||materialize(cursor);let oldMounts=fragmentCursor.findMounts(cursor.from,nest.parser);if("function"==typeof nest.overlay)overlay=new ActiveOverlay(nest.parser,nest.overlay,oldMounts,this.inner.length,cursor.from,cursor.tree,overlay);else{let ranges=punchRanges(this.ranges,nest.overlay||[new Range(cursor.from,cursor.to)]);ranges.length&&this.inner.push(new InnerParse(nest.parser,nest.parser.startParse(this.input,
enterFragments(oldMounts,ranges),ranges),nest.overlay?nest.overlay.map(r=>new Range(r.from-cursor.from,r.to-cursor.from)):null,cursor.tree,ranges));nest.overlay?ranges.length&&(covered={ranges,depth:0,prev:covered}):enter=!1}}else overlay&&(range=overlay.predicate(cursor))&&(!0===range&&(range=new Range(cursor.from,cursor.to)),range.from<range.to&&overlay.ranges.push(range));if(enter&&cursor.firstChild())overlay&&overlay.depth++,covered&&covered.depth++;else for(;!cursor.nextSibling();){if(!cursor.parent())break a;
overlay&&!--overlay.depth&&(enter=punchRanges(this.ranges,overlay.ranges),enter.length&&this.inner.splice(overlay.index,0,new InnerParse(overlay.parser,overlay.parser.startParse(this.input,enterFragments(overlay.mounts,enter),enter),overlay.ranges.map(r=>new Range(r.from-overlay.start,r.to-overlay.start)),overlay.target,enter)),overlay=overlay.prev);covered&&!--covered.depth&&(covered=covered.prev)}}}}class StructureCursor{constructor(root,offset){this.offset=offset;this.done=!1;this.cursor=root.cursor(exports.IterMode.IncludeAnonymous|
exports.IterMode.IgnoreMounts)}moveTo(pos){let {cursor}=this,p=pos-this.offset;for(;!this.done&&cursor.from<p;)cursor.to>=pos&&cursor.enter(p,1,exports.IterMode.IgnoreOverlays|exports.IterMode.ExcludeBuffers)||cursor.next(!1)||(this.done=!0)}hasNode(cursor){this.moveTo(cursor.from);if(!this.done&&this.cursor.from+this.offset==cursor.from&&this.cursor.tree)for(let tree=this.cursor.tree;;){if(tree==cursor.tree)return!0;if(tree.children.length&&0==tree.positions[0]&&tree.children[0]instanceof Tree)tree=
tree.children[0];else break}return!1}}class FragmentCursor{constructor(fragments){var _a;this.fragments=fragments;this.fragI=this.curTo=0;fragments.length?(fragments=this.curFrag=fragments[0],this.curTo=null!==(_a=fragments.tree.prop(stoppedInner))&&void 0!==_a?_a:fragments.to,this.inner=new StructureCursor(fragments.tree,-fragments.offset)):this.curFrag=this.inner=null}hasNode(node){for(;this.curFrag&&node.from>=this.curTo;)this.nextFrag();return this.curFrag&&this.curFrag.from<=node.from&&this.curTo>=
node.to&&this.inner.hasNode(node)}nextFrag(){var _a;this.fragI++;if(this.fragI==this.fragments.length)this.curFrag=this.inner=null;else{let frag=this.curFrag=this.fragments[this.fragI];this.curTo=null!==(_a=frag.tree.prop(stoppedInner))&&void 0!==_a?_a:frag.to;this.inner=new StructureCursor(frag.tree,-frag.offset)}}findMounts(pos,parser){var _a;let result=[];if(this.inner)for(this.inner.cursor.moveTo(pos,1),pos=this.inner.cursor.node;pos;pos=pos.parent){let mount=null===(_a=pos.tree)||void 0===_a?
void 0:_a.prop(NodeProp.mounted);if(mount&&mount.parser==parser)for(let i=this.fragI;i<this.fragments.length;i++){let frag=this.fragments[i];if(frag.from>=pos.to)break;frag.tree==this.curFrag.tree&&result.push({frag,pos:pos.from-frag.offset,mount})}}return result}}exports.DefaultBufferLength=1024;exports.MountedTree=MountedTree;exports.NodeProp=NodeProp;exports.NodeSet=NodeSet;exports.NodeType=NodeType;exports.NodeWeakMap=NodeWeakMap;exports.Parser=Parser;exports.Tree=Tree;exports.TreeBuffer=TreeBuffer;
exports.TreeCursor=TreeCursor;exports.TreeFragment=TreeFragment;exports.parseMixed=function(nest){return(parse,input,fragments,ranges)=>new MixedParse(parse,nest,input,fragments,ranges)}}
//# sourceMappingURL=module$node_modules$$lezer$common$dist$index_cjs.js.map
