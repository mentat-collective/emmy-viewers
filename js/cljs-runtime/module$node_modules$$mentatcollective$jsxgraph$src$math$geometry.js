shadow$provide.module$node_modules$$mentatcollective$jsxgraph$src$math$geometry=function(global,require,module,exports){function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj}}Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;var _jxg=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$jxg")),_constants=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$constants")),_coords=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$base$coords")),
_math=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$math")),_numerics=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$math$numerics")),_type=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$type")),_expect=_interopRequireDefault(require("module$node_modules$$mentatcollective$jsxgraph$src$utils$expect"));_math.default.Geometry={};_jxg.default.extend(_math.default.Geometry,{angle:function(A,
B,C){var v=[];var t=[];var c=[];_jxg.default.deprecated("Geometry.angle()","Geometry.rad()");A.coords?(v[0]=A.coords.usrCoords[1],v[1]=A.coords.usrCoords[2]):(v[0]=A[0],v[1]=A[1]);B.coords?(t[0]=B.coords.usrCoords[1],t[1]=B.coords.usrCoords[2]):(t[0]=B[0],t[1]=B[1]);C.coords?(c[0]=C.coords.usrCoords[1],c[1]=C.coords.usrCoords[2]):(c[0]=C[0],c[1]=C[1]);A=v[0]-t[0];v=v[1]-t[1];B=c[0]-t[0];t=c[1]-t[1];return Math.atan2(A*t-v*B,A*B+v*t)},trueAngle:function(A,B,C){return 57.29577951308232*this.rad(A,B,
C)},rad:function(A,B,C){if(A.coords){var ax=A.coords.usrCoords[1];A=A.coords.usrCoords[2]}else ax=A[0],A=A[1];if(B.coords){var bx=B.coords.usrCoords[1];B=B.coords.usrCoords[2]}else bx=B[0],B=B[1];if(C.coords){var cx=C.coords.usrCoords[1];C=C.coords.usrCoords[2]}else cx=C[0],C=C[1];ax=Math.atan2(C-B,cx-bx)-Math.atan2(A-B,ax-bx);0>ax&&(ax+=6.283185307179586);return ax},angleBisector:function(A,B,C,board){var phiA=A.coords.usrCoords;B=B.coords.usrCoords;C=C.coords.usrCoords;_type.default.exists(board)||
(board=A.board);if(0===B[0])return new _coords.default(_constants.default.COORDS_BY_USER,[1,.5*(phiA[1]+C[1]),.5*(phiA[2]+C[2])],board);A=phiA[1]-B[1];var y=phiA[2]-B[2];phiA=Math.atan2(y,A);A=C[1]-B[1];y=C[2]-B[2];A=Math.atan2(y,A);C=.5*(phiA+A);phiA>A&&(C+=Math.PI);A=Math.cos(C)+B[1];y=Math.sin(C)+B[2];return new _coords.default(_constants.default.COORDS_BY_USER,[1,A,y],board)},reflection:function(line,point,board){var pc=point.coords.usrCoords;var mu=line.point1.coords.usrCoords;line=line.point2.coords.usrCoords;
_type.default.exists(board)||(board=point.board);point=line[1]-mu[1];line=line[2]-mu[2];mu=(point*(pc[2]-mu[2])-line*(pc[1]-mu[1]))/(point*point+line*line);return new _coords.default(_constants.default.COORDS_BY_USER,[pc[1]+2*mu*line,pc[2]-2*mu*point],board)},rotation:function(rotpoint,point,phi,board){var y0=point.coords.usrCoords;rotpoint=rotpoint.coords.usrCoords;_type.default.exists(board)||(board=point.board);point=y0[1]-rotpoint[1];y0=y0[2]-rotpoint[2];var c=Math.cos(phi);phi=Math.sin(phi);
return new _coords.default(_constants.default.COORDS_BY_USER,[point*c-y0*phi+rotpoint[1],point*phi+y0*c+rotpoint[2]],board)},perpendicular:function(line,point,board){var c=line.point1.coords.usrCoords;var change=line.point2.coords.usrCoords;var C=point.coords.usrCoords;_type.default.exists(board)||(board=point.board);if(point===line.point1){line=c[1]+change[2]-c[2];point=c[2]-change[1]+c[1];var z=c[0]*change[0];Math.abs(z)<_math.default.eps&&(line=change[2],point=-change[1]);c=[z,line,point];change=
!0}else point===line.point2?(line=change[1]+c[2]-change[2],point=change[2]-c[1]+change[1],z=c[0]*change[0],Math.abs(z)<_math.default.eps&&(line=c[2],point=-c[1]),c=[z,line,point],change=!1):Math.abs(_math.default.innerProduct(C,line.stdform,3))<_math.default.eps?(line=C[1]+change[2]-C[2],point=C[2]-change[1]+C[1],z=change[0],Math.abs(z)<_math.default.eps&&(line=change[2],point=-change[1]),change=!0,Math.abs(z)>_math.default.eps&&Math.abs(line-C[1])<_math.default.eps&&Math.abs(point-C[2])<_math.default.eps&&
(line=C[1]+c[2]-C[2],point=C[2]-c[1]+C[1],change=!1),c=[z,line,point]):(c=[0,line.stdform[1],line.stdform[2]],c=_math.default.crossProduct(c,C),c=_math.default.crossProduct(c,line.stdform),change=!0);return[new _coords.default(_constants.default.COORDS_BY_USER,c,board),change]},circumcenterMidpoint:function(){_jxg.default.deprecated("Geometry.circumcenterMidpoint()","Geometry.circumcenter()");this.circumcenter.apply(this,arguments)},circumcenter:function(point1,point2,point3,board){var m1=point1.coords.usrCoords;
point2=point2.coords.usrCoords;point3=point3.coords.usrCoords;_type.default.exists(board)||(board=point1.board);point1=[point2[0]-m1[0],-point2[2]+m1[2],point2[1]-m1[1]];var v=[.5*(m1[0]+point2[0]),.5*(m1[1]+point2[1]),.5*(m1[2]+point2[2])];m1=_math.default.crossProduct(point1,v);point1=[point3[0]-point2[0],-point3[2]+point2[2],point3[1]-point2[1]];v=[.5*(point2[0]+point3[0]),.5*(point2[1]+point3[1]),.5*(point2[2]+point3[2])];point2=_math.default.crossProduct(point1,v);return new _coords.default(_constants.default.COORDS_BY_USER,
_math.default.crossProduct(m1,point2),board)},distance:function(array1,array2,n){var i,sum=0;n||(n=Math.min(array1.length,array2.length));for(i=0;i<n;i++)sum+=(array1[i]-array2[i])*(array1[i]-array2[i]);return Math.sqrt(sum)},affineDistance:function(array1,array2,n){n=this.distance(array1,array2,n);return n>_math.default.eps&&(Math.abs(array1[0])<_math.default.eps||Math.abs(array2[0])<_math.default.eps)?Infinity:n},affineRatio:function(a,b,c){_type.default.exists(a.usrCoords)&&(a=a.usrCoords);_type.default.exists(b.usrCoords)&&
(b=b.usrCoords);_type.default.exists(c.usrCoords)&&(c=c.usrCoords);var dx=b[1]-a[1];return Math.abs(dx)>_math.default.eps?(c[1]-a[1])/dx:(c[2]-a[2])/(b[2]-a[2])},sortVertices:function(p){p=_expect.default.each(p,_expect.default.coordsArray);for(var N=p.length,lastPoint=null;p[0][0]===p[N-1][0]&&p[0][1]===p[N-1][1]&&p[0][2]===p[N-1][2];)lastPoint=p.pop(),N--;var ll=p[0];p.sort(function(a,b){return(a[2]===ll[2]&&a[1]===ll[1]?-Infinity:Math.atan2(a[2]-ll[2],a[1]-ll[1]))-(b[2]===ll[2]&&b[1]===ll[1]?-Infinity:
Math.atan2(b[2]-ll[2],b[1]-ll[1]))});null!==lastPoint&&p.push(lastPoint);return p},signedTriangle:function(p1,p2,p3){p1=_expect.default.coordsArray(p1);p2=_expect.default.coordsArray(p2);p3=_expect.default.coordsArray(p3);return.5*((p2[1]-p1[1])*(p3[2]-p1[2])-(p2[2]-p1[2])*(p3[1]-p1[1]))},signedPolygon:function(p,sort){var A=0;p=_expect.default.each(p,_expect.default.coordsArray);void 0===sort&&(sort=!0);sort?p.unshift(p[p.length-1]):p=this.sortVertices(p);var N=p.length;for(sort=1;sort<N;sort++)A+=
p[sort-1][1]*p[sort][2]-p[sort][1]*p[sort-1][2];return.5*A},GrahamScan:function(points){var M=1,ps=_expect.default.each(points,_expect.default.coordsArray);ps=this.sortVertices(ps);var N=ps.length;for(points=2;points<N;points++){for(;0>=this.signedTriangle(ps[M-1],ps[M],ps[points]);){if(1<M)--M;else if(points===N-1)break;points+=1}M+=1;ps=_type.default.swap(ps,M,points)}return ps.slice(0,M)},calcStraight:function(el,point1,point2,margin){var p2;_type.default.exists(margin)||(margin=10);var straightFirst=
_type.default.evaluate(el.visProp.straightfirst);var straightLast=_type.default.evaluate(el.visProp.straightlast);Math.abs(point1.scrCoords[0])<_math.default.eps&&(straightFirst=!0);Math.abs(point2.scrCoords[0])<_math.default.eps&&(straightLast=!0);if(straightFirst||straightLast){var c=[];c[0]=el.stdform[0]-el.stdform[1]*el.board.origin.scrCoords[1]/el.board.unitX+el.stdform[2]*el.board.origin.scrCoords[2]/el.board.unitY;c[1]=el.stdform[1]/el.board.unitX;c[2]=-el.stdform[2]/el.board.unitY;if(!isNaN(c[0]+
c[1]+c[2])){var takePoint1=!straightFirst&&Math.abs(point1.usrCoords[0])>=_math.default.eps&&0<=point1.scrCoords[1]&&point1.scrCoords[1]<=el.board.canvasWidth&&0<=point1.scrCoords[2]&&point1.scrCoords[2]<=el.board.canvasHeight;var takePoint2=!straightLast&&Math.abs(point2.usrCoords[0])>=_math.default.eps&&0<=point2.scrCoords[1]&&point2.scrCoords[1]<=el.board.canvasWidth&&0<=point2.scrCoords[2]&&point2.scrCoords[2]<=el.board.canvasHeight;margin=this.meetLineBoard(c,el.board,margin);el=margin[0];margin=
margin[1];if(takePoint1||takePoint2||(straightFirst||!straightLast||this.isSameDirection(point1,point2,el)||this.isSameDirection(point1,point2,margin))&&(!straightFirst||straightLast||this.isSameDirection(point2,point1,el)||this.isSameDirection(point2,point1,margin))){if(takePoint1)takePoint2||(p2=this.isSameDir(point1,point2,el,margin)?margin:el);else if(takePoint2)var p1=this.isSameDir(point1,point2,el,margin)?el:margin;else this.isSameDir(point1,point2,el,margin)?(p1=el,p2=margin):(p2=el,p1=margin);
p1&&point1.setCoordinates(_constants.default.COORDS_BY_USER,p1.usrCoords);p2&&point2.setCoordinates(_constants.default.COORDS_BY_USER,p2.usrCoords)}}}},calcLineDelimitingPoints:function(el,point1,point2){var p2;var straightFirst=_type.default.evaluate(el.visProp.straightfirst);var straightLast=_type.default.evaluate(el.visProp.straightlast);Math.abs(point1.scrCoords[0])<_math.default.eps&&(straightFirst=!0);Math.abs(point2.scrCoords[0])<_math.default.eps&&(straightLast=!0);var intersect1=[];intersect1[0]=
el.stdform[0]-el.stdform[1]*el.board.origin.scrCoords[1]/el.board.unitX+el.stdform[2]*el.board.origin.scrCoords[2]/el.board.unitY;intersect1[1]=el.stdform[1]/el.board.unitX;intersect1[2]=-el.stdform[2]/el.board.unitY;if(!isNaN(intersect1[0]+intersect1[1]+intersect1[2])){var takePoint1=!straightFirst;var takePoint2=!straightLast;var boundingBox=el.board.getBoundingBox();0<=el.getSlope()?(intersect1=this.projectPointToLine({coords:{usrCoords:[1,boundingBox[2],boundingBox[1]]}},el,el.board),boundingBox=
this.projectPointToLine({coords:{usrCoords:[1,boundingBox[0],boundingBox[3]]}},el,el.board)):(intersect1=this.projectPointToLine({coords:{usrCoords:[1,boundingBox[0],boundingBox[1]]}},el,el.board),boundingBox=this.projectPointToLine({coords:{usrCoords:[1,boundingBox[2],boundingBox[3]]}},el,el.board));if(!takePoint1&&!takePoint2&&(!straightFirst&&!straightLast&&(el=point1.distance(_constants.default.COORDS_BY_USER,point2),Math.abs(point1.distance(_constants.default.COORDS_BY_USER,intersect1)+intersect1.distance(_constants.default.COORDS_BY_USER,
point2)-el)>_math.default.eps||Math.abs(point1.distance(_constants.default.COORDS_BY_USER,boundingBox)+boundingBox.distance(_constants.default.COORDS_BY_USER,point2)-el)>_math.default.eps)||!straightFirst&&straightLast&&!this.isSameDirection(point1,point2,intersect1)&&!this.isSameDirection(point1,point2,boundingBox)||straightFirst&&!straightLast&&!this.isSameDirection(point2,point1,intersect1)&&!this.isSameDirection(point2,point1,boundingBox)))return;if(takePoint1)takePoint2||(p2=this.isSameDir(point1,
point2,intersect1,boundingBox)?boundingBox:intersect1);else if(takePoint2)var p1=this.isSameDir(point1,point2,intersect1,boundingBox)?intersect1:boundingBox;else this.isSameDir(point1,point2,intersect1,boundingBox)?(p1=intersect1,p2=boundingBox):(p2=intersect1,p1=boundingBox);p1&&point1.setCoordinates(_constants.default.COORDS_BY_USER,p1.usrCoords);p2&&point2.setCoordinates(_constants.default.COORDS_BY_USER,p2.usrCoords)}},calcLabelQuadrant:function(angle){0>angle&&(angle+=2*Math.PI);return"rt urt top ulft lft llft lrt".split(" ")[Math.floor((angle+
Math.PI/8)/(Math.PI/4))%8]},isSameDir:function(p1,p2,i1,i2){var dpx=p2.usrCoords[1]-p1.usrCoords[1],dpy=p2.usrCoords[2]-p1.usrCoords[2],dix=i2.usrCoords[1]-i1.usrCoords[1];i1=i2.usrCoords[2]-i1.usrCoords[2];Math.abs(p2.usrCoords[0])<_math.default.eps&&(dpx=p2.usrCoords[1],dpy=p2.usrCoords[2]);Math.abs(p1.usrCoords[0])<_math.default.eps&&(dpx=-p1.usrCoords[1],dpy=-p1.usrCoords[2]);return 0<=dpx*dix+dpy*i1},isSameDirection:function(start,p,s){var r=!1;var dx=p.usrCoords[1]-start.usrCoords[1];p=p.usrCoords[2]-
start.usrCoords[2];var sx=s.usrCoords[1]-start.usrCoords[1];start=s.usrCoords[2]-start.usrCoords[2];Math.abs(dx)<_math.default.eps&&(dx=0);Math.abs(p)<_math.default.eps&&(p=0);Math.abs(sx)<_math.default.eps&&(sx=0);Math.abs(start)<_math.default.eps&&(start=0);0<=dx&&0<=sx?r=0<=p&&0<=start||0>=p&&0>=start:0>=dx&&0>=sx&&(r=0<=p&&0<=start||0>=p&&0>=start);return r},det3p:function(p1,p2,q){return(p1[1]-q[1])*(p2[2]-q[2])-(p2[1]-q[1])*(p1[2]-q[2])},windingNumber:function(usrCoords,path,doNotClosePath){var wn=
0,le=path.length,x=usrCoords[1],y=usrCoords[2],i,off=0;if(0===le)return 0;doNotClosePath&&(off=1);if(isNaN(x)||isNaN(y))return 1;doNotClosePath=_type.default.exists(path[0].coords)?path[0].coords:path[0];if(doNotClosePath.usrCoords[1]===x&&doNotClosePath.usrCoords[2]===y)return 1;for(i=0;i<le-off;i++){if(_type.default.exists(path[i].coords)){doNotClosePath=path[i].coords.usrCoords;var p2=path[(i+1)%le].coords.usrCoords}else doNotClosePath=path[i].usrCoords,p2=path[(i+1)%le].usrCoords;if(!(0===doNotClosePath[0]||
0===p2[0]||isNaN(doNotClosePath[1])||isNaN(p2[1])||isNaN(doNotClosePath[2])||isNaN(p2[2]))){if(p2[2]===y){if(p2[1]===x)return 1;if(doNotClosePath[2]===y&&p2[1]>x===doNotClosePath[1]<x)return 0}if(doNotClosePath[2]<y!==p2[2]<y){var sign=2*(p2[2]>doNotClosePath[2]?1:0)-1;if(doNotClosePath[1]>=x)if(p2[1]>x)wn+=sign;else{var d=this.det3p(doNotClosePath,p2,usrCoords);if(0===d)return 0;d>0+_math.default.eps===p2[2]>doNotClosePath[2]&&(wn+=sign)}else p2[1]>x&&(d=this.det3p(doNotClosePath,p2,usrCoords),d>
0+_math.default.eps===p2[2]>doNotClosePath[2]&&(wn+=sign))}}}return wn},pnpoly:function(x_in,y_in,path,coord_type){var j,isIn=!1;if(coord_type===_constants.default.COORDS_BY_USER){y_in=new _coords.default(_constants.default.COORDS_BY_USER,[x_in,y_in],this.board);x_in=y_in.scrCoords[1];var y=y_in.scrCoords[2]}else y=y_in;coord_type=path.length;y_in=0;for(j=coord_type-2;y_in<coord_type-1;j=y_in++){var vi=_type.default.exists(path[y_in].coords)?path[y_in].coords:path[y_in];j=_type.default.exists(path[j].coords)?
path[j].coords:path[j];vi.scrCoords[2]>y!==j.scrCoords[2]>y&&x_in<(j.scrCoords[1]-vi.scrCoords[1])*(y-vi.scrCoords[2])/(j.scrCoords[2]-vi.scrCoords[2])+vi.scrCoords[1]&&(isIn=!isIn)}return isIn},intersectionFunction:function(board,el1,el2,i,j,alwaysintersect){var that=this,el1_isArcType=!1,el2_isArcType=!1;el1_isArcType=el1.elementClass!==_constants.default.OBJECT_CLASS_CURVE||el1.type!==_constants.default.OBJECT_TYPE_ARC&&el1.type!==_constants.default.OBJECT_TYPE_SECTOR?!1:!0;el2_isArcType=el2.elementClass!==
_constants.default.OBJECT_CLASS_CURVE||el2.type!==_constants.default.OBJECT_TYPE_ARC&&el2.type!==_constants.default.OBJECT_TYPE_SECTOR?!1:!0;return el1.elementClass!==_constants.default.OBJECT_CLASS_CURVE&&el2.elementClass!==_constants.default.OBJECT_CLASS_CURVE||el1.elementClass!==_constants.default.OBJECT_CLASS_CURVE&&el1.elementClass!==_constants.default.OBJECT_CLASS_CIRCLE||el2.elementClass!==_constants.default.OBJECT_CLASS_CURVE&&el2.elementClass!==_constants.default.OBJECT_CLASS_CIRCLE?el1.elementClass===
_constants.default.OBJECT_CLASS_CURVE&&!el1_isArcType&&el2.elementClass===_constants.default.OBJECT_CLASS_LINE||el2.elementClass===_constants.default.OBJECT_CLASS_CURVE&&!el2_isArcType&&el1.elementClass===_constants.default.OBJECT_CLASS_LINE?function(){return that.meetCurveLine(el1,el2,i,el1.board,alwaysintersect)}:el1.type===_constants.default.OBJECT_TYPE_POLYGON||el2.type===_constants.default.OBJECT_TYPE_POLYGON?el1.elementClass===_constants.default.OBJECT_CLASS_LINE?function(){return that.meetPolygonLine(el2,
el1,i,el1.board,alwaysintersect)}:el2.elementClass===_constants.default.OBJECT_CLASS_LINE?function(){return that.meetPolygonLine(el1,el2,i,el1.board,alwaysintersect)}:function(){return that.meetPathPath(el1,el2,i,el1.board)}:el1.elementClass===_constants.default.OBJECT_CLASS_LINE&&el2.elementClass===_constants.default.OBJECT_CLASS_LINE?function(){var first1=_type.default.evaluate(el1.visProp.straightfirst),last1=_type.default.evaluate(el1.visProp.straightlast),first2=_type.default.evaluate(el2.visProp.straightfirst),
last2=_type.default.evaluate(el2.visProp.straightlast);if(!(_type.default.evaluate(alwaysintersect)||first1&&last1&&first2&&last2)){var res=that.meetSegmentSegment(el1.point1.coords.usrCoords,el1.point2.coords.usrCoords,el2.point1.coords.usrCoords,el2.point2.coords.usrCoords);res=!first1&&0>res[1]||!last1&&1<res[1]||!first2&&0>res[2]||!last2&&1<res[2]?[0,NaN,NaN]:res[0];return new _coords.default(_constants.default.COORDS_BY_USER,res,el1.board)}return that.meet(el1.stdform,el2.stdform,i,el1.board)}:
function(){var res=that.meet(el1.stdform,el2.stdform,i,el1.board);if(alwaysintersect)return res;if(el1.elementClass===_constants.default.OBJECT_CLASS_LINE){var has=_type.default.evaluate(el1.visProp.straightfirst);var last=_type.default.evaluate(el1.visProp.straightlast);if(!has||!last){var r=that.affineRatio(el1.point1.coords,el1.point2.coords,res);if(!last&&r>1+_math.default.eps||!has&&r<0-_math.default.eps)return new _coords.default(_jxg.default.COORDS_BY_USER,[0,NaN,NaN],el1.board)}}return el2.elementClass===
_constants.default.OBJECT_CLASS_LINE&&(has=_type.default.evaluate(el2.visProp.straightfirst),last=_type.default.evaluate(el2.visProp.straightlast),!has||!last)&&(r=that.affineRatio(el2.point1.coords,el2.point2.coords,res),!last&&r>1+_math.default.eps||!has&&r<0-_math.default.eps)?new _coords.default(_jxg.default.COORDS_BY_USER,[0,NaN,NaN],el1.board):el1_isArcType&&((has=that.coordsOnArc(el1,res))&&el2_isArcType&&(has=that.coordsOnArc(el2,res)),!has)?new _coords.default(_jxg.default.COORDS_BY_USER,
[0,NaN,NaN],el1.board):res}:function(){return that.meetCurveCurve(el1,el2,i,j,el1.board)}},coordsOnArc:function(arc,coords){coords=this.rad(arc.radiuspoint,arc.center,coords.usrCoords.slice(1));var alpha=0,beta=this.rad(arc.radiuspoint,arc.center,arc.anglepoint);arc=_type.default.evaluate(arc.visProp.selection);if("minor"===arc&&beta>Math.PI||"major"===arc&&beta<Math.PI)alpha=beta,beta=2*Math.PI;return coords<alpha||coords>beta?!1:!0},meet:function(el1,el2,i,board){var eps=_math.default.eps;return Math.abs(el1[3])<
eps&&Math.abs(el2[3])<eps?this.meetLineLine(el1,el2,i,board):Math.abs(el1[3])>=eps&&Math.abs(el2[3])<eps?this.meetLineCircle(el2,el1,i,board):Math.abs(el1[3])<eps&&Math.abs(el2[3])>=eps?this.meetLineCircle(el1,el2,i,board):this.meetCircleCircle(el1,el2,i,board)},meetLineBoard:function(line,board,margin){var s=[];_type.default.exists(margin)||(margin=0);s[0]=_math.default.crossProduct(line,[margin,0,1]);s[1]=_math.default.crossProduct(line,[margin,1,0]);s[2]=_math.default.crossProduct(line,[-margin-
board.canvasHeight,0,1]);s[3]=_math.default.crossProduct(line,[-margin-board.canvasWidth,1,0]);for(line=0;4>line;line++)if(Math.abs(s[line][0])>_math.default.eps){for(margin=2;0<margin;margin--)s[line][margin]/=s[line][0];s[line][0]=1}Math.abs(s[1][0])<_math.default.eps?(line=s[0],s=s[2]):Math.abs(s[0][0])<_math.default.eps?(line=s[1],s=s[3]):0>s[1][2]?(line=s[0],s=s[3][2]>board.canvasHeight?s[2]:s[3]):s[1][2]>board.canvasHeight?(line=s[2],s=0>s[3][2]?s[0]:s[3]):(line=s[1],s=0>s[3][2]?s[0]:s[3][2]>
board.canvasHeight?s[2]:s[3]);line=new _coords.default(_constants.default.COORDS_BY_SCREEN,line.slice(1),board);s=new _coords.default(_constants.default.COORDS_BY_SCREEN,s.slice(1),board);return[line,s]},meetLineLine:function(l1,l2,i,board){l1=isNaN(l1[5]+l2[5])?[0,0,0]:_math.default.crossProduct(l1,l2);return new _coords.default(_constants.default.COORDS_BY_USER,l1,board)},meetLineCircle:function(lin,circ,i,board){if(circ[4]<_math.default.eps)return Math.abs(_math.default.innerProduct([1,circ[6],
circ[7]],lin,3))<_math.default.eps?new _coords.default(_constants.default.COORDS_BY_USER,circ.slice(6,8),board):new _coords.default(_constants.default.COORDS_BY_USER,[NaN,NaN],board);var c=circ[0];var b=circ.slice(1,3);var a=circ[3];circ=lin[0];lin=lin.slice(1,3);var B=b[0]*lin[1]-b[1]*lin[0];b=B*B-4*a*(a*circ*circ-(b[0]*lin[0]+b[1]*lin[1])*circ+c);return b>-_math.default.eps*_math.default.eps?(b=Math.sqrt(Math.abs(b)),a=[(-B+b)/(2*a),(-B-b)/(2*a)],0===i?new _coords.default(_constants.default.COORDS_BY_USER,
[-a[0]*-lin[1]-circ*lin[0],-a[0]*lin[0]-circ*lin[1]],board):new _coords.default(_constants.default.COORDS_BY_USER,[-a[1]*-lin[1]-circ*lin[0],-a[1]*lin[0]-circ*lin[1]],board)):new _coords.default(_constants.default.COORDS_BY_USER,[0,0,0],board)},meetCircleCircle:function(circ1,circ2,i,board){if(circ1[4]<_math.default.eps)return Math.abs(this.distance(circ1.slice(6,2),circ2.slice(6,8))-circ2[4])<_math.default.eps?new _coords.default(_constants.default.COORDS_BY_USER,circ1.slice(6,8),board):new _coords.default(_constants.default.COORDS_BY_USER,
[0,0,0],board);if(circ2[4]<_math.default.eps)return Math.abs(this.distance(circ2.slice(6,2),circ1.slice(6,8))-circ1[4])<_math.default.eps?new _coords.default(_constants.default.COORDS_BY_USER,circ2.slice(6,8),board):new _coords.default(_constants.default.COORDS_BY_USER,[0,0,0],board);circ2=[circ2[3]*circ1[0]-circ1[3]*circ2[0],circ2[3]*circ1[1]-circ1[3]*circ2[1],circ2[3]*circ1[2]-circ1[3]*circ2[2],0,1,Infinity,Infinity,Infinity];circ2=_math.default.normalize(circ2);return this.meetLineCircle(circ2,
circ1,i,board)},meetCurveCurve:function(c1,c2,nr,t2ini,board,method){c1=_type.default.exists(method)&&"newton"===method?_numerics.default.generalizedNewton(c1,c2,nr,t2ini):3===c1.bezierDegree||3===c2.bezierDegree?this.meetBezierCurveRedBlueSegments(c1,c2,nr):this.meetCurveRedBlueSegments(c1,c2,nr);return new _coords.default(_constants.default.COORDS_BY_USER,c1,board)},meetCurveLine:function(el1,el2,nr,board,alwaysIntersect){_type.default.exists(board)||(board=el1.board);if(el1.elementClass===_constants.default.OBJECT_CLASS_CURVE){var cu=
el1;el1=el2}else cu=el2;return this.meetCurveLineDiscrete(cu,el1,nr,board,!alwaysIntersect)},meetCurveLineContinuous:function(cu,li,nr,board,testSegment){var z,epsLow=z=_math.default.eps,i;nr=this.meetCurveLineDiscrete(cu,li,nr,board,testSegment);var x=nr.usrCoords[1];var y=nr.usrCoords[2];testSegment=function(t){if(t>cu.maxX()||t<cu.minX())return Infinity;var c1=x-cu.X(t);t=y-cu.Y(t);return c1*c1+t*t};var func1=function(t){t=li.stdform[0]+li.stdform[1]*cu.X(t)+li.stdform[2]*cu.Y(t);return t*t};var delta=
(cu.maxX()-cu.minX())/50;var tnew=cu.minX();var fmin=1E-4;var tmin=NaN;for(i=0;50>i;i++){nr=_numerics.default.root(testSegment,[Math.max(tnew,cu.minX()),Math.min(tnew+delta,cu.maxX())]);var ft=Math.abs(testSegment(nr));if(ft<=fmin&&(fmin=ft,tmin=nr,fmin<z))break;tnew+=delta}nr=tmin;nr=_numerics.default.root(func1,[Math.max(nr-delta,cu.minX()),Math.min(nr+delta,cu.maxX())]);ft=func1(nr);z=isNaN(ft)||Math.abs(ft)>epsLow?0:1;return new _coords.default(_constants.default.COORDS_BY_USER,[z,cu.X(nr),cu.Y(nr)],
board)},meetCurveLineDiscrete:function(cu,li,nr,board,testSegment){var lip1=li.point1.coords.usrCoords,lip2=li.point2.coords.usrCoords,cnt=0,len=cu.numberPoints,ev_sf=_type.default.evaluate(li.visProp.straightfirst),ev_sl=_type.default.evaluate(li.visProp.straightlast);var q=new _coords.default(_constants.default.COORDS_BY_USER,[0,NaN,NaN],board);0===lip1[0]?lip1=[1,lip2[1]+li.stdform[2],lip2[2]-li.stdform[1]]:0===lip2[0]&&(lip2=[1,lip1[1]+li.stdform[2],lip1[2]-li.stdform[1]]);var p2=cu.points[0].usrCoords;
for(li=1;li<len;li+=cu.bezierDegree){var j=p2.slice(0);p2=cu.points[li].usrCoords;var p=this.distance(j,p2);if(p>_math.default.eps){var res=3===cu.bezierDegree?this.meetBeziersegmentBeziersegment([cu.points[li-1].usrCoords.slice(1),cu.points[li].usrCoords.slice(1),cu.points[li+1].usrCoords.slice(1),cu.points[li+2].usrCoords.slice(1)],[lip1.slice(1),lip2.slice(1)],testSegment):[this.meetSegmentSegment(j,p2,lip1,lip2)];for(j=0;j<res.length;j++)if(p=res[j],0<=p[1]&&1>=p[1]){if(cnt===nr)return testSegment&&
(!ev_sf&&0>p[2]||!ev_sl&&1<p[2])?q:q=new _coords.default(_constants.default.COORDS_BY_USER,p[0],board);cnt+=1}}}return q},meetCurveRedBlueSegments:function(red,blue,nr){var i,j,iFound=0,lenBlue=blue.numberPoints,lenRed=red.numberPoints;if(1>=lenBlue||1>=lenRed)return[0,NaN,NaN];for(i=1;i<lenRed;i++){var red1=red.points[i-1].usrCoords;var red2=red.points[i].usrCoords;var minX=Math.min(red1[1],red2[1]);var maxX=Math.max(red1[1],red2[1]);var blue2=blue.points[0].usrCoords;for(j=1;j<lenBlue;j++){var blue1=
blue2;blue2=blue.points[j].usrCoords;if(Math.min(blue1[1],blue2[1])<maxX&&Math.max(blue1[1],blue2[1])>minX&&(blue1=this.meetSegmentSegment(red1,red2,blue1,blue2),0<=blue1[1]&&0<=blue1[2]&&(1>blue1[1]&&1>blue1[2]||i===lenRed-1&&1===blue1[1]||j===lenBlue-1&&1===blue1[2]))){if(iFound===nr)return blue1[0];iFound++}}}return[0,NaN,NaN]},meetSegmentSegment:function(p1,p2,q1,q2){var i=_math.default.crossProduct(p1,p2);var li2=_math.default.crossProduct(q1,q2);li2=_math.default.crossProduct(i,li2);if(Math.abs(li2[0])<
_math.default.eps)return[li2,Infinity,Infinity];li2[1]/=li2[0];li2[2]/=li2[0];li2[0]/=li2[0];i=Math.abs(p2[1]-p2[0]*p1[1])<_math.default.eps?2:1;p1=p1[i]/p1[0];p2=(li2[i]-p1)/(0!==p2[0]?p2[i]/p2[0]-p1:p2[i]);i=Math.abs(q2[1]-q2[0]*q1[1])<_math.default.eps?2:1;p1=q1[i]/q1[0];return[li2,p2,(li2[i]-p1)/(0!==q2[0]?q2[i]/q2[0]-p1:q2[i])]},meetPathPath:function(path1,path2,nr,board){path1=_jxg.default.Math.Clip._getPath(path1,board);var len=path1.length;0<len&&this.distance(path1[0].coords.usrCoords,path1[len-
1].coords.usrCoords,3)<_math.default.eps&&path1.pop();path2=_jxg.default.Math.Clip._getPath(path2,board);len=path2.length;0<len&&this.distance(path2[0].coords.usrCoords,path2[len-1].coords.usrCoords,3)<_math.default.eps*_math.default.eps&&path2.pop();if(0>nr||_jxg.default.Math.Clip.isEmptyCase(path1,path2,"intersection"))return new _coords.default(_constants.default.COORDS_BY_USER,[0,0,0],board);_jxg.default.Math.Clip.makeDoublyLinkedList(path1);_jxg.default.Math.Clip.makeDoublyLinkedList(path2);
path2=_jxg.default.Math.Clip.findIntersections(path1,path2,board)[0];return nr<path2.length?path2[nr].coords:new _coords.default(_constants.default.COORDS_BY_USER,[0,0,0],board)},meetPolygonLine:function(path,line,nr,board,alwaysIntersect){var i,crds=[0,0,0],len=path.borders.length,intersections=[];for(i=0;i<len;i++){var res=path.borders[i];res=this.meetSegmentSegment(res.point1.coords.usrCoords,res.point2.coords.usrCoords,line.point1.coords.usrCoords,line.point2.coords.usrCoords);(!alwaysIntersect||
0<=res[2]&&1>res[2])&&0<=res[1]&&1>res[1]&&intersections.push(res[0])}0<=nr&&nr<intersections.length&&(crds=intersections[nr]);return new _coords.default(_constants.default.COORDS_BY_USER,crds,board)},_bezierSplit:function(curve){var p0=[.5*(curve[0][0]+curve[1][0]),.5*(curve[0][1]+curve[1][1])];var p1=[.5*(curve[1][0]+curve[2][0]),.5*(curve[1][1]+curve[2][1])];var p2=[.5*(curve[2][0]+curve[3][0]),.5*(curve[2][1]+curve[3][1])];var p00=[.5*(p0[0]+p1[0]),.5*(p0[1]+p1[1])];p1=[.5*(p1[0]+p2[0]),.5*(p1[1]+
p2[1])];var p000=[.5*(p00[0]+p1[0]),.5*(p00[1]+p1[1])];return[[curve[0],p0,p00,p000],[p000,p1,p2,curve[3]]]},_bezierBbox:function(curve){var bb=[];4===curve.length?(bb[0]=Math.min(curve[0][0],curve[1][0],curve[2][0],curve[3][0]),bb[1]=Math.max(curve[0][1],curve[1][1],curve[2][1],curve[3][1]),bb[2]=Math.max(curve[0][0],curve[1][0],curve[2][0],curve[3][0]),bb[3]=Math.min(curve[0][1],curve[1][1],curve[2][1],curve[3][1])):(bb[0]=Math.min(curve[0][0],curve[1][0]),bb[1]=Math.max(curve[0][1],curve[1][1]),
bb[2]=Math.max(curve[0][0],curve[1][0]),bb[3]=Math.min(curve[0][1],curve[1][1]));return bb},_bezierOverlap:function(bb1,bb2){return bb1[2]>=bb2[0]&&bb1[0]<=bb2[2]&&bb1[1]>=bb2[3]&&bb1[3]<=bb2[1]},_bezierListConcat:function(L,Lnew,t1,t2){var t2exists=_type.default.exists(t2);var i=0;var len=Lnew.length,le=L.length;for(0<le&&0<len&&(1===L[le-1][1]&&0===Lnew[0][1]||t2exists&&1===L[le-1][2]&&0===Lnew[0][2])&&(i=1);i<len;i++)t2exists&&(Lnew[i][2]*=.5,Lnew[i][2]+=t2),Lnew[i][1]*=.5,Lnew[i][1]+=t1,L.push(Lnew[i])},
_bezierMeetSubdivision:function(red,blue,level){var p0=[];var bbr=this._bezierBbox(blue);var bbb=this._bezierBbox(red);if(!this._bezierOverlap(bbr,bbb))return[];if(5>level)return bbr=this._bezierSplit(red),red=bbr[0],bbb=bbr[1],bbr=this._bezierSplit(blue),blue=bbr[0],bbr=bbr[1],this._bezierListConcat(p0,this._bezierMeetSubdivision(red,blue,level+1),0,0),this._bezierListConcat(p0,this._bezierMeetSubdivision(red,bbr,level+1),0,.5),this._bezierListConcat(p0,this._bezierMeetSubdivision(bbb,blue,level+
1),.5,0),this._bezierListConcat(p0,this._bezierMeetSubdivision(bbb,bbr,level+1),.5,.5),p0;level=[1].concat(red[0]);red=[1].concat(red[3]);p0=[1].concat(blue[0]);blue=[1].concat(blue[3]);blue=this.meetSegmentSegment(level,red,p0,blue);return 0<=blue[1]&&0<=blue[2]&&1>=blue[1]&&1>=blue[2]?[blue]:[]},_bezierLineMeetSubdivision:function(red,blue,level,testSegment){var p0=[];var bbb=this._bezierBbox(blue);var bbr=this._bezierBbox(red);if(testSegment&&!this._bezierOverlap(bbr,bbb))return[];if(5>level)return red=
this._bezierSplit(red),testSegment=red[0],red=red[1],this._bezierListConcat(p0,this._bezierLineMeetSubdivision(testSegment,blue,level+1),0),this._bezierListConcat(p0,this._bezierLineMeetSubdivision(red,blue,level+1),.5),p0;level=[1].concat(red[0]);red=[1].concat(red[3]);p0=[1].concat(blue[0]);blue=[1].concat(blue[1]);blue=this.meetSegmentSegment(level,red,p0,blue);return 0<=blue[1]&&1>=blue[1]&&(!testSegment||0<=blue[2]&&1>=blue[2])?[blue]:[]},meetBeziersegmentBeziersegment:function(red,blue,testSegment){red=
4===red.length&&4===blue.length?this._bezierMeetSubdivision(red,blue,0):this._bezierLineMeetSubdivision(red,blue,0,testSegment);red.sort(function(a,b){return 1E7*(a[1]-b[1])+(a[2]-b[2])});blue=[];for(testSegment=0;testSegment<red.length;testSegment++)0!==testSegment&&red[testSegment][1]===red[testSegment-1][1]&&red[testSegment][2]===red[testSegment-1][2]||blue.push(red[testSegment]);return blue},meetBezierCurveRedBlueSegments:function(red,blue,nr){var i,j,startBlue=i=0,lenBlue=blue.numberPoints,lenRed=
red.numberPoints,L=[];if(lenBlue<blue.bezierDegree+1||lenRed<red.bezierDegree+1)return[0,NaN,NaN];lenBlue-=blue.bezierDegree;lenRed-=red.bezierDegree;red.type===_constants.default.OBJECT_TYPE_SECTOR&&(i=3,lenRed-=3);blue.type===_constants.default.OBJECT_TYPE_SECTOR&&(startBlue=3,lenBlue-=3);for(;i<lenRed;i+=red.bezierDegree){var p=red.points;var redArr=[p[i].usrCoords.slice(1),p[i+1].usrCoords.slice(1)];3===red.bezierDegree&&(redArr[2]=p[i+2].usrCoords.slice(1),redArr[3]=p[i+3].usrCoords.slice(1));
var bbr=this._bezierBbox(redArr);for(j=startBlue;j<lenBlue;j+=blue.bezierDegree){p=blue.points;var k=[p[j].usrCoords.slice(1),p[j+1].usrCoords.slice(1)];3===blue.bezierDegree&&(k[2]=p[j+2].usrCoords.slice(1),k[3]=p[j+3].usrCoords.slice(1));p=this._bezierBbox(k);if(this._bezierOverlap(bbr,p)){var intersections=this.meetBeziersegmentBeziersegment(redArr,k);if(0!==intersections.length){for(k=0;k<intersections.length;k++)p=intersections[k],p[1]<-_math.default.eps||p[1]>1+_math.default.eps||p[2]<-_math.default.eps||
p[2]>1+_math.default.eps||L.push(p);if(L.length>nr)return L[nr][0]}}}}return L.length>nr?L[nr][0]:[0,NaN,NaN]},bezierSegmentEval:function(t,curve){var t1=1-t;var f=t1*t1*t1;var x=f*curve[0][0];var y=f*curve[0][1];f=3*t*t1*t1;x+=f*curve[1][0];y+=f*curve[1][1];f=3*t*t*t1;x+=f*curve[2][0];y+=f*curve[2][1];f=t*t*t;x+=f*curve[3][0];y+=f*curve[3][1];return[1,x,y]},bezierArc:function(A,B,C,withLegs,sgn){var PI2=.5*Math.PI,x=B[1],y=B[2];var p1=B[0];var r=this.distance(B,A);x/=p1;y/=p1;B=this.rad(A.slice(1),
B.slice(1),C.slice(1));-1===sgn&&(B=2*Math.PI-B);p1=A;p1[1]/=p1[0];p1[2]/=p1[0];p1[0]/=p1[0];var p4=p1.slice(0);withLegs?(A=[x,x+.333*(p1[1]-x),x+.666*(p1[1]-x),p1[1]],C=[y,y+.333*(p1[2]-y),y+.666*(p1[2]-y),p1[2]]):(A=[p1[1]],C=[p1[2]]);for(;B>_math.default.eps;){if(B>PI2){var p3=PI2;B-=PI2}else p3=B,B=0;p4=Math.cos(sgn*p3);p3=Math.sin(sgn*p3);p4=[[1,0,0],[x*(1-p4)+y*p3,p4,-p3],[y*(1-p4)-x*p3,p3,p4]];p4=_math.default.matVecMult(p4,p1);p4=[p4[0]/p4[0],p4[1]/p4[0],p4[2]/p4[0]];var ax=p1[1]-x;var ay=
p1[2]-y;p3=p4[1]-x;var by=p4[2]-y;var k=Math.sqrt((ax+p3)*(ax+p3)+(ay+by)*(ay+by));k=Math.abs(by-ay)>_math.default.eps?(ax+p3)*(r/k-.5)/(by-ay)*8/3:(ay+by)*(r/k-.5)/(ax-p3)*8/3;p1=[1,p1[1]-k*ay,p1[2]+k*ax];p3=[1,p4[1]+k*by,p4[2]-k*p3];A=A.concat([p1[1],p3[1],p4[1]]);C=C.concat([p1[2],p3[2],p4[2]]);p1=p4.slice(0)}withLegs&&(A=A.concat([p4[1]+.333*(x-p4[1]),p4[1]+.666*(x-p4[1]),x]),C=C.concat([p4[2]+.333*(y-p4[2]),p4[2]+.666*(y-p4[2]),y]));return[A,C]},projectPointToCircle:function(point,circle,board){var M=
circle.center.coords.usrCoords;_type.default.exists(board)||(board=point.board);if(_type.default.isPoint(point)){var dist=point.coords.distance(_constants.default.COORDS_BY_USER,circle.center.coords);point=point.coords.usrCoords}else dist=point.distance(_constants.default.COORDS_BY_USER,circle.center.coords),point=point.usrCoords;Math.abs(dist)<_math.default.eps&&(dist=_math.default.eps);circle=circle.Radius()/dist;return new _coords.default(_constants.default.COORDS_BY_USER,[M[1]+circle*(point[1]-
M[1]),M[2]+circle*(point[2]-M[2])],board)},projectPointToLine:function(point,line,board){var v=[0,line.stdform[1],line.stdform[2]];_type.default.exists(board)||(board=_type.default.exists(point.coords)?point.board:line.board);point=_type.default.exists(point.coords)?point.coords.usrCoords:point.usrCoords;v=_math.default.crossProduct(v,point);return new _coords.default(_constants.default.COORDS_BY_USER,_math.default.crossProduct(v,line.stdform),board)},projectCoordsToSegment:function(p,q1,q2){q2=[q2[1]-
q1[1],q2[2]-q1[2]];if(Math.abs(q2[0])<_math.default.eps&&Math.abs(q2[1])<_math.default.eps)return[q1,0];p=_math.default.innerProduct([p[1]-q1[1],p[2]-q1[2]],q2);var denom=_math.default.innerProduct(q2,q2);p/=denom;return[[1,p*q2[0]+q1[1],p*q2[1]+q1[2]],p]},projectCoordsToBeziersegment:function(pos,curve,start){var t0=_jxg.default.Math.Numerics.fminbr(function(t){t=[1,curve.X(start+t),curve.Y(start+t)];t[1]-=pos[1];t[2]-=pos[2];return t[1]*t[1]+t[2]*t[2]},[0,1]);return[[1,curve.X(t0+start),curve.Y(t0+
start)],t0]},projectPointToCurve:function(point,curve,board){_type.default.exists(board)||(board=point.board);var x=point.X(),y=point.Y();return this.projectCoordsToCurve(x,y,point.position||0,curve,board)},projectCoordsToCurve:function(x,y,t$jscomp$0,curve,board){var j,p1;var i=Number.POSITIVE_INFINITY;_type.default.exists(board)||(board=curve.board);if("plot"===_type.default.evaluate(curve.visProp.curvetype)){t$jscomp$0=0;var mindist=i;var newCoords=0===curve.numberPoints?[0,1,1]:[curve.Z(0),curve.X(0),
curve.Y(0)];if(1<curve.numberPoints){var v=[1,x,y];3===curve.bezierDegree?j=0:p1=[curve.Z(0),curve.X(0),curve.Y(0)];for(i=0;i<curve.numberPoints-1;i++){if(3===curve.bezierDegree)var coords=this.projectCoordsToBeziersegment(v,curve,j);else{var p2=[curve.Z(i+1),curve.X(i+1),curve.Y(i+1)];coords=this.projectCoordsToSegment(v,p1,p2)}var lbda=coords[1];coords=coords[0];if(0<=lbda&&1>=lbda){var dist=this.distance(coords,v);var d=i+lbda}else 0>lbda?(coords=p1,dist=this.distance(p1,v),d=i):1<lbda&&i===curve.numberPoints-
2&&(coords=p2,dist=this.distance(coords,v),d=curve.numberPoints-1);dist<mindist&&(mindist=dist,t$jscomp$0=d,newCoords=coords);3===curve.bezierDegree?(j++,i+=2):p1=p2}}board=new _coords.default(_constants.default.COORDS_BY_USER,newCoords,board)}else{j=function(t){if(t<curve.minX()||t>curve.maxX())return Infinity;var dx=x-curve.X(t);t=y-curve.Y(t);return dx*dx+t*t};p1=j(t$jscomp$0);newCoords=curve.minX();mindist=curve.maxX();p2=(mindist-newCoords)/50;dist=newCoords;for(i=0;50>i;i++){d=j(dist);if(d<
p1||Infinity===p1||isNaN(p1))t$jscomp$0=dist,p1=d;dist+=p2}t$jscomp$0=_numerics.default.fminbr(j,[Math.max(t$jscomp$0-p2,newCoords),Math.min(t$jscomp$0+p2,mindist)]);t$jscomp$0=t$jscomp$0<newCoords?newCoords:t$jscomp$0;t$jscomp$0=t$jscomp$0>mindist?mindist:t$jscomp$0;board=new _coords.default(_constants.default.COORDS_BY_USER,[curve.X(t$jscomp$0),curve.Y(t$jscomp$0)],board)}return[curve.updateTransform(board),t$jscomp$0]},projectCoordsToPolygon:function(p,pol){var i,len=pol.vertices.length,d_best=
Infinity;for(i=0;i<len-1;i++){var projection=_jxg.default.Math.Geometry.projectCoordsToSegment(p,pol.vertices[i].coords.usrCoords,pol.vertices[i+1].coords.usrCoords);if(0<=projection[1]&&1>=projection[1]){var d=_jxg.default.Math.Geometry.distance(projection[0],p,3);projection=projection[0]}else 0>projection[1]?(d=_jxg.default.Math.Geometry.distance(pol.vertices[i].coords.usrCoords,p,3),projection=pol.vertices[i].coords.usrCoords):(d=_jxg.default.Math.Geometry.distance(pol.vertices[i+1].coords.usrCoords,
p,3),projection=pol.vertices[i+1].coords.usrCoords);if(d<d_best){var bestprojection=projection.slice(0);d_best=d}}return bestprojection},projectPointToTurtle:function(point,turtle,board){var i,np=0,npmin=0,mindist=Number.POSITIVE_INFINITY,len=turtle.objects.length;_type.default.exists(board)||(board=point.board);for(i=0;i<len;i++){var el=turtle.objects[i];if(el.elementClass===_constants.default.OBJECT_CLASS_CURVE){var dist=this.projectPointToCurve(point,el);var newCoords=dist[0];var newPos=dist[1];
dist=this.distance(newCoords.usrCoords,point.coords.usrCoords);if(dist<mindist){var x=newCoords.usrCoords[1];var y=newCoords.usrCoords[2];var t=newPos;mindist=dist;var minEl=el;npmin=np}np+=el.numberPoints}}newCoords=new _coords.default(_constants.default.COORDS_BY_USER,[x,y],board);return[minEl.updateTransform(newCoords),t+npmin]},projectPointToPoint:function(point,dest){return dest.coords},projectPointToBoard:function(point,board){board=board||point.board;var config=[[1,1,0,0,3,0,1],[-1,2,1,0,1,
2,1],[-1,1,2,2,1,2,3],[1,2,3,0,3,2,3]],coords=point.coords||point,bbox=board.getBoundingBox();for(point=0;4>point;point++){var l=config[point];l[0]*coords.usrCoords[l[1]]<l[0]*bbox[l[2]]&&(l=_math.default.crossProduct([1,bbox[l[3]],bbox[l[4]]],[1,bbox[l[5]],bbox[l[6]]]),l[3]=0,l=_math.default.normalize(l),coords=this.projectPointToLine({coords},{stdform:l},board))}return coords},distPointLine:function(point,line){var a=line[1],b=line[2];return Math.abs(a)+Math.abs(b)<_math.default.eps?Number.POSITIVE_INFINITY:
Math.abs(a*point[1]+b*point[2]+line[0])/Math.sqrt(a*a+b*b)},reuleauxPolygon:function(points,nr){var beta,pi2=2*Math.PI,pi2_n=pi2/nr,diag=(nr-1)/2,d=0,makeFct=function(which,trig){return function(t,suspendUpdate){t=(t%pi2+pi2)%pi2;var j=Math.floor(t/pi2_n)%nr;suspendUpdate||(d=points[0].Dist(points[diag]),beta=_math.default.Geometry.rad([points[0].X()+1,points[0].Y()],points[0],points[diag%nr]));if(isNaN(j))return j;t=.5*t+j*pi2_n*.5+beta;return points[j][which]()+d*Math[trig](t)}};return[makeFct("X",
"cos"),makeFct("Y","sin"),0,pi2]},meet3Planes:function(n1,d1,n2,d2,n3,d3){var p=[0,0,0];var n31=_math.default.crossProduct(n3,n1);var n12=_math.default.crossProduct(n1,n2);n2=_math.default.crossProduct(n2,n3);n1=_math.default.innerProduct(n1,n2,3);for(n3=0;3>n3;n3++)p[n3]=(d1*n2[n3]+d2*n31[n3]+d3*n12[n3])/n1;return p},meetPlanePlane:function(v11,v12,v21,v22){var i,v=[0,0,0],w=[0,0,0];for(i=0;3>i;i++)v[i]=_type.default.evaluate(v11[i]),w[i]=_type.default.evaluate(v12[i]);v11=_math.default.crossProduct(v,
w);for(i=0;3>i;i++)v[i]=_type.default.evaluate(v21[i]),w[i]=_type.default.evaluate(v22[i]);v21=_math.default.crossProduct(v,w);return _math.default.crossProduct(v11,v21)},project3DTo3DPlane:function(point,normal,foot){foot=foot||[0,0,0];var le=_math.default.norm(normal);var d1=_math.default.innerProduct(point,normal,3);foot=_math.default.innerProduct(foot,normal,3);return _math.default.axpy(-((d1-foot)/le),normal,point)},getPlaneBounds:function(v1,v2,q,s,e){if(0!==v1[2]+v2[0]){v2=[[v1[0],v2[0]],[v1[1],
v2[1]]];var rhs=[s-q[0],s-q[1]];rhs=_numerics.default.Gauss(v2,rhs);s=rhs[0];v1=rhs[1];rhs=[e-q[0],e-q[1]];rhs=_numerics.default.Gauss(v2,rhs);q=rhs[0];e=rhs[1];return[s,q,v1,e]}return null}});exports.default=_math.default.Geometry}
//# sourceMappingURL=module$node_modules$$mentatcollective$jsxgraph$src$math$geometry.js.map
