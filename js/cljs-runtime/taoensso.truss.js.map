{"version":3,"sources":["taoensso/truss.cljs"],"mappings":";AAMA,AAiDA,AAoCA,AAoDA;;;4CAAA,5CAAMA;AAAN,AAEKC;;AAOL,AAEA,2BAAA,3BAASC,8DAAWC;AAApB,AAAuB,GAAI,+CAAA,/CAACC,6CAAED;AAAYE;;AAAsBF;;;AAChE;;;oCAAA,pCAAMG,gFAEHH;AAFH,AAGS,QAAkBI,2CAAuB,AAACL,yBAAUC","names":["taoensso.truss/get-dynamic-assertion-data","taoensso.truss.impl/*?data*","taoensso.truss/-error-fn","f","cljs.core._EQ_","taoensso.truss.impl/default-error-fn","taoensso.truss/set-error-fn!","taoensso.truss.impl/*error-fn*"],"sourcesContent":["(ns taoensso.truss\n  \"An opinionated assertions API for Clojure/Script.\"\n  {:author \"Peter Taoussanis (@ptaoussanis)\"}\n                                                                             \n         (:require [taoensso.truss.impl :as impl :refer-macros [-invariant]]))\n\n(comment (require '[taoensso.encore :as enc :refer (qb)]))\n\n;;;; Core API\n\n              \n                                                                  \n                                                                             \n                                                                     \n\n                                                                         \n                \n\n                                                                             \n                                                  \n\n                                                                  \n                                              \n\n                                                                   \n                                                               \n\n                             \n                                                        \n                                                                    \n\n               \n                                                                          \n                                                           \n                                                                     \n                                                                                    \n                                                        \n                                                                        \n\n               \n                                                                          \n                                                                 \n                                                        \n                                                              \n\n                \n                                                                           \n                                                                          \n                                        \n\n                                                                            \n                                                                            \n                                                        \n                                                                         \n\n(comment\n  (let [x 5]      (have    integer? x))\n  (let [x 5]      (have    string?  x))\n  (let [x 5]      (have :! string?  x))\n  (let [x 5 y  6] (have odd?  x x x y x))\n  (let [x 0 y :a] (have zero? x x x y x))\n  (have string? (do (println \"eval1\") \"foo\")\n                (do (println \"eval2\") \"bar\"))\n  (have number? (do (println \"eval1\") 5)\n                (do (println \"eval2\") \"bar\")\n                (do (println \"eval3\") 10))\n  (have pos? \"hello\")\n  (have pos? (/ 1 0))\n  (have nil? false)\n  (have nil)\n  (have false)\n  (have string? :in [\"a\" \"b\"])\n  (have string? :in (if true  [\"a\" \"b\"] [1 2]))\n  (have string? :in (if false [\"a\" \"b\"] [1 2]))\n  (have string? :in (mapv str (range 10)))\n  (have string? :in [\"a\" 1])\n  (have string? :in [\"a\" \"b\"] [\"a\" \"b\"])\n  (have string? :in [\"a\" \"b\"] [\"a\" \"b\" 1])\n  ((fn foo [x] {:pre [(have? integer? x)]} (* x x)) \"foo\")\n  (macroexpand '(have a))\n  (have? [:or nil? string?] \"hello\")\n  (macroexpand '(have? [:or nil? string?] \"hello\"))\n  (have? [:set>= #{:a :b}]    [:a :b :c])\n  (have? [:set<= [:a :b :c]] #{:a :b})\n  (have? [:n= 3] [:a :b :c :d])\n  (qb 10000\n    (with-error-fn nil                  (have? string? 5))\n    (with-error-fn (fn [_] :truss/error) (have? string? 5)))\n\n  (have string? (range 1000)))\n\n(comment\n  ;; HotSpot is great with these:\n  (qb 10000\n    (string? \"a\")\n    (have?   \"a\")\n    (have            string?  \"a\" \"b\" \"c\")\n    (have? [:or nil? string?] \"a\" \"b\" \"c\")\n    (have? [:or nil? string?] \"a\" \"b\" \"c\" :data \"foo\"))\n  ;; [     5.59 26.48 45.82     ] ; 1st gen (macro form)\n  ;; [     3.31 13.48 36.22     ] ; 2nd gen (fn form)\n  ;; [0.82 1.75  7.57 27.05     ] ; 3rd gen (lean macro form)\n  ;; [0.4  0.47  1.3  1.77  1.53] ; 4th gen (macro preds)\n\n  (qb 10000\n    (have  string? :in [\"foo\" \"bar\" \"baz\"])\n    (have? string? :in [\"foo\" \"bar\" \"baz\"]))\n\n  (macroexpand '(have string? 5))\n  (macroexpand '(have string? 5 :data \"foo\"))\n  (macroexpand '(have string? 5 :data (enc/get-env)))\n  (let [x :x]   (have string? 5 :data (enc/get-env)))\n\n  (have string? 5)\n  (have string? 5 :data {:a \"a\"})\n  (have string? 5 :data {:a (/ 5 0)})\n\n  ((fn [x]\n     (let [a \"a\" b \"b\"]\n       (have string? x :data {:env (enc/get-env)}))) 5)\n\n  (do\n    (set! *assert* false)\n    (have? integer? 4.0))\n\n  ;; Combinations: truthy?, single?, in? (8 combinations)\n  (do (def i1 1) (def v1 [1 2 3]) (def s1 #{1 2 3}))\n  (macroexpand '(have? integer?      1))\n  (macroexpand '(have? integer?      1 2 i1))\n  (macroexpand '(have? integer? :in [1 2 i1]))\n  (macroexpand '(have? integer? :in [1 2] [3 4 i1] v1))\n  (macroexpand '(have  integer?      1))\n  (macroexpand '(have  integer?      1 2 i1))\n  (macroexpand '(have  integer? :in [1 2 i1]))\n  (macroexpand '(have  integer? :in [1 2] [3 4 i1] v1))\n\n  (have? integer? :in s1)\n  (have  integer? :in s1)\n  (have  integer? :in #{1 2 3})\n  (have  integer? :in #{1 2 3} [4 5 6] #{7 8 9} s1))\n\n;;;; Utils\n\n(defn get-dynamic-assertion-data\n  \"Returns current value of dynamic assertion data.\"\n  [] impl/*?data*)\n\n                                     \n                                                                  \n                                                                     \n                                                       \n\n(comment (with-dynamic-assertion-data \"foo\" (have string? 5 :data \"bar\")))\n\n(defn-   -error-fn [f] (if (= f :default) impl/default-error-fn f))\n(defn set-error-fn!\n  \"Sets the root (fn [data-map-delay]) called on invariant violations.\"\n  [f]\n         (set!             impl/*error-fn*        (-error-fn f))\n                                                                  )\n\n                                  \n                                                     \n\n;;;;;;;;;;;; This file autogenerated from src/taoensso/truss.cljx\n"]}