shadow$provide.module$node_modules$three$src$textures$Source=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function serializeImage(image){if("undefined"!==typeof HTMLImageElement&&image instanceof HTMLImageElement||
"undefined"!==typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&image instanceof ImageBitmap)return _ImageUtils.ImageUtils.getDataURL(image);if(image.data)return{data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name};console.warn("THREE.Texture: Unable to serialize Texture.");return{}}Object.defineProperty(exports,"__esModule",{value:!0});exports.Source=void 0;var _ImageUtils=require("module$node_modules$three$src$extras$ImageUtils"),
MathUtils=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,
key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$three$src$math$MathUtils"));class Source{constructor(data=null){this.isSource=!0;this.uuid=MathUtils.generateUUID();this.data=data;this.version=0}set needsUpdate(value){!0===value&&this.version++}toJSON(meta){const isRootObject=void 0===meta||"string"===typeof meta;if(!isRootObject&&void 0!==meta.images[this.uuid])return meta.images[this.uuid];
const output={uuid:this.uuid,url:""},data=this.data;if(null!==data){let url;if(Array.isArray(data)){url=[];for(let i=0,l=data.length;i<l;i++)data[i].isDataTexture?url.push(serializeImage(data[i].image)):url.push(serializeImage(data[i]))}else url=serializeImage(data);output.url=url}isRootObject||(meta.images[this.uuid]=output);return output}}exports.Source=Source}
//# sourceMappingURL=module$node_modules$three$src$textures$Source.js.map
