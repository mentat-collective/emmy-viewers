shadow$provide.module$node_modules$mathbox$build$esm$shaders$glsl$line_position=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="// Units and calibration\nuniform float worldUnit;\nuniform float lineWidth;\nuniform float lineDepth;\nuniform float focusDepth;\n\n// General data index\nuniform vec4 geometryClip;\nattribute vec4 position4;\n\n// (Top/bottom -1,1)\nattribute float line;\n\n// 0...1 for round or bevel joins\n#ifdef LINE_JOIN_DETAIL\nattribute float joint;\n#else\nconst float joint \x3d 0.0;\n#endif\n\n// Knock out excessively long line segments (e.g. for asymtpotes)\n#ifdef LINE_PROXIMITY\nuniform float lineProximity;\nvarying float vClipProximity;\n#endif\n\n// Ghetto line stroking (local only, not global)\n#ifdef LINE_STROKE\nvarying float vClipStrokeWidth;\nvarying float vClipStrokeIndex;\nvarying vec3  vClipStrokeEven;\nvarying vec3  vClipStrokeOdd;\nvarying vec3  vClipStrokePosition;\n#endif\n\n// External\nvec3 getPosition(vec4 xyzw, float canonical);\n\n// Clip line ends for arrows / decoration\n#ifdef LINE_CLIP\nuniform float clipRange;\nuniform vec2  clipStyle;\nuniform float clipSpace;\n\nattribute vec2 strip;\n\nvarying vec2 vClipEnds;\n\nvoid clipEnds(vec4 xyzw, vec3 center, vec3 pos) {\n\n  // Sample start of line strip\n  vec4 xyzwS \x3d vec4(0.0, xyzw.yzw);\n  vec3 start \x3d getPosition(xyzwS, 0.0);\n\n  // Sample middle of line strip\n  vec4 xyzwM \x3d vec4(geometryClip.x / 2.0, xyzw.yzw);\n  vec3 middle \x3d getPosition(xyzwM, 0.0);\n\n#ifdef LINE_CLOSED\n  vec3 end \x3d start;\n#else\n  // Sample other end of line strip\n  vec4 xyzwE \x3d vec4(geometryClip.x, xyzw.yzw);\n  vec3 end   \x3d getPosition(xyzwE, 0.0);\n#endif\n\n  // Measure length\n  float l \x3d max(length(end - middle), length(middle - start)) * clipSpace * 2.0;\n\n  // Arrow length (\x3d2.5x radius)\n  float arrowSize \x3d 1.25 * clipRange * lineWidth * worldUnit;\n\n#ifdef LINE_CLOSED\n  // Clip around start/end\n  end \x3d start;\n#endif\n\n  vClipEnds \x3d vec2(1.0);\n\n  if (clipStyle.y \x3e 0.0) {\n    // Depth blend end\n    float depth \x3d focusDepth;\n    if (lineDepth \x3c 1.0) {\n      float z \x3d max(0.00001, -end.z);\n      depth \x3d mix(z, focusDepth, lineDepth);\n    }\n\n    // Absolute arrow length\n    float size \x3d arrowSize * depth;\n\n    // Adjust clip range\n    // Approach linear scaling with cubic ease the smaller we get\n    float mini \x3d clamp(1.0 - l / size * .333, 0.0, 1.0);\n    float scale \x3d 1.0 - mini * mini * mini;\n    float invrange \x3d 1.0 / (size * scale);\n\n    // Clip end\n    vec3 diff \x3d end - center;\n    if(diff \x3d\x3d vec3(0.0))\n      vClipEnds.x \x3d -1.0;\n    else {\n      diff \x3d normalize(end - center);\n      float d \x3d dot(end - pos, diff);\n      vClipEnds.x \x3d d * invrange - 1.0;\n    }\n  }\n\n  if (clipStyle.x \x3e 0.0) {\n    // Depth blend start\n    float depth \x3d focusDepth;\n    if (lineDepth \x3c 1.0) {\n      float z \x3d max(0.00001, -start.z);\n      depth \x3d mix(z, focusDepth, lineDepth);\n    }\n\n    // Absolute arrow length\n    float size \x3d arrowSize * depth;\n\n    // Adjust clip range\n    // Approach linear scaling with cubic ease the smaller we get\n    float mini \x3d clamp(1.0 - l / size * .333, 0.0, 1.0);\n    float scale \x3d 1.0 - mini * mini * mini;\n    float invrange \x3d 1.0 / (size * scale);\n\n    // Clip start\n    vec3 diff \x3d center - start;\n    if(diff \x3d\x3d vec3(0.0))\n      vClipEnds.y \x3d -1.0;\n    else {\n      diff \x3d normalize(center - start);\n      float d \x3d dot(pos - start, diff);\n      vClipEnds.y \x3d d * invrange - 1.0;\n    }\n  }\n}\n#endif\n\n// Adjust left/center/right to be inside near/far z range\nconst float epsilon \x3d 1e-5;\nvoid fixCenter(inout vec3 left, inout vec3 center, inout vec3 right) {\n  if (center.z \x3e\x3d 0.0) {\n    if (left.z \x3c 0.0) {\n      float d \x3d (center.z + epsilon) / (center.z - left.z);\n      center \x3d mix(center, left, d);\n    }\n    else if (right.z \x3c 0.0) {\n      float d \x3d (center.z + epsilon) / (center.z - right.z);\n      center \x3d mix(center, right, d);\n    }\n  }\n\n  if (left.z \x3e\x3d 0.0) {\n    if (center.z \x3c 0.0) {\n      float d \x3d (left.z + epsilon) / (left.z - center.z);\n      left \x3d mix(left, center, d);\n    }\n  }\n\n  if (right.z \x3e\x3d 0.0) {\n    if (center.z \x3c 0.0) {\n      float d \x3d (right.z + epsilon) / (right.z - center.z);\n      right \x3d mix(right, center, d);\n    }\n  }\n}\n\nvec4 wrapAround(vec4 xyzw) {\n#ifdef LINE_CLOSED\n  float gx \x3d geometryClip.x;\n  if (xyzw.x \x3c 0.0) xyzw.x +\x3d gx;\n  if (xyzw.x \x3e\x3d gx) xyzw.x -\x3d gx;\n#endif\n  return xyzw;\n}\n\n// Sample the source data in an edge-aware manner\nvoid getLineGeometry(vec4 xyzw, float edge, out vec3 left, out vec3 center, out vec3 right) {\n  vec4 delta \x3d vec4(1.0, 0.0, 0.0, 0.0);\n\n  center \x3d getPosition(xyzw, 1.0);\n  left   \x3d (edge \x3e -0.5) ? getPosition(wrapAround(xyzw - delta), 0.0) : center;\n  right  \x3d (edge \x3c 0.5)  ? getPosition(wrapAround(xyzw + delta), 0.0) : center;\n}\n\n// Calculate the position for a vertex along the line, including joins\nvec3 getLineJoin(float edge, bool odd, vec3 left, vec3 center, vec3 right, float width, float offset, float joint) {\n  vec2 join \x3d vec2(1.0, 0.0);\n\n  fixCenter(left, center, right);\n\n  vec4 a \x3d vec4(left.xy, right.xy);\n  vec4 b \x3d a / vec4(left.zz, right.zz);\n\n  vec2 l \x3d b.xy;\n  vec2 r \x3d b.zw;\n  vec2 c \x3d center.xy / center.z;\n\n  vec4 d \x3d vec4(l, c) - vec4(c, r);\n  float l1 \x3d dot(d.xy, d.xy);\n  float l2 \x3d dot(d.zw, d.zw);\n\n  if (l1 + l2 \x3e 0.0) {\n\n    if (edge \x3e 0.5 || l2 \x3d\x3d 0.0) {\n      vec2 nl \x3d normalize(d.xy);\n      vec2 tl \x3d vec2(nl.y, -nl.x);\n\n#ifdef LINE_PROXIMITY\n      vClipProximity \x3d 1.0;\n#endif\n\n#ifdef LINE_STROKE\n      vClipStrokeEven \x3d vClipStrokeOdd \x3d normalize(left - center);\n#endif\n      join \x3d tl;\n    }\n    else if (edge \x3c -0.5 || l1 \x3d\x3d 0.0) {\n      vec2 nr \x3d normalize(d.zw);\n      vec2 tr \x3d vec2(nr.y, -nr.x);\n\n#ifdef LINE_PROXIMITY\n      vClipProximity \x3d 1.0;\n#endif\n\n#ifdef LINE_STROKE\n      vClipStrokeEven \x3d vClipStrokeOdd \x3d normalize(center - right);\n#endif\n      join \x3d tr;\n    }\n    else {\n      // Limit join stretch for tiny segments\n      float lmin2 \x3d min(l1, l2) / (width * width);\n\n      // Hide line segment if ratio of leg lengths exceeds promixity threshold\n#ifdef LINE_PROXIMITY\n      float lr     \x3d l1 / l2;\n      float rl     \x3d l2 / l1;\n      float ratio  \x3d max(lr, rl);\n      float thresh \x3d lineProximity + 1.0;\n      vClipProximity \x3d (ratio \x3e thresh * thresh) ? 1.0 : 0.0;\n#endif\n\n      // Calculate normals/tangents\n      vec2 nl \x3d normalize(d.xy);\n      vec2 nr \x3d normalize(d.zw);\n\n      // Calculate tangents\n      vec2 tl \x3d vec2(nl.y, -nl.x);\n      vec2 tr \x3d vec2(nr.y, -nr.x);\n\n#ifdef LINE_PROXIMITY\n      // Mix tangents according to leg lengths\n      vec2 tc \x3d normalize(mix(tl, tr, l1/(l1+l2)));\n#else\n      // Average tangent\n      vec2 tc \x3d normalize(tl + tr);\n#endif\n\n      // Miter join\n      float cosA   \x3d dot(nl, tc);\n      float sinA   \x3d max(0.1, abs(dot(tl, tc)));\n      float factor \x3d cosA / sinA;\n      float scale  \x3d sqrt(1.0 + min(lmin2, factor * factor));\n\n      // Stroke normals\n#ifdef LINE_STROKE\n      vec3 stroke1 \x3d normalize(left - center);\n      vec3 stroke2 \x3d normalize(center - right);\n\n      if (odd) {\n        vClipStrokeEven \x3d stroke1;\n        vClipStrokeOdd  \x3d stroke2;\n      }\n      else {\n        vClipStrokeEven \x3d stroke2;\n        vClipStrokeOdd  \x3d stroke1;\n      }\n#endif\n\n#ifdef LINE_JOIN_MITER\n      // Apply straight up miter\n      join \x3d tc * scale;\n#endif\n\n#ifdef LINE_JOIN_ROUND\n      // Slerp bevel join into circular arc\n      float dotProduct \x3d dot(nl, nr);\n      float angle \x3d acos(dotProduct);\n      float sinT  \x3d sin(angle);\n      join \x3d (sin((1.0 - joint) * angle) * tl + sin(joint * angle) * tr) / sinT;\n#endif\n\n#ifdef LINE_JOIN_BEVEL\n      // Direct bevel join between two flat ends\n      float dotProduct \x3d dot(nl, nr);\n      join \x3d mix(tl, tr, joint);\n#endif\n\n#ifdef LINE_JOIN_DETAIL\n      // Check if on inside or outside of joint\n      float crossProduct \x3d nl.x * nr.y - nl.y * nr.x;\n      if (offset * crossProduct \x3c 0.0) {\n        // For near-180-degree bends, correct back to a miter to avoid discontinuities\n        float ratio \x3d clamp(-dotProduct * 2.0 - 1.0, 0.0, 1.0);\n        // Otherwise collapse the inside vertices into one.\n        join \x3d mix(tc * scale, join, ratio * ratio * ratio);\n      }\n#endif\n\n    }\n    return vec3(join, 0.0);\n  }\n  else {\n    return vec3(0.0);\n  }\n\n}\n\n// Calculate final line position\nvec3 getLinePosition() {\n  vec3 left, center, right, join;\n\n  // Up/down along segment\n  float offset \x3d line;\n\n  // Clip data\n  vec4 p \x3d min(geometryClip, position4);\n\n  // Left/center/right\n  float edge \x3d 0.0;\n#ifdef LINE_CLOSED\n  if (p.x \x3d\x3d geometryClip.x) p.x \x3d 0.0;\n#else\n  if (p.x \x3d\x3d geometryClip.x) edge \x3d 1.0;\n  if (p.x \x3d\x3d 0.0) edge \x3d -1.0;\n#endif\n\n  // Get position + adjacent neighbours\n  getLineGeometry(p, edge, left, center, right);\n\n#ifdef LINE_STROKE\n  // Set parameters for line stroke fragment shader\n  vClipStrokePosition \x3d center;\n  vClipStrokeIndex \x3d p.x;\n  bool odd \x3d mod(p.x, 2.0) \x3e\x3d 1.0;\n#else\n  bool odd \x3d true;\n#endif\n\n  // Divide line width up/down\n  float width \x3d lineWidth * 0.5;\n\n  float depth \x3d focusDepth;\n  if (lineDepth \x3c 1.0) {\n    // Depth blending\n    float z \x3d max(0.00001, -center.z);\n    depth \x3d mix(z, focusDepth, lineDepth);\n  }\n  width *\x3d depth;\n\n  // Convert to world units\n  width *\x3d worldUnit;\n\n  // Calculate line join\n#ifdef LINE_CLOSED\n  join \x3d getLineJoin(0.0, odd, left, center, right, width, offset, joint);\n#else\n  join \x3d getLineJoin(edge, odd, left, center, right, width, offset, joint);\n#endif\n  vec3 pos \x3d center + join * offset * width;\n\n#ifdef LINE_STROKE\n  vClipStrokeWidth \x3d width;\n#endif\n\n#ifdef LINE_CLIP\n  clipEnds(p, center, pos);\n#endif\n\n  return pos;\n}\n"}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$shaders$glsl$line_position.js.map
