{"version":3,"sources":["sicmutils/numerical/ode.cljc"],"mappings":"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","names":["sicmutils.numerical.ode/near?","sicmutils.value/within","p__103185","map__103186","cljs.core/--destructure-map","cljs.core.get","sicmutils.numerical.ode/integration-opts","state-derivative","derivative-args","initial-state","compile?","epsilon","evaluation-time","sicmutils.util.stopwatch.stopwatch","evaluation-count","cljs.core.atom","dimension","cljs.core/count","cljs.core/flatten","param-array","derivative-fn","sicmutils.expression.compile.compile_js","or__4253__auto__","cljs.core/deref","cljs.core.into","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","p1__103182#","d:dt","cljs.core.apply","array->state","sicmutils.structure.unflatten","cljs.core.comp","state->array","state","cljs.core.map","sicmutils.util/double","cljs.core.into_array","equations","out","js/Array","_","y","cljs.core.swap_BANG_","cljs.core/inc","integrator","solver","js/module$node_modules$odex$src$odex.Solver","sicmutils.numerical.ode/make-integrator","total-time","latest","p__103202","map__103203","step-size","t","sicmutils$numerical$ode$make_integrator_$_call","observe","opts","map__103204","p1__103200#","stopwatch","counter","initial-state-array","observe-fn","cljs.core/reset!","G__103206","G__103207","output","ret","and__4251__auto__","cljs.core/not","sicmutils.util.stopwatch/repr","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.numerical.ode/state-advancer","seq103216","G__103218","cljs.core/first","cljs.core/next","self__4851__auto__","state-derivative-args","I","sicmutils$numerical$ode$call","sicmutils.numerical.ode/evolve","seq103225","G__103226","sicmutils.numerical.ode/integrate-state-derivative","t1","dt","collector","cljs.core/conj"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.ode\n  \"ODE solvers for working with initial value problems.\"\n  (:require [sicmutils.expression.compile :as c]\n            #?(:cljs [sicmutils.util :as u])\n            #?(:cljs [sicmutils.value :as v])\n            [sicmutils.structure :as struct]\n            [sicmutils.util.stopwatch :as us]\n            [taoensso.timbre :as log]\n            #?(:cljs [\"odex\" :as o]))\n  #?(:clj\n     (:import (org.apache.commons.math3.ode.nonstiff GraggBulirschStoerIntegrator)\n              (org.apache.commons.math3.ode FirstOrderDifferentialEquations)\n              (org.apache.commons.math3.ode.sampling StepHandler))))\n\n#?(:cljs\n   (def ^:private near? (v/within 1e-8)))\n\n#?(:clj\n   (defn- round-up\n     \"Returns `n` rounded up to the nearest multiple of `step-size`. the returned\n  value will always equal `0`, mod `step-size`\"\n     [n step-size]\n     (let [offset (mod n step-size)]\n       (if (pos? offset)\n         (-> (- n offset)\n             (+ step-size))\n         n))))\n\n#?(:clj\n   (defn step-handler\n     \"Generates a StepHandler instance that can be attached to an integrator.\n\n  When used as an observation callback, the `StepHandler` is not invoked at\n  every grid point; rather, it is invoked once in a while over a range of time\n  within which the integrated function may be accurately evaluated. The handler\n  we install does this, invoking the callback for each requested grid point\n  within the valid range, ensuring that we also invoke the callback for the\n  final point.\"\n     [observe step-size initial-state]\n     (let [array->state #(struct/unflatten % initial-state)]\n       (reify StepHandler\n         (init [_ _ _ _])\n         (handleStep [_ interpolator final-step?]\n           (let [it0         (.getPreviousTime interpolator)\n                 it1         (.getCurrentTime interpolator)\n                 t0          (round-up it0 step-size)\n                 final-state (when final-step?\n                               (array->state\n                                (.getInterpolatedState interpolator)))]\n             (doseq [t (range t0 it1 step-size)]\n               (.setInterpolatedTime interpolator t)\n               (observe t (array->state\n                           (.getInterpolatedState interpolator))))\n             ;; `range` has an exclusive upper bound, so the final point will\n             ;; never be observed in the `doseq`. Handle it here.\n             (when final-step?\n               (observe it1 final-state))))))))\n\n#?(:clj\n   (defn attach-handler\n     \"We implement the observation callback by adding a StepHandler to the\n  integration. The StepHandler is not invoked at every grid point; rather, it is\n  invoked once in a while over a range of time within which the integrated\n  function may be accurately evaluated. The handler we install does this,\n  invoking the callback for each requested grid point within the valid range,\n  ensuring that we also invoke the callback for the final point.\"\n     [^GraggBulirschStoerIntegrator integrator observe step-size initial-state]\n     (let [handler (step-handler observe step-size initial-state)]\n       (.addStepHandler integrator handler))))\n\n;; TODO okay, what have I learned...\n;;\n;; - the stopwatch is killing me, delete that shit!!\n;; - I want some way to NOT trigger a re-render... but to get some state shoved into the system.\n;; - JS compilation is really janky now and needs to get better, tighten up that CODE!\n\n(defn integration-opts\n  \"Returns a map with the following kv pairs:\n\n  - `:integrator` an instance of `GraggBulirschStoerIntegrator`\n  - `:equations` instance of `FirstOrderDifferentialEquations`\n  - `:dimension` the total number of entries in the flattened initial state tuple\n  - `:stopwatch` [[IStopwatch]] instance that records total evaluation time inside\n    the derivative function\n  - `:counter` an atom containing a `Long` that increments every time derivative fn\n    is called.\"\n  [state-derivative derivative-args initial-state\n   {:keys [compile? epsilon] :or {epsilon 1e-8 compile? true}}]\n  (let [evaluation-time  (us/stopwatch :started? false)\n        evaluation-count (atom 0)\n        dimension        (count (flatten initial-state))\n        param-array      #?(:cljs derivative-args\n                            :clj (double-array derivative-args))\n        derivative-fn    (if compile?\n                           #?(:cljs\n                              (c/compile-js\n                               state-derivative\n                               initial-state {:parameters\n                                              (or\n                                               (into [] @derivative-args)\n                                               [])})\n                              :clj (c/compile-state-fn*\n                                    state-derivative initial-state {:parameters (or derivative-args [])}))\n                           (do (log/warn \"Not compiling function for ODE analysis\")\n                               (let [d:dt (apply state-derivative derivative-args)\n                                     array->state #(struct/unflatten % initial-state)]\n                                 (comp d:dt array->state))))\n        state->array     #?(:clj\n                            (comp double-array flatten)\n\n                            :cljs\n                            (fn [state]\n                              (->> (flatten state)\n                                   (map u/double)\n                                   (into-array))))\n        equations        #?(:clj\n                            (if compile?\n                              (reify FirstOrderDifferentialEquations\n                                (computeDerivatives [_ _ y out]\n                                  (us/start evaluation-time)\n                                  (swap! evaluation-count inc)\n                                  (derivative-fn y param-array out)\n                                  (us/stop evaluation-time))\n                                (getDimension [_] dimension))\n                              (reify FirstOrderDifferentialEquations\n                                (computeDerivatives [_ _ y out]\n                                  (us/start evaluation-time)\n                                  (swap! evaluation-count inc)\n                                  (let [y' (state->array\n                                            (derivative-fn y))]\n                                    (System/arraycopy y' 0 out 0 dimension))\n                                  (us/stop evaluation-time))\n                                (getDimension [_] dimension)))\n\n                            :cljs\n                            (if compile?\n                              (let [out (make-array dimension)]\n                                (fn [_ y]\n\n                                  (derivative-fn y @param-array out)\n                                  out))\n\n                              ;; TODO get this branch going as well\n                              (let [out (make-array dimension)]\n                                (fn [_ y]\n                                  (us/start evaluation-time)\n                                  (swap! evaluation-count inc)\n                                  (derivative-fn y @param-array out)\n                                  (us/stop evaluation-time)\n                                  out))))\n        integrator #?(:clj\n                      (GraggBulirschStoerIntegrator. 0. 1.\n                                                     (double epsilon)\n                                                     (double epsilon))\n\n                      :cljs\n                      (let [solver (o/Solver. dimension)]\n                        (set! (.-absoluteTolerance solver) epsilon)\n                        (set! (.-relativeTolerance solver) epsilon)\n                        solver))]\n    {:integrator integrator\n     :equations equations\n     :dimension dimension\n     :stopwatch evaluation-time\n     :counter evaluation-count}))\n\n(defn make-integrator\n  \"make-integrator takes a state derivative function (which in this\n  system is assumed to be a map from a structure to a structure of the\n  same shape, as differentiating a function does not change its\n  shape), and returns an integrator, which is a function of several\n  arguments:\n\n  - the initial state\n  - an intermediate-state observation function\n  - the step size desired\n  - the final time to seek, and\n  - an error tolerance.\n\n\n  If the `observe` function is not nil, it will be invoked with the time as\n  first argument and integrated state as the second, at each intermediate step.\"\n  [state-derivative derivative-args]\n  #?(:cljs\n     (let [total-time (us/stopwatch :started? false)\n           latest     (atom 0)]\n       (fn call\n         ([initial-state step-size t]\n          (call initial-state step-size t {}))\n         ([initial-state step-size t {:keys [observe] :as opts}]\n          (us/start total-time)\n          (let [{:keys [integrator equations stopwatch counter]}\n                (integration-opts state-derivative derivative-args initial-state opts)\n                initial-state-array (into-array\n                                     (flatten initial-state))\n                array->state #(struct/unflatten % initial-state)\n                observe-fn    (when observe\n                                (set! (.-denseOutput integrator) true)\n                                (.grid integrator step-size\n                                       (fn [t y]\n                                         (reset! latest t)\n                                         (observe t (array->state y)))))\n                output (.solve integrator equations 0 initial-state-array t observe-fn)\n                ret    (array->state (.-y output))]\n            (when (and observe (not (near? t @latest)))\n              (observe t ret))\n            (us/stop total-time)\n            (log/info \"#\" @counter \"total\" (us/repr total-time) \"f\" (us/repr stopwatch))\n            (us/reset total-time)\n            (reset! latest 0)\n            ret))))\n\n     :clj\n     (let [total-time (us/stopwatch :started? false)]\n       (fn call\n         ([initial-state step-size t]\n          (call initial-state step-size t {}))\n         ([initial-state step-size t {:keys [observe] :as opts}]\n          (us/start total-time)\n          (let [{:keys [integrator equations dimension stopwatch counter]}\n                (integration-opts state-derivative derivative-args initial-state opts)\n                initial-state-array (double-array\n                                     (flatten initial-state))\n                array->state #(struct/unflatten % initial-state)\n                output-buffer (double-array dimension)]\n            (when observe\n              (attach-handler integrator observe step-size initial-state))\n            (.integrate ^GraggBulirschStoerIntegrator\n                        integrator equations 0\n                        initial-state-array t output-buffer)\n            (us/stop total-time)\n            (log/info \"#\" @counter \"total\" (us/repr total-time) \"f\" (us/repr stopwatch))\n            (us/reset total-time)\n            (array->state output-buffer)))))))\n\n(defn state-advancer\n  \"state-advancer takes a state derivative function constructor followed by the\n  arguments to construct it with. The state derivative function is constructed\n  and an integrator is produced which takes:\n\n  - initial state\n  - target time\n\n  as arguments. Optionally, supply an options map with these optional fields:\n\n  `:compile?`: If true, the ODE solver will compile your state function.\n\n  `:epsilon`: The maximum error tolerance allowed by the ODE solver, both\n  relative and absolute.\n\n  Returns the final state.\n\n  The state derivative is expected to map a structure to a structure of the same\n  shape, and is required to have the time parameter as the first element.\"\n  [state-derivative & state-derivative-args]\n  (let [I (make-integrator state-derivative (or state-derivative-args []))]\n    (fn call\n      ([initial-state t]\n       (call initial-state t {}))\n      ([initial-state t opts]\n       (I initial-state 0 t opts)))))\n\n(defn evolve\n  \"evolve takes a state derivative function constructor and its arguments, and\n  returns an integrator via make-integrator.\n\n  In particular, the returned function accepts a callback function which will be\n  invoked at intermediate grid points of the integration.\"\n  [state-derivative & state-derivative-args]\n  (make-integrator state-derivative state-derivative-args))\n\n(defn integrate-state-derivative\n  \"A wrapper for evolve, which is more convenient when you just\n  want a vector of (time, state) pairs over the integration interval\n  instead of having to deal with a callback. Integrates the supplied\n  state derivative (and its argument package) from [0 to t1] in steps\n  of size dt\"\n  [state-derivative state-derivative-args initial-state t1 dt]\n  (let [I (make-integrator state-derivative state-derivative-args)\n        out (atom [])\n        collector (fn [_ state]\n                    (swap! out conj state))]\n    (I initial-state dt t1 {:compile? true\n                            :epsilon 1e-6\n                            :observe collector})\n    @out))\n"]}