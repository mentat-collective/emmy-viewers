shadow$provide.module$node_modules$three$build$three=function(global$jscomp$0,require,module,exports$jscomp$0){(function(global,factory){"object"===typeof exports$jscomp$0&&"undefined"!==typeof module?factory(exports$jscomp$0):"function"===typeof define&&define.amd?define(["exports"],factory):(global="undefined"!==typeof globalThis?globalThis:global||self,factory(global.THREE={}))})(this,function(exports){function generateUUID(){const d0=4294967295*Math.random()|0,d1=4294967295*Math.random()|0,d2=
4294967295*Math.random()|0,d3=4294967295*Math.random()|0;return(_lut[d0&255]+_lut[d0>>8&255]+_lut[d0>>16&255]+_lut[d0>>24&255]+"-"+_lut[d1&255]+_lut[d1>>8&255]+"-"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+"-"+_lut[d2&63|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[d3&255]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255]).toLowerCase()}function clamp(value,min,max){return Math.max(min,Math.min(max,value))}function euclideanModulo(n,m){return(n%m+m)%m}function lerp(x,y,t){return(1-t)*
x+t*y}function isPowerOfTwo(value){return 0===(value&value-1)&&0!==value}function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2))}function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2))}function denormalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint16Array:return value/65535;case Uint8Array:return value/255;case Int16Array:return Math.max(value/32767,-1);case Int8Array:return Math.max(value/127,-1);default:throw Error("Invalid component type.");
}}function normalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint16Array:return Math.round(65535*value);case Uint8Array:return Math.round(255*value);case Int16Array:return Math.round(32767*value);case Int8Array:return Math.round(127*value);default:throw Error("Invalid component type.");}}function arrayNeedsUint32(array){for(let i=array.length-1;0<=i;--i)if(65535<=array[i])return!0;return!1}function createElementNS(name){return document.createElementNS("http://www.w3.org/1999/xhtml",
name)}function SRGBToLinear(c){return.04045>c?.0773993808*c:Math.pow(.9478672986*c+.0521327014,2.4)}function LinearToSRGB(c){return.0031308>c?12.92*c:1.055*Math.pow(c,.41666)-.055}function hue2rgb(p,q,t){0>t&&(t+=1);1<t&&--t;return t<1/6?p+6*(q-p)*t:.5>t?q:t<2/3?p+6*(q-p)*(2/3-t):p}function toComponents(source,target){target.r=source.r;target.g=source.g;target.b=source.b;return target}function serializeImage(image){if("undefined"!==typeof HTMLImageElement&&image instanceof HTMLImageElement||"undefined"!==
typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&image instanceof ImageBitmap)return ImageUtils.getDataURL(image);if(image.data)return{data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name};console.warn("THREE.Texture: Unable to serialize Texture.");return{}}function satForAxes(axes,v0,v1,v2,extents){for(let i=0,j=axes.length-3;i<=j;i+=3){_testAxis.fromArray(axes,i);const r=extents.x*Math.abs(_testAxis.x)+
extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z),p0=v0.dot(_testAxis),p1=v1.dot(_testAxis),p2=v2.dot(_testAxis);if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r)return!1}return!0}function checkBufferGeometryIntersection(object,material,raycaster,ray,position,morphPosition,morphTargetsRelative,uv,uv2,a,b,c){_vA$1.fromBufferAttribute(position,a);_vB$1.fromBufferAttribute(position,b);_vC$1.fromBufferAttribute(position,c);position=object.morphTargetInfluences;if(morphPosition&&position){_morphA.set(0,
0,0);_morphB.set(0,0,0);_morphC.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){var influence=position[i];const morphAttribute=morphPosition[i];0!==influence&&(_tempA.fromBufferAttribute(morphAttribute,a),_tempB.fromBufferAttribute(morphAttribute,b),_tempC.fromBufferAttribute(morphAttribute,c),morphTargetsRelative?(_morphA.addScaledVector(_tempA,influence),_morphB.addScaledVector(_tempB,influence),_morphC.addScaledVector(_tempC,influence)):(_morphA.addScaledVector(_tempA.sub(_vA$1),influence),
_morphB.addScaledVector(_tempB.sub(_vB$1),influence),_morphC.addScaledVector(_tempC.sub(_vC$1),influence)))}_vA$1.add(_morphA);_vB$1.add(_morphB);_vC$1.add(_morphC)}object.isSkinnedMesh&&(object.boneTransform(a,_vA$1),object.boneTransform(b,_vB$1),object.boneTransform(c,_vC$1));morphPosition=_vA$1;morphTargetsRelative=_vB$1;position=_vC$1;influence=_intersectionPoint;null===(1===material.side?ray.intersectTriangle(position,morphTargetsRelative,morphPosition,!0,influence):ray.intersectTriangle(morphPosition,
morphTargetsRelative,position,2!==material.side,influence))?object=null:(_intersectionPointWorld.copy(influence),_intersectionPointWorld.applyMatrix4(object.matrixWorld),material=raycaster.ray.origin.distanceTo(_intersectionPointWorld),object=material<raycaster.near||material>raycaster.far?null:{distance:material,point:_intersectionPointWorld.clone(),object});object&&(uv&&(_uvA$1.fromBufferAttribute(uv,a),_uvB$1.fromBufferAttribute(uv,b),_uvC$1.fromBufferAttribute(uv,c),object.uv=Triangle.getUV(_intersectionPoint,
_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),uv2&&(_uvA$1.fromBufferAttribute(uv2,a),_uvB$1.fromBufferAttribute(uv2,b),_uvC$1.fromBufferAttribute(uv2,c),object.uv2=Triangle.getUV(_intersectionPoint,_vA$1,_vB$1,_vC$1,_uvA$1,_uvB$1,_uvC$1,new Vector2)),uv={a,b,c,normal:new Vector3,materialIndex:0},Triangle.getNormal(_vA$1,_vB$1,_vC$1,uv.normal),object.face=uv);return object}function cloneUniforms(src){const dst={};for(const u in src){dst[u]={};for(const p in src[u]){const property=src[u][p];
property&&(property.isColor||property.isMatrix3||property.isMatrix4||property.isVector2||property.isVector3||property.isVector4||property.isTexture||property.isQuaternion)?dst[u][p]=property.clone():Array.isArray(property)?dst[u][p]=property.slice():dst[u][p]=property}}return dst}function mergeUniforms(uniforms){const merged={};for(let u=0;u<uniforms.length;u++){const tmp=cloneUniforms(uniforms[u]);for(const p in tmp)merged[p]=tmp[p]}return merged}function WebGLAnimation(){function onAnimationFrame(time,
frame){animationLoop(time,frame);requestId=context.requestAnimationFrame(onAnimationFrame)}let context=null,isAnimating=!1,animationLoop=null,requestId=null;return{start:function(){!0!==isAnimating&&null!==animationLoop&&(requestId=context.requestAnimationFrame(onAnimationFrame),isAnimating=!0)},stop:function(){context.cancelAnimationFrame(requestId);isAnimating=!1},setAnimationLoop:function(callback){animationLoop=callback},setContext:function(value){context=value}}}function WebGLAttributes(gl,capabilities){const isWebGL2=
capabilities.isWebGL2,buffers=new WeakMap;return{get:function(attribute){attribute.isInterleavedBufferAttribute&&(attribute=attribute.data);return buffers.get(attribute)},remove:function(attribute){attribute.isInterleavedBufferAttribute&&(attribute=attribute.data);const data=buffers.get(attribute);data&&(gl.deleteBuffer(data.buffer),buffers.delete(attribute))},update:function(attribute,bufferType){if(attribute.isGLBufferAttribute)bufferType=buffers.get(attribute),(!bufferType||bufferType.version<
attribute.version)&&buffers.set(attribute,{buffer:attribute.buffer,type:attribute.type,bytesPerElement:attribute.elementSize,version:attribute.version});else{attribute.isInterleavedBufferAttribute&&(attribute=attribute.data);var data=buffers.get(attribute);if(void 0===data){data=buffers.set;var JSCompiler_temp_const=attribute,array=attribute.array;const usage=attribute.usage,buffer=gl.createBuffer();gl.bindBuffer(bufferType,buffer);gl.bufferData(bufferType,array,usage);attribute.onUploadCallback();
if(array instanceof Float32Array)bufferType=gl.FLOAT;else if(array instanceof Uint16Array)if(attribute.isFloat16BufferAttribute)if(isWebGL2)bufferType=gl.HALF_FLOAT;else throw Error("THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2.");else bufferType=gl.UNSIGNED_SHORT;else if(array instanceof Int16Array)bufferType=gl.SHORT;else if(array instanceof Uint32Array)bufferType=gl.UNSIGNED_INT;else if(array instanceof Int32Array)bufferType=gl.INT;else if(array instanceof Int8Array)bufferType=
gl.BYTE;else if(array instanceof Uint8Array)bufferType=gl.UNSIGNED_BYTE;else if(array instanceof Uint8ClampedArray)bufferType=gl.UNSIGNED_BYTE;else throw Error("THREE.WebGLAttributes: Unsupported buffer data format: "+array);data.call(buffers,JSCompiler_temp_const,{buffer,type:bufferType,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version})}else data.version<attribute.version&&(JSCompiler_temp_const=attribute.array,array=attribute.updateRange,gl.bindBuffer(bufferType,data.buffer),-1===
array.count?gl.bufferSubData(bufferType,0,JSCompiler_temp_const):(isWebGL2?gl.bufferSubData(bufferType,array.offset*JSCompiler_temp_const.BYTES_PER_ELEMENT,JSCompiler_temp_const,array.offset,array.count):gl.bufferSubData(bufferType,array.offset*JSCompiler_temp_const.BYTES_PER_ELEMENT,JSCompiler_temp_const.subarray(array.offset,array.offset+array.count)),array.count=-1),data.version=attribute.version)}}}}function WebGLBackground(renderer$jscomp$0,cubemaps,cubeuvmaps,state,objects,alpha$jscomp$0,premultipliedAlpha){function setClear(color,
alpha){state.buffers.color.setClear(color.r,color.g,color.b,alpha,premultipliedAlpha)}const clearColor=new Color(0);let clearAlpha=!0===alpha$jscomp$0?0:1,planeMesh,boxMesh,currentBackground=null,currentBackgroundVersion=0,currentTonemapping=null;return{getClearColor:function(){return clearColor},setClearColor:function(color,alpha=1){clearColor.set(color);clearAlpha=alpha;setClear(clearColor,clearAlpha)},getClearAlpha:function(){return clearAlpha},setClearAlpha:function(alpha){clearAlpha=alpha;setClear(clearColor,
clearAlpha)},render:function(renderList,scene$jscomp$0){let forceClear=!1,background=!0===scene$jscomp$0.isScene?scene$jscomp$0.background:null;background&&background.isTexture&&(background=(0<scene$jscomp$0.backgroundBlurriness?cubeuvmaps:cubemaps).get(background));var xr=renderer$jscomp$0.xr;(xr=xr.getSession&&xr.getSession())&&"additive"===xr.environmentBlendMode&&(background=null);null===background?setClear(clearColor,clearAlpha):background&&background.isColor&&(setClear(background,1),forceClear=
!0);(renderer$jscomp$0.autoClear||forceClear)&&renderer$jscomp$0.clear(renderer$jscomp$0.autoClearColor,renderer$jscomp$0.autoClearDepth,renderer$jscomp$0.autoClearStencil);if(background&&(background.isCubeTexture||306===background.mapping)){void 0===boxMesh&&(boxMesh=new Mesh(new BoxGeometry(1,1,1),new ShaderMaterial({name:"BackgroundCubeMaterial",uniforms:cloneUniforms(ShaderLib.backgroundCube.uniforms),vertexShader:ShaderLib.backgroundCube.vertexShader,fragmentShader:ShaderLib.backgroundCube.fragmentShader,
side:1,depthTest:!1,depthWrite:!1,fog:!1})),boxMesh.geometry.deleteAttribute("normal"),boxMesh.geometry.deleteAttribute("uv"),boxMesh.onBeforeRender=function(renderer,scene,camera){this.matrixWorld.copyPosition(camera.matrixWorld)},Object.defineProperty(boxMesh.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),objects.update(boxMesh));boxMesh.material.uniforms.envMap.value=background;boxMesh.material.uniforms.flipEnvMap.value=background.isCubeTexture&&!1===background.isRenderTargetTexture?
-1:1;boxMesh.material.uniforms.backgroundBlurriness.value=scene$jscomp$0.backgroundBlurriness;if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer$jscomp$0.toneMapping)boxMesh.material.needsUpdate=!0,currentBackground=background,currentBackgroundVersion=background.version,currentTonemapping=renderer$jscomp$0.toneMapping;boxMesh.layers.enableAll();renderList.unshift(boxMesh,boxMesh.geometry,boxMesh.material,0,0,null)}else if(background&&background.isTexture){void 0===
planeMesh&&(planeMesh=new Mesh(new PlaneGeometry(2,2),new ShaderMaterial({name:"BackgroundMaterial",uniforms:cloneUniforms(ShaderLib.background.uniforms),vertexShader:ShaderLib.background.vertexShader,fragmentShader:ShaderLib.background.fragmentShader,side:0,depthTest:!1,depthWrite:!1,fog:!1})),planeMesh.geometry.deleteAttribute("normal"),Object.defineProperty(planeMesh.material,"map",{get:function(){return this.uniforms.t2D.value}}),objects.update(planeMesh));planeMesh.material.uniforms.t2D.value=
background;!0===background.matrixAutoUpdate&&background.updateMatrix();planeMesh.material.uniforms.uvTransform.value.copy(background.matrix);if(currentBackground!==background||currentBackgroundVersion!==background.version||currentTonemapping!==renderer$jscomp$0.toneMapping)planeMesh.material.needsUpdate=!0,currentBackground=background,currentBackgroundVersion=background.version,currentTonemapping=renderer$jscomp$0.toneMapping;planeMesh.layers.enableAll();renderList.unshift(planeMesh,planeMesh.geometry,
planeMesh.material,0,0,null)}}}}function WebGLBindingStates(gl,extensions,attributes,capabilities){function bindVertexArrayObject(vao){return capabilities.isWebGL2?gl.bindVertexArray(vao):extension.bindVertexArrayOES(vao)}function deleteVertexArrayObject(vao){return capabilities.isWebGL2?gl.deleteVertexArray(vao):extension.deleteVertexArrayOES(vao)}function createBindingState(vao){const newAttributes=[],enabledAttributes=[],attributeDivisors=[];for(let i=0;i<maxVertexAttributes;i++)newAttributes[i]=
0,enabledAttributes[i]=0,attributeDivisors[i]=0;return{geometry:null,program:null,wireframe:!1,newAttributes,enabledAttributes,attributeDivisors,object:vao,attributes:{},index:null}}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i=0,il=newAttributes.length;i<il;i++)newAttributes[i]=0}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,0)}function enableAttributeAndDivisor(attribute,meshPerAttribute){const enabledAttributes=currentState.enabledAttributes,
attributeDivisors=currentState.attributeDivisors;currentState.newAttributes[attribute]=1;0===enabledAttributes[attribute]&&(gl.enableVertexAttribArray(attribute),enabledAttributes[attribute]=1);attributeDivisors[attribute]!==meshPerAttribute&&((capabilities.isWebGL2?gl:extensions.get("ANGLE_instanced_arrays"))[capabilities.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](attribute,meshPerAttribute),attributeDivisors[attribute]=meshPerAttribute)}function disableUnusedAttributes(){const newAttributes=
currentState.newAttributes,enabledAttributes=currentState.enabledAttributes;for(let i=0,il=enabledAttributes.length;i<il;i++)enabledAttributes[i]!==newAttributes[i]&&(gl.disableVertexAttribArray(i),enabledAttributes[i]=0)}function vertexAttribPointer(index,size,type,normalized,stride,offset){!0!==capabilities.isWebGL2||type!==gl.INT&&type!==gl.UNSIGNED_INT?gl.vertexAttribPointer(index,size,type,normalized,stride,offset):gl.vertexAttribIPointer(index,size,type,stride,offset)}function reset(){resetDefaultState();
forceUpdate=!0;currentState!==defaultState&&(currentState=defaultState,bindVertexArrayObject(currentState.object))}function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=!1}const maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS),extension=capabilities.isWebGL2?null:extensions.get("OES_vertex_array_object"),vaoAvailable=capabilities.isWebGL2||null!==extension,bindingStates={},defaultState=createBindingState(null);let currentState=defaultState,
forceUpdate=!1;return{setup:function(object,material,program,geometry,index){var updateBuffers=!1;if(vaoAvailable){updateBuffers=!0===material.wireframe;var programMap=bindingStates[geometry.id];void 0===programMap&&(programMap={},bindingStates[geometry.id]=programMap);var stateMap=programMap[program.id];void 0===stateMap&&(stateMap={},programMap[program.id]=stateMap);programMap=stateMap[updateBuffers];void 0===programMap&&(programMap=createBindingState(capabilities.isWebGL2?gl.createVertexArray():
extension.createVertexArrayOES()),stateMap[updateBuffers]=programMap);updateBuffers=programMap;currentState!==updateBuffers&&(currentState=updateBuffers,bindVertexArrayObject(currentState.object));a:{updateBuffers=currentState.attributes;stateMap=geometry.attributes;programMap=0;var programAttributes=program.getAttributes();for(var name$jscomp$0 in programAttributes)if(0<=programAttributes[name$jscomp$0].location){var cachedAttribute=updateBuffers[name$jscomp$0],geometryAttribute=stateMap[name$jscomp$0];
void 0===geometryAttribute&&("instanceMatrix"===name$jscomp$0&&object.instanceMatrix&&(geometryAttribute=object.instanceMatrix),"instanceColor"===name$jscomp$0&&object.instanceColor&&(geometryAttribute=object.instanceColor));if(void 0===cachedAttribute||cachedAttribute.attribute!==geometryAttribute||geometryAttribute&&cachedAttribute.data!==geometryAttribute.data){updateBuffers=!0;break a}programMap++}updateBuffers=currentState.attributesNum!==programMap||currentState.index!==index?!0:!1}if(updateBuffers){name$jscomp$0=
{};stateMap=geometry.attributes;programMap=0;programAttributes=program.getAttributes();for(var name$jscomp$1 in programAttributes)0<=programAttributes[name$jscomp$1].location&&(cachedAttribute=stateMap[name$jscomp$1],void 0===cachedAttribute&&("instanceMatrix"===name$jscomp$1&&object.instanceMatrix&&(cachedAttribute=object.instanceMatrix),"instanceColor"===name$jscomp$1&&object.instanceColor&&(cachedAttribute=object.instanceColor)),geometryAttribute={},(geometryAttribute.attribute=cachedAttribute)&&
cachedAttribute.data&&(geometryAttribute.data=cachedAttribute.data),name$jscomp$0[name$jscomp$1]=geometryAttribute,programMap++);currentState.attributes=name$jscomp$0;currentState.attributesNum=programMap;currentState.index=index}}else if(name$jscomp$1=!0===material.wireframe,currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==name$jscomp$1)currentState.geometry=geometry.id,currentState.program=program.id,currentState.wireframe=name$jscomp$1,updateBuffers=
!0;null!==index&&attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);if(updateBuffers||forceUpdate){forceUpdate=!1;if(!1!==capabilities.isWebGL2||!object.isInstancedMesh&&!geometry.isInstancedBufferGeometry||null!==extensions.get("ANGLE_instanced_arrays")){initAttributes();name$jscomp$1=geometry.attributes;program=program.getAttributes();material=material.defaultAttributeValues;for(const name in program)if(name$jscomp$0=program[name],0<=name$jscomp$0.location){var geometryAttribute$jscomp$0=name$jscomp$1[name];
void 0===geometryAttribute$jscomp$0&&("instanceMatrix"===name&&object.instanceMatrix&&(geometryAttribute$jscomp$0=object.instanceMatrix),"instanceColor"===name&&object.instanceColor&&(geometryAttribute$jscomp$0=object.instanceColor));if(void 0!==geometryAttribute$jscomp$0){if(updateBuffers=geometryAttribute$jscomp$0.normalized,stateMap=geometryAttribute$jscomp$0.itemSize,programAttributes=attributes.get(geometryAttribute$jscomp$0),void 0!==programAttributes)if(cachedAttribute=programAttributes.buffer,
programMap=programAttributes.type,programAttributes=programAttributes.bytesPerElement,geometryAttribute$jscomp$0.isInterleavedBufferAttribute){var data=geometryAttribute$jscomp$0.data;geometryAttribute=data.stride;geometryAttribute$jscomp$0=geometryAttribute$jscomp$0.offset;if(data.isInstancedInterleavedBuffer){for(let i=0;i<name$jscomp$0.locationSize;i++)enableAttributeAndDivisor(name$jscomp$0.location+i,data.meshPerAttribute);!0!==object.isInstancedMesh&&void 0===geometry._maxInstanceCount&&(geometry._maxInstanceCount=
data.meshPerAttribute*data.count)}else for(data=0;data<name$jscomp$0.locationSize;data++)enableAttribute(name$jscomp$0.location+data);gl.bindBuffer(gl.ARRAY_BUFFER,cachedAttribute);for(cachedAttribute=0;cachedAttribute<name$jscomp$0.locationSize;cachedAttribute++)vertexAttribPointer(name$jscomp$0.location+cachedAttribute,stateMap/name$jscomp$0.locationSize,programMap,updateBuffers,geometryAttribute*programAttributes,(geometryAttribute$jscomp$0+stateMap/name$jscomp$0.locationSize*cachedAttribute)*
programAttributes)}else{if(geometryAttribute$jscomp$0.isInstancedBufferAttribute){for(geometryAttribute=0;geometryAttribute<name$jscomp$0.locationSize;geometryAttribute++)enableAttributeAndDivisor(name$jscomp$0.location+geometryAttribute,geometryAttribute$jscomp$0.meshPerAttribute);!0!==object.isInstancedMesh&&void 0===geometry._maxInstanceCount&&(geometry._maxInstanceCount=geometryAttribute$jscomp$0.meshPerAttribute*geometryAttribute$jscomp$0.count)}else for(geometryAttribute=0;geometryAttribute<
name$jscomp$0.locationSize;geometryAttribute++)enableAttribute(name$jscomp$0.location+geometryAttribute);gl.bindBuffer(gl.ARRAY_BUFFER,cachedAttribute);for(cachedAttribute=0;cachedAttribute<name$jscomp$0.locationSize;cachedAttribute++)vertexAttribPointer(name$jscomp$0.location+cachedAttribute,stateMap/name$jscomp$0.locationSize,programMap,updateBuffers,stateMap*programAttributes,stateMap/name$jscomp$0.locationSize*cachedAttribute*programAttributes)}}else if(void 0!==material&&(updateBuffers=material[name],
void 0!==updateBuffers))switch(updateBuffers.length){case 2:gl.vertexAttrib2fv(name$jscomp$0.location,updateBuffers);break;case 3:gl.vertexAttrib3fv(name$jscomp$0.location,updateBuffers);break;case 4:gl.vertexAttrib4fv(name$jscomp$0.location,updateBuffers);break;default:gl.vertexAttrib1fv(name$jscomp$0.location,updateBuffers)}}disableUnusedAttributes()}null!==index&&gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer)}},reset,resetDefaultState,dispose:function(){reset();for(const geometryId in bindingStates){const programMap=
bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometryId]}},releaseStatesOfGeometry:function(geometry){if(void 0!==bindingStates[geometry.id]){var programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),
delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometry.id]}},releaseStatesOfProgram:function(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(void 0===programMap[program.id])continue;const stateMap=programMap[program.id];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[program.id]}},initAttributes,enableAttribute,disableUnusedAttributes}}function WebGLBufferRenderer(gl,
extensions,info,capabilities){const isWebGL2=capabilities.isWebGL2;let mode;this.setMode=function(value){mode=value};this.render=function(start,count){gl.drawArrays(mode,start,count);info.update(count,mode,1)};this.renderInstances=function(start,count,primcount){if(0!==primcount){if(isWebGL2){var extension=gl;var methodName="drawArraysInstanced"}else if(extension=extensions.get("ANGLE_instanced_arrays"),methodName="drawArraysInstancedANGLE",null===extension){console.error("THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");
return}extension[methodName](mode,start,count,primcount);info.update(count,mode,primcount)}}}function WebGLCapabilities(gl,extensions,parameters){function getMaxPrecision(precision){if("highp"===precision){if(0<gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.HIGH_FLOAT).precision&&0<gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,gl.HIGH_FLOAT).precision)return"highp";precision="mediump"}return"mediump"===precision&&0<gl.getShaderPrecisionFormat(gl.VERTEX_SHADER,gl.MEDIUM_FLOAT).precision&&0<gl.getShaderPrecisionFormat(gl.FRAGMENT_SHADER,
gl.MEDIUM_FLOAT).precision?"mediump":"lowp"}let maxAnisotropy;const isWebGL2="undefined"!==typeof WebGL2RenderingContext&&gl instanceof WebGL2RenderingContext||"undefined"!==typeof WebGL2ComputeRenderingContext&&gl instanceof WebGL2ComputeRenderingContext;let precision$jscomp$0=void 0!==parameters.precision?parameters.precision:"highp";var maxPrecision=getMaxPrecision(precision$jscomp$0);maxPrecision!==precision$jscomp$0&&(console.warn("THREE.WebGLRenderer:",precision$jscomp$0,"not supported, using",
maxPrecision,"instead."),precision$jscomp$0=maxPrecision);maxPrecision=isWebGL2||extensions.has("WEBGL_draw_buffers");parameters=!0===parameters.logarithmicDepthBuffer;const maxTextures=gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS),maxVertexTextures=gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),maxTextureSize=gl.getParameter(gl.MAX_TEXTURE_SIZE),maxCubemapSize=gl.getParameter(gl.MAX_CUBE_MAP_TEXTURE_SIZE),maxAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS),maxVertexUniforms=gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS),
maxVaryings=gl.getParameter(gl.MAX_VARYING_VECTORS),maxFragmentUniforms=gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS),vertexTextures=0<maxVertexTextures,floatFragmentTextures=isWebGL2||extensions.has("OES_texture_float"),floatVertexTextures=vertexTextures&&floatFragmentTextures,maxSamples=isWebGL2?gl.getParameter(gl.MAX_SAMPLES):0;return{isWebGL2,drawBuffers:maxPrecision,getMaxAnisotropy:function(){if(void 0!==maxAnisotropy)return maxAnisotropy;if(!0===extensions.has("EXT_texture_filter_anisotropic")){const extension=
extensions.get("EXT_texture_filter_anisotropic");maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else maxAnisotropy=0;return maxAnisotropy},getMaxPrecision,precision:precision$jscomp$0,logarithmicDepthBuffer:parameters,maxTextures,maxVertexTextures,maxTextureSize,maxCubemapSize,maxAttributes,maxVertexUniforms,maxVaryings,maxFragmentUniforms,vertexTextures,floatFragmentTextures,floatVertexTextures,maxSamples}}function WebGLClipping(properties){function resetGlobalState(){uniform.value!==
globalState&&(uniform.value=globalState,uniform.needsUpdate=0<numGlobalPlanes);scope.numPlanes=numGlobalPlanes;scope.numIntersection=0}function projectPlanes(planes,camera,dstOffset,skipTransform){const nPlanes=null!==planes?planes.length:0;let dstArray=null;if(0!==nPlanes){dstArray=uniform.value;if(!0!==skipTransform||null===dstArray){skipTransform=dstOffset+4*nPlanes;camera=camera.matrixWorldInverse;viewNormalMatrix.getNormalMatrix(camera);if(null===dstArray||dstArray.length<skipTransform)dstArray=
new Float32Array(skipTransform);for(let i=0,i4=dstOffset;i!==nPlanes;++i,i4+=4)plane.copy(planes[i]).applyMatrix4(camera,viewNormalMatrix),plane.normal.toArray(dstArray,i4),dstArray[i4+3]=plane.constant}uniform.value=dstArray;uniform.needsUpdate=!0}scope.numPlanes=nPlanes;scope.numIntersection=0;return dstArray}const scope=this;let globalState=null,numGlobalPlanes=0,localClippingEnabled=!1,renderingShadows=!1;const plane=new Plane,viewNormalMatrix=new Matrix3,uniform={value:null,needsUpdate:!1};this.uniform=
uniform;this.numIntersection=this.numPlanes=0;this.init=function(planes,enableLocalClipping,camera){const enabled=0!==planes.length||enableLocalClipping||0!==numGlobalPlanes||localClippingEnabled;localClippingEnabled=enableLocalClipping;globalState=projectPlanes(planes,camera,0);numGlobalPlanes=planes.length;return enabled};this.beginShadows=function(){renderingShadows=!0;projectPlanes(null)};this.endShadows=function(){renderingShadows=!1;resetGlobalState()};this.setState=function(material,camera,
useCache){const planes=material.clippingPlanes,clipIntersection=material.clipIntersection;var clipShadows=material.clipShadows;material=properties.get(material);if(!localClippingEnabled||null===planes||0===planes.length||renderingShadows&&!clipShadows)renderingShadows?projectPlanes(null):resetGlobalState();else{clipShadows=renderingShadows?0:numGlobalPlanes;const lGlobal=4*clipShadows;let dstArray=material.clippingState||null;uniform.value=dstArray;dstArray=projectPlanes(planes,camera,lGlobal,useCache);
for(camera=0;camera!==lGlobal;++camera)dstArray[camera]=globalState[camera];material.clippingState=dstArray;this.numIntersection=clipIntersection?this.numPlanes:0;this.numPlanes+=clipShadows}}}function WebGLCubeMaps(renderer){function mapTextureMapping(texture,mapping){303===mapping?texture.mapping=301:304===mapping&&(texture.mapping=302);return texture}function onTextureDispose(event){event=event.target;event.removeEventListener("dispose",onTextureDispose);const cubemap=cubemaps.get(event);void 0!==
cubemap&&(cubemaps.delete(event),cubemap.dispose())}let cubemaps=new WeakMap;return{get:function(texture){if(texture&&texture.isTexture&&!1===texture.isRenderTargetTexture){var mapping=texture.mapping;if(303===mapping||304===mapping)return cubemaps.has(texture)?(mapping=cubemaps.get(texture).texture,mapTextureMapping(mapping,texture.mapping)):(mapping=texture.image)&&0<mapping.height?(mapping=new WebGLCubeRenderTarget(mapping.height/2),mapping.fromEquirectangularTexture(renderer,texture),cubemaps.set(texture,
mapping),texture.addEventListener("dispose",onTextureDispose),mapTextureMapping(mapping.texture,texture.mapping)):null}return texture},dispose:function(){cubemaps=new WeakMap}}}function _createRenderTarget(width,height,params){width=new WebGLRenderTarget(width,height,params);width.texture.mapping=306;width.texture.name="PMREM.cubeUv";width.scissorTest=!0;return width}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height)}function _getEquirectMaterial(){return new ShaderMaterial({name:"EquirectangularToCubeUV",
uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include \x3ccommon\x3e\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection \x3d normalize( vOutputDirection );\n\t\t\t\tvec2 uv \x3d equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor \x3d vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:0,
depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor \x3d textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
blending:0,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv \x3d 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction \x3d vec3( uv, 1.0 );\n\n\t\t\tif ( face \x3d\x3d 0.0 ) {\n\n\t\t\t\tdirection \x3d direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face \x3d\x3d 1.0 ) {\n\n\t\t\t\tdirection \x3d direction.xzy;\n\t\t\t\tdirection.xz *\x3d -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face \x3d\x3d 2.0 ) {\n\n\t\t\t\tdirection.x *\x3d -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face \x3d\x3d 3.0 ) {\n\n\t\t\t\tdirection \x3d direction.zyx;\n\t\t\t\tdirection.xz *\x3d -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face \x3d\x3d 4.0 ) {\n\n\t\t\t\tdirection \x3d direction.xzy;\n\t\t\t\tdirection.xy *\x3d -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face \x3d\x3d 5.0 ) {\n\n\t\t\t\tdirection.z *\x3d -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection \x3d getDirection( uv, faceIndex );\n\t\t\tgl_Position \x3d vec4( position, 1.0 );\n\n\t\t}\n\t"}
function WebGLCubeUVMaps(renderer){function onTextureDispose(event){event=event.target;event.removeEventListener("dispose",onTextureDispose);const cubemapUV=cubeUVmaps.get(event);void 0!==cubemapUV&&(cubeUVmaps.delete(event),cubemapUV.dispose())}let cubeUVmaps=new WeakMap,pmremGenerator=null;return{get:function(texture){if(texture&&texture.isTexture){var mapping=texture.mapping,isEquirectMap=303===mapping||304===mapping,isCubeMap=301===mapping||302===mapping;if(isEquirectMap||isCubeMap){if(texture.isRenderTargetTexture&&
!0===texture.needsPMREMUpdate)return texture.needsPMREMUpdate=!1,mapping=cubeUVmaps.get(texture),null===pmremGenerator&&(pmremGenerator=new PMREMGenerator(renderer)),mapping=isEquirectMap?pmremGenerator.fromEquirectangular(texture,mapping):pmremGenerator.fromCubemap(texture,mapping),cubeUVmaps.set(texture,mapping),mapping.texture;if(cubeUVmaps.has(texture))return cubeUVmaps.get(texture).texture;mapping=texture.image;var JSCompiler_temp;if(!(JSCompiler_temp=isEquirectMap&&mapping&&0<mapping.height)&&
(JSCompiler_temp=isCubeMap&&mapping)){JSCompiler_temp=0;for(isCubeMap=0;6>isCubeMap;isCubeMap++)void 0!==mapping[isCubeMap]&&JSCompiler_temp++;JSCompiler_temp=6===JSCompiler_temp}return JSCompiler_temp?(null===pmremGenerator&&(pmremGenerator=new PMREMGenerator(renderer)),isEquirectMap=isEquirectMap?pmremGenerator.fromEquirectangular(texture):pmremGenerator.fromCubemap(texture),cubeUVmaps.set(texture,isEquirectMap),texture.addEventListener("dispose",onTextureDispose),isEquirectMap.texture):null}}return texture},
dispose:function(){cubeUVmaps=new WeakMap;null!==pmremGenerator&&(pmremGenerator.dispose(),pmremGenerator=null)}}}function WebGLExtensions(gl){function getExtension(name){if(void 0!==extensions[name])return extensions[name];let extension;switch(name){case "WEBGL_depth_texture":extension=gl.getExtension("WEBGL_depth_texture")||gl.getExtension("MOZ_WEBGL_depth_texture")||gl.getExtension("WEBKIT_WEBGL_depth_texture");break;case "EXT_texture_filter_anisotropic":extension=gl.getExtension("EXT_texture_filter_anisotropic")||
gl.getExtension("MOZ_EXT_texture_filter_anisotropic")||gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case "WEBGL_compressed_texture_s3tc":extension=gl.getExtension("WEBGL_compressed_texture_s3tc")||gl.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case "WEBGL_compressed_texture_pvrtc":extension=gl.getExtension("WEBGL_compressed_texture_pvrtc")||gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:extension=
gl.getExtension(name)}return extensions[name]=extension}const extensions={};return{has:function(name){return null!==getExtension(name)},init:function(capabilities){capabilities.isWebGL2?getExtension("EXT_color_buffer_float"):(getExtension("WEBGL_depth_texture"),getExtension("OES_texture_float"),getExtension("OES_texture_half_float"),getExtension("OES_texture_half_float_linear"),getExtension("OES_standard_derivatives"),getExtension("OES_element_index_uint"),getExtension("OES_vertex_array_object"),
getExtension("ANGLE_instanced_arrays"));getExtension("OES_texture_float_linear");getExtension("EXT_color_buffer_half_float");getExtension("WEBGL_multisampled_render_to_texture")},get:function(name){const extension=getExtension(name);null===extension&&console.warn("THREE.WebGLRenderer: "+name+" extension not supported.");return extension}}}function WebGLGeometries(gl,attributes,info,bindingStates){function onGeometryDispose(event){event=event.target;null!==event.index&&attributes.remove(event.index);
for(var name in event.attributes)attributes.remove(event.attributes[name]);event.removeEventListener("dispose",onGeometryDispose);delete geometries[event.id];if(name=wireframeAttributes.get(event))attributes.remove(name),wireframeAttributes.delete(event);bindingStates.releaseStatesOfGeometry(event);!0===event.isInstancedBufferGeometry&&delete event._maxInstanceCount;info.memory.geometries--}function updateWireframeAttribute(geometry){var indices=[],geometryIndex=geometry.index,geometryPosition=geometry.attributes.position;
if(null!==geometryIndex){geometryPosition=geometryIndex.array;geometryIndex=geometryIndex.version;for(let i=0,l=geometryPosition.length;i<l;i+=3){var a=geometryPosition[i+0],b=geometryPosition[i+1];const c=geometryPosition[i+2];indices.push(a,b,b,c,c,a)}}else{a=geometryPosition.array;geometryIndex=geometryPosition.version;for(let i=0,l=a.length/3-1;i<l;i+=3)geometryPosition=i+0,a=i+1,b=i+2,indices.push(geometryPosition,a,a,b,b,geometryPosition)}indices=new (arrayNeedsUint32(indices)?Uint32BufferAttribute:
Uint16BufferAttribute)(indices,1);indices.version=geometryIndex;(geometryIndex=wireframeAttributes.get(geometry))&&attributes.remove(geometryIndex);wireframeAttributes.set(geometry,indices)}const geometries={},wireframeAttributes=new WeakMap;return{get:function(object,geometry){if(!0===geometries[geometry.id])return geometry;geometry.addEventListener("dispose",onGeometryDispose);geometries[geometry.id]=!0;info.memory.geometries++;return geometry},update:function(geometry){var geometryAttributes=geometry.attributes;
for(const name in geometryAttributes)attributes.update(geometryAttributes[name],gl.ARRAY_BUFFER);geometry=geometry.morphAttributes;for(const name in geometry){geometryAttributes=geometry[name];for(let i=0,l=geometryAttributes.length;i<l;i++)attributes.update(geometryAttributes[i],gl.ARRAY_BUFFER)}},getWireframeAttribute:function(geometry){const currentAttribute=wireframeAttributes.get(geometry);if(currentAttribute){const geometryIndex=geometry.index;null!==geometryIndex&&currentAttribute.version<
geometryIndex.version&&updateWireframeAttribute(geometry)}else updateWireframeAttribute(geometry);return wireframeAttributes.get(geometry)}}}function WebGLIndexedBufferRenderer(gl,extensions,info,capabilities){const isWebGL2=capabilities.isWebGL2;let mode,type,bytesPerElement;this.setMode=function(value){mode=value};this.setIndex=function(value){type=value.type;bytesPerElement=value.bytesPerElement};this.render=function(start,count){gl.drawElements(mode,count,type,start*bytesPerElement);info.update(count,
mode,1)};this.renderInstances=function(start,count,primcount){if(0!==primcount){if(isWebGL2){var extension=gl;var methodName="drawElementsInstanced"}else if(extension=extensions.get("ANGLE_instanced_arrays"),methodName="drawElementsInstancedANGLE",null===extension){console.error("THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.");return}extension[methodName](mode,count,type,start*bytesPerElement,primcount);info.update(count,
mode,primcount)}}}function WebGLInfo(gl){const render={frame:0,calls:0,triangles:0,points:0,lines:0};return{memory:{geometries:0,textures:0},render,programs:null,autoReset:!0,reset:function(){render.frame++;render.calls=0;render.triangles=0;render.points=0;render.lines=0},update:function(count,mode,instanceCount){render.calls++;switch(mode){case gl.TRIANGLES:render.triangles+=count/3*instanceCount;break;case gl.LINES:render.lines+=count/2*instanceCount;break;case gl.LINE_STRIP:render.lines+=instanceCount*
(count-1);break;case gl.LINE_LOOP:render.lines+=instanceCount*count;break;case gl.POINTS:render.points+=instanceCount*count;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",mode)}}}}function numericalSort(a,b){return a[0]-b[0]}function absNumericalSort(a,b){return Math.abs(b[1])-Math.abs(a[1])}function WebGLMorphtargets(gl,capabilities,textures){const influencesList={},morphInfluences=new Float32Array(8),morphTextures=new WeakMap,morph=new Vector4,workInfluences=[];for(let i=0;8>
i;i++)workInfluences[i]=[i,0];return{update:function(object,geometry,material,program){object=object.morphTargetInfluences;if(!0===capabilities.isWebGL2){material=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;material=void 0!==material?material.length:0;var entry=morphTextures.get(geometry);if(void 0===entry||entry.count!==material){void 0!==entry&&entry.texture.dispose();entry=void 0!==geometry.morphAttributes.position;var hasMorphNormals=void 0!==
geometry.morphAttributes.normal,hasMorphColors=void 0!==geometry.morphAttributes.color,morphTargets=geometry.morphAttributes.position||[];const morphNormals=geometry.morphAttributes.normal||[],morphColors=geometry.morphAttributes.color||[];var vertexDataCount=0;!0===entry&&(vertexDataCount=1);!0===hasMorphNormals&&(vertexDataCount=2);!0===hasMorphColors&&(vertexDataCount=3);let width=geometry.attributes.position.count*vertexDataCount,height=1;width>capabilities.maxTextureSize&&(height=Math.ceil(width/
capabilities.maxTextureSize),width=capabilities.maxTextureSize);const buffer=new Float32Array(width*height*4*material),texture=new DataArrayTexture(buffer,width,height,material);texture.type=1015;texture.needsUpdate=!0;vertexDataCount*=4;for(let i=0;i<material;i++){const morphTarget=morphTargets[i],morphNormal=morphNormals[i],morphColor=morphColors[i],offset=width*height*4*i;for(let j=0;j<morphTarget.count;j++){const stride=j*vertexDataCount;!0===entry&&(morph.fromBufferAttribute(morphTarget,j),buffer[offset+
stride+0]=morph.x,buffer[offset+stride+1]=morph.y,buffer[offset+stride+2]=morph.z,buffer[offset+stride+3]=0);!0===hasMorphNormals&&(morph.fromBufferAttribute(morphNormal,j),buffer[offset+stride+4]=morph.x,buffer[offset+stride+5]=morph.y,buffer[offset+stride+6]=morph.z,buffer[offset+stride+7]=0);!0===hasMorphColors&&(morph.fromBufferAttribute(morphColor,j),buffer[offset+stride+8]=morph.x,buffer[offset+stride+9]=morph.y,buffer[offset+stride+10]=morph.z,buffer[offset+stride+11]=4===morphColor.itemSize?
morph.w:1)}}entry={count:material,texture,size:new Vector2(width,height)};morphTextures.set(geometry,entry);function disposeTexture(){texture.dispose();morphTextures.delete(geometry);geometry.removeEventListener("dispose",disposeTexture)}geometry.addEventListener("dispose",disposeTexture)}material=0;for(hasMorphNormals=0;hasMorphNormals<object.length;hasMorphNormals++)material+=object[hasMorphNormals];material=geometry.morphTargetsRelative?1:1-material;program.getUniforms().setValue(gl,"morphTargetBaseInfluence",
material);program.getUniforms().setValue(gl,"morphTargetInfluences",object);program.getUniforms().setValue(gl,"morphTargetsTexture",entry.texture,textures);program.getUniforms().setValue(gl,"morphTargetsTextureSize",entry.size)}else{material=void 0===object?0:object.length;entry=influencesList[geometry.id];if(void 0===entry||entry.length!==material){entry=[];for(hasMorphNormals=0;hasMorphNormals<material;hasMorphNormals++)entry[hasMorphNormals]=[hasMorphNormals,0];influencesList[geometry.id]=entry}for(hasMorphNormals=
0;hasMorphNormals<material;hasMorphNormals++)hasMorphColors=entry[hasMorphNormals],hasMorphColors[0]=hasMorphNormals,hasMorphColors[1]=object[hasMorphNormals];entry.sort(absNumericalSort);for(object=0;8>object;object++)object<material&&entry[object][1]?(workInfluences[object][0]=entry[object][0],workInfluences[object][1]=entry[object][1]):(workInfluences[object][0]=Number.MAX_SAFE_INTEGER,workInfluences[object][1]=0);workInfluences.sort(numericalSort);object=geometry.morphAttributes.position;material=
geometry.morphAttributes.normal;entry=0;for(hasMorphNormals=0;8>hasMorphNormals;hasMorphNormals++)morphTargets=workInfluences[hasMorphNormals],hasMorphColors=morphTargets[0],morphTargets=morphTargets[1],hasMorphColors!==Number.MAX_SAFE_INTEGER&&morphTargets?(object&&geometry.getAttribute("morphTarget"+hasMorphNormals)!==object[hasMorphColors]&&geometry.setAttribute("morphTarget"+hasMorphNormals,object[hasMorphColors]),material&&geometry.getAttribute("morphNormal"+hasMorphNormals)!==material[hasMorphColors]&&
geometry.setAttribute("morphNormal"+hasMorphNormals,material[hasMorphColors]),morphInfluences[hasMorphNormals]=morphTargets,entry+=morphTargets):(object&&!0===geometry.hasAttribute("morphTarget"+hasMorphNormals)&&geometry.deleteAttribute("morphTarget"+hasMorphNormals),material&&!0===geometry.hasAttribute("morphNormal"+hasMorphNormals)&&geometry.deleteAttribute("morphNormal"+hasMorphNormals),morphInfluences[hasMorphNormals]=0);object=geometry.morphTargetsRelative?1:1-entry;program.getUniforms().setValue(gl,
"morphTargetBaseInfluence",object);program.getUniforms().setValue(gl,"morphTargetInfluences",morphInfluences)}}}}function WebGLObjects(gl,geometries,attributes,info){function onInstancedMeshDispose(event){event=event.target;event.removeEventListener("dispose",onInstancedMeshDispose);attributes.remove(event.instanceMatrix);null!==event.instanceColor&&attributes.remove(event.instanceColor)}let updateMap=new WeakMap;return{update:function(object){const frame=info.render.frame,buffergeometry=geometries.get(object,
object.geometry);updateMap.get(buffergeometry)!==frame&&(geometries.update(buffergeometry),updateMap.set(buffergeometry,frame));object.isInstancedMesh&&(!1===object.hasEventListener("dispose",onInstancedMeshDispose)&&object.addEventListener("dispose",onInstancedMeshDispose),attributes.update(object.instanceMatrix,gl.ARRAY_BUFFER),null!==object.instanceColor&&attributes.update(object.instanceColor,gl.ARRAY_BUFFER));return buffergeometry},dispose:function(){updateMap=new WeakMap}}}function flatten(array,
nBlocks,blockSize){const firstElem=array[0];if(0>=firstElem||0<firstElem)return array;const n=nBlocks*blockSize;let r=arrayCacheF32[n];void 0===r&&(r=new Float32Array(n),arrayCacheF32[n]=r);if(0!==nBlocks){firstElem.toArray(r,0);for(let i=1,offset=0;i!==nBlocks;++i)offset+=blockSize,array[i].toArray(r,offset)}return r}function arraysEqual(a,b){if(a.length!==b.length)return!1;for(let i=0,l=a.length;i<l;i++)if(a[i]!==b[i])return!1;return!0}function copyArray(a,b){for(let i=0,l=b.length;i<l;i++)a[i]=
b[i]}function allocTexUnits(textures,n){let r=arrayCacheI32[n];void 0===r&&(r=new Int32Array(n),arrayCacheI32[n]=r);for(let i=0;i!==n;++i)r[i]=textures.allocateTextureUnit();return r}function setValueV1f(gl,v){const cache=this.cache;cache[0]!==v&&(gl.uniform1f(this.addr,v),cache[0]=v)}function setValueV2f(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y)gl.uniform2f(this.addr,v.x,v.y),cache[0]=v.x,cache[1]=v.y}else arraysEqual(cache,v)||(gl.uniform2fv(this.addr,v),copyArray(cache,
v))}function setValueV3f(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z)gl.uniform3f(this.addr,v.x,v.y,v.z),cache[0]=v.x,cache[1]=v.y,cache[2]=v.z}else if(void 0!==v.r){if(cache[0]!==v.r||cache[1]!==v.g||cache[2]!==v.b)gl.uniform3f(this.addr,v.r,v.g,v.b),cache[0]=v.r,cache[1]=v.g,cache[2]=v.b}else arraysEqual(cache,v)||(gl.uniform3fv(this.addr,v),copyArray(cache,v))}function setValueV4f(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||
cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w)gl.uniform4f(this.addr,v.x,v.y,v.z,v.w),cache[0]=v.x,cache[1]=v.y,cache[2]=v.z,cache[3]=v.w}else arraysEqual(cache,v)||(gl.uniform4fv(this.addr,v),copyArray(cache,v))}function setValueM2(gl,v){const cache=this.cache,elements=v.elements;void 0===elements?arraysEqual(cache,v)||(gl.uniformMatrix2fv(this.addr,!1,v),copyArray(cache,v)):arraysEqual(cache,elements)||(mat2array.set(elements),gl.uniformMatrix2fv(this.addr,!1,mat2array),copyArray(cache,elements))}
function setValueM3(gl,v){const cache=this.cache,elements=v.elements;void 0===elements?arraysEqual(cache,v)||(gl.uniformMatrix3fv(this.addr,!1,v),copyArray(cache,v)):arraysEqual(cache,elements)||(mat3array.set(elements),gl.uniformMatrix3fv(this.addr,!1,mat3array),copyArray(cache,elements))}function setValueM4(gl,v){const cache=this.cache,elements=v.elements;void 0===elements?arraysEqual(cache,v)||(gl.uniformMatrix4fv(this.addr,!1,v),copyArray(cache,v)):arraysEqual(cache,elements)||(mat4array.set(elements),
gl.uniformMatrix4fv(this.addr,!1,mat4array),copyArray(cache,elements))}function setValueV1i(gl,v){const cache=this.cache;cache[0]!==v&&(gl.uniform1i(this.addr,v),cache[0]=v)}function setValueV2i(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y)gl.uniform2i(this.addr,v.x,v.y),cache[0]=v.x,cache[1]=v.y}else arraysEqual(cache,v)||(gl.uniform2iv(this.addr,v),copyArray(cache,v))}function setValueV3i(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==
v.y||cache[2]!==v.z)gl.uniform3i(this.addr,v.x,v.y,v.z),cache[0]=v.x,cache[1]=v.y,cache[2]=v.z}else arraysEqual(cache,v)||(gl.uniform3iv(this.addr,v),copyArray(cache,v))}function setValueV4i(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w)gl.uniform4i(this.addr,v.x,v.y,v.z,v.w),cache[0]=v.x,cache[1]=v.y,cache[2]=v.z,cache[3]=v.w}else arraysEqual(cache,v)||(gl.uniform4iv(this.addr,v),copyArray(cache,v))}function setValueV1ui(gl,v){const cache=
this.cache;cache[0]!==v&&(gl.uniform1ui(this.addr,v),cache[0]=v)}function setValueV2ui(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y)gl.uniform2ui(this.addr,v.x,v.y),cache[0]=v.x,cache[1]=v.y}else arraysEqual(cache,v)||(gl.uniform2uiv(this.addr,v),copyArray(cache,v))}function setValueV3ui(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z)gl.uniform3ui(this.addr,v.x,v.y,v.z),cache[0]=v.x,cache[1]=v.y,cache[2]=v.z}else arraysEqual(cache,
v)||(gl.uniform3uiv(this.addr,v),copyArray(cache,v))}function setValueV4ui(gl,v){const cache=this.cache;if(void 0!==v.x){if(cache[0]!==v.x||cache[1]!==v.y||cache[2]!==v.z||cache[3]!==v.w)gl.uniform4ui(this.addr,v.x,v.y,v.z,v.w),cache[0]=v.x,cache[1]=v.y,cache[2]=v.z,cache[3]=v.w}else arraysEqual(cache,v)||(gl.uniform4uiv(this.addr,v),copyArray(cache,v))}function setValueT1(gl,v,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=
unit);textures.setTexture2D(v||emptyTexture,unit)}function setValueT3D1(gl,v,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit);textures.setTexture3D(v||empty3dTexture,unit)}function setValueT6(gl,v,textures){const cache=this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit);textures.setTextureCube(v||emptyCubeTexture,unit)}function setValueT2DArray1(gl,v,textures){const cache=
this.cache,unit=textures.allocateTextureUnit();cache[0]!==unit&&(gl.uniform1i(this.addr,unit),cache[0]=unit);textures.setTexture2DArray(v||emptyArrayTexture,unit)}function getSingularSetter(type){switch(type){case 5126:return setValueV1f;case 35664:return setValueV2f;case 35665:return setValueV3f;case 35666:return setValueV4f;case 35674:return setValueM2;case 35675:return setValueM3;case 35676:return setValueM4;case 5124:case 35670:return setValueV1i;case 35667:case 35671:return setValueV2i;case 35668:case 35672:return setValueV3i;
case 35669:case 35673:return setValueV4i;case 5125:return setValueV1ui;case 36294:return setValueV2ui;case 36295:return setValueV3ui;case 36296:return setValueV4ui;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1;case 35679:case 36299:case 36307:return setValueT3D1;case 35680:case 36300:case 36308:case 36293:return setValueT6;case 36289:case 36303:case 36311:case 36292:return setValueT2DArray1}}function setValueV1fArray(gl,v){gl.uniform1fv(this.addr,v)}function setValueV2fArray(gl,
v){v=flatten(v,this.size,2);gl.uniform2fv(this.addr,v)}function setValueV3fArray(gl,v){v=flatten(v,this.size,3);gl.uniform3fv(this.addr,v)}function setValueV4fArray(gl,v){v=flatten(v,this.size,4);gl.uniform4fv(this.addr,v)}function setValueM2Array(gl,v){v=flatten(v,this.size,4);gl.uniformMatrix2fv(this.addr,!1,v)}function setValueM3Array(gl,v){v=flatten(v,this.size,9);gl.uniformMatrix3fv(this.addr,!1,v)}function setValueM4Array(gl,v){v=flatten(v,this.size,16);gl.uniformMatrix4fv(this.addr,!1,v)}function setValueV1iArray(gl,
v){gl.uniform1iv(this.addr,v)}function setValueV2iArray(gl,v){gl.uniform2iv(this.addr,v)}function setValueV3iArray(gl,v){gl.uniform3iv(this.addr,v)}function setValueV4iArray(gl,v){gl.uniform4iv(this.addr,v)}function setValueV1uiArray(gl,v){gl.uniform1uiv(this.addr,v)}function setValueV2uiArray(gl,v){gl.uniform2uiv(this.addr,v)}function setValueV3uiArray(gl,v){gl.uniform3uiv(this.addr,v)}function setValueV4uiArray(gl,v){gl.uniform4uiv(this.addr,v)}function setValueT1Array(gl,v,textures){const cache=
this.cache,n=v.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(gl=0;gl!==n;++gl)textures.setTexture2D(v[gl]||emptyTexture,units[gl])}function setValueT3DArray(gl,v,textures){const cache=this.cache,n=v.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(gl=0;gl!==n;++gl)textures.setTexture3D(v[gl]||empty3dTexture,units[gl])}function setValueT6Array(gl,
v,textures){const cache=this.cache,n=v.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(gl=0;gl!==n;++gl)textures.setTextureCube(v[gl]||emptyCubeTexture,units[gl])}function setValueT2DArrayArray(gl,v,textures){const cache=this.cache,n=v.length,units=allocTexUnits(textures,n);arraysEqual(cache,units)||(gl.uniform1iv(this.addr,units),copyArray(cache,units));for(gl=0;gl!==n;++gl)textures.setTexture2DArray(v[gl]||emptyArrayTexture,
units[gl])}function getPureArraySetter(type){switch(type){case 5126:return setValueV1fArray;case 35664:return setValueV2fArray;case 35665:return setValueV3fArray;case 35666:return setValueV4fArray;case 35674:return setValueM2Array;case 35675:return setValueM3Array;case 35676:return setValueM4Array;case 5124:case 35670:return setValueV1iArray;case 35667:case 35671:return setValueV2iArray;case 35668:case 35672:return setValueV3iArray;case 35669:case 35673:return setValueV4iArray;case 5125:return setValueV1uiArray;
case 36294:return setValueV2uiArray;case 36295:return setValueV3uiArray;case 36296:return setValueV4uiArray;case 35678:case 36198:case 36298:case 36306:case 35682:return setValueT1Array;case 35679:case 36299:case 36307:return setValueT3DArray;case 35680:case 36300:case 36308:case 36293:return setValueT6Array;case 36289:case 36303:case 36311:case 36292:return setValueT2DArrayArray}}function WebGLShader(gl,type,string){type=gl.createShader(type);gl.shaderSource(type,string);gl.compileShader(type);return type}
function getShaderErrors(gl,shader,type){var status=gl.getShaderParameter(shader,gl.COMPILE_STATUS),errors=gl.getShaderInfoLog(shader).trim();if(status&&""===errors)return"";if(status=/ERROR: 0:(\d+)/.exec(errors)){status=parseInt(status[1]);type=type.toUpperCase()+"\n\n"+errors+"\n\n";shader=gl.getShaderSource(shader);gl=status;shader=shader.split("\n");errors=[];var from=Math.max(gl-6,0);for(status=Math.min(gl+6,shader.length);from<status;from++){const line=from+1;errors.push(`${line===gl?"\x3e":
" "} ${line}: ${shader[from]}`)}gl=errors.join("\n");return type+gl}return errors}function getTexelEncodingFunction(functionName,encoding){a:switch(encoding){case 3E3:encoding=["Linear","( value )"];break a;case 3001:encoding=["sRGB","( value )"];break a;default:console.warn("THREE.WebGLProgram: Unsupported encoding:",encoding),encoding=["Linear","( value )"]}return"vec4 "+functionName+"( vec4 value ) { return LinearTo"+encoding[0]+encoding[1]+"; }"}function getToneMappingFunction(functionName,toneMapping){switch(toneMapping){case 1:toneMapping=
"Linear";break;case 2:toneMapping="Reinhard";break;case 3:toneMapping="OptimizedCineon";break;case 4:toneMapping="ACESFilmic";break;case 5:toneMapping="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",toneMapping),toneMapping="Linear"}return"vec3 "+functionName+"( vec3 color ) { return "+toneMapping+"ToneMapping( color ); }"}function generateDefines(defines){const chunks=[];for(const name in defines){const value=defines[name];!1!==value&&chunks.push("#define "+name+
" "+value)}return chunks.join("\n")}function filterEmptyLine(string){return""!==string}function replaceLightNums(string,parameters){const numSpotLightCoords=parameters.numSpotLightShadows+parameters.numSpotLightMaps-parameters.numSpotLightShadowsWithMaps;return string.replace(/NUM_DIR_LIGHTS/g,parameters.numDirLights).replace(/NUM_SPOT_LIGHTS/g,parameters.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,parameters.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,numSpotLightCoords).replace(/NUM_RECT_AREA_LIGHTS/g,
parameters.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,parameters.numPointLights).replace(/NUM_HEMI_LIGHTS/g,parameters.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,parameters.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,parameters.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,parameters.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,parameters.numPointLightShadows)}function replaceClippingPlaneNums(string,parameters){return string.replace(/NUM_CLIPPING_PLANES/g,
parameters.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,parameters.numClippingPlanes-parameters.numClipIntersection)}function includeReplacer(match,include){match=ShaderChunk[include];if(void 0===match)throw Error("Can not resolve #include \x3c"+include+"\x3e");return match.replace(includePattern,includeReplacer)}function loopReplacer(match,start,end,snippet){match="";for(start=parseInt(start);start<parseInt(end);start++)match+=snippet.replace(/\[\s*i\s*\]/g,"[ "+start+" ]").replace(/UNROLLED_LOOP_INDEX/g,
start);return match}function generatePrecision(parameters){let precisionstring="precision "+parameters.precision+" float;\nprecision "+parameters.precision+" int;";"highp"===parameters.precision?precisionstring+="\n#define HIGH_PRECISION":"mediump"===parameters.precision?precisionstring+="\n#define MEDIUM_PRECISION":"lowp"===parameters.precision&&(precisionstring+="\n#define LOW_PRECISION");return precisionstring}function generateShadowMapTypeDefine(parameters){let shadowMapTypeDefine="SHADOWMAP_TYPE_BASIC";
1===parameters.shadowMapType?shadowMapTypeDefine="SHADOWMAP_TYPE_PCF":2===parameters.shadowMapType?shadowMapTypeDefine="SHADOWMAP_TYPE_PCF_SOFT":3===parameters.shadowMapType&&(shadowMapTypeDefine="SHADOWMAP_TYPE_VSM");return shadowMapTypeDefine}function generateEnvMapTypeDefine(parameters){let envMapTypeDefine="ENVMAP_TYPE_CUBE";if(parameters.envMap)switch(parameters.envMapMode){case 301:case 302:envMapTypeDefine="ENVMAP_TYPE_CUBE";break;case 306:envMapTypeDefine="ENVMAP_TYPE_CUBE_UV"}return envMapTypeDefine}
function generateEnvMapModeDefine(parameters){let envMapModeDefine="ENVMAP_MODE_REFLECTION";if(parameters.envMap)switch(parameters.envMapMode){case 302:envMapModeDefine="ENVMAP_MODE_REFRACTION"}return envMapModeDefine}function generateEnvMapBlendingDefine(parameters){let envMapBlendingDefine="ENVMAP_BLENDING_NONE";if(parameters.envMap)switch(parameters.combine){case 0:envMapBlendingDefine="ENVMAP_BLENDING_MULTIPLY";break;case 1:envMapBlendingDefine="ENVMAP_BLENDING_MIX";break;case 2:envMapBlendingDefine=
"ENVMAP_BLENDING_ADD"}return envMapBlendingDefine}function generateCubeUVSize(parameters){parameters=parameters.envMapCubeUVHeight;if(null===parameters)return null;const maxMip=Math.log2(parameters)-2;return{texelWidth:1/(3*Math.max(Math.pow(2,maxMip),112)),texelHeight:1/parameters,maxMip}}function WebGLProgram(renderer,cacheKey,parameters,bindingStates){const gl=renderer.getContext();var defines=parameters.defines,vertexShader=parameters.vertexShader,fragmentShader=parameters.fragmentShader,shadowMapTypeDefine=
generateShadowMapTypeDefine(parameters),envMapTypeDefine=generateEnvMapTypeDefine(parameters),envMapModeDefine=generateEnvMapModeDefine(parameters),envMapBlendingDefine=generateEnvMapBlendingDefine(parameters),envMapCubeUVSize=generateCubeUVSize(parameters),customExtensions=parameters.isWebGL2?"":[parameters.extensionDerivatives||parameters.envMapCubeUVHeight||parameters.bumpMap||parameters.tangentSpaceNormalMap||parameters.clearcoatNormalMap||parameters.flatShading||"physical"===parameters.shaderID?
"#extension GL_OES_standard_derivatives : enable":"",(parameters.extensionFragDepth||parameters.logarithmicDepthBuffer)&&parameters.rendererExtensionFragDepth?"#extension GL_EXT_frag_depth : enable":"",parameters.extensionDrawBuffers&&parameters.rendererExtensionDrawBuffers?"#extension GL_EXT_draw_buffers : require":"",(parameters.extensionShaderTextureLOD||parameters.envMap||parameters.transmission)&&parameters.rendererExtensionShaderTextureLod?"#extension GL_EXT_shader_texture_lod : enable":""].filter(filterEmptyLine).join("\n");
const customDefines=generateDefines(defines),program=gl.createProgram();var versionString=parameters.glslVersion?"#version "+parameters.glslVersion+"\n":"";parameters.isRawShaderMaterial?(defines=[customDefines].filter(filterEmptyLine).join("\n"),0<defines.length&&(defines+="\n"),shadowMapTypeDefine=[customExtensions,customDefines].filter(filterEmptyLine).join("\n"),0<shadowMapTypeDefine.length&&(shadowMapTypeDefine+="\n")):(defines=[generatePrecision(parameters),"#define SHADER_NAME "+parameters.shaderName,
customDefines,parameters.instancing?"#define USE_INSTANCING":"",parameters.instancingColor?"#define USE_INSTANCING_COLOR":"",parameters.supportsVertexTextures?"#define VERTEX_TEXTURES":"",parameters.useFog&&parameters.fog?"#define USE_FOG":"",parameters.useFog&&parameters.fogExp2?"#define FOG_EXP2":"",parameters.map?"#define USE_MAP":"",parameters.envMap?"#define USE_ENVMAP":"",parameters.envMap?"#define "+envMapModeDefine:"",parameters.lightMap?"#define USE_LIGHTMAP":"",parameters.aoMap?"#define USE_AOMAP":
"",parameters.emissiveMap?"#define USE_EMISSIVEMAP":"",parameters.bumpMap?"#define USE_BUMPMAP":"",parameters.normalMap?"#define USE_NORMALMAP":"",parameters.normalMap&&parameters.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",parameters.normalMap&&parameters.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",parameters.clearcoatMap?"#define USE_CLEARCOATMAP":"",parameters.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",parameters.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":
"",parameters.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",parameters.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",parameters.displacementMap&&parameters.supportsVertexTextures?"#define USE_DISPLACEMENTMAP":"",parameters.specularMap?"#define USE_SPECULARMAP":"",parameters.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":"",parameters.specularColorMap?"#define USE_SPECULARCOLORMAP":"",parameters.roughnessMap?"#define USE_ROUGHNESSMAP":"",parameters.metalnessMap?"#define USE_METALNESSMAP":
"",parameters.alphaMap?"#define USE_ALPHAMAP":"",parameters.transmission?"#define USE_TRANSMISSION":"",parameters.transmissionMap?"#define USE_TRANSMISSIONMAP":"",parameters.thicknessMap?"#define USE_THICKNESSMAP":"",parameters.sheenColorMap?"#define USE_SHEENCOLORMAP":"",parameters.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",parameters.vertexTangents?"#define USE_TANGENT":"",parameters.vertexColors?"#define USE_COLOR":"",parameters.vertexAlphas?"#define USE_COLOR_ALPHA":"",parameters.vertexUvs?
"#define USE_UV":"",parameters.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",parameters.flatShading?"#define FLAT_SHADED":"",parameters.skinning?"#define USE_SKINNING":"",parameters.morphTargets?"#define USE_MORPHTARGETS":"",parameters.morphNormals&&!1===parameters.flatShading?"#define USE_MORPHNORMALS":"",parameters.morphColors&&parameters.isWebGL2?"#define USE_MORPHCOLORS":"",0<parameters.morphTargetsCount&&parameters.isWebGL2?"#define MORPHTARGETS_TEXTURE":"",0<parameters.morphTargetsCount&&parameters.isWebGL2?
"#define MORPHTARGETS_TEXTURE_STRIDE "+parameters.morphTextureStride:"",0<parameters.morphTargetsCount&&parameters.isWebGL2?"#define MORPHTARGETS_COUNT "+parameters.morphTargetsCount:"",parameters.doubleSided?"#define DOUBLE_SIDED":"",parameters.flipSided?"#define FLIP_SIDED":"",parameters.shadowMapEnabled?"#define USE_SHADOWMAP":"",parameters.shadowMapEnabled?"#define "+shadowMapTypeDefine:"",parameters.sizeAttenuation?"#define USE_SIZEATTENUATION":"",parameters.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":
"",parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","\tattribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","\tattribute vec3 instanceColor;","#endif","attribute vec3 position;","attribute vec3 normal;",
"attribute vec2 uv;","#ifdef USE_TANGENT","\tattribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","\tattribute vec4 color;","#elif defined( USE_COLOR )","\tattribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) \x26\x26 ! defined( MORPHTARGETS_TEXTURE ) )","\tattribute vec3 morphTarget0;","\tattribute vec3 morphTarget1;","\tattribute vec3 morphTarget2;","\tattribute vec3 morphTarget3;","\t#ifdef USE_MORPHNORMALS","\t\tattribute vec3 morphNormal0;","\t\tattribute vec3 morphNormal1;",
"\t\tattribute vec3 morphNormal2;","\t\tattribute vec3 morphNormal3;","\t#else","\t\tattribute vec3 morphTarget4;","\t\tattribute vec3 morphTarget5;","\t\tattribute vec3 morphTarget6;","\t\tattribute vec3 morphTarget7;","\t#endif","#endif","#ifdef USE_SKINNING","\tattribute vec4 skinIndex;","\tattribute vec4 skinWeight;","#endif","\n"].filter(filterEmptyLine).join("\n"),shadowMapTypeDefine=[customExtensions,generatePrecision(parameters),"#define SHADER_NAME "+parameters.shaderName,customDefines,parameters.useFog&&
parameters.fog?"#define USE_FOG":"",parameters.useFog&&parameters.fogExp2?"#define FOG_EXP2":"",parameters.map?"#define USE_MAP":"",parameters.matcap?"#define USE_MATCAP":"",parameters.envMap?"#define USE_ENVMAP":"",parameters.envMap?"#define "+envMapTypeDefine:"",parameters.envMap?"#define "+envMapModeDefine:"",parameters.envMap?"#define "+envMapBlendingDefine:"",envMapCubeUVSize?"#define CUBEUV_TEXEL_WIDTH "+envMapCubeUVSize.texelWidth:"",envMapCubeUVSize?"#define CUBEUV_TEXEL_HEIGHT "+envMapCubeUVSize.texelHeight:
"",envMapCubeUVSize?"#define CUBEUV_MAX_MIP "+envMapCubeUVSize.maxMip+".0":"",parameters.lightMap?"#define USE_LIGHTMAP":"",parameters.aoMap?"#define USE_AOMAP":"",parameters.emissiveMap?"#define USE_EMISSIVEMAP":"",parameters.bumpMap?"#define USE_BUMPMAP":"",parameters.normalMap?"#define USE_NORMALMAP":"",parameters.normalMap&&parameters.objectSpaceNormalMap?"#define OBJECTSPACE_NORMALMAP":"",parameters.normalMap&&parameters.tangentSpaceNormalMap?"#define TANGENTSPACE_NORMALMAP":"",parameters.clearcoat?
"#define USE_CLEARCOAT":"",parameters.clearcoatMap?"#define USE_CLEARCOATMAP":"",parameters.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",parameters.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",parameters.iridescence?"#define USE_IRIDESCENCE":"",parameters.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",parameters.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",parameters.specularMap?"#define USE_SPECULARMAP":"",parameters.specularIntensityMap?"#define USE_SPECULARINTENSITYMAP":
"",parameters.specularColorMap?"#define USE_SPECULARCOLORMAP":"",parameters.roughnessMap?"#define USE_ROUGHNESSMAP":"",parameters.metalnessMap?"#define USE_METALNESSMAP":"",parameters.alphaMap?"#define USE_ALPHAMAP":"",parameters.alphaTest?"#define USE_ALPHATEST":"",parameters.sheen?"#define USE_SHEEN":"",parameters.sheenColorMap?"#define USE_SHEENCOLORMAP":"",parameters.sheenRoughnessMap?"#define USE_SHEENROUGHNESSMAP":"",parameters.transmission?"#define USE_TRANSMISSION":"",parameters.transmissionMap?
"#define USE_TRANSMISSIONMAP":"",parameters.thicknessMap?"#define USE_THICKNESSMAP":"",parameters.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",parameters.vertexTangents?"#define USE_TANGENT":"",parameters.vertexColors||parameters.instancingColor?"#define USE_COLOR":"",parameters.vertexAlphas?"#define USE_COLOR_ALPHA":"",parameters.vertexUvs?"#define USE_UV":"",parameters.uvsVertexOnly?"#define UVS_VERTEX_ONLY":"",parameters.gradientMap?"#define USE_GRADIENTMAP":"",parameters.flatShading?"#define FLAT_SHADED":
"",parameters.doubleSided?"#define DOUBLE_SIDED":"",parameters.flipSided?"#define FLIP_SIDED":"",parameters.shadowMapEnabled?"#define USE_SHADOWMAP":"",parameters.shadowMapEnabled?"#define "+shadowMapTypeDefine:"",parameters.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",parameters.physicallyCorrectLights?"#define PHYSICALLY_CORRECT_LIGHTS":"",parameters.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",parameters.logarithmicDepthBuffer&&parameters.rendererExtensionFragDepth?"#define USE_LOGDEPTHBUF_EXT":
"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",0!==parameters.toneMapping?"#define TONE_MAPPING":"",0!==parameters.toneMapping?ShaderChunk.tonemapping_pars_fragment:"",0!==parameters.toneMapping?getToneMappingFunction("toneMapping",parameters.toneMapping):"",parameters.dithering?"#define DITHERING":"",parameters.opaque?"#define OPAQUE":"",ShaderChunk.encodings_pars_fragment,getTexelEncodingFunction("linearToOutputTexel",parameters.outputEncoding),parameters.useDepthPacking?
"#define DEPTH_PACKING "+parameters.depthPacking:"","\n"].filter(filterEmptyLine).join("\n"));vertexShader=vertexShader.replace(includePattern,includeReplacer);vertexShader=replaceLightNums(vertexShader,parameters);vertexShader=replaceClippingPlaneNums(vertexShader,parameters);fragmentShader=fragmentShader.replace(includePattern,includeReplacer);fragmentShader=replaceLightNums(fragmentShader,parameters);fragmentShader=replaceClippingPlaneNums(fragmentShader,parameters);vertexShader=vertexShader.replace(unrollLoopPattern,
loopReplacer);fragmentShader=fragmentShader.replace(unrollLoopPattern,loopReplacer);parameters.isWebGL2&&!0!==parameters.isRawShaderMaterial&&(versionString="#version 300 es\n",defines="precision mediump sampler2DArray;\n#define attribute in\n#define varying out\n#define texture2D texture\n"+defines,shadowMapTypeDefine=["#define varying in","300 es"===parameters.glslVersion?"":"layout(location \x3d 0) out highp vec4 pc_fragColor;","300 es"===parameters.glslVersion?"":"#define gl_FragColor pc_fragColor",
"#define gl_FragDepthEXT gl_FragDepth\n#define texture2D texture\n#define textureCube texture\n#define texture2DProj textureProj\n#define texture2DLodEXT textureLod\n#define texture2DProjLodEXT textureProjLod\n#define textureCubeLodEXT textureLod\n#define texture2DGradEXT textureGrad\n#define texture2DProjGradEXT textureProjGrad\n#define textureCubeGradEXT textureGrad"].join("\n")+"\n"+shadowMapTypeDefine);fragmentShader=versionString+shadowMapTypeDefine+fragmentShader;vertexShader=WebGLShader(gl,
gl.VERTEX_SHADER,versionString+defines+vertexShader);fragmentShader=WebGLShader(gl,gl.FRAGMENT_SHADER,fragmentShader);gl.attachShader(program,vertexShader);gl.attachShader(program,fragmentShader);void 0!==parameters.index0AttributeName?gl.bindAttribLocation(program,0,parameters.index0AttributeName):!0===parameters.morphTargets&&gl.bindAttribLocation(program,0,"position");gl.linkProgram(program);if(renderer.debug.checkShaderErrors){renderer=gl.getProgramInfoLog(program).trim();versionString=gl.getShaderInfoLog(vertexShader).trim();
envMapTypeDefine=gl.getShaderInfoLog(fragmentShader).trim();envMapBlendingDefine=envMapModeDefine=!0;if(!1===gl.getProgramParameter(program,gl.LINK_STATUS))envMapModeDefine=!1,envMapCubeUVSize=getShaderErrors(gl,vertexShader,"vertex"),customExtensions=getShaderErrors(gl,fragmentShader,"fragment"),console.error("THREE.WebGLProgram: Shader Error "+gl.getError()+" - VALIDATE_STATUS "+gl.getProgramParameter(program,gl.VALIDATE_STATUS)+"\n\nProgram Info Log: "+renderer+"\n"+envMapCubeUVSize+"\n"+customExtensions);
else if(""!==renderer)console.warn("THREE.WebGLProgram: Program Info Log:",renderer);else if(""===versionString||""===envMapTypeDefine)envMapBlendingDefine=!1;envMapBlendingDefine&&(this.diagnostics={runnable:envMapModeDefine,programLog:renderer,vertexShader:{log:versionString,prefix:defines},fragmentShader:{log:envMapTypeDefine,prefix:shadowMapTypeDefine}})}gl.deleteShader(vertexShader);gl.deleteShader(fragmentShader);let cachedUniforms;this.getUniforms=function(){void 0===cachedUniforms&&(cachedUniforms=
new WebGLUniforms(gl,program));return cachedUniforms};let cachedAttributes;this.getAttributes=function(){if(void 0===cachedAttributes){const attributes={},n=gl.getProgramParameter(program,gl.ACTIVE_ATTRIBUTES);for(let i=0;i<n;i++){const info=gl.getActiveAttrib(program,i),name=info.name;let locationSize=1;info.type===gl.FLOAT_MAT2&&(locationSize=2);info.type===gl.FLOAT_MAT3&&(locationSize=3);info.type===gl.FLOAT_MAT4&&(locationSize=4);attributes[name]={type:info.type,location:gl.getAttribLocation(program,
name),locationSize}}cachedAttributes=attributes}return cachedAttributes};this.destroy=function(){bindingStates.releaseStatesOfProgram(this);gl.deleteProgram(program);this.program=void 0};this.name=parameters.shaderName;this.id=programIdCount++;this.cacheKey=cacheKey;this.usedTimes=1;this.program=program;this.vertexShader=vertexShader;this.fragmentShader=fragmentShader;return this}function WebGLPrograms(renderer,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping){const _programLayers=
new Layers,_customShaders=new WebGLShaderCache,programs=[],isWebGL2=capabilities.isWebGL2,logarithmicDepthBuffer=capabilities.logarithmicDepthBuffer,vertexTextures=capabilities.vertexTextures;let precision=capabilities.precision;const shaderIDs={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",
MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};return{getParameters:function(material,lights,shadows,scene,object){const fog=scene.fog,geometry=object.geometry;scene=material.isMeshStandardMaterial?scene.environment:null;const envMapCubeUVHeight=(scene=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||scene))&&306===scene.mapping?scene.image.height:null,shaderID=shaderIDs[material.type];
null!==material.precision&&(precision=capabilities.getMaxPrecision(material.precision),precision!==material.precision&&console.warn("THREE.WebGLProgram.getParameters:",material.precision,"not supported, using",precision,"instead."));var morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;morphAttribute=void 0!==morphAttribute?morphAttribute.length:0;let morphTextureStride=0;void 0!==geometry.morphAttributes.position&&(morphTextureStride=
1);void 0!==geometry.morphAttributes.normal&&(morphTextureStride=2);void 0!==geometry.morphAttributes.color&&(morphTextureStride=3);let vertexShader;let customVertexShaderID,customFragmentShaderID;if(shaderID){var fragmentShader=ShaderLib[shaderID];vertexShader=fragmentShader.vertexShader;fragmentShader=fragmentShader.fragmentShader}else vertexShader=material.vertexShader,fragmentShader=material.fragmentShader,_customShaders.update(material),customVertexShaderID=_customShaders.getVertexShaderID(material),
customFragmentShaderID=_customShaders.getFragmentShaderID(material);const currentRenderTarget=renderer.getRenderTarget(),useClearcoat=0<material.clearcoat,useIridescence=0<material.iridescence;return{isWebGL2,shaderID,shaderName:material.type,vertexShader,fragmentShader,defines:material.defines,customVertexShaderID,customFragmentShaderID,isRawShaderMaterial:!0===material.isRawShaderMaterial,glslVersion:material.glslVersion,precision,instancing:!0===object.isInstancedMesh,instancingColor:!0===object.isInstancedMesh&&
null!==object.instanceColor,supportsVertexTextures:vertexTextures,outputEncoding:null===currentRenderTarget?renderer.outputEncoding:!0===currentRenderTarget.isXRRenderTarget?currentRenderTarget.texture.encoding:3E3,map:!!material.map,matcap:!!material.matcap,envMap:!!scene,envMapMode:scene&&scene.mapping,envMapCubeUVHeight,lightMap:!!material.lightMap,aoMap:!!material.aoMap,emissiveMap:!!material.emissiveMap,bumpMap:!!material.bumpMap,normalMap:!!material.normalMap,objectSpaceNormalMap:1===material.normalMapType,
tangentSpaceNormalMap:0===material.normalMapType,decodeVideoTexture:!!material.map&&!0===material.map.isVideoTexture&&3001===material.map.encoding,clearcoat:useClearcoat,clearcoatMap:useClearcoat&&!!material.clearcoatMap,clearcoatRoughnessMap:useClearcoat&&!!material.clearcoatRoughnessMap,clearcoatNormalMap:useClearcoat&&!!material.clearcoatNormalMap,iridescence:useIridescence,iridescenceMap:useIridescence&&!!material.iridescenceMap,iridescenceThicknessMap:useIridescence&&!!material.iridescenceThicknessMap,
displacementMap:!!material.displacementMap,roughnessMap:!!material.roughnessMap,metalnessMap:!!material.metalnessMap,specularMap:!!material.specularMap,specularIntensityMap:!!material.specularIntensityMap,specularColorMap:!!material.specularColorMap,opaque:!1===material.transparent&&1===material.blending,alphaMap:!!material.alphaMap,alphaTest:0<material.alphaTest,gradientMap:!!material.gradientMap,sheen:0<material.sheen,sheenColorMap:!!material.sheenColorMap,sheenRoughnessMap:!!material.sheenRoughnessMap,
transmission:0<material.transmission,transmissionMap:!!material.transmissionMap,thicknessMap:!!material.thicknessMap,combine:material.combine,vertexTangents:!!material.normalMap&&!!geometry.attributes.tangent,vertexColors:material.vertexColors,vertexAlphas:!0===material.vertexColors&&!!geometry.attributes.color&&4===geometry.attributes.color.itemSize,vertexUvs:!!material.map||!!material.bumpMap||!!material.normalMap||!!material.specularMap||!!material.alphaMap||!!material.emissiveMap||!!material.roughnessMap||
!!material.metalnessMap||!!material.clearcoatMap||!!material.clearcoatRoughnessMap||!!material.clearcoatNormalMap||!!material.iridescenceMap||!!material.iridescenceThicknessMap||!!material.displacementMap||!!material.transmissionMap||!!material.thicknessMap||!!material.specularIntensityMap||!!material.specularColorMap||!!material.sheenColorMap||!!material.sheenRoughnessMap,uvsVertexOnly:!(material.map||material.bumpMap||material.normalMap||material.specularMap||material.alphaMap||material.emissiveMap||
material.roughnessMap||material.metalnessMap||material.clearcoatNormalMap||material.iridescenceMap||material.iridescenceThicknessMap||0<material.transmission||material.transmissionMap||material.thicknessMap||material.specularIntensityMap||material.specularColorMap||0<material.sheen||material.sheenColorMap||material.sheenRoughnessMap)&&!!material.displacementMap,fog:!!fog,useFog:!0===material.fog,fogExp2:fog&&fog.isFogExp2,flatShading:!!material.flatShading,sizeAttenuation:material.sizeAttenuation,
logarithmicDepthBuffer,skinning:!0===object.isSkinnedMesh,morphTargets:void 0!==geometry.morphAttributes.position,morphNormals:void 0!==geometry.morphAttributes.normal,morphColors:void 0!==geometry.morphAttributes.color,morphTargetsCount:morphAttribute,morphTextureStride,numDirLights:lights.directional.length,numPointLights:lights.point.length,numSpotLights:lights.spot.length,numSpotLightMaps:lights.spotLightMap.length,numRectAreaLights:lights.rectArea.length,numHemiLights:lights.hemi.length,numDirLightShadows:lights.directionalShadowMap.length,
numPointLightShadows:lights.pointShadowMap.length,numSpotLightShadows:lights.spotShadowMap.length,numSpotLightShadowsWithMaps:lights.numSpotLightShadowsWithMaps,numClippingPlanes:clipping.numPlanes,numClipIntersection:clipping.numIntersection,dithering:material.dithering,shadowMapEnabled:renderer.shadowMap.enabled&&0<shadows.length,shadowMapType:renderer.shadowMap.type,toneMapping:material.toneMapped?renderer.toneMapping:0,physicallyCorrectLights:renderer.physicallyCorrectLights,premultipliedAlpha:material.premultipliedAlpha,
doubleSided:2===material.side,flipSided:1===material.side,useDepthPacking:!!material.depthPacking,depthPacking:material.depthPacking||0,index0AttributeName:material.index0AttributeName,extensionDerivatives:material.extensions&&material.extensions.derivatives,extensionFragDepth:material.extensions&&material.extensions.fragDepth,extensionDrawBuffers:material.extensions&&material.extensions.drawBuffers,extensionShaderTextureLOD:material.extensions&&material.extensions.shaderTextureLOD,rendererExtensionFragDepth:isWebGL2||
extensions.has("EXT_frag_depth"),rendererExtensionDrawBuffers:isWebGL2||extensions.has("WEBGL_draw_buffers"),rendererExtensionShaderTextureLod:isWebGL2||extensions.has("EXT_shader_texture_lod"),customProgramCacheKey:material.customProgramCacheKey()}},getProgramCacheKey:function(parameters){const array=[];parameters.shaderID?array.push(parameters.shaderID):(array.push(parameters.customVertexShaderID),array.push(parameters.customFragmentShaderID));if(void 0!==parameters.defines)for(const name in parameters.defines)array.push(name),
array.push(parameters.defines[name]);!1===parameters.isRawShaderMaterial&&(array.push(parameters.precision),array.push(parameters.outputEncoding),array.push(parameters.envMapMode),array.push(parameters.envMapCubeUVHeight),array.push(parameters.combine),array.push(parameters.vertexUvs),array.push(parameters.fogExp2),array.push(parameters.sizeAttenuation),array.push(parameters.morphTargetsCount),array.push(parameters.morphAttributeCount),array.push(parameters.numDirLights),array.push(parameters.numPointLights),
array.push(parameters.numSpotLights),array.push(parameters.numSpotLightMaps),array.push(parameters.numHemiLights),array.push(parameters.numRectAreaLights),array.push(parameters.numDirLightShadows),array.push(parameters.numPointLightShadows),array.push(parameters.numSpotLightShadows),array.push(parameters.numSpotLightShadowsWithMaps),array.push(parameters.shadowMapType),array.push(parameters.toneMapping),array.push(parameters.numClippingPlanes),array.push(parameters.numClipIntersection),array.push(parameters.depthPacking),
_programLayers.disableAll(),parameters.isWebGL2&&_programLayers.enable(0),parameters.supportsVertexTextures&&_programLayers.enable(1),parameters.instancing&&_programLayers.enable(2),parameters.instancingColor&&_programLayers.enable(3),parameters.map&&_programLayers.enable(4),parameters.matcap&&_programLayers.enable(5),parameters.envMap&&_programLayers.enable(6),parameters.lightMap&&_programLayers.enable(7),parameters.aoMap&&_programLayers.enable(8),parameters.emissiveMap&&_programLayers.enable(9),
parameters.bumpMap&&_programLayers.enable(10),parameters.normalMap&&_programLayers.enable(11),parameters.objectSpaceNormalMap&&_programLayers.enable(12),parameters.tangentSpaceNormalMap&&_programLayers.enable(13),parameters.clearcoat&&_programLayers.enable(14),parameters.clearcoatMap&&_programLayers.enable(15),parameters.clearcoatRoughnessMap&&_programLayers.enable(16),parameters.clearcoatNormalMap&&_programLayers.enable(17),parameters.iridescence&&_programLayers.enable(18),parameters.iridescenceMap&&
_programLayers.enable(19),parameters.iridescenceThicknessMap&&_programLayers.enable(20),parameters.displacementMap&&_programLayers.enable(21),parameters.specularMap&&_programLayers.enable(22),parameters.roughnessMap&&_programLayers.enable(23),parameters.metalnessMap&&_programLayers.enable(24),parameters.gradientMap&&_programLayers.enable(25),parameters.alphaMap&&_programLayers.enable(26),parameters.alphaTest&&_programLayers.enable(27),parameters.vertexColors&&_programLayers.enable(28),parameters.vertexAlphas&&
_programLayers.enable(29),parameters.vertexUvs&&_programLayers.enable(30),parameters.vertexTangents&&_programLayers.enable(31),parameters.uvsVertexOnly&&_programLayers.enable(32),array.push(_programLayers.mask),_programLayers.disableAll(),parameters.fog&&_programLayers.enable(0),parameters.useFog&&_programLayers.enable(1),parameters.flatShading&&_programLayers.enable(2),parameters.logarithmicDepthBuffer&&_programLayers.enable(3),parameters.skinning&&_programLayers.enable(4),parameters.morphTargets&&
_programLayers.enable(5),parameters.morphNormals&&_programLayers.enable(6),parameters.morphColors&&_programLayers.enable(7),parameters.premultipliedAlpha&&_programLayers.enable(8),parameters.shadowMapEnabled&&_programLayers.enable(9),parameters.physicallyCorrectLights&&_programLayers.enable(10),parameters.doubleSided&&_programLayers.enable(11),parameters.flipSided&&_programLayers.enable(12),parameters.useDepthPacking&&_programLayers.enable(13),parameters.dithering&&_programLayers.enable(14),parameters.specularIntensityMap&&
_programLayers.enable(15),parameters.specularColorMap&&_programLayers.enable(16),parameters.transmission&&_programLayers.enable(17),parameters.transmissionMap&&_programLayers.enable(18),parameters.thicknessMap&&_programLayers.enable(19),parameters.sheen&&_programLayers.enable(20),parameters.sheenColorMap&&_programLayers.enable(21),parameters.sheenRoughnessMap&&_programLayers.enable(22),parameters.decodeVideoTexture&&_programLayers.enable(23),parameters.opaque&&_programLayers.enable(24),array.push(_programLayers.mask),
array.push(renderer.outputEncoding));array.push(parameters.customProgramCacheKey);return array.join()},getUniforms:function(material){const shaderID=shaderIDs[material.type];return shaderID?UniformsUtils.clone(ShaderLib[shaderID].uniforms):material.uniforms},acquireProgram:function(parameters,cacheKey){let program;for(let p=0,pl=programs.length;p<pl;p++){const preexistingProgram=programs[p];if(preexistingProgram.cacheKey===cacheKey){program=preexistingProgram;++program.usedTimes;break}}void 0===program&&
(program=new WebGLProgram(renderer,cacheKey,parameters,bindingStates),programs.push(program));return program},releaseProgram:function(program){if(0===--program.usedTimes){const i=programs.indexOf(program);programs[i]=programs[programs.length-1];programs.pop();program.destroy()}},releaseShaderCache:function(material){_customShaders.remove(material)},programs,dispose:function(){_customShaders.dispose()}}}function WebGLProperties(){let properties=new WeakMap;return{get:function(object){let map=properties.get(object);
void 0===map&&(map={},properties.set(object,map));return map},remove:function(object){properties.delete(object)},update:function(object,key,value){properties.get(object)[key]=value},dispose:function(){properties=new WeakMap}}}function painterSortStable(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.material.id!==b.material.id?a.material.id-b.material.id:a.z!==b.z?a.z-b.z:a.id-b.id}function reversePainterSortStable(a,b){return a.groupOrder!==
b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function WebGLRenderList(){function getNextRenderItem(object,geometry,material,groupOrder,z,group){let renderItem=renderItems[renderItemsIndex];void 0===renderItem?(renderItem={id:object.id,object,geometry,material,groupOrder,renderOrder:object.renderOrder,z,group},renderItems[renderItemsIndex]=renderItem):(renderItem.id=object.id,renderItem.object=object,renderItem.geometry=
geometry,renderItem.material=material,renderItem.groupOrder=groupOrder,renderItem.renderOrder=object.renderOrder,renderItem.z=z,renderItem.group=group);renderItemsIndex++;return renderItem}const renderItems=[];let renderItemsIndex=0;const opaque=[],transmissive=[],transparent=[];return{opaque,transmissive,transparent,init:function(){renderItemsIndex=0;opaque.length=0;transmissive.length=0;transparent.length=0},push:function(object,geometry,material,groupOrder,z,group){object=getNextRenderItem(object,
geometry,material,groupOrder,z,group);0<material.transmission?transmissive.push(object):!0===material.transparent?transparent.push(object):opaque.push(object)},unshift:function(object,geometry,material,groupOrder,z,group){object=getNextRenderItem(object,geometry,material,groupOrder,z,group);0<material.transmission?transmissive.unshift(object):!0===material.transparent?transparent.unshift(object):opaque.unshift(object)},finish:function(){for(let i=renderItemsIndex,il=renderItems.length;i<il;i++){const renderItem=
renderItems[i];if(null===renderItem.id)break;renderItem.id=null;renderItem.object=null;renderItem.geometry=null;renderItem.material=null;renderItem.group=null}},sort:function(customOpaqueSort,customTransparentSort){1<opaque.length&&opaque.sort(customOpaqueSort||painterSortStable);1<transmissive.length&&transmissive.sort(customTransparentSort||reversePainterSortStable);1<transparent.length&&transparent.sort(customTransparentSort||reversePainterSortStable)}}}function WebGLRenderLists(){let lists=new WeakMap;
return{get:function(scene,renderCallDepth){const listArray=lists.get(scene);void 0===listArray?(renderCallDepth=new WebGLRenderList,lists.set(scene,[renderCallDepth])):renderCallDepth>=listArray.length?(renderCallDepth=new WebGLRenderList,listArray.push(renderCallDepth)):renderCallDepth=listArray[renderCallDepth];return renderCallDepth},dispose:function(){lists=new WeakMap}}}function UniformsCache(){const lights={};return{get:function(light){if(void 0!==lights[light.id])return lights[light.id];let uniforms;
switch(light.type){case "DirectionalLight":uniforms={direction:new Vector3,color:new Color};break;case "SpotLight":uniforms={position:new Vector3,direction:new Vector3,color:new Color,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case "PointLight":uniforms={position:new Vector3,color:new Color,distance:0,decay:0};break;case "HemisphereLight":uniforms={direction:new Vector3,skyColor:new Color,groundColor:new Color};break;case "RectAreaLight":uniforms={color:new Color,position:new Vector3,halfWidth:new Vector3,
halfHeight:new Vector3}}return lights[light.id]=uniforms}}}function ShadowUniformsCache(){const lights={};return{get:function(light){if(void 0!==lights[light.id])return lights[light.id];let uniforms;switch(light.type){case "DirectionalLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case "SpotLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Vector2};break;case "PointLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,
shadowMapSize:new Vector2,shadowCameraNear:1,shadowCameraFar:1E3}}return lights[light.id]=uniforms}}}function shadowCastingAndTexturingLightsFirst(lightA,lightB){return(lightB.castShadow?2:0)-(lightA.castShadow?2:0)+(lightB.map?1:0)-(lightA.map?1:0)}function WebGLLights(extensions,capabilities){const cache=new UniformsCache,shadowCache=ShadowUniformsCache(),state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,
numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let i=0;9>i;i++)state.probe.push(new Vector3);const vector3=new Vector3,matrix4=new Matrix4,matrix42=new Matrix4;return{setup:function(lights,
physicallyCorrectLights){let r=0,g=0,b=0;for(var i$jscomp$0=0;9>i$jscomp$0;i$jscomp$0++)state.probe[i$jscomp$0].set(0,0,0);let pointLength=i$jscomp$0=0,spotLength=0,rectAreaLength=0,hemiLength=0,numDirectionalShadows=0,numPointShadows=0,numSpotShadows=0,numSpotMaps=0,numSpotShadowsWithMaps=0;lights.sort(shadowCastingAndTexturingLightsFirst);physicallyCorrectLights=!0!==physicallyCorrectLights?Math.PI:1;for(let i=0,l=lights.length;i<l;i++){var light=lights[i],color=light.color,intensity=light.intensity,
distance=light.distance,shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight)r+=color.r*intensity*physicallyCorrectLights,g+=color.g*intensity*physicallyCorrectLights,b+=color.b*intensity*physicallyCorrectLights;else if(light.isLightProbe)for(shadowMap=0;9>shadowMap;shadowMap++)state.probe[shadowMap].addScaledVector(light.sh.coefficients[shadowMap],intensity);else if(light.isDirectionalLight)intensity=cache.get(light),intensity.color.copy(light.color).multiplyScalar(light.intensity*
physicallyCorrectLights),light.castShadow&&(color=light.shadow,distance=shadowCache.get(light),distance.shadowBias=color.bias,distance.shadowNormalBias=color.normalBias,distance.shadowRadius=color.radius,distance.shadowMapSize=color.mapSize,state.directionalShadow[i$jscomp$0]=distance,state.directionalShadowMap[i$jscomp$0]=shadowMap,state.directionalShadowMatrix[i$jscomp$0]=light.shadow.matrix,numDirectionalShadows++),state.directional[i$jscomp$0]=intensity,i$jscomp$0++;else if(light.isSpotLight){const uniforms=
cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);uniforms.color.copy(color).multiplyScalar(intensity*physicallyCorrectLights);uniforms.distance=distance;uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.decay;state.spot[spotLength]=uniforms;intensity=light.shadow;light.map&&(state.spotLightMap[numSpotMaps]=light.map,numSpotMaps++,intensity.updateMatrices(light),light.castShadow&&numSpotShadowsWithMaps++);
state.spotLightMatrix[spotLength]=intensity.matrix;light.castShadow&&(light=shadowCache.get(light),light.shadowBias=intensity.bias,light.shadowNormalBias=intensity.normalBias,light.shadowRadius=intensity.radius,light.shadowMapSize=intensity.mapSize,state.spotShadow[spotLength]=light,state.spotShadowMap[spotLength]=shadowMap,numSpotShadows++);spotLength++}else light.isRectAreaLight?(shadowMap=cache.get(light),shadowMap.color.copy(color).multiplyScalar(intensity),shadowMap.halfWidth.set(.5*light.width,
0,0),shadowMap.halfHeight.set(0,.5*light.height,0),state.rectArea[rectAreaLength]=shadowMap,rectAreaLength++):light.isPointLight?(intensity=cache.get(light),intensity.color.copy(light.color).multiplyScalar(light.intensity*physicallyCorrectLights),intensity.distance=light.distance,intensity.decay=light.decay,light.castShadow&&(color=light.shadow,distance=shadowCache.get(light),distance.shadowBias=color.bias,distance.shadowNormalBias=color.normalBias,distance.shadowRadius=color.radius,distance.shadowMapSize=
color.mapSize,distance.shadowCameraNear=color.camera.near,distance.shadowCameraFar=color.camera.far,state.pointShadow[pointLength]=distance,state.pointShadowMap[pointLength]=shadowMap,state.pointShadowMatrix[pointLength]=light.shadow.matrix,numPointShadows++),state.point[pointLength]=intensity,pointLength++):light.isHemisphereLight&&(shadowMap=cache.get(light),shadowMap.skyColor.copy(light.color).multiplyScalar(intensity*physicallyCorrectLights),shadowMap.groundColor.copy(light.groundColor).multiplyScalar(intensity*
physicallyCorrectLights),state.hemi[hemiLength]=shadowMap,hemiLength++)}0<rectAreaLength&&(capabilities.isWebGL2?(state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):!0===extensions.has("OES_texture_float_linear")?(state.rectAreaLTC1=UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=UniformsLib.LTC_FLOAT_2):!0===extensions.has("OES_texture_half_float_linear")?(state.rectAreaLTC1=UniformsLib.LTC_HALF_1,state.rectAreaLTC2=UniformsLib.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."));
state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;lights=state.hash;if(lights.directionalLength!==i$jscomp$0||lights.pointLength!==pointLength||lights.spotLength!==spotLength||lights.rectAreaLength!==rectAreaLength||lights.hemiLength!==hemiLength||lights.numDirectionalShadows!==numDirectionalShadows||lights.numPointShadows!==numPointShadows||lights.numSpotShadows!==numSpotShadows||lights.numSpotMaps!==numSpotMaps)state.directional.length=i$jscomp$0,state.spot.length=spotLength,state.rectArea.length=
rectAreaLength,state.point.length=pointLength,state.hemi.length=hemiLength,state.directionalShadow.length=numDirectionalShadows,state.directionalShadowMap.length=numDirectionalShadows,state.pointShadow.length=numPointShadows,state.pointShadowMap.length=numPointShadows,state.spotShadow.length=numSpotShadows,state.spotShadowMap.length=numSpotShadows,state.directionalShadowMatrix.length=numDirectionalShadows,state.pointShadowMatrix.length=numPointShadows,state.spotLightMatrix.length=numSpotShadows+numSpotMaps-
numSpotShadowsWithMaps,state.spotLightMap.length=numSpotMaps,state.numSpotLightShadowsWithMaps=numSpotShadowsWithMaps,lights.directionalLength=i$jscomp$0,lights.pointLength=pointLength,lights.spotLength=spotLength,lights.rectAreaLength=rectAreaLength,lights.hemiLength=hemiLength,lights.numDirectionalShadows=numDirectionalShadows,lights.numPointShadows=numPointShadows,lights.numSpotShadows=numSpotShadows,lights.numSpotMaps=numSpotMaps,state.version=nextVersion++},setupView:function(lights,camera){let directionalLength=
0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;camera=camera.matrixWorldInverse;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];if(light.isDirectionalLight){var uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(camera);directionalLength++}else light.isSpotLight?(uniforms=state.spot[spotLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),
uniforms.position.applyMatrix4(camera),uniforms.direction.setFromMatrixPosition(light.matrixWorld),vector3.setFromMatrixPosition(light.target.matrixWorld),uniforms.direction.sub(vector3),uniforms.direction.transformDirection(camera),spotLength++):light.isRectAreaLight?(uniforms=state.rectArea[rectAreaLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(camera),matrix42.identity(),matrix4.copy(light.matrixWorld),matrix4.premultiply(camera),matrix42.extractRotation(matrix4),
uniforms.halfWidth.set(.5*light.width,0,0),uniforms.halfHeight.set(0,.5*light.height,0),uniforms.halfWidth.applyMatrix4(matrix42),uniforms.halfHeight.applyMatrix4(matrix42),rectAreaLength++):light.isPointLight?(uniforms=state.point[pointLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(camera),pointLength++):light.isHemisphereLight&&(uniforms=state.hemi[hemiLength],uniforms.direction.setFromMatrixPosition(light.matrixWorld),uniforms.direction.transformDirection(camera),
hemiLength++)}},state}}function WebGLRenderState(extensions,capabilities){const lights=new WebGLLights(extensions,capabilities),lightsArray=[],shadowsArray=[];return{init:function(){lightsArray.length=0;shadowsArray.length=0},state:{lightsArray,shadowsArray,lights},setupLights:function(physicallyCorrectLights){lights.setup(lightsArray,physicallyCorrectLights)},setupLightsView:function(camera){lights.setupView(lightsArray,camera)},pushLight:function(light){lightsArray.push(light)},pushShadow:function(shadowLight){shadowsArray.push(shadowLight)}}}
function WebGLRenderStates(extensions,capabilities){let renderStates=new WeakMap;return{get:function(scene,renderCallDepth=0){const renderStateArray=renderStates.get(scene);void 0===renderStateArray?(renderCallDepth=new WebGLRenderState(extensions,capabilities),renderStates.set(scene,[renderCallDepth])):renderCallDepth>=renderStateArray.length?(renderCallDepth=new WebGLRenderState(extensions,capabilities),renderStateArray.push(renderCallDepth)):renderCallDepth=renderStateArray[renderCallDepth];return renderCallDepth},
dispose:function(){renderStates=new WeakMap}}}function WebGLShadowMap(_renderer,_objects,_capabilities){function getDepthMaterial(object,material,light,shadowCameraNear,shadowCameraFar,type){object=!0===light.isPointLight?object.customDistanceMaterial:object.customDepthMaterial;object=void 0!==object?object:!0===light.isPointLight?_distanceMaterial:_depthMaterial;if(_renderer.localClippingEnabled&&!0===material.clipShadows&&Array.isArray(material.clippingPlanes)&&0!==material.clippingPlanes.length||
material.displacementMap&&0!==material.displacementScale||material.alphaMap&&0<material.alphaTest){var keyA=object.uuid;const keyB=material.uuid;let materialsForVariant=_materialCache[keyA];void 0===materialsForVariant&&(materialsForVariant={},_materialCache[keyA]=materialsForVariant);keyA=materialsForVariant[keyB];void 0===keyA&&(keyA=object.clone(),materialsForVariant[keyB]=keyA);object=keyA}object.visible=material.visible;object.wireframe=material.wireframe;object.side=3===type?null!==material.shadowSide?
material.shadowSide:material.side:null!==material.shadowSide?material.shadowSide:shadowSide[material.side];object.alphaMap=material.alphaMap;object.alphaTest=material.alphaTest;object.clipShadows=material.clipShadows;object.clippingPlanes=material.clippingPlanes;object.clipIntersection=material.clipIntersection;object.displacementMap=material.displacementMap;object.displacementScale=material.displacementScale;object.displacementBias=material.displacementBias;object.wireframeLinewidth=material.wireframeLinewidth;
object.linewidth=material.linewidth;!0===light.isPointLight&&!0===object.isMeshDistanceMaterial&&(object.referencePosition.setFromMatrixPosition(light.matrixWorld),object.nearDistance=shadowCameraNear,object.farDistance=shadowCameraFar);return object}function renderObject(object,camera,shadowCamera,light,type){if(!1!==object.visible){if(object.layers.test(camera.layers)&&(object.isMesh||object.isLine||object.isPoints)&&(object.castShadow||object.receiveShadow&&3===type)&&(!object.frustumCulled||_frustum.intersectsObject(object))){object.modelViewMatrix.multiplyMatrices(shadowCamera.matrixWorldInverse,
object.matrixWorld);const geometry=_objects.update(object);var material=object.material;if(Array.isArray(material)){const groups=geometry.groups;for(let k=0,kl=groups.length;k<kl;k++){const group=groups[k];var groupMaterial=material[group.materialIndex];groupMaterial&&groupMaterial.visible&&(groupMaterial=getDepthMaterial(object,groupMaterial,light,shadowCamera.near,shadowCamera.far,type),_renderer.renderBufferDirect(shadowCamera,null,geometry,groupMaterial,object,group))}}else material.visible&&
(material=getDepthMaterial(object,material,light,shadowCamera.near,shadowCamera.far,type),_renderer.renderBufferDirect(shadowCamera,null,geometry,material,object,null))}object=object.children;for(let i=0,l=object.length;i<l;i++)renderObject(object[i],camera,shadowCamera,light,type)}}let _frustum=new Frustum;const _shadowMapSize=new Vector2,_viewportSize=new Vector2,_viewport=new Vector4,_depthMaterial=new MeshDepthMaterial({depthPacking:3201}),_distanceMaterial=new MeshDistanceMaterial,_materialCache=
{},_maxTextureSize=_capabilities.maxTextureSize,shadowSide={0:1,1:0,2:2},shadowMaterialVertical=new ShaderMaterial({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Vector2},radius:{value:4}},vertexShader:"void main() {\n\tgl_Position \x3d vec4( position, 1.0 );\n}",fragmentShader:"uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include \x3cpacking\x3e\nvoid main() {\n\tconst float samples \x3d float( VSM_SAMPLES );\n\tfloat mean \x3d 0.0;\n\tfloat squared_mean \x3d 0.0;\n\tfloat uvStride \x3d samples \x3c\x3d 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart \x3d samples \x3c\x3d 1.0 ? 0.0 : - 1.0;\n\tfor ( float i \x3d 0.0; i \x3c samples; i ++ ) {\n\t\tfloat uvOffset \x3d uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution \x3d unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean +\x3d distribution.x;\n\t\t\tsquared_mean +\x3d distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth \x3d unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean +\x3d depth;\n\t\t\tsquared_mean +\x3d depth * depth;\n\t\t#endif\n\t}\n\tmean \x3d mean / samples;\n\tsquared_mean \x3d squared_mean / samples;\n\tfloat std_dev \x3d sqrt( squared_mean - mean * mean );\n\tgl_FragColor \x3d pack2HalfToRGBA( vec2( mean, std_dev ) );\n}"}),
shadowMaterialHorizontal=shadowMaterialVertical.clone();shadowMaterialHorizontal.defines.HORIZONTAL_PASS=1;_capabilities=new BufferGeometry;_capabilities.setAttribute("position",new BufferAttribute(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const fullScreenMesh=new Mesh(_capabilities,shadowMaterialVertical),scope=this;this.enabled=!1;this.autoUpdate=!0;this.needsUpdate=!1;this.type=1;this.render=function(lights,scene,camera){if(!1!==scope.enabled&&(!1!==scope.autoUpdate||!1!==scope.needsUpdate)&&
0!==lights.length){var currentRenderTarget=_renderer.getRenderTarget(),activeCubeFace=_renderer.getActiveCubeFace(),activeMipmapLevel=_renderer.getActiveMipmapLevel(),_state=_renderer.state;_state.setBlending(0);_state.buffers.color.setClear(1,1,1,1);_state.buffers.depth.setTest(!0);_state.setScissorTest(!1);for(let i=0,il=lights.length;i<il;i++){var light=lights[i];const shadow=light.shadow;if(void 0===shadow)console.warn("THREE.WebGLShadowMap:",light,"has no shadow.");else if(!1!==shadow.autoUpdate||
!1!==shadow.needsUpdate){_shadowMapSize.copy(shadow.mapSize);var shadowFrameExtents=shadow.getFrameExtents();_shadowMapSize.multiply(shadowFrameExtents);_viewportSize.copy(shadow.mapSize);if(_shadowMapSize.x>_maxTextureSize||_shadowMapSize.y>_maxTextureSize)_shadowMapSize.x>_maxTextureSize&&(_viewportSize.x=Math.floor(_maxTextureSize/shadowFrameExtents.x),_shadowMapSize.x=_viewportSize.x*shadowFrameExtents.x,shadow.mapSize.x=_viewportSize.x),_shadowMapSize.y>_maxTextureSize&&(_viewportSize.y=Math.floor(_maxTextureSize/
shadowFrameExtents.y),_shadowMapSize.y=_viewportSize.y*shadowFrameExtents.y,shadow.mapSize.y=_viewportSize.y);null===shadow.map&&(shadow.map=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y,3!==this.type?{minFilter:1003,magFilter:1003}:{}),shadow.map.texture.name=light.name+".shadowMap",shadow.camera.updateProjectionMatrix());_renderer.setRenderTarget(shadow.map);_renderer.clear();shadowFrameExtents=shadow.getViewportCount();for(var vp=0;vp<shadowFrameExtents;vp++){const viewport=shadow.getViewport(vp);
_viewport.set(_viewportSize.x*viewport.x,_viewportSize.y*viewport.y,_viewportSize.x*viewport.z,_viewportSize.y*viewport.w);_state.viewport(_viewport);shadow.updateMatrices(light,vp);_frustum=shadow.getFrustum();renderObject(scene,camera,shadow.camera,light,this.type)}!0!==shadow.isPointLightShadow&&3===this.type&&(light=shadow,shadowFrameExtents=camera,vp=_objects.update(fullScreenMesh),shadowMaterialVertical.defines.VSM_SAMPLES!==light.blurSamples&&(shadowMaterialVertical.defines.VSM_SAMPLES=light.blurSamples,
shadowMaterialHorizontal.defines.VSM_SAMPLES=light.blurSamples,shadowMaterialVertical.needsUpdate=!0,shadowMaterialHorizontal.needsUpdate=!0),null===light.mapPass&&(light.mapPass=new WebGLRenderTarget(_shadowMapSize.x,_shadowMapSize.y)),shadowMaterialVertical.uniforms.shadow_pass.value=light.map.texture,shadowMaterialVertical.uniforms.resolution.value=light.mapSize,shadowMaterialVertical.uniforms.radius.value=light.radius,_renderer.setRenderTarget(light.mapPass),_renderer.clear(),_renderer.renderBufferDirect(shadowFrameExtents,
null,vp,shadowMaterialVertical,fullScreenMesh,null),shadowMaterialHorizontal.uniforms.shadow_pass.value=light.mapPass.texture,shadowMaterialHorizontal.uniforms.resolution.value=light.mapSize,shadowMaterialHorizontal.uniforms.radius.value=light.radius,_renderer.setRenderTarget(light.map),_renderer.clear(),_renderer.renderBufferDirect(shadowFrameExtents,null,vp,shadowMaterialHorizontal,fullScreenMesh,null));shadow.needsUpdate=!1}}scope.needsUpdate=!1;_renderer.setRenderTarget(currentRenderTarget,activeCubeFace,
activeMipmapLevel)}}}function WebGLState(gl,extensions,capabilities){function createTexture(type,target,count){const data=new Uint8Array(4),texture=gl.createTexture();gl.bindTexture(type,texture);gl.texParameteri(type,gl.TEXTURE_MIN_FILTER,gl.NEAREST);gl.texParameteri(type,gl.TEXTURE_MAG_FILTER,gl.NEAREST);for(type=0;type<count;type++)gl.texImage2D(target+type,0,gl.RGBA,1,1,0,gl.RGBA,gl.UNSIGNED_BYTE,data);return texture}function enable(id){!0!==enabledCapabilities[id]&&(gl.enable(id),enabledCapabilities[id]=
!0)}function disable(id){!1!==enabledCapabilities[id]&&(gl.disable(id),enabledCapabilities[id]=!1)}function setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){if(0===blending)!0===currentBlendingEnabled&&(disable(gl.BLEND),currentBlendingEnabled=!1);else if(!1===currentBlendingEnabled&&(enable(gl.BLEND),currentBlendingEnabled=!0),5!==blending){if(blending!==currentBlending||premultipliedAlpha!==currentPremultipledAlpha){if(100!==
currentBlendEquation||100!==currentBlendEquationAlpha)gl.blendEquation(gl.FUNC_ADD),currentBlendEquationAlpha=currentBlendEquation=100;if(premultipliedAlpha)switch(blending){case 1:gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case 2:gl.blendFunc(gl.ONE,gl.ONE);break;case 3:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case 4:gl.blendFuncSeparate(gl.ZERO,gl.SRC_COLOR,gl.ZERO,gl.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",
blending)}else switch(blending){case 1:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case 2:gl.blendFunc(gl.SRC_ALPHA,gl.ONE);break;case 3:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case 4:gl.blendFunc(gl.ZERO,gl.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",blending)}currentBlendDstAlpha=currentBlendSrcAlpha=currentBlendDst=currentBlendSrc=null;currentBlending=blending;currentPremultipledAlpha=
premultipliedAlpha}}else{blendEquationAlpha=blendEquationAlpha||blendEquation;blendSrcAlpha=blendSrcAlpha||blendSrc;blendDstAlpha=blendDstAlpha||blendDst;if(blendEquation!==currentBlendEquation||blendEquationAlpha!==currentBlendEquationAlpha)gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]),currentBlendEquation=blendEquation,currentBlendEquationAlpha=blendEquationAlpha;if(blendSrc!==currentBlendSrc||blendDst!==currentBlendDst||blendSrcAlpha!==currentBlendSrcAlpha||
blendDstAlpha!==currentBlendDstAlpha)gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]),currentBlendSrc=blendSrc,currentBlendDst=blendDst,currentBlendSrcAlpha=blendSrcAlpha,currentBlendDstAlpha=blendDstAlpha;currentBlending=blending;currentPremultipledAlpha=null}}function setFlipSided(flipSided){currentFlipSided!==flipSided&&(flipSided?gl.frontFace(gl.CW):gl.frontFace(gl.CCW),currentFlipSided=flipSided)}function setCullFace(cullFace){0!==
cullFace?(enable(gl.CULL_FACE),cullFace!==currentCullFace&&(1===cullFace?gl.cullFace(gl.BACK):2===cullFace?gl.cullFace(gl.FRONT):gl.cullFace(gl.FRONT_AND_BACK))):disable(gl.CULL_FACE);currentCullFace=cullFace}function setPolygonOffset(polygonOffset,factor,units){if(polygonOffset){if(enable(gl.POLYGON_OFFSET_FILL),currentPolygonOffsetFactor!==factor||currentPolygonOffsetUnits!==units)gl.polygonOffset(factor,units),currentPolygonOffsetFactor=factor,currentPolygonOffsetUnits=units}else disable(gl.POLYGON_OFFSET_FILL)}
const isWebGL2=capabilities.isWebGL2,colorBuffer=new function(){let locked=!1;const color=new Vector4;let currentColorMask=null;const currentColorClear=new Vector4(0,0,0,0);return{setMask:function(colorMask){currentColorMask===colorMask||locked||(gl.colorMask(colorMask,colorMask,colorMask,colorMask),currentColorMask=colorMask)},setLocked:function(lock){locked=lock},setClear:function(r,g,b,a,premultipliedAlpha){!0===premultipliedAlpha&&(r*=a,g*=a,b*=a);color.set(r,g,b,a);!1===currentColorClear.equals(color)&&
(gl.clearColor(r,g,b,a),currentColorClear.copy(color))},reset:function(){locked=!1;currentColorMask=null;currentColorClear.set(-1,0,0,0)}}},depthBuffer=new function(){let locked=!1,currentDepthMask=null,currentDepthFunc=null,currentDepthClear=null;return{setTest:function(depthTest){depthTest?enable(gl.DEPTH_TEST):disable(gl.DEPTH_TEST)},setMask:function(depthMask){currentDepthMask===depthMask||locked||(gl.depthMask(depthMask),currentDepthMask=depthMask)},setFunc:function(depthFunc){if(currentDepthFunc!==
depthFunc){switch(depthFunc){case 0:gl.depthFunc(gl.NEVER);break;case 1:gl.depthFunc(gl.ALWAYS);break;case 2:gl.depthFunc(gl.LESS);break;case 3:gl.depthFunc(gl.LEQUAL);break;case 4:gl.depthFunc(gl.EQUAL);break;case 5:gl.depthFunc(gl.GEQUAL);break;case 6:gl.depthFunc(gl.GREATER);break;case 7:gl.depthFunc(gl.NOTEQUAL);break;default:gl.depthFunc(gl.LEQUAL)}currentDepthFunc=depthFunc}},setLocked:function(lock){locked=lock},setClear:function(depth){currentDepthClear!==depth&&(gl.clearDepth(depth),currentDepthClear=
depth)},reset:function(){locked=!1;currentDepthClear=currentDepthFunc=currentDepthMask=null}}},stencilBuffer=new function(){let locked=!1,currentStencilMask=null,currentStencilFunc=null,currentStencilRef=null,currentStencilFuncMask=null,currentStencilFail=null,currentStencilZFail=null,currentStencilZPass=null,currentStencilClear=null;return{setTest:function(stencilTest){locked||(stencilTest?enable(gl.STENCIL_TEST):disable(gl.STENCIL_TEST))},setMask:function(stencilMask){currentStencilMask===stencilMask||
locked||(gl.stencilMask(stencilMask),currentStencilMask=stencilMask)},setFunc:function(stencilFunc,stencilRef,stencilMask){if(currentStencilFunc!==stencilFunc||currentStencilRef!==stencilRef||currentStencilFuncMask!==stencilMask)gl.stencilFunc(stencilFunc,stencilRef,stencilMask),currentStencilFunc=stencilFunc,currentStencilRef=stencilRef,currentStencilFuncMask=stencilMask},setOp:function(stencilFail,stencilZFail,stencilZPass){if(currentStencilFail!==stencilFail||currentStencilZFail!==stencilZFail||
currentStencilZPass!==stencilZPass)gl.stencilOp(stencilFail,stencilZFail,stencilZPass),currentStencilFail=stencilFail,currentStencilZFail=stencilZFail,currentStencilZPass=stencilZPass},setLocked:function(lock){locked=lock},setClear:function(stencil){currentStencilClear!==stencil&&(gl.clearStencil(stencil),currentStencilClear=stencil)},reset:function(){locked=!1;currentStencilClear=currentStencilZPass=currentStencilZFail=currentStencilFail=currentStencilFuncMask=currentStencilRef=currentStencilFunc=
currentStencilMask=null}}},uboBindings=new WeakMap,uboProgamMap=new WeakMap;let enabledCapabilities={},currentBoundFramebuffers={},currentDrawbuffers=new WeakMap,defaultDrawbuffers=[],currentProgram=null,currentBlendingEnabled=!1,currentBlending=null,currentBlendEquation=null,currentBlendSrc=null,currentBlendDst=null,currentBlendEquationAlpha=null,currentBlendSrcAlpha=null,currentBlendDstAlpha=null,currentPremultipledAlpha=!1,currentFlipSided=null,currentCullFace=null,currentLineWidth=null,currentPolygonOffsetFactor=
null,currentPolygonOffsetUnits=null;const maxTextures=gl.getParameter(gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let lineWidthAvailable=!1;var version=0;version=gl.getParameter(gl.VERSION);-1!==version.indexOf("WebGL")?(version=parseFloat(/^WebGL (\d)/.exec(version)[1]),lineWidthAvailable=1<=version):-1!==version.indexOf("OpenGL ES")&&(version=parseFloat(/^OpenGL ES (\d)/.exec(version)[1]),lineWidthAvailable=2<=version);let currentTextureSlot=null,currentBoundTextures={};version=gl.getParameter(gl.SCISSOR_BOX);
const viewportParam=gl.getParameter(gl.VIEWPORT),currentScissor=(new Vector4).fromArray(version),currentViewport=(new Vector4).fromArray(viewportParam),emptyTextures={};emptyTextures[gl.TEXTURE_2D]=createTexture(gl.TEXTURE_2D,gl.TEXTURE_2D,1);emptyTextures[gl.TEXTURE_CUBE_MAP]=createTexture(gl.TEXTURE_CUBE_MAP,gl.TEXTURE_CUBE_MAP_POSITIVE_X,6);colorBuffer.setClear(0,0,0,1);depthBuffer.setClear(1);stencilBuffer.setClear(0);enable(gl.DEPTH_TEST);depthBuffer.setFunc(3);setFlipSided(!1);setCullFace(1);
enable(gl.CULL_FACE);setBlending(0);const equationToGL={[100]:gl.FUNC_ADD,[101]:gl.FUNC_SUBTRACT,[102]:gl.FUNC_REVERSE_SUBTRACT};isWebGL2?(equationToGL[103]=gl.MIN,equationToGL[104]=gl.MAX):(version=extensions.get("EXT_blend_minmax"),null!==version&&(equationToGL[103]=version.MIN_EXT,equationToGL[104]=version.MAX_EXT));const factorToGL={[200]:gl.ZERO,[201]:gl.ONE,[202]:gl.SRC_COLOR,[204]:gl.SRC_ALPHA,[210]:gl.SRC_ALPHA_SATURATE,[208]:gl.DST_COLOR,[206]:gl.DST_ALPHA,[203]:gl.ONE_MINUS_SRC_COLOR,[205]:gl.ONE_MINUS_SRC_ALPHA,
[209]:gl.ONE_MINUS_DST_COLOR,[207]:gl.ONE_MINUS_DST_ALPHA};return{buffers:{color:colorBuffer,depth:depthBuffer,stencil:stencilBuffer},enable,disable,bindFramebuffer:function(target,framebuffer){return currentBoundFramebuffers[target]!==framebuffer?(gl.bindFramebuffer(target,framebuffer),currentBoundFramebuffers[target]=framebuffer,isWebGL2&&(target===gl.DRAW_FRAMEBUFFER&&(currentBoundFramebuffers[gl.FRAMEBUFFER]=framebuffer),target===gl.FRAMEBUFFER&&(currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER]=
framebuffer)),!0):!1},drawBuffers:function(renderTarget,framebuffer){let drawBuffers=defaultDrawbuffers,needsUpdate=!1;if(renderTarget)if(drawBuffers=currentDrawbuffers.get(framebuffer),void 0===drawBuffers&&(drawBuffers=[],currentDrawbuffers.set(framebuffer,drawBuffers)),renderTarget.isWebGLMultipleRenderTargets){if(renderTarget=renderTarget.texture,drawBuffers.length!==renderTarget.length||drawBuffers[0]!==gl.COLOR_ATTACHMENT0){for(let i=0,il=renderTarget.length;i<il;i++)drawBuffers[i]=gl.COLOR_ATTACHMENT0+
i;drawBuffers.length=renderTarget.length;needsUpdate=!0}}else drawBuffers[0]!==gl.COLOR_ATTACHMENT0&&(drawBuffers[0]=gl.COLOR_ATTACHMENT0,needsUpdate=!0);else drawBuffers[0]!==gl.BACK&&(drawBuffers[0]=gl.BACK,needsUpdate=!0);needsUpdate&&(capabilities.isWebGL2?gl.drawBuffers(drawBuffers):extensions.get("WEBGL_draw_buffers").drawBuffersWEBGL(drawBuffers))},useProgram:function(program){return currentProgram!==program?(gl.useProgram(program),currentProgram=program,!0):!1},setBlending,setMaterial:function(material,
frontFaceCW){2===material.side?disable(gl.CULL_FACE):enable(gl.CULL_FACE);let flipSided=1===material.side;frontFaceCW&&(flipSided=!flipSided);setFlipSided(flipSided);1===material.blending&&!1===material.transparent?setBlending(0):setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha);depthBuffer.setFunc(material.depthFunc);depthBuffer.setTest(material.depthTest);
depthBuffer.setMask(material.depthWrite);colorBuffer.setMask(material.colorWrite);frontFaceCW=material.stencilWrite;stencilBuffer.setTest(frontFaceCW);frontFaceCW&&(stencilBuffer.setMask(material.stencilWriteMask),stencilBuffer.setFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask),stencilBuffer.setOp(material.stencilFail,material.stencilZFail,material.stencilZPass));setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits);!0===material.alphaToCoverage?
enable(gl.SAMPLE_ALPHA_TO_COVERAGE):disable(gl.SAMPLE_ALPHA_TO_COVERAGE)},setFlipSided,setCullFace,setLineWidth:function(width){width!==currentLineWidth&&(lineWidthAvailable&&gl.lineWidth(width),currentLineWidth=width)},setPolygonOffset,setScissorTest:function(scissorTest){scissorTest?enable(gl.SCISSOR_TEST):disable(gl.SCISSOR_TEST)},activeTexture:function(webglSlot){void 0===webglSlot&&(webglSlot=gl.TEXTURE0+maxTextures-1);currentTextureSlot!==webglSlot&&(gl.activeTexture(webglSlot),currentTextureSlot=
webglSlot)},bindTexture:function(webglType,webglTexture,webglSlot){void 0===webglSlot&&(webglSlot=null===currentTextureSlot?gl.TEXTURE0+maxTextures-1:currentTextureSlot);let boundTexture=currentBoundTextures[webglSlot];void 0===boundTexture&&(boundTexture={type:void 0,texture:void 0},currentBoundTextures[webglSlot]=boundTexture);if(boundTexture.type!==webglType||boundTexture.texture!==webglTexture)currentTextureSlot!==webglSlot&&(gl.activeTexture(webglSlot),currentTextureSlot=webglSlot),gl.bindTexture(webglType,
webglTexture||emptyTextures[webglType]),boundTexture.type=webglType,boundTexture.texture=webglTexture},unbindTexture:function(){const boundTexture=currentBoundTextures[currentTextureSlot];void 0!==boundTexture&&void 0!==boundTexture.type&&(gl.bindTexture(boundTexture.type,null),boundTexture.type=void 0,boundTexture.texture=void 0)},compressedTexImage2D:function(){try{gl.compressedTexImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},compressedTexImage3D:function(){try{gl.compressedTexImage3D.apply(gl,
arguments)}catch(error){console.error("THREE.WebGLState:",error)}},texImage2D:function(){try{gl.texImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},texImage3D:function(){try{gl.texImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},updateUBOMapping:function(uniformsGroup,program){let mapping=uboProgamMap.get(program);void 0===mapping&&(mapping=new WeakMap,uboProgamMap.set(program,mapping));let blockIndex=mapping.get(uniformsGroup);
void 0===blockIndex&&(blockIndex=gl.getUniformBlockIndex(program,uniformsGroup.name),mapping.set(uniformsGroup,blockIndex))},uniformBlockBinding:function(uniformsGroup,program){const blockIndex=uboProgamMap.get(program).get(uniformsGroup);uboBindings.get(uniformsGroup)!==blockIndex&&(gl.uniformBlockBinding(program,blockIndex,uniformsGroup.__bindingPointIndex),uboBindings.set(uniformsGroup,blockIndex))},texStorage2D:function(){try{gl.texStorage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",
error)}},texStorage3D:function(){try{gl.texStorage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},texSubImage2D:function(){try{gl.texSubImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},texSubImage3D:function(){try{gl.texSubImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},compressedTexSubImage2D:function(){try{gl.compressedTexSubImage2D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",
error)}},compressedTexSubImage3D:function(){try{gl.compressedTexSubImage3D.apply(gl,arguments)}catch(error){console.error("THREE.WebGLState:",error)}},scissor:function(scissor){!1===currentScissor.equals(scissor)&&(gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w),currentScissor.copy(scissor))},viewport:function(viewport){!1===currentViewport.equals(viewport)&&(gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w),currentViewport.copy(viewport))},reset:function(){gl.disable(gl.BLEND);gl.disable(gl.CULL_FACE);
gl.disable(gl.DEPTH_TEST);gl.disable(gl.POLYGON_OFFSET_FILL);gl.disable(gl.SCISSOR_TEST);gl.disable(gl.STENCIL_TEST);gl.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);gl.blendEquation(gl.FUNC_ADD);gl.blendFunc(gl.ONE,gl.ZERO);gl.blendFuncSeparate(gl.ONE,gl.ZERO,gl.ONE,gl.ZERO);gl.colorMask(!0,!0,!0,!0);gl.clearColor(0,0,0,0);gl.depthMask(!0);gl.depthFunc(gl.LESS);gl.clearDepth(1);gl.stencilMask(4294967295);gl.stencilFunc(gl.ALWAYS,0,4294967295);gl.stencilOp(gl.KEEP,gl.KEEP,gl.KEEP);gl.clearStencil(0);gl.cullFace(gl.BACK);
gl.frontFace(gl.CCW);gl.polygonOffset(0,0);gl.activeTexture(gl.TEXTURE0);gl.bindFramebuffer(gl.FRAMEBUFFER,null);!0===isWebGL2&&(gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null),gl.bindFramebuffer(gl.READ_FRAMEBUFFER,null));gl.useProgram(null);gl.lineWidth(1);gl.scissor(0,0,gl.canvas.width,gl.canvas.height);gl.viewport(0,0,gl.canvas.width,gl.canvas.height);enabledCapabilities={};currentTextureSlot=null;currentBoundTextures={};currentBoundFramebuffers={};currentDrawbuffers=new WeakMap;defaultDrawbuffers=
[];currentProgram=null;currentBlendingEnabled=!1;currentBlendDstAlpha=currentBlendSrcAlpha=currentBlendEquationAlpha=currentBlendDst=currentBlendSrc=currentBlendEquation=currentBlending=null;currentPremultipledAlpha=!1;currentPolygonOffsetUnits=currentPolygonOffsetFactor=currentLineWidth=currentCullFace=currentFlipSided=null;currentScissor.set(0,0,gl.canvas.width,gl.canvas.height);currentViewport.set(0,0,gl.canvas.width,gl.canvas.height);colorBuffer.reset();depthBuffer.reset();stencilBuffer.reset()}}}
function WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info){function resizeImage(image,needsPowerOfTwo,needsNewCanvas,maxSize){var scale=1;if(image.width>maxSize||image.height>maxSize)scale=maxSize/Math.max(image.width,image.height);if(1>scale||!0===needsPowerOfTwo){if("undefined"!==typeof HTMLImageElement&&image instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&image instanceof ImageBitmap)return maxSize=
needsPowerOfTwo?floorPowerOfTwo:Math.floor,needsPowerOfTwo=maxSize(scale*image.width),scale=maxSize(scale*image.height),void 0===_canvas&&(_canvas=useOffscreenCanvas?new OffscreenCanvas(needsPowerOfTwo,scale):createElementNS("canvas")),needsNewCanvas=needsNewCanvas?useOffscreenCanvas?new OffscreenCanvas(needsPowerOfTwo,scale):createElementNS("canvas"):_canvas,needsNewCanvas.width=needsPowerOfTwo,needsNewCanvas.height=scale,needsNewCanvas.getContext("2d").drawImage(image,0,0,needsPowerOfTwo,scale),
console.warn("THREE.WebGLRenderer: Texture has been resized from ("+image.width+"x"+image.height+") to ("+needsPowerOfTwo+"x"+scale+")."),needsNewCanvas;"data"in image&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+image.width+"x"+image.height+").")}return image}function isPowerOfTwo$1(image){return isPowerOfTwo(image.width)&&isPowerOfTwo(image.height)}function textureNeedsGenerateMipmaps(texture,supportsMips){return texture.generateMipmaps&&supportsMips&&1003!==texture.minFilter&&
1006!==texture.minFilter}function getInternalFormat(internalFormatName,glFormat,glType,encoding,forceLinearEncoding=!1){if(!1===isWebGL2)return glFormat;if(null!==internalFormatName){if(void 0!==_gl[internalFormatName])return _gl[internalFormatName];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+internalFormatName+"'")}internalFormatName=glFormat;glFormat===_gl.RED&&(glType===_gl.FLOAT&&(internalFormatName=_gl.R32F),glType===_gl.HALF_FLOAT&&(internalFormatName=
_gl.R16F),glType===_gl.UNSIGNED_BYTE&&(internalFormatName=_gl.R8));glFormat===_gl.RG&&(glType===_gl.FLOAT&&(internalFormatName=_gl.RG32F),glType===_gl.HALF_FLOAT&&(internalFormatName=_gl.RG16F),glType===_gl.UNSIGNED_BYTE&&(internalFormatName=_gl.RG8));glFormat===_gl.RGBA&&(glType===_gl.FLOAT&&(internalFormatName=_gl.RGBA32F),glType===_gl.HALF_FLOAT&&(internalFormatName=_gl.RGBA16F),glType===_gl.UNSIGNED_BYTE&&(internalFormatName=3001===encoding&&!1===forceLinearEncoding?_gl.SRGB8_ALPHA8:_gl.RGBA8),
glType===_gl.UNSIGNED_SHORT_4_4_4_4&&(internalFormatName=_gl.RGBA4),glType===_gl.UNSIGNED_SHORT_5_5_5_1&&(internalFormatName=_gl.RGB5_A1));internalFormatName!==_gl.R16F&&internalFormatName!==_gl.R32F&&internalFormatName!==_gl.RG16F&&internalFormatName!==_gl.RG32F&&internalFormatName!==_gl.RGBA16F&&internalFormatName!==_gl.RGBA32F||extensions.get("EXT_color_buffer_float");return internalFormatName}function getMipLevels(texture,image,supportsMips){return!0===textureNeedsGenerateMipmaps(texture,supportsMips)||
texture.isFramebufferTexture&&1003!==texture.minFilter&&1006!==texture.minFilter?Math.log2(Math.max(image.width,image.height))+1:void 0!==texture.mipmaps&&0<texture.mipmaps.length?texture.mipmaps.length:texture.isCompressedTexture&&Array.isArray(texture.image)?image.mipmaps.length:1}function filterFallback(f){return 1003===f||1004===f||1005===f?_gl.NEAREST:_gl.LINEAR}function onTextureDispose(event){event=event.target;event.removeEventListener("dispose",onTextureDispose);var textureProperties=properties.get(event);
if(void 0!==textureProperties.__webglInit){var source=event.source,webglTextures=_sources.get(source);webglTextures&&(textureProperties=webglTextures[textureProperties.__cacheKey],textureProperties.usedTimes--,0===textureProperties.usedTimes&&deleteTexture(event),0===Object.keys(webglTextures).length&&_sources.delete(source));properties.remove(event)}event.isVideoTexture&&_videoTextures.delete(event)}function onRenderTargetDispose(event){event=event.target;event.removeEventListener("dispose",onRenderTargetDispose);
const texture=event.texture;var renderTargetProperties=properties.get(event),textureProperties=properties.get(texture);void 0!==textureProperties.__webglTexture&&(_gl.deleteTexture(textureProperties.__webglTexture),info.memory.textures--);event.depthTexture&&event.depthTexture.dispose();if(event.isWebGLCubeRenderTarget)for(textureProperties=0;6>textureProperties;textureProperties++)_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer[textureProperties]),renderTargetProperties.__webglDepthbuffer&&
_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer[textureProperties]);else{_gl.deleteFramebuffer(renderTargetProperties.__webglFramebuffer);renderTargetProperties.__webglDepthbuffer&&_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthbuffer);renderTargetProperties.__webglMultisampledFramebuffer&&_gl.deleteFramebuffer(renderTargetProperties.__webglMultisampledFramebuffer);if(renderTargetProperties.__webglColorRenderbuffer)for(textureProperties=0;textureProperties<renderTargetProperties.__webglColorRenderbuffer.length;textureProperties++)renderTargetProperties.__webglColorRenderbuffer[textureProperties]&&
_gl.deleteRenderbuffer(renderTargetProperties.__webglColorRenderbuffer[textureProperties]);renderTargetProperties.__webglDepthRenderbuffer&&_gl.deleteRenderbuffer(renderTargetProperties.__webglDepthRenderbuffer)}if(event.isWebGLMultipleRenderTargets)for(let i=0,il=texture.length;i<il;i++)renderTargetProperties=properties.get(texture[i]),renderTargetProperties.__webglTexture&&(_gl.deleteTexture(renderTargetProperties.__webglTexture),info.memory.textures--),properties.remove(texture[i]);properties.remove(texture);
properties.remove(event)}function deleteTexture(texture){const textureProperties=properties.get(texture);_gl.deleteTexture(textureProperties.__webglTexture);delete _sources.get(texture.source)[textureProperties.__cacheKey];info.memory.textures--}function setTexture2D(texture,slot){const textureProperties=properties.get(texture);if(texture.isVideoTexture){var frame=info.render.frame;_videoTextures.get(texture)!==frame&&(_videoTextures.set(texture,frame),texture.update())}if(!1===texture.isRenderTargetTexture&&
0<texture.version&&textureProperties.__version!==texture.version)if(frame=texture.image,null===frame)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(!1===frame.complete)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{uploadTexture(textureProperties,texture,slot);return}state.bindTexture(_gl.TEXTURE_2D,textureProperties.__webglTexture,_gl.TEXTURE0+slot)}function setTextureParameters(textureType,texture,supportsMips){supportsMips?
(_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_S,wrappingToGL[texture.wrapS]),_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,wrappingToGL[texture.wrapT]),textureType!==_gl.TEXTURE_3D&&textureType!==_gl.TEXTURE_2D_ARRAY||_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_R,wrappingToGL[texture.wrapR]),_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterToGL[texture.magFilter]),_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterToGL[texture.minFilter])):(_gl.texParameteri(textureType,
_gl.TEXTURE_WRAP_S,_gl.CLAMP_TO_EDGE),_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_T,_gl.CLAMP_TO_EDGE),textureType!==_gl.TEXTURE_3D&&textureType!==_gl.TEXTURE_2D_ARRAY||_gl.texParameteri(textureType,_gl.TEXTURE_WRAP_R,_gl.CLAMP_TO_EDGE),1001===texture.wrapS&&1001===texture.wrapT||console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."),_gl.texParameteri(textureType,_gl.TEXTURE_MAG_FILTER,filterFallback(texture.magFilter)),
_gl.texParameteri(textureType,_gl.TEXTURE_MIN_FILTER,filterFallback(texture.minFilter)),1003!==texture.minFilter&&1006!==texture.minFilter&&console.warn("THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."));!0===extensions.has("EXT_texture_filter_anisotropic")&&(supportsMips=extensions.get("EXT_texture_filter_anisotropic"),1015===texture.type&&!1===extensions.has("OES_texture_float_linear")||!1===isWebGL2&&1016===texture.type&&
!1===extensions.has("OES_texture_half_float_linear")||!(1<texture.anisotropy||properties.get(texture).__currentAnisotropy)||(_gl.texParameterf(textureType,supportsMips.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,capabilities.getMaxAnisotropy())),properties.get(texture).__currentAnisotropy=texture.anisotropy))}function initTexture(textureProperties,texture){let forceUpload=!1;void 0===textureProperties.__webglInit&&(textureProperties.__webglInit=!0,texture.addEventListener("dispose",onTextureDispose));
var source=texture.source;let webglTextures=_sources.get(source);void 0===webglTextures&&(webglTextures={},_sources.set(source,webglTextures));source=[];source.push(texture.wrapS);source.push(texture.wrapT);source.push(texture.wrapR||0);source.push(texture.magFilter);source.push(texture.minFilter);source.push(texture.anisotropy);source.push(texture.internalFormat);source.push(texture.format);source.push(texture.type);source.push(texture.generateMipmaps);source.push(texture.premultiplyAlpha);source.push(texture.flipY);
source.push(texture.unpackAlignment);source.push(texture.encoding);source=source.join();if(source!==textureProperties.__cacheKey){void 0===webglTextures[source]&&(webglTextures[source]={texture:_gl.createTexture(),usedTimes:0},info.memory.textures++,forceUpload=!0);webglTextures[source].usedTimes++;const webglTexture=webglTextures[textureProperties.__cacheKey];void 0!==webglTexture&&(webglTextures[textureProperties.__cacheKey].usedTimes--,0===webglTexture.usedTimes&&deleteTexture(texture));textureProperties.__cacheKey=
source;textureProperties.__webglTexture=webglTextures[source].texture}return forceUpload}function uploadTexture(textureProperties,texture,slot){let textureType=_gl.TEXTURE_2D;if(texture.isDataArrayTexture||texture.isCompressedArrayTexture)textureType=_gl.TEXTURE_2D_ARRAY;texture.isData3DTexture&&(textureType=_gl.TEXTURE_3D);var forceUpload=initTexture(textureProperties,texture);const source=texture.source;state.bindTexture(textureType,textureProperties.__webglTexture,_gl.TEXTURE0+slot);const sourceProperties=
properties.get(source);if(source.version!==sourceProperties.__version||!0===forceUpload){state.activeTexture(_gl.TEXTURE0+slot);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,texture.unpackAlignment);_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,_gl.NONE);slot=isWebGL2?!1:1001!==texture.wrapS||1001!==texture.wrapT||1003!==texture.minFilter&&1006!==texture.minFilter;slot=
slot&&!1===isPowerOfTwo$1(texture.image);var image=resizeImage(texture.image,slot,!1,maxTextureSize);image=verifyColorSpace(texture,image);slot=isPowerOfTwo$1(image)||isWebGL2;const glFormat=utils.convert(texture.format,texture.encoding);let glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding,texture.isVideoTexture);setTextureParameters(textureType,texture,slot);var mipmaps=texture.mipmaps,useTexStorage=isWebGL2&&!0!==texture.isVideoTexture;
const allocateMemory=void 0===sourceProperties.__version||!0===forceUpload;forceUpload=getMipLevels(texture,image,slot);if(texture.isDepthTexture)glInternalFormat=_gl.DEPTH_COMPONENT,isWebGL2?glInternalFormat=1015===texture.type?_gl.DEPTH_COMPONENT32F:1014===texture.type?_gl.DEPTH_COMPONENT24:1020===texture.type?_gl.DEPTH24_STENCIL8:_gl.DEPTH_COMPONENT16:1015===texture.type&&console.error("WebGLRenderer: Floating point depth texture requires WebGL2."),1026===texture.format&&glInternalFormat===_gl.DEPTH_COMPONENT&&
1012!==texture.type&&1014!==texture.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."),texture.type=1014,glType=utils.convert(texture.type)),1027===texture.format&&glInternalFormat===_gl.DEPTH_COMPONENT&&(glInternalFormat=_gl.DEPTH_STENCIL,1020!==texture.type&&(console.warn("THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."),texture.type=1020,glType=utils.convert(texture.type))),allocateMemory&&(useTexStorage?
state.texStorage2D(_gl.TEXTURE_2D,1,glInternalFormat,image.width,image.height):state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,glFormat,glType,null));else if(texture.isDataTexture)if(0<mipmaps.length&&slot){useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,forceUpload,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(let i=0,il=mipmaps.length;i<il;i++)forceUpload=mipmaps[i],useTexStorage?state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,forceUpload.width,
forceUpload.height,glFormat,glType,forceUpload.data):state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,forceUpload.width,forceUpload.height,0,glFormat,glType,forceUpload.data);texture.generateMipmaps=!1}else useTexStorage?(allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,forceUpload,glInternalFormat,image.width,image.height),state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,image.width,image.height,glFormat,glType,image.data)):state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,image.width,image.height,0,
glFormat,glType,image.data);else if(texture.isCompressedTexture)if(texture.isCompressedArrayTexture){useTexStorage&&allocateMemory&&state.texStorage3D(_gl.TEXTURE_2D_ARRAY,forceUpload,glInternalFormat,mipmaps[0].width,mipmaps[0].height,image.depth);for(let i=0,il=mipmaps.length;i<il;i++)forceUpload=mipmaps[i],1023!==texture.format?null!==glFormat?useTexStorage?state.compressedTexSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,0,forceUpload.width,forceUpload.height,image.depth,glFormat,forceUpload.data,0,0):
state.compressedTexImage3D(_gl.TEXTURE_2D_ARRAY,i,glInternalFormat,forceUpload.width,forceUpload.height,image.depth,0,forceUpload.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):useTexStorage?state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,i,0,0,0,forceUpload.width,forceUpload.height,image.depth,glFormat,glType,forceUpload.data):state.texImage3D(_gl.TEXTURE_2D_ARRAY,i,glInternalFormat,forceUpload.width,forceUpload.height,image.depth,
0,glFormat,glType,forceUpload.data)}else{useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,forceUpload,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(let i=0,il=mipmaps.length;i<il;i++)forceUpload=mipmaps[i],1023!==texture.format?null!==glFormat?useTexStorage?state.compressedTexSubImage2D(_gl.TEXTURE_2D,i,0,0,forceUpload.width,forceUpload.height,glFormat,forceUpload.data):state.compressedTexImage2D(_gl.TEXTURE_2D,i,glInternalFormat,forceUpload.width,forceUpload.height,0,forceUpload.data):
console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):useTexStorage?state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,forceUpload.width,forceUpload.height,glFormat,glType,forceUpload.data):state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,forceUpload.width,forceUpload.height,0,glFormat,glType,forceUpload.data)}else if(texture.isDataArrayTexture)useTexStorage?(allocateMemory&&state.texStorage3D(_gl.TEXTURE_2D_ARRAY,forceUpload,glInternalFormat,image.width,
image.height,image.depth),state.texSubImage3D(_gl.TEXTURE_2D_ARRAY,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data)):state.texImage3D(_gl.TEXTURE_2D_ARRAY,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);else if(texture.isData3DTexture)useTexStorage?(allocateMemory&&state.texStorage3D(_gl.TEXTURE_3D,forceUpload,glInternalFormat,image.width,image.height,image.depth),state.texSubImage3D(_gl.TEXTURE_3D,0,0,0,0,image.width,image.height,image.depth,
glFormat,glType,image.data)):state.texImage3D(_gl.TEXTURE_3D,0,glInternalFormat,image.width,image.height,image.depth,0,glFormat,glType,image.data);else if(texture.isFramebufferTexture){if(allocateMemory)if(useTexStorage)state.texStorage2D(_gl.TEXTURE_2D,forceUpload,glInternalFormat,image.width,image.height);else for(mipmaps=image.width,image=image.height,useTexStorage=0;useTexStorage<forceUpload;useTexStorage++)state.texImage2D(_gl.TEXTURE_2D,useTexStorage,glInternalFormat,mipmaps,image,0,glFormat,
glType,null),mipmaps>>=1,image>>=1}else if(0<mipmaps.length&&slot){useTexStorage&&allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,forceUpload,glInternalFormat,mipmaps[0].width,mipmaps[0].height);for(let i=0,il=mipmaps.length;i<il;i++)forceUpload=mipmaps[i],useTexStorage?state.texSubImage2D(_gl.TEXTURE_2D,i,0,0,glFormat,glType,forceUpload):state.texImage2D(_gl.TEXTURE_2D,i,glInternalFormat,glFormat,glType,forceUpload);texture.generateMipmaps=!1}else useTexStorage?(allocateMemory&&state.texStorage2D(_gl.TEXTURE_2D,
forceUpload,glInternalFormat,image.width,image.height),state.texSubImage2D(_gl.TEXTURE_2D,0,0,0,glFormat,glType,image)):state.texImage2D(_gl.TEXTURE_2D,0,glInternalFormat,glFormat,glType,image);textureNeedsGenerateMipmaps(texture,slot)&&_gl.generateMipmap(textureType);sourceProperties.__version=source.version;if(texture.onUpdate)texture.onUpdate(texture)}textureProperties.__version=texture.version}function setupFrameBufferTexture(framebuffer,renderTarget,texture,attachment,textureTarget){const glFormat=
utils.convert(texture.format,texture.encoding),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);properties.get(renderTarget).__hasExternalTextures||(textureTarget===_gl.TEXTURE_3D||textureTarget===_gl.TEXTURE_2D_ARRAY?state.texImage3D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,renderTarget.depth,0,glFormat,glType,null):state.texImage2D(textureTarget,0,glInternalFormat,renderTarget.width,renderTarget.height,
0,glFormat,glType,null));state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);useMultisampledRTT(renderTarget)?multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(texture).__webglTexture,0,getRenderTargetSamples(renderTarget)):(textureTarget===_gl.TEXTURE_2D||textureTarget>=_gl.TEXTURE_CUBE_MAP_POSITIVE_X&&textureTarget<=_gl.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&_gl.framebufferTexture2D(_gl.FRAMEBUFFER,attachment,textureTarget,properties.get(texture).__webglTexture,
0);state.bindFramebuffer(_gl.FRAMEBUFFER,null)}function setupRenderBufferStorage(renderbuffer,renderTarget,isMultisample){_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderbuffer);if(renderTarget.depthBuffer&&!renderTarget.stencilBuffer){var glInternalFormat=_gl.DEPTH_COMPONENT16;isMultisample||useMultisampledRTT(renderTarget)?((isMultisample=renderTarget.depthTexture)&&isMultisample.isDepthTexture&&(1015===isMultisample.type?glInternalFormat=_gl.DEPTH_COMPONENT32F:1014===isMultisample.type&&(glInternalFormat=
_gl.DEPTH_COMPONENT24)),isMultisample=getRenderTargetSamples(renderTarget),useMultisampledRTT(renderTarget)?multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,isMultisample,glInternalFormat,renderTarget.width,renderTarget.height):_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,isMultisample,glInternalFormat,renderTarget.width,renderTarget.height)):_gl.renderbufferStorage(_gl.RENDERBUFFER,glInternalFormat,renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,
_gl.DEPTH_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer)}else if(renderTarget.depthBuffer&&renderTarget.stencilBuffer)glInternalFormat=getRenderTargetSamples(renderTarget),isMultisample&&!1===useMultisampledRTT(renderTarget)?_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,glInternalFormat,_gl.DEPTH24_STENCIL8,renderTarget.width,renderTarget.height):useMultisampledRTT(renderTarget)?multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,glInternalFormat,_gl.DEPTH24_STENCIL8,renderTarget.width,
renderTarget.height):_gl.renderbufferStorage(_gl.RENDERBUFFER,_gl.DEPTH_STENCIL,renderTarget.width,renderTarget.height),_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.RENDERBUFFER,renderbuffer);else for(renderbuffer=!0===renderTarget.isWebGLMultipleRenderTargets?renderTarget.texture:[renderTarget.texture],glInternalFormat=0;glInternalFormat<renderbuffer.length;glInternalFormat++){var texture=renderbuffer[glInternalFormat],glFormat=utils.convert(texture.format,texture.encoding);
const glType=utils.convert(texture.type);texture=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding);glFormat=getRenderTargetSamples(renderTarget);isMultisample&&!1===useMultisampledRTT(renderTarget)?_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,glFormat,texture,renderTarget.width,renderTarget.height):useMultisampledRTT(renderTarget)?multisampledRTTExt.renderbufferStorageMultisampleEXT(_gl.RENDERBUFFER,glFormat,texture,renderTarget.width,renderTarget.height):_gl.renderbufferStorage(_gl.RENDERBUFFER,
texture,renderTarget.width,renderTarget.height)}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null)}function setupDepthRenderbuffer(renderTarget){var renderTargetProperties=properties.get(renderTarget),isCube=!0===renderTarget.isWebGLCubeRenderTarget;if(renderTarget.depthTexture&&!renderTargetProperties.__autoAllocateDepthBuffer){if(isCube)throw Error("target.depthTexture not supported in Cube render targets");if(renderTarget&&renderTarget.isWebGLCubeRenderTarget)throw Error("Depth Texture with cube render targets is not supported");
state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);if(!renderTarget.depthTexture||!renderTarget.depthTexture.isDepthTexture)throw Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");properties.get(renderTarget.depthTexture).__webglTexture&&renderTarget.depthTexture.image.width===renderTarget.width&&renderTarget.depthTexture.image.height===renderTarget.height||(renderTarget.depthTexture.image.width=renderTarget.width,renderTarget.depthTexture.image.height=
renderTarget.height,renderTarget.depthTexture.needsUpdate=!0);setTexture2D(renderTarget.depthTexture,0);renderTargetProperties=properties.get(renderTarget.depthTexture).__webglTexture;isCube=getRenderTargetSamples(renderTarget);if(1026===renderTarget.depthTexture.format)useMultisampledRTT(renderTarget)?multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,_gl.TEXTURE_2D,renderTargetProperties,0,isCube):_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_ATTACHMENT,
_gl.TEXTURE_2D,renderTargetProperties,0);else if(1027===renderTarget.depthTexture.format)useMultisampledRTT(renderTarget)?multisampledRTTExt.framebufferTexture2DMultisampleEXT(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,renderTargetProperties,0,isCube):_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.DEPTH_STENCIL_ATTACHMENT,_gl.TEXTURE_2D,renderTargetProperties,0);else throw Error("Unknown depthTexture format");}else if(isCube)for(renderTargetProperties.__webglDepthbuffer=[],isCube=0;6>
isCube;isCube++)state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer[isCube]),renderTargetProperties.__webglDepthbuffer[isCube]=_gl.createRenderbuffer(),setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer[isCube],renderTarget,!1);else state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer),renderTargetProperties.__webglDepthbuffer=_gl.createRenderbuffer(),setupRenderBufferStorage(renderTargetProperties.__webglDepthbuffer,renderTarget,
!1);state.bindFramebuffer(_gl.FRAMEBUFFER,null)}function getRenderTargetSamples(renderTarget){return Math.min(maxSamples,renderTarget.samples)}function useMultisampledRTT(renderTarget){const renderTargetProperties=properties.get(renderTarget);return isWebGL2&&0<renderTarget.samples&&!0===extensions.has("WEBGL_multisampled_render_to_texture")&&!1!==renderTargetProperties.__useRenderToTexture}function verifyColorSpace(texture,image){const encoding=texture.encoding,format=texture.format,type=texture.type;
if(!0===texture.isCompressedTexture||!0===texture.isVideoTexture||1035===texture.format)return image;3E3!==encoding&&(3001===encoding?!1===isWebGL2?!0===extensions.has("EXT_sRGB")&&1023===format?(texture.format=1035,texture.minFilter=1006,texture.generateMipmaps=!1):image=ImageUtils.sRGBToLinear(image):1023===format&&1009===type||console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture encoding:",
encoding));return image}const isWebGL2=capabilities.isWebGL2,maxTextures=capabilities.maxTextures,maxCubemapSize=capabilities.maxCubemapSize,maxTextureSize=capabilities.maxTextureSize,maxSamples=capabilities.maxSamples,multisampledRTTExt=extensions.has("WEBGL_multisampled_render_to_texture")?extensions.get("WEBGL_multisampled_render_to_texture"):null,supportsInvalidateFramebuffer=/OculusBrowser/g.test("undefined"===typeof navigator?"":navigator.userAgent),_videoTextures=new WeakMap;let _canvas;const _sources=
new WeakMap;let useOffscreenCanvas=!1;try{useOffscreenCanvas="undefined"!==typeof OffscreenCanvas&&null!==(new OffscreenCanvas(1,1)).getContext("2d")}catch(err){}let textureUnits=0;const wrappingToGL={[1E3]:_gl.REPEAT,[1001]:_gl.CLAMP_TO_EDGE,[1002]:_gl.MIRRORED_REPEAT},filterToGL={[1003]:_gl.NEAREST,[1004]:_gl.NEAREST_MIPMAP_NEAREST,[1005]:_gl.NEAREST_MIPMAP_LINEAR,[1006]:_gl.LINEAR,[1007]:_gl.LINEAR_MIPMAP_NEAREST,[1008]:_gl.LINEAR_MIPMAP_LINEAR};this.allocateTextureUnit=function(){const textureUnit=
textureUnits;textureUnit>=maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+textureUnit+" texture units while this GPU supports only "+maxTextures);textureUnits+=1;return textureUnit};this.resetTextureUnits=function(){textureUnits=0};this.setTexture2D=setTexture2D;this.setTexture2DArray=function(texture,slot){const textureProperties=properties.get(texture);0<texture.version&&textureProperties.__version!==texture.version?uploadTexture(textureProperties,texture,slot):state.bindTexture(_gl.TEXTURE_2D_ARRAY,
textureProperties.__webglTexture,_gl.TEXTURE0+slot)};this.setTexture3D=function(texture,slot){const textureProperties=properties.get(texture);0<texture.version&&textureProperties.__version!==texture.version?uploadTexture(textureProperties,texture,slot):state.bindTexture(_gl.TEXTURE_3D,textureProperties.__webglTexture,_gl.TEXTURE0+slot)};this.setTextureCube=function(texture,slot){const textureProperties=properties.get(texture);if(0<texture.version&&textureProperties.__version!==texture.version){if(6===
texture.image.length){var forceUpload=initTexture(textureProperties,texture),source=texture.source;state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot);var sourceProperties=properties.get(source);if(source.version!==sourceProperties.__version||!0===forceUpload){state.activeTexture(_gl.TEXTURE0+slot);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,texture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,
texture.unpackAlignment);_gl.pixelStorei(_gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,_gl.NONE);var isCompressed=texture.isCompressedTexture||texture.image[0].isCompressedTexture,isDataTexture=texture.image[0]&&texture.image[0].isDataTexture;slot=[];for(var i=0;6>i;i++)slot[i]=isCompressed||isDataTexture?isDataTexture?texture.image[i].image:texture.image[i]:resizeImage(texture.image[i],!1,!0,maxCubemapSize),slot[i]=verifyColorSpace(texture,slot[i]);var image=slot[0];i=isPowerOfTwo$1(image)||isWebGL2;const glFormat=
utils.convert(texture.format,texture.encoding),glType=utils.convert(texture.type),glInternalFormat=getInternalFormat(texture.internalFormat,glFormat,glType,texture.encoding),useTexStorage=isWebGL2&&!0!==texture.isVideoTexture;forceUpload=void 0===sourceProperties.__version||!0===forceUpload;var levels=getMipLevels(texture,image,i);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,i);if(isCompressed)for(useTexStorage&&forceUpload&&state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,image.width,
image.height),isDataTexture=0;6>isDataTexture;isDataTexture++)for(isCompressed=slot[isDataTexture].mipmaps,forceUpload=0;forceUpload<isCompressed.length;forceUpload++)image=isCompressed[forceUpload],1023!==texture.format?null!==glFormat?useTexStorage?state.compressedTexSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+isDataTexture,forceUpload,0,0,image.width,image.height,glFormat,image.data):state.compressedTexImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+isDataTexture,forceUpload,glInternalFormat,image.width,
image.height,0,image.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+isDataTexture,forceUpload,0,0,image.width,image.height,glFormat,glType,image.data):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+isDataTexture,forceUpload,glInternalFormat,image.width,image.height,0,glFormat,glType,image.data);else for(isCompressed=texture.mipmaps,useTexStorage&&forceUpload&&
(0<isCompressed.length&&levels++,state.texStorage2D(_gl.TEXTURE_CUBE_MAP,levels,glInternalFormat,slot[0].width,slot[0].height)),forceUpload=0;6>forceUpload;forceUpload++)if(isDataTexture)for(useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,0,0,0,slot[forceUpload].width,slot[forceUpload].height,glFormat,glType,slot[forceUpload].data):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,0,glInternalFormat,slot[forceUpload].width,slot[forceUpload].height,0,glFormat,
glType,slot[forceUpload].data),image=0;image<isCompressed.length;image++)levels=isCompressed[image].image[forceUpload].image,useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,image+1,0,0,levels.width,levels.height,glFormat,glType,levels.data):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,image+1,glInternalFormat,levels.width,levels.height,0,glFormat,glType,levels.data);else for(useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,
0,0,0,glFormat,glType,slot[forceUpload]):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,0,glInternalFormat,glFormat,glType,slot[forceUpload]),image=0;image<isCompressed.length;image++)levels=isCompressed[image],useTexStorage?state.texSubImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,image+1,0,0,glFormat,glType,levels.image[forceUpload]):state.texImage2D(_gl.TEXTURE_CUBE_MAP_POSITIVE_X+forceUpload,image+1,glInternalFormat,glFormat,glType,levels.image[forceUpload]);textureNeedsGenerateMipmaps(texture,
i)&&_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP);sourceProperties.__version=source.version;if(texture.onUpdate)texture.onUpdate(texture)}textureProperties.__version=texture.version}}else state.bindTexture(_gl.TEXTURE_CUBE_MAP,textureProperties.__webglTexture,_gl.TEXTURE0+slot)};this.rebindTextures=function(renderTarget,colorTexture,depthTexture){const renderTargetProperties=properties.get(renderTarget);void 0!==colorTexture&&setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,
renderTarget.texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D);void 0!==depthTexture&&setupDepthRenderbuffer(renderTarget)};this.setupRenderTarget=function(renderTarget){var texture=renderTarget.texture;const renderTargetProperties=properties.get(renderTarget);var textureProperties=properties.get(texture);renderTarget.addEventListener("dispose",onRenderTargetDispose);!0!==renderTarget.isWebGLMultipleRenderTargets&&(void 0===textureProperties.__webglTexture&&(textureProperties.__webglTexture=_gl.createTexture()),
textureProperties.__version=texture.version,info.memory.textures++);var isCube=!0===renderTarget.isWebGLCubeRenderTarget;const isMultipleRenderTargets=!0===renderTarget.isWebGLMultipleRenderTargets,supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2;if(isCube){renderTargetProperties.__webglFramebuffer=[];for(var i$jscomp$0=0;6>i$jscomp$0;i$jscomp$0++)renderTargetProperties.__webglFramebuffer[i$jscomp$0]=_gl.createFramebuffer()}else{renderTargetProperties.__webglFramebuffer=_gl.createFramebuffer();
if(isMultipleRenderTargets)if(capabilities.drawBuffers){i$jscomp$0=renderTarget.texture;for(let i=0,il=i$jscomp$0.length;i<il;i++){var attachmentProperties=properties.get(i$jscomp$0[i]);void 0===attachmentProperties.__webglTexture&&(attachmentProperties.__webglTexture=_gl.createTexture(),info.memory.textures++)}}else console.warn("THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension.");if(isWebGL2&&0<renderTarget.samples&&!1===useMultisampledRTT(renderTarget)){i$jscomp$0=
isMultipleRenderTargets?texture:[texture];renderTargetProperties.__webglMultisampledFramebuffer=_gl.createFramebuffer();renderTargetProperties.__webglColorRenderbuffer=[];state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);for(attachmentProperties=0;attachmentProperties<i$jscomp$0.length;attachmentProperties++){var texture$jscomp$0=i$jscomp$0[attachmentProperties];renderTargetProperties.__webglColorRenderbuffer[attachmentProperties]=_gl.createRenderbuffer();
_gl.bindRenderbuffer(_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[attachmentProperties]);var glFormat=utils.convert(texture$jscomp$0.format,texture$jscomp$0.encoding);const glType=utils.convert(texture$jscomp$0.type);texture$jscomp$0=getInternalFormat(texture$jscomp$0.internalFormat,glFormat,glType,texture$jscomp$0.encoding,!0===renderTarget.isXRRenderTarget);glFormat=getRenderTargetSamples(renderTarget);_gl.renderbufferStorageMultisample(_gl.RENDERBUFFER,glFormat,texture$jscomp$0,
renderTarget.width,renderTarget.height);_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+attachmentProperties,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[attachmentProperties])}_gl.bindRenderbuffer(_gl.RENDERBUFFER,null);renderTarget.depthBuffer&&(renderTargetProperties.__webglDepthRenderbuffer=_gl.createRenderbuffer(),setupRenderBufferStorage(renderTargetProperties.__webglDepthRenderbuffer,renderTarget,!0));state.bindFramebuffer(_gl.FRAMEBUFFER,null)}}if(isCube){state.bindTexture(_gl.TEXTURE_CUBE_MAP,
textureProperties.__webglTexture);setTextureParameters(_gl.TEXTURE_CUBE_MAP,texture,supportsMips);for(textureProperties=0;6>textureProperties;textureProperties++)setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer[textureProperties],renderTarget,texture,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+textureProperties);textureNeedsGenerateMipmaps(texture,supportsMips)&&_gl.generateMipmap(_gl.TEXTURE_CUBE_MAP)}else if(isMultipleRenderTargets){texture=renderTarget.texture;for(let i=
0,il=texture.length;i<il;i++)textureProperties=texture[i],isCube=properties.get(textureProperties),state.bindTexture(_gl.TEXTURE_2D,isCube.__webglTexture),setTextureParameters(_gl.TEXTURE_2D,textureProperties,supportsMips),setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,textureProperties,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D),textureNeedsGenerateMipmaps(textureProperties,supportsMips)&&_gl.generateMipmap(_gl.TEXTURE_2D)}else{isCube=_gl.TEXTURE_2D;if(renderTarget.isWebGL3DRenderTarget||
renderTarget.isWebGLArrayRenderTarget)isWebGL2?isCube=renderTarget.isWebGL3DRenderTarget?_gl.TEXTURE_3D:_gl.TEXTURE_2D_ARRAY:console.error("THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2.");state.bindTexture(isCube,textureProperties.__webglTexture);setTextureParameters(isCube,texture,supportsMips);setupFrameBufferTexture(renderTargetProperties.__webglFramebuffer,renderTarget,texture,_gl.COLOR_ATTACHMENT0,isCube);textureNeedsGenerateMipmaps(texture,supportsMips)&&
_gl.generateMipmap(isCube)}state.unbindTexture();renderTarget.depthBuffer&&setupDepthRenderbuffer(renderTarget)};this.updateRenderTargetMipmap=function(renderTarget){const supportsMips=isPowerOfTwo$1(renderTarget)||isWebGL2,textures=!0===renderTarget.isWebGLMultipleRenderTargets?renderTarget.texture:[renderTarget.texture];for(let i=0,il=textures.length;i<il;i++){var texture=textures[i];if(textureNeedsGenerateMipmaps(texture,supportsMips)){const target=renderTarget.isWebGLCubeRenderTarget?_gl.TEXTURE_CUBE_MAP:
_gl.TEXTURE_2D;texture=properties.get(texture).__webglTexture;state.bindTexture(target,texture);_gl.generateMipmap(target);state.unbindTexture()}}};this.updateMultisampleRenderTarget=function(renderTarget){if(isWebGL2&&0<renderTarget.samples&&!1===useMultisampledRTT(renderTarget)){const textures=renderTarget.isWebGLMultipleRenderTargets?renderTarget.texture:[renderTarget.texture];var width=renderTarget.width;const height=renderTarget.height;let mask=_gl.COLOR_BUFFER_BIT;const invalidationArray=[],
depthStyle=renderTarget.stencilBuffer?_gl.DEPTH_STENCIL_ATTACHMENT:_gl.DEPTH_ATTACHMENT,renderTargetProperties=properties.get(renderTarget),isMultipleRenderTargets=!0===renderTarget.isWebGLMultipleRenderTargets;if(isMultipleRenderTargets)for(var i=0;i<textures.length;i++)state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer),_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.RENDERBUFFER,null),state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer),
_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+i,_gl.TEXTURE_2D,null,0);state.bindFramebuffer(_gl.READ_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglFramebuffer);for(i=0;i<textures.length;i++){invalidationArray.push(_gl.COLOR_ATTACHMENT0+i);renderTarget.depthBuffer&&invalidationArray.push(depthStyle);var ignoreDepthValues=void 0!==renderTargetProperties.__ignoreDepthValues?renderTargetProperties.__ignoreDepthValues:
!1;!1===ignoreDepthValues&&(renderTarget.depthBuffer&&(mask|=_gl.DEPTH_BUFFER_BIT),renderTarget.stencilBuffer&&(mask|=_gl.STENCIL_BUFFER_BIT));isMultipleRenderTargets&&_gl.framebufferRenderbuffer(_gl.READ_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[i]);!0===ignoreDepthValues&&(_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER,[depthStyle]),_gl.invalidateFramebuffer(_gl.DRAW_FRAMEBUFFER,[depthStyle]));isMultipleRenderTargets&&(ignoreDepthValues=properties.get(textures[i]).__webglTexture,
_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_2D,ignoreDepthValues,0));_gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,_gl.NEAREST);supportsInvalidateFramebuffer&&_gl.invalidateFramebuffer(_gl.READ_FRAMEBUFFER,invalidationArray)}state.bindFramebuffer(_gl.READ_FRAMEBUFFER,null);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,null);if(isMultipleRenderTargets)for(renderTarget=0;renderTarget<textures.length;renderTarget++)state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer),
_gl.framebufferRenderbuffer(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+renderTarget,_gl.RENDERBUFFER,renderTargetProperties.__webglColorRenderbuffer[renderTarget]),width=properties.get(textures[renderTarget]).__webglTexture,state.bindFramebuffer(_gl.FRAMEBUFFER,renderTargetProperties.__webglFramebuffer),_gl.framebufferTexture2D(_gl.DRAW_FRAMEBUFFER,_gl.COLOR_ATTACHMENT0+renderTarget,_gl.TEXTURE_2D,width,0);state.bindFramebuffer(_gl.DRAW_FRAMEBUFFER,renderTargetProperties.__webglMultisampledFramebuffer)}};
this.setupDepthRenderbuffer=setupDepthRenderbuffer;this.setupFrameBufferTexture=setupFrameBufferTexture;this.useMultisampledRTT=useMultisampledRTT}function WebGLUtils(gl,extensions,capabilities){const isWebGL2=capabilities.isWebGL2;return{convert:function(p,encoding=null){let extension;if(1009===p)return gl.UNSIGNED_BYTE;if(1017===p)return gl.UNSIGNED_SHORT_4_4_4_4;if(1018===p)return gl.UNSIGNED_SHORT_5_5_5_1;if(1010===p)return gl.BYTE;if(1011===p)return gl.SHORT;if(1012===p)return gl.UNSIGNED_SHORT;
if(1013===p)return gl.INT;if(1014===p)return gl.UNSIGNED_INT;if(1015===p)return gl.FLOAT;if(1016===p){if(isWebGL2)return gl.HALF_FLOAT;extension=extensions.get("OES_texture_half_float");return null!==extension?extension.HALF_FLOAT_OES:null}if(1021===p)return gl.ALPHA;if(1023===p)return gl.RGBA;if(1024===p)return gl.LUMINANCE;if(1025===p)return gl.LUMINANCE_ALPHA;if(1026===p)return gl.DEPTH_COMPONENT;if(1027===p)return gl.DEPTH_STENCIL;if(1028===p)return gl.RED;if(1022===p)return console.warn("THREE.WebGLRenderer: THREE.RGBFormat has been removed. Use THREE.RGBAFormat instead. https://github.com/mrdoob/three.js/pull/23228"),
gl.RGBA;if(1035===p)return extension=extensions.get("EXT_sRGB"),null!==extension?extension.SRGB_ALPHA_EXT:null;if(1029===p)return gl.RED_INTEGER;if(1030===p)return gl.RG;if(1031===p)return gl.RG_INTEGER;if(1033===p)return gl.RGBA_INTEGER;if(33776===p||33777===p||33778===p||33779===p)if(3001===encoding)if(extension=extensions.get("WEBGL_compressed_texture_s3tc_srgb"),null!==extension){if(33776===p)return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(33777===p)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
if(33778===p)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(33779===p)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(extension=extensions.get("WEBGL_compressed_texture_s3tc"),null!==extension){if(33776===p)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===p)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===p)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===p)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(35840===p||
35841===p||35842===p||35843===p)if(extension=extensions.get("WEBGL_compressed_texture_pvrtc"),null!==extension){if(35840===p)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===p)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===p)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===p)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(36196===p)return extension=extensions.get("WEBGL_compressed_texture_etc1"),null!==extension?extension.COMPRESSED_RGB_ETC1_WEBGL:
null;if(37492===p||37496===p)if(extension=extensions.get("WEBGL_compressed_texture_etc"),null!==extension){if(37492===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ETC2:extension.COMPRESSED_RGB8_ETC2;if(37496===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:extension.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(37808===p||37809===p||37810===p||37811===p||37812===p||37813===p||37814===p||37815===p||37816===p||37817===p||37818===p||37819===p||37820===p||37821===p)if(extension=
extensions.get("WEBGL_compressed_texture_astc"),null!==extension){if(37808===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:extension.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:extension.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:extension.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:
extension.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:extension.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:extension.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:extension.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
if(37816===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:extension.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:extension.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:extension.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:extension.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===
p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:extension.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===p)return 3001===encoding?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:extension.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(36492===p)if(extension=extensions.get("EXT_texture_compression_bptc"),null!==extension){if(36492===p)return 3001===encoding?extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:extension.COMPRESSED_RGBA_BPTC_UNORM_EXT}else return null;if(1020===p){if(isWebGL2)return gl.UNSIGNED_INT_24_8;
extension=extensions.get("WEBGL_depth_texture");return null!==extension?extension.UNSIGNED_INT_24_8_WEBGL:null}return void 0!==gl[p]?gl[p]:null}}}function WebGLMaterials(renderer,properties){function refreshUniformsCommon(uniforms,material){uniforms.opacity.value=material.opacity;material.color&&uniforms.diffuse.value.copy(material.color);material.emissive&&uniforms.emissive.value.copy(material.emissive).multiplyScalar(material.emissiveIntensity);material.map&&(uniforms.map.value=material.map);material.alphaMap&&
(uniforms.alphaMap.value=material.alphaMap);material.bumpMap&&(uniforms.bumpMap.value=material.bumpMap,uniforms.bumpScale.value=material.bumpScale,1===material.side&&(uniforms.bumpScale.value*=-1));material.displacementMap&&(uniforms.displacementMap.value=material.displacementMap,uniforms.displacementScale.value=material.displacementScale,uniforms.displacementBias.value=material.displacementBias);material.emissiveMap&&(uniforms.emissiveMap.value=material.emissiveMap);material.normalMap&&(uniforms.normalMap.value=
material.normalMap,uniforms.normalScale.value.copy(material.normalScale),1===material.side&&uniforms.normalScale.value.negate());material.specularMap&&(uniforms.specularMap.value=material.specularMap);0<material.alphaTest&&(uniforms.alphaTest.value=material.alphaTest);const envMap=properties.get(material).envMap;envMap&&(uniforms.envMap.value=envMap,uniforms.flipEnvMap.value=envMap.isCubeTexture&&!1===envMap.isRenderTargetTexture?-1:1,uniforms.reflectivity.value=material.reflectivity,uniforms.ior.value=
material.ior,uniforms.refractionRatio.value=material.refractionRatio);material.lightMap&&(uniforms.lightMap.value=material.lightMap,uniforms.lightMapIntensity.value=material.lightMapIntensity*(!0!==renderer.physicallyCorrectLights?Math.PI:1));material.aoMap&&(uniforms.aoMap.value=material.aoMap,uniforms.aoMapIntensity.value=material.aoMapIntensity);let uvScaleMap;material.map?uvScaleMap=material.map:material.specularMap?uvScaleMap=material.specularMap:material.displacementMap?uvScaleMap=material.displacementMap:
material.normalMap?uvScaleMap=material.normalMap:material.bumpMap?uvScaleMap=material.bumpMap:material.roughnessMap?uvScaleMap=material.roughnessMap:material.metalnessMap?uvScaleMap=material.metalnessMap:material.alphaMap?uvScaleMap=material.alphaMap:material.emissiveMap?uvScaleMap=material.emissiveMap:material.clearcoatMap?uvScaleMap=material.clearcoatMap:material.clearcoatNormalMap?uvScaleMap=material.clearcoatNormalMap:material.clearcoatRoughnessMap?uvScaleMap=material.clearcoatRoughnessMap:material.iridescenceMap?
uvScaleMap=material.iridescenceMap:material.iridescenceThicknessMap?uvScaleMap=material.iridescenceThicknessMap:material.specularIntensityMap?uvScaleMap=material.specularIntensityMap:material.specularColorMap?uvScaleMap=material.specularColorMap:material.transmissionMap?uvScaleMap=material.transmissionMap:material.thicknessMap?uvScaleMap=material.thicknessMap:material.sheenColorMap?uvScaleMap=material.sheenColorMap:material.sheenRoughnessMap&&(uvScaleMap=material.sheenRoughnessMap);void 0!==uvScaleMap&&
(uvScaleMap.isWebGLRenderTarget&&(uvScaleMap=uvScaleMap.texture),!0===uvScaleMap.matrixAutoUpdate&&uvScaleMap.updateMatrix(),uniforms.uvTransform.value.copy(uvScaleMap.matrix));let uv2ScaleMap;material.aoMap?uv2ScaleMap=material.aoMap:material.lightMap&&(uv2ScaleMap=material.lightMap);void 0!==uv2ScaleMap&&(uv2ScaleMap.isWebGLRenderTarget&&(uv2ScaleMap=uv2ScaleMap.texture),!0===uv2ScaleMap.matrixAutoUpdate&&uv2ScaleMap.updateMatrix(),uniforms.uv2Transform.value.copy(uv2ScaleMap.matrix))}return{refreshFogUniforms:function(uniforms,
fog){uniforms.fogColor.value.copy(fog.color);fog.isFog?(uniforms.fogNear.value=fog.near,uniforms.fogFar.value=fog.far):fog.isFogExp2&&(uniforms.fogDensity.value=fog.density)},refreshMaterialUniforms:function(uniforms,material,pixelRatio,height,transmissionRenderTarget){if(material.isMeshBasicMaterial)refreshUniformsCommon(uniforms,material);else if(material.isMeshLambertMaterial)refreshUniformsCommon(uniforms,material);else if(material.isMeshToonMaterial)refreshUniformsCommon(uniforms,material),material.gradientMap&&
(uniforms.gradientMap.value=material.gradientMap);else if(material.isMeshPhongMaterial)refreshUniformsCommon(uniforms,material),uniforms.specular.value.copy(material.specular),uniforms.shininess.value=Math.max(material.shininess,1E-4);else if(material.isMeshStandardMaterial)refreshUniformsCommon(uniforms,material),uniforms.roughness.value=material.roughness,uniforms.metalness.value=material.metalness,material.roughnessMap&&(uniforms.roughnessMap.value=material.roughnessMap),material.metalnessMap&&
(uniforms.metalnessMap.value=material.metalnessMap),properties.get(material).envMap&&(uniforms.envMapIntensity.value=material.envMapIntensity),material.isMeshPhysicalMaterial&&(uniforms.ior.value=material.ior,0<material.sheen&&(uniforms.sheenColor.value.copy(material.sheenColor).multiplyScalar(material.sheen),uniforms.sheenRoughness.value=material.sheenRoughness,material.sheenColorMap&&(uniforms.sheenColorMap.value=material.sheenColorMap),material.sheenRoughnessMap&&(uniforms.sheenRoughnessMap.value=
material.sheenRoughnessMap)),0<material.clearcoat&&(uniforms.clearcoat.value=material.clearcoat,uniforms.clearcoatRoughness.value=material.clearcoatRoughness,material.clearcoatMap&&(uniforms.clearcoatMap.value=material.clearcoatMap),material.clearcoatRoughnessMap&&(uniforms.clearcoatRoughnessMap.value=material.clearcoatRoughnessMap),material.clearcoatNormalMap&&(uniforms.clearcoatNormalScale.value.copy(material.clearcoatNormalScale),uniforms.clearcoatNormalMap.value=material.clearcoatNormalMap,1===
material.side&&uniforms.clearcoatNormalScale.value.negate())),0<material.iridescence&&(uniforms.iridescence.value=material.iridescence,uniforms.iridescenceIOR.value=material.iridescenceIOR,uniforms.iridescenceThicknessMinimum.value=material.iridescenceThicknessRange[0],uniforms.iridescenceThicknessMaximum.value=material.iridescenceThicknessRange[1],material.iridescenceMap&&(uniforms.iridescenceMap.value=material.iridescenceMap),material.iridescenceThicknessMap&&(uniforms.iridescenceThicknessMap.value=
material.iridescenceThicknessMap)),0<material.transmission&&(uniforms.transmission.value=material.transmission,uniforms.transmissionSamplerMap.value=transmissionRenderTarget.texture,uniforms.transmissionSamplerSize.value.set(transmissionRenderTarget.width,transmissionRenderTarget.height),material.transmissionMap&&(uniforms.transmissionMap.value=material.transmissionMap),uniforms.thickness.value=material.thickness,material.thicknessMap&&(uniforms.thicknessMap.value=material.thicknessMap),uniforms.attenuationDistance.value=
material.attenuationDistance,uniforms.attenuationColor.value.copy(material.attenuationColor)),uniforms.specularIntensity.value=material.specularIntensity,uniforms.specularColor.value.copy(material.specularColor),material.specularIntensityMap&&(uniforms.specularIntensityMap.value=material.specularIntensityMap),material.specularColorMap&&(uniforms.specularColorMap.value=material.specularColorMap));else if(material.isMeshMatcapMaterial)refreshUniformsCommon(uniforms,material),material.matcap&&(uniforms.matcap.value=
material.matcap);else if(material.isMeshDepthMaterial)refreshUniformsCommon(uniforms,material);else if(material.isMeshDistanceMaterial)refreshUniformsCommon(uniforms,material),uniforms.referencePosition.value.copy(material.referencePosition),uniforms.nearDistance.value=material.nearDistance,uniforms.farDistance.value=material.farDistance;else if(material.isMeshNormalMaterial)refreshUniformsCommon(uniforms,material);else if(material.isLineBasicMaterial)uniforms.diffuse.value.copy(material.color),uniforms.opacity.value=
material.opacity,material.isLineDashedMaterial&&(uniforms.dashSize.value=material.dashSize,uniforms.totalSize.value=material.dashSize+material.gapSize,uniforms.scale.value=material.scale);else if(material.isPointsMaterial){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.size.value=material.size*pixelRatio;uniforms.scale.value=.5*height;material.map&&(uniforms.map.value=material.map);material.alphaMap&&(uniforms.alphaMap.value=material.alphaMap);0<material.alphaTest&&
(uniforms.alphaTest.value=material.alphaTest);let uvScaleMap;material.map?uvScaleMap=material.map:material.alphaMap&&(uvScaleMap=material.alphaMap);void 0!==uvScaleMap&&(!0===uvScaleMap.matrixAutoUpdate&&uvScaleMap.updateMatrix(),uniforms.uvTransform.value.copy(uvScaleMap.matrix))}else if(material.isSpriteMaterial){uniforms.diffuse.value.copy(material.color);uniforms.opacity.value=material.opacity;uniforms.rotation.value=material.rotation;material.map&&(uniforms.map.value=material.map);material.alphaMap&&
(uniforms.alphaMap.value=material.alphaMap);0<material.alphaTest&&(uniforms.alphaTest.value=material.alphaTest);let uvScaleMap;material.map?uvScaleMap=material.map:material.alphaMap&&(uvScaleMap=material.alphaMap);void 0!==uvScaleMap&&(!0===uvScaleMap.matrixAutoUpdate&&uvScaleMap.updateMatrix(),uniforms.uvTransform.value.copy(uvScaleMap.matrix))}else material.isShadowMaterial?(uniforms.color.value.copy(material.color),uniforms.opacity.value=material.opacity):material.isShaderMaterial&&(material.uniformsNeedUpdate=
!1)}}}function WebGLUniformsGroups(gl,info$jscomp$0,capabilities,state){function prepareUniformsGroup(uniformsGroup){const uniforms=uniformsGroup.uniforms;let offset=0;for(let i=0,l=uniforms.length;i<l;i++){const uniform=uniforms[i];var chunkOffset=uniform.value;var info={boundary:0,storage:0};"number"===typeof chunkOffset?(info.boundary=4,info.storage=4):chunkOffset.isVector2?(info.boundary=8,info.storage=8):chunkOffset.isVector3||chunkOffset.isColor?(info.boundary=16,info.storage=12):chunkOffset.isVector4?
(info.boundary=16,info.storage=16):chunkOffset.isMatrix3?(info.boundary=48,info.storage=48):chunkOffset.isMatrix4?(info.boundary=64,info.storage=64):chunkOffset.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",chunkOffset);uniform.__data=new Float32Array(info.storage/Float32Array.BYTES_PER_ELEMENT);uniform.__offset=offset;if(0<i){chunkOffset=offset%16;const remainingSizeInChunk=
16-chunkOffset;0!==chunkOffset&&0>remainingSizeInChunk-info.boundary&&(offset+=16-chunkOffset,uniform.__offset=offset)}offset+=info.storage}chunkOffset=offset%16;0<chunkOffset&&(offset+=16-chunkOffset);uniformsGroup.__size=offset;uniformsGroup.__cache={};return this}function onUniformsGroupsDispose(event){event=event.target;event.removeEventListener("dispose",onUniformsGroupsDispose);const index=allocatedBindingPoints.indexOf(event.__bindingPointIndex);allocatedBindingPoints.splice(index,1);gl.deleteBuffer(buffers[event.id]);
delete buffers[event.id];delete updateList[event.id]}let buffers={},updateList={},allocatedBindingPoints=[];const maxBindingPoints=capabilities.isWebGL2?gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS):0;return{bind:function(uniformsGroup,program){state.uniformBlockBinding(uniformsGroup,program.program)},update:function(uniformsGroup,program){var buffer=buffers[uniformsGroup.id];if(void 0===buffer){prepareUniformsGroup(uniformsGroup);a:{for(buffer=0;buffer<maxBindingPoints;buffer++)if(-1===allocatedBindingPoints.indexOf(buffer)){allocatedBindingPoints.push(buffer);
break a}console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");buffer=0}uniformsGroup.__bindingPointIndex=buffer;var buffer$jscomp$0=gl.createBuffer(),size=uniformsGroup.__size,usage=uniformsGroup.usage;gl.bindBuffer(gl.UNIFORM_BUFFER,buffer$jscomp$0);gl.bufferData(gl.UNIFORM_BUFFER,size,usage);gl.bindBuffer(gl.UNIFORM_BUFFER,null);gl.bindBufferBase(gl.UNIFORM_BUFFER,buffer,buffer$jscomp$0);buffer=buffer$jscomp$0;buffers[uniformsGroup.id]=buffer;uniformsGroup.addEventListener("dispose",
onUniformsGroupsDispose)}state.updateUBOMapping(uniformsGroup,program.program);program=info$jscomp$0.render.frame;if(updateList[uniformsGroup.id]!==program){buffer=uniformsGroup.uniforms;buffer$jscomp$0=uniformsGroup.__cache;gl.bindBuffer(gl.UNIFORM_BUFFER,buffers[uniformsGroup.id]);for(let i=0,il=buffer.length;i<il;i++){size=buffer[i];a:{var index=i,cache=buffer$jscomp$0;usage=size.value;if(void 0===cache[index])cache[index]="number"===typeof usage?usage:usage.clone(),usage=!0;else{if("number"===
typeof usage){if(cache[index]!==usage){cache[index]=usage;usage=!0;break a}}else if(index=cache[index],!1===index.equals(usage)){index.copy(usage);usage=!0;break a}usage=!1}}!0===usage&&(usage=size.value,index=size.__offset,"number"===typeof usage?size.__data[0]=usage:size.value.isMatrix3?(size.__data[0]=size.value.elements[0],size.__data[1]=size.value.elements[1],size.__data[2]=size.value.elements[2],size.__data[3]=size.value.elements[0],size.__data[4]=size.value.elements[3],size.__data[5]=size.value.elements[4],
size.__data[6]=size.value.elements[5],size.__data[7]=size.value.elements[0],size.__data[8]=size.value.elements[6],size.__data[9]=size.value.elements[7],size.__data[10]=size.value.elements[8],size.__data[11]=size.value.elements[0]):usage.toArray(size.__data),gl.bufferSubData(gl.UNIFORM_BUFFER,index,size.__data))}gl.bindBuffer(gl.UNIFORM_BUFFER,null);updateList[uniformsGroup.id]=program}},dispose:function(){for(const id in buffers)gl.deleteBuffer(buffers[id]);allocatedBindingPoints=[];buffers={};updateList=
{}}}}function createCanvasElement(){const canvas=createElementNS("canvas");canvas.style.display="block";return canvas}function WebGLRenderer(parameters$jscomp$0={}){function getContext(contextNames,contextAttributes){for(let i=0;i<contextNames.length;i++){const context=_canvas.getContext(contextNames[i],contextAttributes);if(null!==context)return context}return null}function initGLContext(){extensions=new WebGLExtensions(_gl);capabilities=new WebGLCapabilities(_gl,extensions,parameters$jscomp$0);
extensions.init(capabilities);utils=new WebGLUtils(_gl,extensions,capabilities);state=new WebGLState(_gl,extensions,capabilities);info=new WebGLInfo(_gl);properties=new WebGLProperties;textures=new WebGLTextures(_gl,extensions,state,properties,capabilities,utils,info);cubemaps=new WebGLCubeMaps(_this);cubeuvmaps=new WebGLCubeUVMaps(_this);attributes=new WebGLAttributes(_gl,capabilities);bindingStates=new WebGLBindingStates(_gl,extensions,attributes,capabilities);geometries=new WebGLGeometries(_gl,
attributes,info,bindingStates);objects=new WebGLObjects(_gl,geometries,attributes,info);morphtargets=new WebGLMorphtargets(_gl,capabilities,textures);clipping=new WebGLClipping(properties);programCache=new WebGLPrograms(_this,cubemaps,cubeuvmaps,extensions,capabilities,bindingStates,clipping);materials=new WebGLMaterials(_this,properties);renderLists=new WebGLRenderLists;renderStates=new WebGLRenderStates(extensions,capabilities);background=new WebGLBackground(_this,cubemaps,cubeuvmaps,state,objects,
_alpha,_premultipliedAlpha);shadowMap=new WebGLShadowMap(_this,objects,capabilities);uniformsGroups=new WebGLUniformsGroups(_gl,info,capabilities,state);bufferRenderer=new WebGLBufferRenderer(_gl,extensions,info,capabilities);indexedBufferRenderer=new WebGLIndexedBufferRenderer(_gl,extensions,info,capabilities);info.programs=programCache.programs;_this.capabilities=capabilities;_this.extensions=extensions;_this.properties=properties;_this.renderLists=renderLists;_this.shadowMap=shadowMap;_this.state=
state;_this.info=info}function onContextLost(event){event.preventDefault();console.log("THREE.WebGLRenderer: Context Lost.");_isContextLost=!0}function onContextRestore(){console.log("THREE.WebGLRenderer: Context Restored.");_isContextLost=!1;const infoAutoReset=info.autoReset,shadowMapEnabled=shadowMap.enabled,shadowMapAutoUpdate=shadowMap.autoUpdate,shadowMapNeedsUpdate=shadowMap.needsUpdate,shadowMapType=shadowMap.type;initGLContext();info.autoReset=infoAutoReset;shadowMap.enabled=shadowMapEnabled;
shadowMap.autoUpdate=shadowMapAutoUpdate;shadowMap.needsUpdate=shadowMapNeedsUpdate;shadowMap.type=shadowMapType}function onContextCreationError(event){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",event.statusMessage)}function onMaterialDispose(event){event=event.target;event.removeEventListener("dispose",onMaterialDispose);releaseMaterialProgramReferences(event);properties.remove(event)}function releaseMaterialProgramReferences(material){const programs=properties.get(material).programs;
void 0!==programs&&(programs.forEach(function(program){programCache.releaseProgram(program)}),material.isShaderMaterial&&programCache.releaseShaderCache(material))}function onXRSessionStart(){animation.stop()}function onXRSessionEnd(){animation.start()}function projectObject(object,camera,groupOrder,sortObjects){if(!1!==object.visible){if(object.layers.test(camera.layers))if(object.isGroup)groupOrder=object.renderOrder;else if(object.isLOD)!0===object.autoUpdate&&object.update(camera);else if(object.isLight)currentRenderState.pushLight(object),
object.castShadow&&currentRenderState.pushShadow(object);else if(object.isSprite){if(!object.frustumCulled||_frustum.intersectsSprite(object)){sortObjects&&_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);var geometry=objects.update(object),material=object.material;material.visible&&currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null)}}else if(object.isMesh||object.isLine||object.isPoints)if(object.isSkinnedMesh&&object.skeleton.frame!==info.render.frame&&
(object.skeleton.update(),object.skeleton.frame=info.render.frame),!object.frustumCulled||_frustum.intersectsObject(object))if(sortObjects&&_vector3.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix),geometry=objects.update(object),material=object.material,Array.isArray(material)){const groups=geometry.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i],groupMaterial=material[group.materialIndex];groupMaterial&&groupMaterial.visible&&currentRenderList.push(object,
geometry,groupMaterial,groupOrder,_vector3.z,group)}}else material.visible&&currentRenderList.push(object,geometry,material,groupOrder,_vector3.z,null);object=object.children;for(let i=0,l=object.length;i<l;i++)projectObject(object[i],camera,groupOrder,sortObjects)}}function renderScene(currentRenderList,scene,camera,viewport){const opaqueObjects=currentRenderList.opaque,transmissiveObjects=currentRenderList.transmissive;currentRenderList=currentRenderList.transparent;currentRenderState.setupLightsView(camera);
if(0<transmissiveObjects.length){var isWebGL2=capabilities.isWebGL2;null===_transmissionRenderTarget&&(_transmissionRenderTarget=new WebGLRenderTarget(1,1,{generateMipmaps:!0,type:extensions.has("EXT_color_buffer_half_float")?1016:1009,minFilter:1008,samples:isWebGL2&&!0===_antialias?4:0}));_this.getDrawingBufferSize(_vector2);isWebGL2?_transmissionRenderTarget.setSize(_vector2.x,_vector2.y):_transmissionRenderTarget.setSize(floorPowerOfTwo(_vector2.x),floorPowerOfTwo(_vector2.y));isWebGL2=_this.getRenderTarget();
_this.setRenderTarget(_transmissionRenderTarget);_this.clear();const currentToneMapping=_this.toneMapping;_this.toneMapping=0;renderObjects(opaqueObjects,scene,camera);_this.toneMapping=currentToneMapping;textures.updateMultisampleRenderTarget(_transmissionRenderTarget);textures.updateRenderTargetMipmap(_transmissionRenderTarget);_this.setRenderTarget(isWebGL2)}viewport&&state.viewport(_currentViewport.copy(viewport));0<opaqueObjects.length&&renderObjects(opaqueObjects,scene,camera);0<transmissiveObjects.length&&
renderObjects(transmissiveObjects,scene,camera);0<currentRenderList.length&&renderObjects(currentRenderList,scene,camera);state.buffers.depth.setTest(!0);state.buffers.depth.setMask(!0);state.buffers.color.setMask(!0);state.setPolygonOffset(!1)}function renderObjects(renderList,scene,camera$jscomp$0){const overrideMaterial=!0===scene.isScene?scene.overrideMaterial:null;for(let i=0,l=renderList.length;i<l;i++){var renderItem=renderList[i],object=renderItem.object,geometry=renderItem.geometry,material=
null===overrideMaterial?renderItem.material:overrideMaterial,group=renderItem.group;if(object.layers.test(camera$jscomp$0.layers)){renderItem=scene;var camera=camera$jscomp$0;object.onBeforeRender(_this,renderItem,camera,geometry,material,group);object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld);object.normalMatrix.getNormalMatrix(object.modelViewMatrix);material.onBeforeRender(_this,renderItem,camera,geometry,object,group);!0===material.transparent&&2===material.side?
(material.side=1,material.needsUpdate=!0,_this.renderBufferDirect(camera,renderItem,geometry,material,object,group),material.side=0,material.needsUpdate=!0,_this.renderBufferDirect(camera,renderItem,geometry,material,object,group),material.side=2):_this.renderBufferDirect(camera,renderItem,geometry,material,object,group);object.onAfterRender(_this,renderItem,camera,geometry,material,group)}}}function getProgram(material,scene,object){!0!==scene.isScene&&(scene=_emptyScene);const materialProperties=
properties.get(material),lights=currentRenderState.state.lights,lightsStateVersion=lights.state.version,parameters=programCache.getParameters(material,lights.state,currentRenderState.state.shadowsArray,scene,object),programCacheKey=programCache.getProgramCacheKey(parameters);let programs=materialProperties.programs;materialProperties.environment=material.isMeshStandardMaterial?scene.environment:null;materialProperties.fog=scene.fog;materialProperties.envMap=(material.isMeshStandardMaterial?cubeuvmaps:
cubemaps).get(material.envMap||materialProperties.environment);void 0===programs&&(material.addEventListener("dispose",onMaterialDispose),programs=new Map,materialProperties.programs=programs);scene=programs.get(programCacheKey);if(void 0!==scene){if(materialProperties.currentProgram===scene&&materialProperties.lightsStateVersion===lightsStateVersion)return updateCommonMaterialProperties(material,parameters),scene}else parameters.uniforms=programCache.getUniforms(material),material.onBuild(object,
parameters,_this),material.onBeforeCompile(parameters,_this),scene=programCache.acquireProgram(parameters,programCacheKey),programs.set(programCacheKey,scene),materialProperties.uniforms=parameters.uniforms;object=materialProperties.uniforms;if(!material.isShaderMaterial&&!material.isRawShaderMaterial||!0===material.clipping)object.clippingPlanes=clipping.uniform;updateCommonMaterialProperties(material,parameters);materialProperties.needsLights=material.isMeshLambertMaterial||material.isMeshToonMaterial||
material.isMeshPhongMaterial||material.isMeshStandardMaterial||material.isShadowMaterial||material.isShaderMaterial&&!0===material.lights;materialProperties.lightsStateVersion=lightsStateVersion;materialProperties.needsLights&&(object.ambientLightColor.value=lights.state.ambient,object.lightProbe.value=lights.state.probe,object.directionalLights.value=lights.state.directional,object.directionalLightShadows.value=lights.state.directionalShadow,object.spotLights.value=lights.state.spot,object.spotLightShadows.value=
lights.state.spotShadow,object.rectAreaLights.value=lights.state.rectArea,object.ltc_1.value=lights.state.rectAreaLTC1,object.ltc_2.value=lights.state.rectAreaLTC2,object.pointLights.value=lights.state.point,object.pointLightShadows.value=lights.state.pointShadow,object.hemisphereLights.value=lights.state.hemi,object.directionalShadowMap.value=lights.state.directionalShadowMap,object.directionalShadowMatrix.value=lights.state.directionalShadowMatrix,object.spotShadowMap.value=lights.state.spotShadowMap,
object.spotLightMatrix.value=lights.state.spotLightMatrix,object.spotLightMap.value=lights.state.spotLightMap,object.pointShadowMap.value=lights.state.pointShadowMap,object.pointShadowMatrix.value=lights.state.pointShadowMatrix);material=scene.getUniforms();material=WebGLUniforms.seqWithValue(material.seq,object);materialProperties.currentProgram=scene;materialProperties.uniformsList=material;return scene}function updateCommonMaterialProperties(material,parameters){material=properties.get(material);
material.outputEncoding=parameters.outputEncoding;material.instancing=parameters.instancing;material.skinning=parameters.skinning;material.morphTargets=parameters.morphTargets;material.morphNormals=parameters.morphNormals;material.morphColors=parameters.morphColors;material.morphTargetsCount=parameters.morphTargetsCount;material.numClippingPlanes=parameters.numClippingPlanes;material.numIntersection=parameters.numClipIntersection;material.vertexAlphas=parameters.vertexAlphas;material.vertexTangents=
parameters.vertexTangents;material.toneMapping=parameters.toneMapping}this.isWebGLRenderer=!0;const _canvas=void 0!==parameters$jscomp$0.canvas?parameters$jscomp$0.canvas:createCanvasElement();var _context=void 0!==parameters$jscomp$0.context?parameters$jscomp$0.context:null,_depth=void 0!==parameters$jscomp$0.depth?parameters$jscomp$0.depth:!0;const _stencil=void 0!==parameters$jscomp$0.stencil?parameters$jscomp$0.stencil:!0,_antialias=void 0!==parameters$jscomp$0.antialias?parameters$jscomp$0.antialias:
!1,_premultipliedAlpha=void 0!==parameters$jscomp$0.premultipliedAlpha?parameters$jscomp$0.premultipliedAlpha:!0,_preserveDrawingBuffer=void 0!==parameters$jscomp$0.preserveDrawingBuffer?parameters$jscomp$0.preserveDrawingBuffer:!1,_powerPreference=void 0!==parameters$jscomp$0.powerPreference?parameters$jscomp$0.powerPreference:"default",_failIfMajorPerformanceCaveat=void 0!==parameters$jscomp$0.failIfMajorPerformanceCaveat?parameters$jscomp$0.failIfMajorPerformanceCaveat:!1;let _alpha;_alpha=null!==
_context?_context.getContextAttributes().alpha:void 0!==parameters$jscomp$0.alpha?parameters$jscomp$0.alpha:!1;let currentRenderList=null,currentRenderState=null;const renderListStack=[],renderStateStack=[];this.domElement=_canvas;this.debug={checkShaderErrors:!0};this.sortObjects=this.autoClearStencil=this.autoClearDepth=this.autoClearColor=this.autoClear=!0;this.clippingPlanes=[];this.localClippingEnabled=!1;this.outputEncoding=3E3;this.physicallyCorrectLights=!1;this.toneMapping=0;this.toneMappingExposure=
1;Object.defineProperties(this,{gammaFactor:{get:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.");return 2},set:function(){console.warn("THREE.WebGLRenderer: .gammaFactor has been removed.")}}});const _this=this;let _isContextLost=!1,_currentActiveCubeFace=0,_currentActiveMipmapLevel=0,_currentRenderTarget=null,_currentMaterialId=-1,_currentCamera=null;const _currentViewport=new Vector4,_currentScissor=new Vector4;let _currentScissorTest=null,_width=_canvas.width,_height=
_canvas.height,_pixelRatio=1,_opaqueSort=null,_transparentSort=null;const _viewport=new Vector4(0,0,_width,_height),_scissor=new Vector4(0,0,_width,_height);let _scissorTest=!1;const _frustum=new Frustum;let _clippingEnabled=!1,_localClippingEnabled=!1,_transmissionRenderTarget=null;const _projScreenMatrix=new Matrix4,_vector2=new Vector2,_vector3=new Vector3,_emptyScene={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let _gl=_context;try{_context={alpha:!0,depth:_depth,
stencil:_stencil,antialias:_antialias,premultipliedAlpha:_premultipliedAlpha,preserveDrawingBuffer:_preserveDrawingBuffer,powerPreference:_powerPreference,failIfMajorPerformanceCaveat:_failIfMajorPerformanceCaveat};"setAttribute"in _canvas&&_canvas.setAttribute("data-engine","three.js r146");_canvas.addEventListener("webglcontextlost",onContextLost,!1);_canvas.addEventListener("webglcontextrestored",onContextRestore,!1);_canvas.addEventListener("webglcontextcreationerror",onContextCreationError,!1);
if(null===_gl&&(_depth=["webgl2","webgl","experimental-webgl"],!0===_this.isWebGL1Renderer&&_depth.shift(),_gl=getContext(_depth,_context),null===_gl)){if(getContext(_depth))throw Error("Error creating WebGL context with your selected attributes.");throw Error("Error creating WebGL context.");}void 0===_gl.getShaderPrecisionFormat&&(_gl.getShaderPrecisionFormat=function(){return{rangeMin:1,rangeMax:1,precision:1}})}catch(error){throw console.error("THREE.WebGLRenderer: "+error.message),error;}let extensions,
capabilities,state,info,properties,textures,cubemaps,cubeuvmaps,attributes,geometries,objects,programCache,materials,renderLists,renderStates,clipping,shadowMap,background,morphtargets,bufferRenderer,indexedBufferRenderer,utils,bindingStates,uniformsGroups;initGLContext();const xr=new WebXRManager(_this,_gl);this.xr=xr;this.getContext=function(){return _gl};this.getContextAttributes=function(){return _gl.getContextAttributes()};this.forceContextLoss=function(){const extension=extensions.get("WEBGL_lose_context");
extension&&extension.loseContext()};this.forceContextRestore=function(){const extension=extensions.get("WEBGL_lose_context");extension&&extension.restoreContext()};this.getPixelRatio=function(){return _pixelRatio};this.setPixelRatio=function(value){void 0!==value&&(_pixelRatio=value,this.setSize(_width,_height,!1))};this.getSize=function(target){return target.set(_width,_height)};this.setSize=function(width,height,updateStyle){xr.isPresenting?console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting."):
(_width=width,_height=height,_canvas.width=Math.floor(width*_pixelRatio),_canvas.height=Math.floor(height*_pixelRatio),!1!==updateStyle&&(_canvas.style.width=width+"px",_canvas.style.height=height+"px"),this.setViewport(0,0,width,height))};this.getDrawingBufferSize=function(target){return target.set(_width*_pixelRatio,_height*_pixelRatio).floor()};this.setDrawingBufferSize=function(width,height,pixelRatio){_width=width;_height=height;_pixelRatio=pixelRatio;_canvas.width=Math.floor(width*pixelRatio);
_canvas.height=Math.floor(height*pixelRatio);this.setViewport(0,0,width,height)};this.getCurrentViewport=function(target){return target.copy(_currentViewport)};this.getViewport=function(target){return target.copy(_viewport)};this.setViewport=function(x,y,width,height){x.isVector4?_viewport.set(x.x,x.y,x.z,x.w):_viewport.set(x,y,width,height);state.viewport(_currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor())};this.getScissor=function(target){return target.copy(_scissor)};this.setScissor=
function(x,y,width,height){x.isVector4?_scissor.set(x.x,x.y,x.z,x.w):_scissor.set(x,y,width,height);state.scissor(_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor())};this.getScissorTest=function(){return _scissorTest};this.setScissorTest=function(boolean){state.setScissorTest(_scissorTest=boolean)};this.setOpaqueSort=function(method){_opaqueSort=method};this.setTransparentSort=function(method){_transparentSort=method};this.getClearColor=function(target){return target.copy(background.getClearColor())};
this.setClearColor=function(){background.setClearColor.apply(background,arguments)};this.getClearAlpha=function(){return background.getClearAlpha()};this.setClearAlpha=function(){background.setClearAlpha.apply(background,arguments)};this.clear=function(color=!0,depth=!0,stencil=!0){let bits=0;color&&(bits|=_gl.COLOR_BUFFER_BIT);depth&&(bits|=_gl.DEPTH_BUFFER_BIT);stencil&&(bits|=_gl.STENCIL_BUFFER_BIT);_gl.clear(bits)};this.clearColor=function(){this.clear(!0,!1,!1)};this.clearDepth=function(){this.clear(!1,
!0,!1)};this.clearStencil=function(){this.clear(!1,!1,!0)};this.dispose=function(){_canvas.removeEventListener("webglcontextlost",onContextLost,!1);_canvas.removeEventListener("webglcontextrestored",onContextRestore,!1);_canvas.removeEventListener("webglcontextcreationerror",onContextCreationError,!1);renderLists.dispose();renderStates.dispose();properties.dispose();cubemaps.dispose();cubeuvmaps.dispose();objects.dispose();bindingStates.dispose();uniformsGroups.dispose();programCache.dispose();xr.dispose();
xr.removeEventListener("sessionstart",onXRSessionStart);xr.removeEventListener("sessionend",onXRSessionEnd);_transmissionRenderTarget&&(_transmissionRenderTarget.dispose(),_transmissionRenderTarget=null);animation.stop()};this.renderBufferDirect=function(camera,scene$jscomp$0,geometry,material,object,group){null===scene$jscomp$0&&(scene$jscomp$0=_emptyScene);var frontFaceCW=object.isMesh&&0>object.matrixWorld.determinant(),scene=scene$jscomp$0;!0!==scene.isScene&&(scene=_emptyScene);textures.resetTextureUnits();
scene$jscomp$0=scene.fog;var environment=material.isMeshStandardMaterial?scene.environment:null,encoding=null===_currentRenderTarget?_this.outputEncoding:!0===_currentRenderTarget.isXRRenderTarget?_currentRenderTarget.texture.encoding:3E3;environment=(material.isMeshStandardMaterial?cubeuvmaps:cubemaps).get(material.envMap||environment);var vertexAlphas=!0===material.vertexColors&&!!geometry.attributes.color&&4===geometry.attributes.color.itemSize,vertexTangents=!!material.normalMap&&!!geometry.attributes.tangent,
morphTargets=!!geometry.morphAttributes.position,morphNormals=!!geometry.morphAttributes.normal;const morphColors=!!geometry.morphAttributes.color,toneMapping=material.toneMapped?_this.toneMapping:0;var JSCompiler_inline_result=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color;const morphTargetsCount=void 0!==JSCompiler_inline_result?JSCompiler_inline_result.length:0;JSCompiler_inline_result=properties.get(material);const lights=currentRenderState.state.lights;
!0!==_clippingEnabled||!0!==_localClippingEnabled&&camera===_currentCamera||clipping.setState(material,camera,camera===_currentCamera&&material.id===_currentMaterialId);let needsProgramChange=!1;material.version===JSCompiler_inline_result.__version?JSCompiler_inline_result.needsLights&&JSCompiler_inline_result.lightsStateVersion!==lights.state.version?needsProgramChange=!0:JSCompiler_inline_result.outputEncoding!==encoding?needsProgramChange=!0:object.isInstancedMesh&&!1===JSCompiler_inline_result.instancing?
needsProgramChange=!0:object.isInstancedMesh||!0!==JSCompiler_inline_result.instancing?object.isSkinnedMesh&&!1===JSCompiler_inline_result.skinning?needsProgramChange=!0:object.isSkinnedMesh||!0!==JSCompiler_inline_result.skinning?JSCompiler_inline_result.envMap!==environment?needsProgramChange=!0:!0===material.fog&&JSCompiler_inline_result.fog!==scene$jscomp$0?needsProgramChange=!0:void 0===JSCompiler_inline_result.numClippingPlanes||JSCompiler_inline_result.numClippingPlanes===clipping.numPlanes&&
JSCompiler_inline_result.numIntersection===clipping.numIntersection?JSCompiler_inline_result.vertexAlphas!==vertexAlphas?needsProgramChange=!0:JSCompiler_inline_result.vertexTangents!==vertexTangents?needsProgramChange=!0:JSCompiler_inline_result.morphTargets!==morphTargets?needsProgramChange=!0:JSCompiler_inline_result.morphNormals!==morphNormals?needsProgramChange=!0:JSCompiler_inline_result.morphColors!==morphColors?needsProgramChange=!0:JSCompiler_inline_result.toneMapping!==toneMapping?needsProgramChange=
!0:!0===capabilities.isWebGL2&&JSCompiler_inline_result.morphTargetsCount!==morphTargetsCount&&(needsProgramChange=!0):needsProgramChange=!0:needsProgramChange=!0:needsProgramChange=!0:(needsProgramChange=!0,JSCompiler_inline_result.__version=material.version);encoding=JSCompiler_inline_result.currentProgram;!0===needsProgramChange&&(encoding=getProgram(material,scene,object));morphTargets=vertexTangents=morphNormals=!1;scene=encoding.getUniforms();vertexAlphas=JSCompiler_inline_result.uniforms;state.useProgram(encoding.program)&&
(morphTargets=vertexTangents=morphNormals=!0);material.id!==_currentMaterialId&&(_currentMaterialId=material.id,vertexTangents=!0);if(morphNormals||_currentCamera!==camera){scene.setValue(_gl,"projectionMatrix",camera.projectionMatrix);capabilities.logarithmicDepthBuffer&&scene.setValue(_gl,"logDepthBufFC",2/(Math.log(camera.far+1)/Math.LN2));_currentCamera!==camera&&(_currentCamera=camera,morphTargets=vertexTangents=!0);if(material.isShaderMaterial||material.isMeshPhongMaterial||material.isMeshToonMaterial||
material.isMeshStandardMaterial||material.envMap)morphNormals=scene.map.cameraPosition,void 0!==morphNormals&&morphNormals.setValue(_gl,_vector3.setFromMatrixPosition(camera.matrixWorld));(material.isMeshPhongMaterial||material.isMeshToonMaterial||material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial)&&scene.setValue(_gl,"isOrthographic",!0===camera.isOrthographicCamera);(material.isMeshPhongMaterial||material.isMeshToonMaterial||
material.isMeshLambertMaterial||material.isMeshBasicMaterial||material.isMeshStandardMaterial||material.isShaderMaterial||material.isShadowMaterial||object.isSkinnedMesh)&&scene.setValue(_gl,"viewMatrix",camera.matrixWorldInverse)}object.isSkinnedMesh&&(scene.setOptional(_gl,object,"bindMatrix"),scene.setOptional(_gl,object,"bindMatrixInverse"),camera=object.skeleton)&&(capabilities.floatVertexTextures?(null===camera.boneTexture&&camera.computeBoneTexture(),scene.setValue(_gl,"boneTexture",camera.boneTexture,
textures),scene.setValue(_gl,"boneTextureSize",camera.boneTextureSize)):console.warn("THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."));camera=geometry.morphAttributes;(void 0!==camera.position||void 0!==camera.normal||void 0!==camera.color&&!0===capabilities.isWebGL2)&&morphtargets.update(object,geometry,material,encoding);if(vertexTangents||JSCompiler_inline_result.receiveShadow!==object.receiveShadow)JSCompiler_inline_result.receiveShadow=
object.receiveShadow,scene.setValue(_gl,"receiveShadow",object.receiveShadow);material.isMeshGouraudMaterial&&null!==material.envMap&&(vertexAlphas.envMap.value=environment,vertexAlphas.flipEnvMap.value=environment.isCubeTexture&&!1===environment.isRenderTargetTexture?-1:1);vertexTangents&&(scene.setValue(_gl,"toneMappingExposure",_this.toneMappingExposure),JSCompiler_inline_result.needsLights&&(camera=morphTargets,vertexAlphas.ambientLightColor.needsUpdate=camera,vertexAlphas.lightProbe.needsUpdate=
camera,vertexAlphas.directionalLights.needsUpdate=camera,vertexAlphas.directionalLightShadows.needsUpdate=camera,vertexAlphas.pointLights.needsUpdate=camera,vertexAlphas.pointLightShadows.needsUpdate=camera,vertexAlphas.spotLights.needsUpdate=camera,vertexAlphas.spotLightShadows.needsUpdate=camera,vertexAlphas.rectAreaLights.needsUpdate=camera,vertexAlphas.hemisphereLights.needsUpdate=camera),scene$jscomp$0&&!0===material.fog&&materials.refreshFogUniforms(vertexAlphas,scene$jscomp$0),materials.refreshMaterialUniforms(vertexAlphas,
material,_pixelRatio,_height,_transmissionRenderTarget),WebGLUniforms.upload(_gl,JSCompiler_inline_result.uniformsList,vertexAlphas,textures));material.isShaderMaterial&&!0===material.uniformsNeedUpdate&&(WebGLUniforms.upload(_gl,JSCompiler_inline_result.uniformsList,vertexAlphas,textures),material.uniformsNeedUpdate=!1);material.isSpriteMaterial&&scene.setValue(_gl,"center",object.center);scene.setValue(_gl,"modelViewMatrix",object.modelViewMatrix);scene.setValue(_gl,"normalMatrix",object.normalMatrix);
scene.setValue(_gl,"modelMatrix",object.matrixWorld);if(material.isShaderMaterial||material.isRawShaderMaterial){scene$jscomp$0=material.uniformsGroups;for(let i=0,l=scene$jscomp$0.length;i<l;i++)capabilities.isWebGL2?(camera=scene$jscomp$0[i],uniformsGroups.update(camera,encoding),uniformsGroups.bind(camera,encoding)):console.warn("THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2.")}JSCompiler_inline_result=encoding;state.setMaterial(material,frontFaceCW);scene$jscomp$0=
geometry.index;camera=geometry.attributes.position;if(null===scene$jscomp$0){if(void 0===camera||0===camera.count)return}else if(0===scene$jscomp$0.count)return;environment=1;!0===material.wireframe&&(scene$jscomp$0=geometries.getWireframeAttribute(geometry),environment=2);bindingStates.setup(object,material,JSCompiler_inline_result,geometry,scene$jscomp$0);frontFaceCW=bufferRenderer;null!==scene$jscomp$0&&(JSCompiler_inline_result=attributes.get(scene$jscomp$0),frontFaceCW=indexedBufferRenderer,
frontFaceCW.setIndex(JSCompiler_inline_result));scene=geometry.drawRange.start*environment;encoding=null!==group?group.start*environment:0;JSCompiler_inline_result=Math.max(scene,encoding);group=Math.max(0,Math.min(null!==scene$jscomp$0?scene$jscomp$0.count:camera.count,scene+geometry.drawRange.count*environment,encoding+(null!==group?group.count*environment:Infinity))-1-JSCompiler_inline_result+1);0!==group&&(object.isMesh?!0===material.wireframe?(state.setLineWidth(material.wireframeLinewidth*(null===
_currentRenderTarget?_pixelRatio:1)),frontFaceCW.setMode(_gl.LINES)):frontFaceCW.setMode(_gl.TRIANGLES):object.isLine?(material=material.linewidth,void 0===material&&(material=1),state.setLineWidth(material*(null===_currentRenderTarget?_pixelRatio:1)),object.isLineSegments?frontFaceCW.setMode(_gl.LINES):object.isLineLoop?frontFaceCW.setMode(_gl.LINE_LOOP):frontFaceCW.setMode(_gl.LINE_STRIP)):object.isPoints?frontFaceCW.setMode(_gl.POINTS):object.isSprite&&frontFaceCW.setMode(_gl.TRIANGLES),object.isInstancedMesh?
frontFaceCW.renderInstances(JSCompiler_inline_result,group,object.count):geometry.isInstancedBufferGeometry?frontFaceCW.renderInstances(JSCompiler_inline_result,group,Math.min(geometry.instanceCount,geometry._maxInstanceCount)):frontFaceCW.render(JSCompiler_inline_result,group))};this.compile=function(scene$jscomp$0,camera){function prepare(material,scene,object){!0===material.transparent&&2===material.side?(material.side=1,material.needsUpdate=!0,getProgram(material,scene,object),material.side=0,
material.needsUpdate=!0,getProgram(material,scene,object),material.side=2):getProgram(material,scene,object)}currentRenderState=renderStates.get(scene$jscomp$0);currentRenderState.init();renderStateStack.push(currentRenderState);scene$jscomp$0.traverseVisible(function(object){object.isLight&&object.layers.test(camera.layers)&&(currentRenderState.pushLight(object),object.castShadow&&currentRenderState.pushShadow(object))});currentRenderState.setupLights(_this.physicallyCorrectLights);scene$jscomp$0.traverse(function(object){const material=
object.material;if(material)if(Array.isArray(material))for(let i=0;i<material.length;i++)prepare(material[i],scene$jscomp$0,object);else prepare(material,scene$jscomp$0,object)});renderStateStack.pop();currentRenderState=null};let onAnimationFrameCallback=null;const animation=new WebGLAnimation;animation.setAnimationLoop(function(time){onAnimationFrameCallback&&onAnimationFrameCallback(time)});"undefined"!==typeof self&&animation.setContext(self);this.setAnimationLoop=function(callback){onAnimationFrameCallback=
callback;xr.setAnimationLoop(callback);null===callback?animation.stop():animation.start()};xr.addEventListener("sessionstart",onXRSessionStart);xr.addEventListener("sessionend",onXRSessionEnd);this.render=function(scene,camera){if(void 0!==camera&&!0!==camera.isCamera)console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");else if(!0!==_isContextLost){!0===scene.matrixWorldAutoUpdate&&scene.updateMatrixWorld();null===camera.parent&&!0===camera.matrixWorldAutoUpdate&&
camera.updateMatrixWorld();!0===xr.enabled&&!0===xr.isPresenting&&(!0===xr.cameraAutoUpdate&&xr.updateCamera(camera),camera=xr.getCamera());if(!0===scene.isScene)scene.onBeforeRender(_this,scene,camera,_currentRenderTarget);currentRenderState=renderStates.get(scene,renderStateStack.length);currentRenderState.init();renderStateStack.push(currentRenderState);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);_frustum.setFromProjectionMatrix(_projScreenMatrix);_localClippingEnabled=
this.localClippingEnabled;_clippingEnabled=clipping.init(this.clippingPlanes,_localClippingEnabled,camera);currentRenderList=renderLists.get(scene,renderListStack.length);currentRenderList.init();renderListStack.push(currentRenderList);projectObject(scene,camera,0,_this.sortObjects);currentRenderList.finish();!0===_this.sortObjects&&currentRenderList.sort(_opaqueSort,_transparentSort);!0===_clippingEnabled&&clipping.beginShadows();shadowMap.render(currentRenderState.state.shadowsArray,scene,camera);
!0===_clippingEnabled&&clipping.endShadows();!0===this.info.autoReset&&this.info.reset();background.render(currentRenderList,scene);currentRenderState.setupLights(_this.physicallyCorrectLights);if(camera.isArrayCamera){const cameras=camera.cameras;for(let i=0,l=cameras.length;i<l;i++){const camera2=cameras[i];renderScene(currentRenderList,scene,camera2,camera2.viewport)}}else renderScene(currentRenderList,scene,camera);null!==_currentRenderTarget&&(textures.updateMultisampleRenderTarget(_currentRenderTarget),
textures.updateRenderTargetMipmap(_currentRenderTarget));if(!0===scene.isScene)scene.onAfterRender(_this,scene,camera);bindingStates.resetDefaultState();_currentMaterialId=-1;_currentCamera=null;renderStateStack.pop();currentRenderState=0<renderStateStack.length?renderStateStack[renderStateStack.length-1]:null;renderListStack.pop();currentRenderList=0<renderListStack.length?renderListStack[renderListStack.length-1]:null}};this.getActiveCubeFace=function(){return _currentActiveCubeFace};this.getActiveMipmapLevel=
function(){return _currentActiveMipmapLevel};this.getRenderTarget=function(){return _currentRenderTarget};this.setRenderTargetTextures=function(renderTarget,colorTexture,depthTexture){properties.get(renderTarget.texture).__webglTexture=colorTexture;properties.get(renderTarget.depthTexture).__webglTexture=depthTexture;renderTarget=properties.get(renderTarget);renderTarget.__hasExternalTextures=!0;renderTarget.__hasExternalTextures&&(renderTarget.__autoAllocateDepthBuffer=void 0===depthTexture,renderTarget.__autoAllocateDepthBuffer||
!0!==extensions.has("WEBGL_multisampled_render_to_texture")||(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),renderTarget.__useRenderToTexture=!1))};this.setRenderTargetFramebuffer=function(renderTarget,defaultFramebuffer){renderTarget=properties.get(renderTarget);renderTarget.__webglFramebuffer=defaultFramebuffer;renderTarget.__useDefaultFramebuffer=void 0===defaultFramebuffer};this.setRenderTarget=function(renderTarget,activeCubeFace=
0,activeMipmapLevel=0){_currentRenderTarget=renderTarget;_currentActiveCubeFace=activeCubeFace;_currentActiveMipmapLevel=activeMipmapLevel;let useDefaultFramebuffer=!0;var framebuffer=null;let isCube=!1,isRenderTarget3D=!1;if(renderTarget){framebuffer=properties.get(renderTarget);void 0!==framebuffer.__useDefaultFramebuffer?(state.bindFramebuffer(_gl.FRAMEBUFFER,null),useDefaultFramebuffer=!1):void 0===framebuffer.__webglFramebuffer?textures.setupRenderTarget(renderTarget):framebuffer.__hasExternalTextures&&
textures.rebindTextures(renderTarget,properties.get(renderTarget.texture).__webglTexture,properties.get(renderTarget.depthTexture).__webglTexture);framebuffer=renderTarget.texture;if(framebuffer.isData3DTexture||framebuffer.isDataArrayTexture||framebuffer.isCompressedArrayTexture)isRenderTarget3D=!0;framebuffer=properties.get(renderTarget).__webglFramebuffer;renderTarget.isWebGLCubeRenderTarget?(framebuffer=framebuffer[activeCubeFace],isCube=!0):framebuffer=capabilities.isWebGL2&&0<renderTarget.samples&&
!1===textures.useMultisampledRTT(renderTarget)?properties.get(renderTarget).__webglMultisampledFramebuffer:framebuffer;_currentViewport.copy(renderTarget.viewport);_currentScissor.copy(renderTarget.scissor);_currentScissorTest=renderTarget.scissorTest}else _currentViewport.copy(_viewport).multiplyScalar(_pixelRatio).floor(),_currentScissor.copy(_scissor).multiplyScalar(_pixelRatio).floor(),_currentScissorTest=_scissorTest;state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer)&&capabilities.drawBuffers&&
useDefaultFramebuffer&&state.drawBuffers(renderTarget,framebuffer);state.viewport(_currentViewport);state.scissor(_currentScissor);state.setScissorTest(_currentScissorTest);isCube?(renderTarget=properties.get(renderTarget.texture),_gl.framebufferTexture2D(_gl.FRAMEBUFFER,_gl.COLOR_ATTACHMENT0,_gl.TEXTURE_CUBE_MAP_POSITIVE_X+activeCubeFace,renderTarget.__webglTexture,activeMipmapLevel)):isRenderTarget3D&&(renderTarget=properties.get(renderTarget.texture),_gl.framebufferTextureLayer(_gl.FRAMEBUFFER,
_gl.COLOR_ATTACHMENT0,renderTarget.__webglTexture,activeMipmapLevel||0,activeCubeFace||0));_currentMaterialId=-1};this.readRenderTargetPixels=function(renderTarget,x,y,width,height,buffer,activeCubeFaceIndex){if(renderTarget&&renderTarget.isWebGLRenderTarget){var framebuffer=properties.get(renderTarget).__webglFramebuffer;renderTarget.isWebGLCubeRenderTarget&&void 0!==activeCubeFaceIndex&&(framebuffer=framebuffer[activeCubeFaceIndex]);if(framebuffer){state.bindFramebuffer(_gl.FRAMEBUFFER,framebuffer);
try{const texture=renderTarget.texture,textureFormat=texture.format,textureType=texture.type;if(1023!==textureFormat&&utils.convert(textureFormat)!==_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_FORMAT))console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");else{var halfFloatSupportedByExt=1016===textureType&&(extensions.has("EXT_color_buffer_half_float")||capabilities.isWebGL2&&extensions.has("EXT_color_buffer_float"));1009===textureType||
utils.convert(textureType)===_gl.getParameter(_gl.IMPLEMENTATION_COLOR_READ_TYPE)||1015===textureType&&(capabilities.isWebGL2||extensions.has("OES_texture_float")||extensions.has("WEBGL_color_buffer_float"))||halfFloatSupportedByExt?0<=x&&x<=renderTarget.width-width&&0<=y&&y<=renderTarget.height-height&&_gl.readPixels(x,y,width,height,utils.convert(textureFormat),utils.convert(textureType),buffer):console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.")}}finally{renderTarget=
null!==_currentRenderTarget?properties.get(_currentRenderTarget).__webglFramebuffer:null,state.bindFramebuffer(_gl.FRAMEBUFFER,renderTarget)}}}else console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.")};this.copyFramebufferToTexture=function(position,texture,level=0){var levelScale=Math.pow(2,-level);const width=Math.floor(texture.image.width*levelScale);levelScale=Math.floor(texture.image.height*levelScale);textures.setTexture2D(texture,0);_gl.copyTexSubImage2D(_gl.TEXTURE_2D,
level,0,0,position.x,position.y,width,levelScale);state.unbindTexture()};this.copyTextureToTexture=function(position,srcTexture,dstTexture,level=0){const width=srcTexture.image.width,height=srcTexture.image.height,glFormat=utils.convert(dstTexture.format),glType=utils.convert(dstTexture.type);textures.setTexture2D(dstTexture,0);_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,
dstTexture.unpackAlignment);srcTexture.isDataTexture?_gl.texSubImage2D(_gl.TEXTURE_2D,level,position.x,position.y,width,height,glFormat,glType,srcTexture.image.data):srcTexture.isCompressedTexture?_gl.compressedTexSubImage2D(_gl.TEXTURE_2D,level,position.x,position.y,srcTexture.mipmaps[0].width,srcTexture.mipmaps[0].height,glFormat,srcTexture.mipmaps[0].data):_gl.texSubImage2D(_gl.TEXTURE_2D,level,position.x,position.y,glFormat,glType,srcTexture.image);0===level&&dstTexture.generateMipmaps&&_gl.generateMipmap(_gl.TEXTURE_2D);
state.unbindTexture()};this.copyTextureToTexture3D=function(sourceBox,position,srcTexture,dstTexture,level=0){if(_this.isWebGL1Renderer)console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2.");else{var width=sourceBox.max.x-sourceBox.min.x+1,height=sourceBox.max.y-sourceBox.min.y+1,depth=sourceBox.max.z-sourceBox.min.z+1,glFormat=utils.convert(dstTexture.format),glType=utils.convert(dstTexture.type);if(dstTexture.isData3DTexture){textures.setTexture3D(dstTexture,0);
var glTarget=_gl.TEXTURE_3D}else if(dstTexture.isDataArrayTexture)textures.setTexture2DArray(dstTexture,0),glTarget=_gl.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}_gl.pixelStorei(_gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY);_gl.pixelStorei(_gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha);_gl.pixelStorei(_gl.UNPACK_ALIGNMENT,dstTexture.unpackAlignment);var unpackRowLen=_gl.getParameter(_gl.UNPACK_ROW_LENGTH),
unpackImageHeight=_gl.getParameter(_gl.UNPACK_IMAGE_HEIGHT),unpackSkipPixels=_gl.getParameter(_gl.UNPACK_SKIP_PIXELS),unpackSkipRows=_gl.getParameter(_gl.UNPACK_SKIP_ROWS),unpackSkipImages=_gl.getParameter(_gl.UNPACK_SKIP_IMAGES),image=srcTexture.isCompressedTexture?srcTexture.mipmaps[0]:srcTexture.image;_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,image.width);_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,image.height);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,sourceBox.min.x);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,
sourceBox.min.y);_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,sourceBox.min.z);srcTexture.isDataTexture||srcTexture.isData3DTexture?_gl.texSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image.data):srcTexture.isCompressedArrayTexture?(console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."),_gl.compressedTexSubImage3D(glTarget,level,position.x,position.y,position.z,width,height,depth,glFormat,image.data)):_gl.texSubImage3D(glTarget,
level,position.x,position.y,position.z,width,height,depth,glFormat,glType,image);_gl.pixelStorei(_gl.UNPACK_ROW_LENGTH,unpackRowLen);_gl.pixelStorei(_gl.UNPACK_IMAGE_HEIGHT,unpackImageHeight);_gl.pixelStorei(_gl.UNPACK_SKIP_PIXELS,unpackSkipPixels);_gl.pixelStorei(_gl.UNPACK_SKIP_ROWS,unpackSkipRows);_gl.pixelStorei(_gl.UNPACK_SKIP_IMAGES,unpackSkipImages);0===level&&dstTexture.generateMipmaps&&_gl.generateMipmap(glTarget);state.unbindTexture()}};this.initTexture=function(texture){texture.isCubeTexture?
textures.setTextureCube(texture,0):texture.isData3DTexture?textures.setTexture3D(texture,0):texture.isDataArrayTexture||texture.isCompressedArrayTexture?textures.setTexture2DArray(texture,0):textures.setTexture2D(texture,0);state.unbindTexture()};this.resetState=function(){_currentActiveMipmapLevel=_currentActiveCubeFace=0;_currentRenderTarget=null;state.reset();bindingStates.reset()};"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}
function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){_alignedPosition.subVectors(vertexPosition,center).addScalar(.5).multiply(scale);void 0!==sin?(_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y,_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition);vertexPosition.copy(mvPosition);vertexPosition.x+=_rotatedPosition.x;vertexPosition.y+=_rotatedPosition.y;vertexPosition.applyMatrix4(_viewWorldMatrix)}function testPoint(point,
index,localThresholdSq,matrixWorld,raycaster,intersects,object){const rayPointDistanceSq=_ray.distanceSqToPoint(point);rayPointDistanceSq<localThresholdSq&&(localThresholdSq=new Vector3,_ray.closestPointToPoint(point,localThresholdSq),localThresholdSq.applyMatrix4(matrixWorld),point=raycaster.ray.origin.distanceTo(localThresholdSq),point<raycaster.near||point>raycaster.far||intersects.push({distance:point,distanceToRay:Math.sqrt(rayPointDistanceSq),point:localThresholdSq,index,face:null,object}))}
function CubicPoly(){let c0=0,c1=0,c2=0,c3=0;return{initCatmullRom:function(x0,x1,x2,x3,tension){x0=tension*(x2-x0);x3=tension*(x3-x1);c0=x1;c1=x0;c2=-3*x1+3*x2-2*x0-x3;c3=2*x1-2*x2+x0+x3},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){x0=((x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1)*dt1;x3=((x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2)*dt1;c0=x1;c1=x0;c2=-3*x1+3*x2-2*x0-x3;c3=2*x1-2*x2+x0+x3},calc:function(t){const t2=t*t;return c0+c1*t+c2*t2+c3*t2*t}}}function CatmullRom(t,p0,p1,p2,p3){p0=
.5*(p2-p0);p3=.5*(p3-p1);const t2=t*t;return(2*p1-2*p2+p0+p3)*t*t2+(-3*p1+3*p2-2*p0-p3)*t2+p0*t+p1}function QuadraticBezier(t,p0,p1,p2){const k=1-t;return k*k*p0+2*(1-t)*t*p1+t*t*p2}function CubicBezier(t,p0,p1,p2,p3){const k=1-t,k$jscomp$0=1-t;return k*k*k*p0+3*k$jscomp$0*k$jscomp$0*t*p1+3*(1-t)*t*t*p2+t*t*t*p3}function linkedList(data,start,end,dim,clockwise){let last,sum=0;for(let i=start,j=end-dim;i<end;i+=dim)sum+=(data[j]-data[i])*(data[i+1]+data[j+1]),j=i;if(clockwise===0<sum)for(clockwise=
start;clockwise<end;clockwise+=dim)last=insertNode(clockwise,data[clockwise],data[clockwise+1],last);else for(clockwise=end-dim;clockwise>=start;clockwise-=dim)last=insertNode(clockwise,data[clockwise],data[clockwise+1],last);last&&equals(last,last.next)&&(removeNode(last),last=last.next);return last}function filterPoints(start,end){if(!start)return start;end||(end=start);let again;do if(again=!1,start.steiner||!equals(start,start.next)&&0!==area(start.prev,start,start.next))start=start.next;else{removeNode(start);
start=end=start.prev;if(start===start.next)break;again=!0}while(again||start!==end);return end}function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(ear){if(!pass&&invSize){var start=ear,p=start;do 0===p.z&&(p.z=zOrder(p.x,p.y,minX,minY,invSize)),p.prevZ=p.prev,p=p.nextZ=p.next;while(p!==start);p.prevZ.nextZ=null;p.prevZ=null;start=p;var i,numMerges,pSize,qSize,inSize=1;do{p=start;var tail=start=null;for(numMerges=0;p;){numMerges++;var q=p;for(i=pSize=0;i<inSize&&(pSize++,q=q.nextZ,q);i++);
for(qSize=inSize;0<pSize||0<qSize&&q;)0!==pSize&&(0===qSize||!q||p.z<=q.z)?(i=p,p=p.nextZ,pSize--):(i=q,q=q.nextZ,qSize--),tail?tail.nextZ=i:start=i,i.prevZ=tail,tail=i;p=q}tail.nextZ=null;inSize*=2}while(1<numMerges)}for(start=ear;ear.prev!==ear.next;){p=ear.prev;q=ear.next;if(invSize)tail=isEarHashed(ear,minX,minY,invSize);else a:{tail=ear.prev;var b=ear;qSize=ear.next;if(0<=area(tail,b,qSize)){tail=!1;break a}numMerges=tail.x;pSize=b.x;inSize=qSize.x;i=tail.y;b=b.y;const cy=qSize.y,x0=numMerges<
pSize?numMerges<inSize?numMerges:inSize:pSize<inSize?pSize:inSize,y0=i<b?i<cy?i:cy:b<cy?b:cy,x1=numMerges>pSize?numMerges>inSize?numMerges:inSize:pSize>inSize?pSize:inSize,y1=i>b?i>cy?i:cy:b>cy?b:cy;for(qSize=qSize.next;qSize!==tail;){if(qSize.x>=x0&&qSize.x<=x1&&qSize.y>=y0&&qSize.y<=y1&&pointInTriangle(numMerges,i,pSize,b,inSize,cy,qSize.x,qSize.y)&&0<=area(qSize.prev,qSize,qSize.next)){tail=!1;break a}qSize=qSize.next}tail=!0}if(tail)triangles.push(p.i/dim|0),triangles.push(ear.i/dim|0),triangles.push(q.i/
dim|0),removeNode(ear),start=ear=q.next;else if(ear=q,ear===start){if(!pass)earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);else if(1===pass){ear=filterPoints(ear);pass=triangles;start=dim;p=ear;do q=p.prev,tail=p.next.next,!equals(q,tail)&&intersects(q,p,p.next,tail)&&locallyInside(q,tail)&&locallyInside(tail,q)&&(pass.push(q.i/start|0),pass.push(p.i/start|0),pass.push(tail.i/start|0),removeNode(p),removeNode(p.next),p=ear=tail),p=p.next;while(p!==ear);ear=filterPoints(p);earcutLinked(ear,
triangles,dim,minX,minY,invSize,2)}else if(2===pass)a:{pass=ear;do{for(start=pass.next.next;start!==pass.prev;){if(p=pass.i!==start.i){p=pass;q=start;if(tail=p.next.i!==q.i&&p.prev.i!==q.i){b:{tail=p;do{if(tail.i!==p.i&&tail.next.i!==p.i&&tail.i!==q.i&&tail.next.i!==q.i&&intersects(tail,tail.next,p,q)){tail=!0;break b}tail=tail.next}while(tail!==p);tail=!1}tail=!tail}if(tail){if(tail=locallyInside(p,q)&&locallyInside(q,p)){tail=p;numMerges=!1;pSize=(p.x+q.x)/2;inSize=(p.y+q.y)/2;do tail.y>inSize!==
tail.next.y>inSize&&tail.next.y!==tail.y&&pSize<(tail.next.x-tail.x)*(inSize-tail.y)/(tail.next.y-tail.y)+tail.x&&(numMerges=!numMerges),tail=tail.next;while(tail!==p);tail=numMerges}tail=tail&&(area(p.prev,p,q.prev)||area(p,q.prev,q))||equals(p,q)&&0<area(p.prev,p,p.next)&&0<area(q.prev,q,q.next)}p=tail}if(p){ear=splitPolygon(pass,start);pass=filterPoints(pass,pass.next);ear=filterPoints(ear,ear.next);earcutLinked(pass,triangles,dim,minX,minY,invSize,0);earcutLinked(ear,triangles,dim,minX,minY,invSize,
0);break a}start=start.next}pass=pass.next}while(pass!==ear)}break}}}}function isEarHashed(ear,minX,minY,invSize){const a=ear.prev,c=ear.next;if(0<=area(a,ear,c))return!1;const ax=a.x,bx=ear.x,cx=c.x,ay=a.y,by=ear.y,cy=c.y,x0=ax<bx?ax<cx?ax:cx:bx<cx?bx:cx,y0=ay<by?ay<cy?ay:cy:by<cy?by:cy,x1=ax>bx?ax>cx?ax:cx:bx>cx?bx:cx,y1=ay>by?ay>cy?ay:cy:by>cy?by:cy,minZ=zOrder(x0,y0,minX,minY,invSize);minX=zOrder(x1,y1,minX,minY,invSize);minY=ear.prevZ;for(ear=ear.nextZ;minY&&minY.z>=minZ&&ear&&ear.z<=minX;){if(minY.x>=
x0&&minY.x<=x1&&minY.y>=y0&&minY.y<=y1&&minY!==a&&minY!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,minY.x,minY.y)&&0<=area(minY.prev,minY,minY.next))return!1;minY=minY.prevZ;if(ear.x>=x0&&ear.x<=x1&&ear.y>=y0&&ear.y<=y1&&ear!==a&&ear!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,ear.x,ear.y)&&0<=area(ear.prev,ear,ear.next))return!1;ear=ear.nextZ}for(;minY&&minY.z>=minZ;){if(minY.x>=x0&&minY.x<=x1&&minY.y>=y0&&minY.y<=y1&&minY!==a&&minY!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,minY.x,minY.y)&&0<=area(minY.prev,
minY,minY.next))return!1;minY=minY.prevZ}for(;ear&&ear.z<=minX;){if(ear.x>=x0&&ear.x<=x1&&ear.y>=y0&&ear.y<=y1&&ear!==a&&ear!==c&&pointInTriangle(ax,ay,bx,by,cx,cy,ear.x,ear.y)&&0<=area(ear.prev,ear,ear.next))return!1;ear=ear.nextZ}return!0}function compareX(a,b){return a.x-b.x}function zOrder(x,y,minX,minY,invSize){x=(x-minX)*invSize|0;y=(y-minY)*invSize|0;x=(x|x<<8)&16711935;x=(x|x<<4)&252645135;x=(x|x<<2)&858993459;y=(y|y<<8)&16711935;y=(y|y<<4)&252645135;y=(y|y<<2)&858993459;return(x|x<<1)&1431655765|
((y|y<<1)&1431655765)<<1}function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)>=(ax-px)*(cy-py)&&(ax-px)*(by-py)>=(bx-px)*(ay-py)&&(bx-px)*(cy-py)>=(cx-px)*(by-py)}function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y)}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y}function intersects(p1,q1,p2,q2){const o1=sign(area(p1,q1,p2)),o2=sign(area(p1,q1,q2)),o3=sign(area(p2,q2,p1)),o4=sign(area(p2,q2,q1));return o1!==o2&&o3!==o4||0===o1&&onSegment(p1,p2,q1)||0===o2&&
onSegment(p1,q2,q1)||0===o3&&onSegment(p2,p1,q2)||0===o4&&onSegment(p2,q1,q2)?!0:!1}function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y)}function sign(num){return 0<num?1:0>num?-1:0}function locallyInside(a,b){return 0>area(a.prev,a,a.next)?0<=area(a,b,a.next)&&0<=area(a,a.prev,b):0>area(a,b,a.prev)||0>area(a,a.next,b)}function splitPolygon(a,b){const a2=new Node(a.i,a.x,a.y),b2=new Node(b.i,b.x,b.y),an=a.next,bp=b.prev;a.next=
b;b.prev=a;a2.next=an;an.prev=a2;b2.next=a2;a2.prev=b2;bp.next=b2;b2.prev=bp;return b2}function insertNode(i,x,y,last){i=new Node(i,x,y);last?(i.next=last.next,i.prev=last,last.next.prev=i,last.next=i):(i.prev=i,i.next=i);return i}function removeNode(p){p.next.prev=p.prev;p.prev.next=p.next;p.prevZ&&(p.prevZ.nextZ=p.nextZ);p.nextZ&&(p.nextZ.prevZ=p.prevZ)}function Node(i,x,y){this.i=i;this.x=x;this.y=y;this.next=this.prev=null;this.z=0;this.nextZ=this.prevZ=null;this.steiner=!1}function removeDupEndPts(points){const l=
points.length;2<l&&points[l-1].equals(points[0])&&points.pop()}function addContour(vertices,contour){for(let i=0;i<contour.length;i++)vertices.push(contour[i].x),vertices.push(contour[i].y)}function isUniqueEdge(start,end,edges){const hash1=`${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;start=`${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;if(!0===edges.has(hash1)||!0===edges.has(start))return!1;edges.add(hash1);edges.add(start);return!0}function arraySlice(array,from,
to){return isTypedArray(array)?new array.constructor(array.subarray(from,void 0!==to?to:array.length)):array.slice(from,to)}function convertArray(array,type,forceClone){return!array||!forceClone&&array.constructor===type?array:"number"===typeof type.BYTES_PER_ELEMENT?new type(array):Array.prototype.slice.call(array)}function isTypedArray(object){return ArrayBuffer.isView(object)&&!(object instanceof DataView)}function getKeyframeOrder(times){const n=times.length,result=Array(n);for(let i=0;i!==n;++i)result[i]=
i;result.sort(function(i,j){return times[i]-times[j]});return result}function sortedArray(values,stride,order){const nValues=values.length,result=new values.constructor(nValues);for(let i=0,dstOffset=0;dstOffset!==nValues;++i){const srcOffset=order[i]*stride;for(let j=0;j!==stride;++j)result[dstOffset++]=values[srcOffset+j]}return result}function flattenJSON(jsonKeys,times,values,valuePropertyName){let i=1,key=jsonKeys[0];for(;void 0!==key&&void 0===key[valuePropertyName];)key=jsonKeys[i++];if(void 0!==
key){var value=key[valuePropertyName];if(void 0!==value)if(Array.isArray(value)){do value=key[valuePropertyName],void 0!==value&&(times.push(key.time),values.push.apply(values,value)),key=jsonKeys[i++];while(void 0!==key)}else if(void 0!==value.toArray){do value=key[valuePropertyName],void 0!==value&&(times.push(key.time),value.toArray(values,values.length)),key=jsonKeys[i++];while(void 0!==key)}else{do value=key[valuePropertyName],void 0!==value&&(times.push(key.time),values.push(value)),key=jsonKeys[i++];
while(void 0!==key)}}}function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case "scalar":case "double":case "float":case "number":case "integer":return NumberKeyframeTrack;case "vector":case "vector2":case "vector3":case "vector4":return VectorKeyframeTrack;case "color":return ColorKeyframeTrack;case "quaternion":return QuaternionKeyframeTrack;case "bool":case "boolean":return BooleanKeyframeTrack;case "string":return StringKeyframeTrack}throw Error("THREE.KeyframeTrack: Unsupported typeName: "+
typeName);}function now$jscomp$0(){return("undefined"===typeof performance?Date:performance).now()}function ascSort(a,b){return a.distance-b.distance}function intersectObject(object,raycaster,intersects,recursive){object.layers.test(raycaster.layers)&&object.raycast(raycaster,intersects);if(!0===recursive){object=object.children;for(let i=0,l=object.length;i<l;i++)intersectObject(object[i],raycaster,intersects,!0)}}function getBoneList(object){const boneList=[];!0===object.isBone&&boneList.push(object);
for(let i=0;i<object.children.length;i++)boneList.push.apply(boneList,getBoneList(object.children[i]));return boneList}function setPoint(point,pointMap,geometry,camera,x,y,z){_vector.set(x,y,z).unproject(camera);point=pointMap[point];if(void 0!==point){geometry=geometry.getAttribute("position");for(let i=0,l=point.length;i<l;i++)geometry.setXYZ(point[i],_vector.x,_vector.y,_vector.z)}}class EventDispatcher{addEventListener(type,listener){void 0===this._listeners&&(this._listeners={});const listeners=
this._listeners;void 0===listeners[type]&&(listeners[type]=[]);-1===listeners[type].indexOf(listener)&&listeners[type].push(listener)}hasEventListener(type,listener){if(void 0===this._listeners)return!1;const listeners=this._listeners;return void 0!==listeners[type]&&-1!==listeners[type].indexOf(listener)}removeEventListener(type,listener){void 0!==this._listeners&&(type=this._listeners[type],void 0!==type&&(listener=type.indexOf(listener),-1!==listener&&type.splice(listener,1)))}dispatchEvent(event){if(void 0!==
this._listeners){var listenerArray=this._listeners[event.type];if(void 0!==listenerArray){event.target=this;listenerArray=listenerArray.slice(0);for(let i=0,l=listenerArray.length;i<l;i++)listenerArray[i].call(this,event);event.target=null}}}}const _lut="00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 15 16 17 18 19 1a 1b 1c 1d 1e 1f 20 21 22 23 24 25 26 27 28 29 2a 2b 2c 2d 2e 2f 30 31 32 33 34 35 36 37 38 39 3a 3b 3c 3d 3e 3f 40 41 42 43 44 45 46 47 48 49 4a 4b 4c 4d 4e 4f 50 51 52 53 54 55 56 57 58 59 5a 5b 5c 5d 5e 5f 60 61 62 63 64 65 66 67 68 69 6a 6b 6c 6d 6e 6f 70 71 72 73 74 75 76 77 78 79 7a 7b 7c 7d 7e 7f 80 81 82 83 84 85 86 87 88 89 8a 8b 8c 8d 8e 8f 90 91 92 93 94 95 96 97 98 99 9a 9b 9c 9d 9e 9f a0 a1 a2 a3 a4 a5 a6 a7 a8 a9 aa ab ac ad ae af b0 b1 b2 b3 b4 b5 b6 b7 b8 b9 ba bb bc bd be bf c0 c1 c2 c3 c4 c5 c6 c7 c8 c9 ca cb cc cd ce cf d0 d1 d2 d3 d4 d5 d6 d7 d8 d9 da db dc dd de df e0 e1 e2 e3 e4 e5 e6 e7 e8 e9 ea eb ec ed ee ef f0 f1 f2 f3 f4 f5 f6 f7 f8 f9 fa fb fc fd fe ff".split(" ");
let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;var MathUtils=Object.freeze({__proto__:null,DEG2RAD,RAD2DEG,generateUUID,clamp,euclideanModulo,mapLinear:function(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1)},inverseLerp:function(x,y,value){return x!==y?(value-x)/(y-x):0},lerp,damp:function(x,y,lambda,dt){return lerp(x,y,1-Math.exp(-lambda*dt))},pingpong:function(x,length=1){return length-Math.abs(euclideanModulo(x,2*length)-length)},smoothstep:function(x,min,max){if(x<=min)return 0;
if(x>=max)return 1;x=(x-min)/(max-min);return x*x*(3-2*x)},smootherstep:function(x,min,max){if(x<=min)return 0;if(x>=max)return 1;x=(x-min)/(max-min);return x*x*x*(x*(6*x-15)+10)},randInt:function(low,high){return low+Math.floor(Math.random()*(high-low+1))},randFloat:function(low,high){return low+Math.random()*(high-low)},randFloatSpread:function(range){return range*(.5-Math.random())},seededRandom:function(s){void 0!==s&&(_seed=s);s=_seed+=1831565813;s=Math.imul(s^s>>>15,s|1);s^=s+Math.imul(s^s>>>
7,s|61);return((s^s>>>14)>>>0)/4294967296},degToRad:function(degrees){return degrees*DEG2RAD},radToDeg:function(radians){return radians*RAD2DEG},isPowerOfTwo,ceilPowerOfTwo,floorPowerOfTwo,setQuaternionFromProperEuler:function(q,a,b,c,order){var cos=Math.cos;const sin=Math.sin,c2=cos(b/2);b=sin(b/2);const c13=cos((a+c)/2),s13=sin((a+c)/2),c1_3=cos((a-c)/2),s1_3=sin((a-c)/2);cos=cos((c-a)/2);a=sin((c-a)/2);switch(order){case "XYX":q.set(c2*s13,b*c1_3,b*s1_3,c2*c13);break;case "YZY":q.set(b*s1_3,c2*
s13,b*c1_3,c2*c13);break;case "ZXZ":q.set(b*c1_3,b*s1_3,c2*s13,c2*c13);break;case "XZX":q.set(c2*s13,b*a,b*cos,c2*c13);break;case "YXY":q.set(b*cos,c2*s13,b*a,c2*c13);break;case "ZYZ":q.set(b*a,b*cos,c2*s13,c2*c13);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+order)}},normalize,denormalize});class Vector2{constructor(x=0,y=0){Vector2.prototype.isVector2=!0;this.x=x;this.y=y}get width(){return this.x}set width(value){this.x=value}get height(){return this.y}set height(value){this.y=
value}set(x,y){this.x=x;this.y=y;return this}setScalar(scalar){this.y=this.x=scalar;return this}setX(x){this.x=x;return this}setY(y){this.y=y;return this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw Error("index is out of range: "+index);}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw Error("index is out of range: "+index);}}clone(){return new this.constructor(this.x,this.y)}copy(v){this.x=
v.x;this.y=v.y;return this}add(v){this.x+=v.x;this.y+=v.y;return this}addScalar(s){this.x+=s;this.y+=s;return this}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;return this}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;return this}sub(v){this.x-=v.x;this.y-=v.y;return this}subScalar(s){this.x-=s;this.y-=s;return this}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;return this}multiply(v){this.x*=v.x;this.y*=v.y;return this}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;return this}divide(v){this.x/=
v.x;this.y/=v.y;return this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}applyMatrix3(m){const x=this.x,y=this.y;m=m.elements;this.x=m[0]*x+m[3]*y+m[6];this.y=m[1]*x+m[4]*y+m[7];return this}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);return this}clamp(min,max){this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));return this}clampScalar(minVal,maxVal){this.x=
Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));return this}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);return this}roundToZero(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);
this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);return this}negate(){this.x=-this.x;this.y=-this.y;return this}dot(v){return this.x*v.x+this.y*v.y}cross(v){return this.x*v.y-this.y*v.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}distanceToSquared(v){const dx=
this.x-v.x;v=this.y-v.y;return dx*dx+v*v}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;return this}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;return this}equals(v){return v.x===this.x&&v.y===this.y}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];return this}toArray(array=[],offset=
0){array[offset]=this.x;array[offset+1]=this.y;return array}fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);return this}rotateAround(center,angle){const c=Math.cos(angle);angle=Math.sin(angle);const x=this.x-center.x,y=this.y-center.y;this.x=x*c-y*angle+center.x;this.y=x*angle+y*c+center.y;return this}random(){this.x=Math.random();this.y=Math.random();return this}*[Symbol.iterator](){yield this.x;yield this.y}}class Matrix3{constructor(){Matrix3.prototype.isMatrix3=
!0;this.elements=[1,0,0,0,1,0,0,0,1]}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;te[0]=n11;te[1]=n21;te[2]=n31;te[3]=n12;te[4]=n22;te[5]=n32;te[6]=n13;te[7]=n23;te[8]=n33;return this}identity(){this.set(1,0,0,0,1,0,0,0,1);return this}copy(m){const te=this.elements;m=m.elements;te[0]=m[0];te[1]=m[1];te[2]=m[2];te[3]=m[3];te[4]=m[4];te[5]=m[5];te[6]=m[6];te[7]=m[7];te[8]=m[8];return this}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrix3Column(this,0);yAxis.setFromMatrix3Column(this,
1);zAxis.setFromMatrix3Column(this,2);return this}setFromMatrix4(m){m=m.elements;this.set(m[0],m[4],m[8],m[1],m[5],m[9],m[2],m[6],m[10]);return this}multiply(m){return this.multiplyMatrices(this,m)}premultiply(m){return this.multiplyMatrices(m,this)}multiplyMatrices(a,b){var ae=a.elements,be=b.elements;b=this.elements;a=ae[0];const a12=ae[3],a13=ae[6],a21=ae[1],a22=ae[4],a23=ae[7],a31=ae[2],a32=ae[5];ae=ae[8];const b11=be[0],b12=be[3],b13=be[6],b21=be[1],b22=be[4],b23=be[7],b31=be[2],b32=be[5];be=
be[8];b[0]=a*b11+a12*b21+a13*b31;b[3]=a*b12+a12*b22+a13*b32;b[6]=a*b13+a12*b23+a13*be;b[1]=a21*b11+a22*b21+a23*b31;b[4]=a21*b12+a22*b22+a23*b32;b[7]=a21*b13+a22*b23+a23*be;b[2]=a31*b11+a32*b21+ae*b31;b[5]=a31*b12+a32*b22+ae*b32;b[8]=a31*b13+a32*b23+ae*be;return this}multiplyScalar(s){const te=this.elements;te[0]*=s;te[3]*=s;te[6]*=s;te[1]*=s;te[4]*=s;te[7]*=s;te[2]*=s;te[5]*=s;te[8]*=s;return this}determinant(){var te=this.elements;const a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7];
te=te[8];return a*e*te-a*f*h-b*d*te+b*f*g+c*d*h-c*e*g}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13;var det=n11*t11+n21*t12+n31*t13;if(0===det)return this.set(0,0,0,0,0,0,0,0,0);det=1/det;te[0]=t11*det;te[1]=(n31*n23-n33*n21)*det;te[2]=(n32*n21-n31*n22)*det;te[3]=t12*det;te[4]=(n33*n11-n31*n13)*det;te[5]=(n31*n12-n32*n11)*det;te[6]=t13*det;te[7]=(n21*n13-n23*n11)*
det;te[8]=(n22*n11-n21*n12)*det;return this}transpose(){let tmp;const m=this.elements;tmp=m[1];m[1]=m[3];m[3]=tmp;tmp=m[2];m[2]=m[6];m[6]=tmp;tmp=m[5];m[5]=m[7];m[7]=tmp;return this}getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose()}transposeIntoArray(r){const m=this.elements;r[0]=m[0];r[1]=m[3];r[2]=m[6];r[3]=m[1];r[4]=m[4];r[5]=m[7];r[6]=m[2];r[7]=m[5];r[8]=m[8];return this}setUvTransform(tx,ty,sx,sy,rotation,cx,cy){const c=Math.cos(rotation);rotation=Math.sin(rotation);
this.set(sx*c,sx*rotation,-sx*(c*cx+rotation*cy)+cx+tx,-sy*rotation,sy*c,-sy*(-rotation*cx+c*cy)+cy+ty,0,0,1);return this}scale(sx,sy){const te=this.elements;te[0]*=sx;te[3]*=sx;te[6]*=sx;te[1]*=sy;te[4]*=sy;te[7]*=sy;return this}rotate(theta){const c=Math.cos(theta);theta=Math.sin(theta);const te=this.elements,a11=te[0],a12=te[3],a13=te[6],a21=te[1],a22=te[4],a23=te[7];te[0]=c*a11+theta*a21;te[3]=c*a12+theta*a22;te[6]=c*a13+theta*a23;te[1]=-theta*a11+c*a21;te[4]=-theta*a12+c*a22;te[7]=-theta*a13+
c*a23;return this}translate(tx,ty){const te=this.elements;te[0]+=tx*te[2];te[3]+=tx*te[5];te[6]+=tx*te[8];te[1]+=ty*te[2];te[4]+=ty*te[5];te[7]+=ty*te[8];return this}equals(matrix){const te=this.elements;matrix=matrix.elements;for(let i=0;9>i;i++)if(te[i]!==matrix[i])return!1;return!0}fromArray(array,offset=0){for(let i=0;9>i;i++)this.elements[i]=array[i+offset];return this}toArray(array=[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+
3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];return array}clone(){return(new this.constructor).fromArray(this.elements)}}const TYPED_ARRAYS={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array},FN={srgb:{["srgb-linear"]:SRGBToLinear},["srgb-linear"]:{srgb:LinearToSRGB}},ColorManagement={legacyMode:!0,get workingColorSpace(){return"srgb-linear"},set workingColorSpace(colorSpace){console.warn("THREE.ColorManagement: .workingColorSpace is readonly.")},
convert:function(color,sourceColorSpace,targetColorSpace){if(this.legacyMode||sourceColorSpace===targetColorSpace||!sourceColorSpace||!targetColorSpace)return color;if(FN[sourceColorSpace]&&void 0!==FN[sourceColorSpace][targetColorSpace])return sourceColorSpace=FN[sourceColorSpace][targetColorSpace],color.r=sourceColorSpace(color.r),color.g=sourceColorSpace(color.g),color.b=sourceColorSpace(color.b),color;throw Error("Unsupported color space conversion.");},fromWorkingColorSpace:function(color,targetColorSpace){return this.convert(color,
this.workingColorSpace,targetColorSpace)},toWorkingColorSpace:function(color,sourceColorSpace){return this.convert(color,sourceColorSpace,this.workingColorSpace)}},_colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,
crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,
floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,
lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,
moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,
sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_rgb={r:0,g:0,b:0},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};class Color{constructor(r,g,b){this.isColor=!0;this.b=this.g=this.r=1;return void 0===g&&void 0===b?this.set(r):
this.setRGB(r,g,b)}set(value){value&&value.isColor?this.copy(value):"number"===typeof value?this.setHex(value):"string"===typeof value&&this.setStyle(value);return this}setScalar(scalar){this.b=this.g=this.r=scalar;return this}setHex(hex,colorSpace="srgb"){hex=Math.floor(hex);this.r=(hex>>16&255)/255;this.g=(hex>>8&255)/255;this.b=(hex&255)/255;ColorManagement.toWorkingColorSpace(this,colorSpace);return this}setRGB(r,g,b,colorSpace="srgb-linear"){this.r=r;this.g=g;this.b=b;ColorManagement.toWorkingColorSpace(this,
colorSpace);return this}setHSL(h,s,l,colorSpace="srgb-linear"){h=euclideanModulo(h,1);s=clamp(s,0,1);l=clamp(l,0,1);0===s?this.r=this.g=this.b=l:(s=.5>=l?l*(1+s):l+s-l*s,l=2*l-s,this.r=hue2rgb(l,s,h+1/3),this.g=hue2rgb(l,s,h),this.b=hue2rgb(l,s,h-1/3));ColorManagement.toWorkingColorSpace(this,colorSpace);return this}setStyle(style,colorSpace="srgb"){function handleAlpha(string){void 0!==string&&1>parseFloat(string)&&console.warn("THREE.Color: Alpha component of "+style+" will be ignored.")}var m;
if(m=/^((?:rgb|hsl)a?)\(([^\)]*)\)/.exec(style)){var components=m[2];switch(m[1]){case "rgb":case "rgba":if(m=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return this.r=Math.min(255,parseInt(m[1],10))/255,this.g=Math.min(255,parseInt(m[2],10))/255,this.b=Math.min(255,parseInt(m[3],10))/255,ColorManagement.toWorkingColorSpace(this,colorSpace),handleAlpha(m[4]),this;if(m=/^\s*(\d+)%\s*,\s*(\d+)%\s*,\s*(\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return this.r=
Math.min(100,parseInt(m[1],10))/100,this.g=Math.min(100,parseInt(m[2],10))/100,this.b=Math.min(100,parseInt(m[3],10))/100,ColorManagement.toWorkingColorSpace(this,colorSpace),handleAlpha(m[4]),this;break;case "hsl":case "hsla":if(m=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)%\s*,\s*(\d*\.?\d+)%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)){components=parseFloat(m[1])/360;const s=parseFloat(m[2])/100,l=parseFloat(m[3])/100;handleAlpha(m[4]);return this.setHSL(components,s,l,colorSpace)}}}else if(m=/^#([A-Fa-f\d]+)$/.exec(style)){m=
m[1];components=m.length;if(3===components)return this.r=parseInt(m.charAt(0)+m.charAt(0),16)/255,this.g=parseInt(m.charAt(1)+m.charAt(1),16)/255,this.b=parseInt(m.charAt(2)+m.charAt(2),16)/255,ColorManagement.toWorkingColorSpace(this,colorSpace),this;if(6===components)return this.r=parseInt(m.charAt(0)+m.charAt(1),16)/255,this.g=parseInt(m.charAt(2)+m.charAt(3),16)/255,this.b=parseInt(m.charAt(4)+m.charAt(5),16)/255,ColorManagement.toWorkingColorSpace(this,colorSpace),this}return style&&0<style.length?
this.setColorName(style,colorSpace):this}setColorName(style,colorSpace="srgb"){const hex=_colorKeywords[style.toLowerCase()];void 0!==hex?this.setHex(hex,colorSpace):console.warn("THREE.Color: Unknown color "+style);return this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(color){this.r=color.r;this.g=color.g;this.b=color.b;return this}copySRGBToLinear(color){this.r=SRGBToLinear(color.r);this.g=SRGBToLinear(color.g);this.b=SRGBToLinear(color.b);return this}copyLinearToSRGB(color){this.r=
LinearToSRGB(color.r);this.g=LinearToSRGB(color.g);this.b=LinearToSRGB(color.b);return this}convertSRGBToLinear(){this.copySRGBToLinear(this);return this}convertLinearToSRGB(){this.copyLinearToSRGB(this);return this}getHex(colorSpace="srgb"){ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);return clamp(255*_rgb.r,0,255)<<16^clamp(255*_rgb.g,0,255)<<8^clamp(255*_rgb.b,0,255)<<0}getHexString(colorSpace="srgb"){return("000000"+this.getHex(colorSpace).toString(16)).slice(-6)}getHSL(target,
colorSpace="srgb-linear"){ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);colorSpace=_rgb.r;const g=_rgb.g,b=_rgb.b,max=Math.max(colorSpace,g,b);var min=Math.min(colorSpace,g,b);let hue;const lightness=(min+max)/2;if(min===max)min=hue=0;else{const delta=max-min;min=.5>=lightness?delta/(max+min):delta/(2-max-min);switch(max){case colorSpace:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-colorSpace)/delta+2;break;case b:hue=(colorSpace-g)/delta+4}hue/=6}target.h=hue;target.s=
min;target.l=lightness;return target}getRGB(target,colorSpace="srgb-linear"){ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);target.r=_rgb.r;target.g=_rgb.g;target.b=_rgb.b;return target}getStyle(colorSpace="srgb"){ColorManagement.fromWorkingColorSpace(toComponents(this,_rgb),colorSpace);return"srgb"!==colorSpace?`color(${colorSpace} ${_rgb.r} ${_rgb.g} ${_rgb.b})`:`rgb(${255*_rgb.r|0},${255*_rgb.g|0},${255*_rgb.b|0})`}offsetHSL(h,s,l){this.getHSL(_hslA);_hslA.h+=h;_hslA.s+=
s;_hslA.l+=l;this.setHSL(_hslA.h,_hslA.s,_hslA.l);return this}add(color){this.r+=color.r;this.g+=color.g;this.b+=color.b;return this}addColors(color1,color2){this.r=color1.r+color2.r;this.g=color1.g+color2.g;this.b=color1.b+color2.b;return this}addScalar(s){this.r+=s;this.g+=s;this.b+=s;return this}sub(color){this.r=Math.max(0,this.r-color.r);this.g=Math.max(0,this.g-color.g);this.b=Math.max(0,this.b-color.b);return this}multiply(color){this.r*=color.r;this.g*=color.g;this.b*=color.b;return this}multiplyScalar(s){this.r*=
s;this.g*=s;this.b*=s;return this}lerp(color,alpha){this.r+=(color.r-this.r)*alpha;this.g+=(color.g-this.g)*alpha;this.b+=(color.b-this.b)*alpha;return this}lerpColors(color1,color2,alpha){this.r=color1.r+(color2.r-color1.r)*alpha;this.g=color1.g+(color2.g-color1.g)*alpha;this.b=color1.b+(color2.b-color1.b)*alpha;return this}lerpHSL(color,alpha){this.getHSL(_hslA);color.getHSL(_hslB);color=lerp(_hslA.h,_hslB.h,alpha);const s=lerp(_hslA.s,_hslB.s,alpha);alpha=lerp(_hslA.l,_hslB.l,alpha);this.setHSL(color,
s,alpha);return this}equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b}fromArray(array,offset=0){this.r=array[offset];this.g=array[offset+1];this.b=array[offset+2];return this}toArray(array=[],offset=0){array[offset]=this.r;array[offset+1]=this.g;array[offset+2]=this.b;return array}fromBufferAttribute(attribute,index){this.r=attribute.getX(index);this.g=attribute.getY(index);this.b=attribute.getZ(index);return this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r;yield this.g;
yield this.b}}Color.NAMES=_colorKeywords;let _canvas;class ImageUtils{static getDataURL(image){if(/^data:/i.test(image.src)||"undefined"==typeof HTMLCanvasElement)return image.src;if(image instanceof HTMLCanvasElement)var canvas=image;else void 0===_canvas&&(_canvas=createElementNS("canvas")),_canvas.width=image.width,_canvas.height=image.height,canvas=_canvas.getContext("2d"),image instanceof ImageData?canvas.putImageData(image,0,0):canvas.drawImage(image,0,0,image.width,image.height),canvas=_canvas;
return 2048<canvas.width||2048<canvas.height?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",image),canvas.toDataURL("image/jpeg",.6)):canvas.toDataURL("image/png")}static sRGBToLinear(image){if("undefined"!==typeof HTMLImageElement&&image instanceof HTMLImageElement||"undefined"!==typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||"undefined"!==typeof ImageBitmap&&image instanceof ImageBitmap){var canvas=createElementNS("canvas");canvas.width=
image.width;canvas.height=image.height;var context=canvas.getContext("2d");context.drawImage(image,0,0,image.width,image.height);image=context.getImageData(0,0,image.width,image.height);const data=image.data;for(let i=0;i<data.length;i++)data[i]=255*SRGBToLinear(data[i]/255);context.putImageData(image,0,0);return canvas}if(image.data){canvas=image.data.slice(0);for(context=0;context<canvas.length;context++)canvas[context]=canvas instanceof Uint8Array||canvas instanceof Uint8ClampedArray?Math.floor(255*
SRGBToLinear(canvas[context]/255)):SRGBToLinear(canvas[context]);return{data:canvas,width:image.width,height:image.height}}console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.");return image}}class Source{constructor(data=null){this.isSource=!0;this.uuid=generateUUID();this.data=data;this.version=0}set needsUpdate(value){!0===value&&this.version++}toJSON(meta){const isRootObject=void 0===meta||"string"===typeof meta;if(!isRootObject&&void 0!==meta.images[this.uuid])return meta.images[this.uuid];
const output={uuid:this.uuid,url:""},data=this.data;if(null!==data){let url;if(Array.isArray(data)){url=[];for(let i=0,l=data.length;i<l;i++)data[i].isDataTexture?url.push(serializeImage(data[i].image)):url.push(serializeImage(data[i]))}else url=serializeImage(data);output.url=url}isRootObject||(meta.images[this.uuid]=output);return output}}let textureId=0;class Texture extends EventDispatcher{constructor(image=Texture.DEFAULT_IMAGE,mapping=Texture.DEFAULT_MAPPING,wrapS=1001,wrapT=1001,magFilter=
1006,minFilter=1008,format=1023,type=1009,anisotropy=1,encoding=3E3){super();this.isTexture=!0;Object.defineProperty(this,"id",{value:textureId++});this.uuid=generateUUID();this.name="";this.source=new Source(image);this.mipmaps=[];this.mapping=mapping;this.wrapS=wrapS;this.wrapT=wrapT;this.magFilter=magFilter;this.minFilter=minFilter;this.anisotropy=anisotropy;this.format=format;this.internalFormat=null;this.type=type;this.offset=new Vector2(0,0);this.repeat=new Vector2(1,1);this.center=new Vector2(0,
0);this.rotation=0;this.matrixAutoUpdate=!0;this.matrix=new Matrix3;this.generateMipmaps=!0;this.premultiplyAlpha=!1;this.flipY=!0;this.unpackAlignment=4;this.encoding=encoding;this.userData={};this.version=0;this.onUpdate=null;this.needsPMREMUpdate=this.isRenderTargetTexture=!1}get image(){return this.source.data}set image(value){this.source.data=value}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return(new this.constructor).copy(this)}copy(source){this.name=
source.name;this.source=source.source;this.mipmaps=source.mipmaps.slice(0);this.mapping=source.mapping;this.wrapS=source.wrapS;this.wrapT=source.wrapT;this.magFilter=source.magFilter;this.minFilter=source.minFilter;this.anisotropy=source.anisotropy;this.format=source.format;this.internalFormat=source.internalFormat;this.type=source.type;this.offset.copy(source.offset);this.repeat.copy(source.repeat);this.center.copy(source.center);this.rotation=source.rotation;this.matrixAutoUpdate=source.matrixAutoUpdate;
this.matrix.copy(source.matrix);this.generateMipmaps=source.generateMipmaps;this.premultiplyAlpha=source.premultiplyAlpha;this.flipY=source.flipY;this.unpackAlignment=source.unpackAlignment;this.encoding=source.encoding;this.userData=JSON.parse(JSON.stringify(source.userData));this.needsUpdate=!0;return this}toJSON(meta){const isRootObject=void 0===meta||"string"===typeof meta;if(!isRootObject&&void 0!==meta.textures[this.uuid])return meta.textures[this.uuid];const output={metadata:{version:4.5,type:"Texture",
generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(meta).uuid,mapping:this.mapping,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,type:this.type,encoding:this.encoding,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};
"{}"!==JSON.stringify(this.userData)&&(output.userData=this.userData);isRootObject||(meta.textures[this.uuid]=output);return output}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(uv){if(300!==this.mapping)return uv;uv.applyMatrix3(this.matrix);if(0>uv.x||1<uv.x)switch(this.wrapS){case 1E3:uv.x-=Math.floor(uv.x);break;case 1001:uv.x=0>uv.x?0:1;break;case 1002:uv.x=1===Math.abs(Math.floor(uv.x)%2)?Math.ceil(uv.x)-uv.x:uv.x-Math.floor(uv.x)}if(0>uv.y||1<uv.y)switch(this.wrapT){case 1E3:uv.y-=
Math.floor(uv.y);break;case 1001:uv.y=0>uv.y?0:1;break;case 1002:uv.y=1===Math.abs(Math.floor(uv.y)%2)?Math.ceil(uv.y)-uv.y:uv.y-Math.floor(uv.y)}this.flipY&&(uv.y=1-uv.y);return uv}set needsUpdate(value){!0===value&&(this.version++,this.source.needsUpdate=!0)}}Texture.DEFAULT_IMAGE=null;Texture.DEFAULT_MAPPING=300;class Vector4{constructor(x=0,y=0,z=0,w=1){Vector4.prototype.isVector4=!0;this.x=x;this.y=y;this.z=z;this.w=w}get width(){return this.z}set width(value){this.z=value}get height(){return this.w}set height(value){this.w=
value}set(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}setScalar(scalar){this.w=this.z=this.y=this.x=scalar;return this}setX(x){this.x=x;return this}setY(y){this.y=y;return this}setZ(z){this.z=z;return this}setW(w){this.w=w;return this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw Error("index is out of range: "+index);}return this}getComponent(index){switch(index){case 0:return this.x;
case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw Error("index is out of range: "+index);}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;this.w=void 0!==v.w?v.w:1;return this}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;this.w+=v.w;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;this.w+=s;return this}addVectors(a,b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;this.w=a.w+b.w;return this}addScaledVector(v,s){this.x+=
v.x*s;this.y+=v.y*s;this.z+=v.z*s;this.w+=v.w*s;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;this.w-=v.w;return this}subScalar(s){this.x-=s;this.y-=s;this.z-=s;this.w-=s;return this}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;this.w=a.w-b.w;return this}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;this.w*=v.w;return this}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;this.w*=scalar;return this}applyMatrix4(m){const x=this.x,y=this.y,z=this.z,w=this.w;
m=m.elements;this.x=m[0]*x+m[4]*y+m[8]*z+m[12]*w;this.y=m[1]*x+m[5]*y+m[9]*z+m[13]*w;this.z=m[2]*x+m[6]*y+m[10]*z+m[14]*w;this.w=m[3]*x+m[7]*y+m[11]*z+m[15]*w;return this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}setAxisAngleFromQuaternion(q){this.w=2*Math.acos(q.w);const s=Math.sqrt(1-q.w*q.w);1E-4>s?(this.x=1,this.z=this.y=0):(this.x=q.x/s,this.y=q.y/s,this.z=q.z/s);return this}setAxisAngleFromRotationMatrix(m){m=m.elements;var m11=m[0];var z=m[4];var m13=m[8];const m21=m[1];var m22=
m[5],m23=m[9];var y=m[2];var x=m[6];var m33=m[10];if(.01>Math.abs(z-m21)&&.01>Math.abs(m13-y)&&.01>Math.abs(m23-x)){if(.1>Math.abs(z+m21)&&.1>Math.abs(m13+y)&&.1>Math.abs(m23+x)&&.1>Math.abs(m11+m22+m33-3))return this.set(1,0,0,0),this;m=Math.PI;m11=(m11+1)/2;m22=(m22+1)/2;m33=(m33+1)/2;z=(z+m21)/4;m13=(m13+y)/4;m23=(m23+x)/4;m11>m22&&m11>m33?.01>m11?(x=0,z=y=.707106781):(x=Math.sqrt(m11),y=z/x,z=m13/x):m22>m33?.01>m22?(x=.707106781,y=0,z=.707106781):(y=Math.sqrt(m22),x=z/y,z=m23/y):.01>m33?(y=x=
.707106781,z=0):(z=Math.sqrt(m33),x=m13/z,y=m23/z);this.set(x,y,z,m);return this}m=Math.sqrt((x-m23)*(x-m23)+(m13-y)*(m13-y)+(m21-z)*(m21-z));.001>Math.abs(m)&&(m=1);this.x=(x-m23)/m;this.y=(m13-y)/m;this.z=(m21-z)/m;this.w=Math.acos((m11+m22+m33-1)/2);return this}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);this.w=Math.min(this.w,v.w);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);this.w=Math.max(this.w,
v.w);return this}clamp(min,max){this.x=Math.max(min.x,Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));this.w=Math.max(min.w,Math.min(max.w,this.w));return this}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));this.w=Math.max(minVal,Math.min(maxVal,this.w));return this}clampLength(min,max){const length=this.length();
return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);this.z=Math.floor(this.z);this.w=Math.floor(this.w);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);this.w=Math.ceil(this.w);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);this.w=Math.round(this.w);return this}roundToZero(){this.x=0>this.x?Math.ceil(this.x):
Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);this.w=0>this.w?Math.ceil(this.w):Math.floor(this.w);return this}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;this.w=-this.w;return this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+
Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;this.w+=(v.w-this.w)*alpha;return this}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;this.w=v1.w+(v2.w-v1.w)*alpha;return this}equals(v){return v.x===this.x&&v.y===this.y&&
v.z===this.z&&v.w===this.w}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];this.w=array[offset+3];return this}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;array[offset+3]=this.w;return array}fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);this.w=attribute.getW(index);return this}random(){this.x=Math.random();this.y=Math.random();
this.z=Math.random();this.w=Math.random();return this}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z;yield this.w}}class WebGLRenderTarget extends EventDispatcher{constructor(width=1,height=1,options={}){super();this.isWebGLRenderTarget=!0;this.width=width;this.height=height;this.depth=1;this.scissor=new Vector4(0,0,width,height);this.scissorTest=!1;this.viewport=new Vector4(0,0,width,height);this.texture=new Texture({width,height,depth:1},options.mapping,options.wrapS,options.wrapT,
options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=!0;this.texture.flipY=!1;this.texture.generateMipmaps=void 0!==options.generateMipmaps?options.generateMipmaps:!1;this.texture.internalFormat=void 0!==options.internalFormat?options.internalFormat:null;this.texture.minFilter=void 0!==options.minFilter?options.minFilter:1006;this.depthBuffer=void 0!==options.depthBuffer?options.depthBuffer:!0;this.stencilBuffer=void 0!==
options.stencilBuffer?options.stencilBuffer:!1;this.depthTexture=void 0!==options.depthTexture?options.depthTexture:null;this.samples=void 0!==options.samples?options.samples:0}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth)this.width=width,this.height=height,this.depth=depth,this.texture.image.width=width,this.texture.image.height=height,this.texture.image.depth=depth,this.dispose();this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height)}clone(){return(new this.constructor).copy(this)}copy(source){this.width=
source.width;this.height=source.height;this.depth=source.depth;this.viewport.copy(source.viewport);this.texture=source.texture.clone();this.texture.isRenderTargetTexture=!0;const image=Object.assign({},source.texture.image);this.texture.source=new Source(image);this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;null!==source.depthTexture&&(this.depthTexture=source.depthTexture.clone());this.samples=source.samples;return this}dispose(){this.dispatchEvent({type:"dispose"})}}
class DataArrayTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null);this.isDataArrayTexture=!0;this.image={data,width,height,depth};this.minFilter=this.magFilter=1003;this.wrapR=1001;this.flipY=this.generateMipmaps=!1;this.unpackAlignment=1}}class WebGLArrayRenderTarget extends WebGLRenderTarget{constructor(width=1,height=1,depth=1){super(width,height);this.isWebGLArrayRenderTarget=!0;this.depth=depth;this.texture=new DataArrayTexture(null,width,height,depth);this.texture.isRenderTargetTexture=
!0}}class Data3DTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null);this.isData3DTexture=!0;this.image={data,width,height,depth};this.minFilter=this.magFilter=1003;this.wrapR=1001;this.flipY=this.generateMipmaps=!1;this.unpackAlignment=1}}class WebGL3DRenderTarget extends WebGLRenderTarget{constructor(width=1,height=1,depth=1){super(width,height);this.isWebGL3DRenderTarget=!0;this.depth=depth;this.texture=new Data3DTexture(null,width,height,depth);this.texture.isRenderTargetTexture=
!0}}class WebGLMultipleRenderTargets extends WebGLRenderTarget{constructor(width=1,height=1,count=1,options={}){super(width,height,options);this.isWebGLMultipleRenderTargets=!0;width=this.texture;this.texture=[];for(height=0;height<count;height++)this.texture[height]=width.clone(),this.texture[height].isRenderTargetTexture=!0}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width;this.height=height;this.depth=depth;for(let i=0,il=this.texture.length;i<
il;i++)this.texture[i].image.width=width,this.texture[i].image.height=height,this.texture[i].image.depth=depth;this.dispose()}this.viewport.set(0,0,width,height);this.scissor.set(0,0,width,height);return this}copy(source){this.dispose();this.width=source.width;this.height=source.height;this.depth=source.depth;this.viewport.set(0,0,this.width,this.height);this.scissor.set(0,0,this.width,this.height);this.depthBuffer=source.depthBuffer;this.stencilBuffer=source.stencilBuffer;null!==source.depthTexture&&
(this.depthTexture=source.depthTexture.clone());this.texture.length=0;for(let i=0,il=source.texture.length;i<il;i++)this.texture[i]=source.texture[i].clone(),this.texture[i].isRenderTargetTexture=!0;return this}}class Quaternion{constructor(x=0,y=0,z=0,w=1){this.isQuaternion=!0;this._x=x;this._y=y;this._z=z;this._w=w}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){let x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2];src0=src0[srcOffset0+3];srcOffset0=src1[srcOffset1+
0];const y1=src1[srcOffset1+1],z1=src1[srcOffset1+2];src1=src1[srcOffset1+3];if(0===t)dst[dstOffset+0]=x0,dst[dstOffset+1]=y0,dst[dstOffset+2]=z0,dst[dstOffset+3]=src0;else if(1===t)dst[dstOffset+0]=srcOffset0,dst[dstOffset+1]=y1,dst[dstOffset+2]=z1,dst[dstOffset+3]=src1;else{if(src0!==src1||x0!==srcOffset0||y0!==y1||z0!==z1){srcOffset1=1-t;var cos=x0*srcOffset0+y0*y1+z0*z1+src0*src1,dir=0<=cos?1:-1,sqrSin=1-cos*cos;sqrSin>Number.EPSILON&&(sqrSin=Math.sqrt(sqrSin),cos=Math.atan2(sqrSin,cos*dir),srcOffset1=
Math.sin(srcOffset1*cos)/sqrSin,t=Math.sin(t*cos)/sqrSin);dir*=t;x0=x0*srcOffset1+srcOffset0*dir;y0=y0*srcOffset1+y1*dir;z0=z0*srcOffset1+z1*dir;src0=src0*srcOffset1+src1*dir;srcOffset1===1-t&&(t=1/Math.sqrt(x0*x0+y0*y0+z0*z0+src0*src0),x0*=t,y0*=t,z0*=t,src0*=t)}dst[dstOffset]=x0;dst[dstOffset+1]=y0;dst[dstOffset+2]=z0;dst[dstOffset+3]=src0}}static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2];src0=src0[srcOffset0+
3];srcOffset0=src1[srcOffset1];const y1=src1[srcOffset1+1],z1=src1[srcOffset1+2];src1=src1[srcOffset1+3];dst[dstOffset]=x0*src1+src0*srcOffset0+y0*z1-z0*y1;dst[dstOffset+1]=y0*src1+src0*y1+z0*srcOffset0-x0*z1;dst[dstOffset+2]=z0*src1+src0*z1+x0*y1-y0*srcOffset0;dst[dstOffset+3]=src0*src1-x0*srcOffset0-y0*y1-z0*z1;return dst}get x(){return this._x}set x(value){this._x=value;this._onChangeCallback()}get y(){return this._y}set y(value){this._y=value;this._onChangeCallback()}get z(){return this._z}set z(value){this._z=
value;this._onChangeCallback()}get w(){return this._w}set w(value){this._w=value;this._onChangeCallback()}set(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._onChangeCallback();return this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(quaternion){this._x=quaternion.x;this._y=quaternion.y;this._z=quaternion.z;this._w=quaternion.w;this._onChangeCallback();return this}setFromEuler(euler,update){var x=euler._x,y=euler._y,z=euler._z;euler=euler._order;var cos=Math.cos;
const sin=Math.sin,c1=cos(x/2),c2=cos(y/2);cos=cos(z/2);x=sin(x/2);y=sin(y/2);z=sin(z/2);switch(euler){case "XYZ":this._x=x*c2*cos+c1*y*z;this._y=c1*y*cos-x*c2*z;this._z=c1*c2*z+x*y*cos;this._w=c1*c2*cos-x*y*z;break;case "YXZ":this._x=x*c2*cos+c1*y*z;this._y=c1*y*cos-x*c2*z;this._z=c1*c2*z-x*y*cos;this._w=c1*c2*cos+x*y*z;break;case "ZXY":this._x=x*c2*cos-c1*y*z;this._y=c1*y*cos+x*c2*z;this._z=c1*c2*z+x*y*cos;this._w=c1*c2*cos-x*y*z;break;case "ZYX":this._x=x*c2*cos-c1*y*z;this._y=c1*y*cos+x*c2*z;
this._z=c1*c2*z-x*y*cos;this._w=c1*c2*cos+x*y*z;break;case "YZX":this._x=x*c2*cos+c1*y*z;this._y=c1*y*cos+x*c2*z;this._z=c1*c2*z-x*y*cos;this._w=c1*c2*cos-x*y*z;break;case "XZY":this._x=x*c2*cos-c1*y*z;this._y=c1*y*cos-x*c2*z;this._z=c1*c2*z+x*y*cos;this._w=c1*c2*cos+x*y*z;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+euler)}!1!==update&&this._onChangeCallback();return this}setFromAxisAngle(axis,angle){angle/=2;const s=Math.sin(angle);this._x=axis.x*
s;this._y=axis.y*s;this._z=axis.z*s;this._w=Math.cos(angle);this._onChangeCallback();return this}setFromRotationMatrix(m){var te=m.elements,m11=te[0];m=te[4];const m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6];te=te[10];const trace=m11+m22+te;0<trace?(m11=.5/Math.sqrt(trace+1),this._w=.25/m11,this._x=(m32-m23)*m11,this._y=(m13-m31)*m11,this._z=(m21-m)*m11):m11>m22&&m11>te?(m11=2*Math.sqrt(1+m11-m22-te),this._w=(m32-m23)/m11,this._x=.25*m11,this._y=(m+m21)/m11,this._z=(m13+m31)/m11):
m22>te?(m11=2*Math.sqrt(1+m22-m11-te),this._w=(m13-m31)/m11,this._x=(m+m21)/m11,this._y=.25*m11,this._z=(m23+m32)/m11):(m11=2*Math.sqrt(1+te-m11-m22),this._w=(m21-m)/m11,this._x=(m13+m31)/m11,this._y=(m23+m32)/m11,this._z=.25*m11);this._onChangeCallback();return this}setFromUnitVectors(vFrom,vTo){let r=vFrom.dot(vTo)+1;r<Number.EPSILON?(r=0,Math.abs(vFrom.x)>Math.abs(vFrom.z)?(this._x=-vFrom.y,this._y=vFrom.x,this._z=0):(this._x=0,this._y=-vFrom.z,this._z=vFrom.y)):(this._x=vFrom.y*vTo.z-vFrom.z*
vTo.y,this._y=vFrom.z*vTo.x-vFrom.x*vTo.z,this._z=vFrom.x*vTo.y-vFrom.y*vTo.x);this._w=r;return this.normalize()}angleTo(q){return 2*Math.acos(Math.abs(clamp(this.dot(q),-1,1)))}rotateTowards(q,step){const angle=this.angleTo(q);if(0===angle)return this;this.slerp(q,Math.min(1,step/angle));return this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){this._x*=-1;this._y*=-1;this._z*=-1;this._onChangeCallback();return this}dot(v){return this._x*v._x+this._y*v._y+this._z*
v._z+this._w*v._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let l=this.length();0===l?(this._z=this._y=this._x=0,this._w=1):(l=1/l,this._x*=l,this._y*=l,this._z*=l,this._w*=l);this._onChangeCallback();return this}multiply(q){return this.multiplyQuaternions(this,q)}premultiply(q){return this.multiplyQuaternions(q,this)}multiplyQuaternions(a,b){const qax=a._x,
qay=a._y,qaz=a._z;a=a._w;const qbx=b._x,qby=b._y,qbz=b._z;b=b._w;this._x=qax*b+a*qbx+qay*qbz-qaz*qby;this._y=qay*b+a*qby+qaz*qbx-qax*qbz;this._z=qaz*b+a*qbz+qax*qby-qay*qbx;this._w=a*b-qax*qbx-qay*qby-qaz*qbz;this._onChangeCallback();return this}slerp(qb,t){if(0===t)return this;if(1===t)return this.copy(qb);const x=this._x,y=this._y,z=this._z,w=this._w;var cosHalfTheta=w*qb._w+x*qb._x+y*qb._y+z*qb._z;0>cosHalfTheta?(this._w=-qb._w,this._x=-qb._x,this._y=-qb._y,this._z=-qb._z,cosHalfTheta=-cosHalfTheta):
this.copy(qb);if(1<=cosHalfTheta)return this._w=w,this._x=x,this._y=y,this._z=z,this;qb=1-cosHalfTheta*cosHalfTheta;if(qb<=Number.EPSILON)return cosHalfTheta=1-t,this._w=cosHalfTheta*w+t*this._w,this._x=cosHalfTheta*x+t*this._x,this._y=cosHalfTheta*y+t*this._y,this._z=cosHalfTheta*z+t*this._z,this.normalize(),this._onChangeCallback(),this;qb=Math.sqrt(qb);const halfTheta=Math.atan2(qb,cosHalfTheta);cosHalfTheta=Math.sin((1-t)*halfTheta)/qb;t=Math.sin(t*halfTheta)/qb;this._w=w*cosHalfTheta+this._w*
t;this._x=x*cosHalfTheta+this._x*t;this._y=y*cosHalfTheta+this._y*t;this._z=z*cosHalfTheta+this._z*t;this._onChangeCallback();return this}slerpQuaternions(qa,qb,t){return this.copy(qa).slerp(qb,t)}random(){var u1=Math.random();const sqrt1u1=Math.sqrt(1-u1);u1=Math.sqrt(u1);const u2=2*Math.PI*Math.random(),u3=2*Math.PI*Math.random();return this.set(sqrt1u1*Math.cos(u2),u1*Math.sin(u3),u1*Math.cos(u3),sqrt1u1*Math.sin(u2))}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&
quaternion._z===this._z&&quaternion._w===this._w}fromArray(array,offset=0){this._x=array[offset];this._y=array[offset+1];this._z=array[offset+2];this._w=array[offset+3];this._onChangeCallback();return this}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._w;return array}fromBufferAttribute(attribute,index){this._x=attribute.getX(index);this._y=attribute.getY(index);this._z=attribute.getZ(index);this._w=attribute.getW(index);return this}_onChange(callback){this._onChangeCallback=
callback;return this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x;yield this._y;yield this._z;yield this._w}}class Vector3{constructor(x=0,y=0,z=0){Vector3.prototype.isVector3=!0;this.x=x;this.y=y;this.z=z}set(x,y,z){void 0===z&&(z=this.z);this.x=x;this.y=y;this.z=z;return this}setScalar(scalar){this.z=this.y=this.x=scalar;return this}setX(x){this.x=x;return this}setY(y){this.y=y;return this}setZ(z){this.z=z;return this}setComponent(index,value){switch(index){case 0:this.x=value;break;
case 1:this.y=value;break;case 2:this.z=value;break;default:throw Error("index is out of range: "+index);}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw Error("index is out of range: "+index);}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(v){this.x=v.x;this.y=v.y;this.z=v.z;return this}add(v){this.x+=v.x;this.y+=v.y;this.z+=v.z;return this}addScalar(s){this.x+=s;this.y+=s;this.z+=s;return this}addVectors(a,
b){this.x=a.x+b.x;this.y=a.y+b.y;this.z=a.z+b.z;return this}addScaledVector(v,s){this.x+=v.x*s;this.y+=v.y*s;this.z+=v.z*s;return this}sub(v){this.x-=v.x;this.y-=v.y;this.z-=v.z;return this}subScalar(s){this.x-=s;this.y-=s;this.z-=s;return this}subVectors(a,b){this.x=a.x-b.x;this.y=a.y-b.y;this.z=a.z-b.z;return this}multiply(v){this.x*=v.x;this.y*=v.y;this.z*=v.z;return this}multiplyScalar(scalar){this.x*=scalar;this.y*=scalar;this.z*=scalar;return this}multiplyVectors(a,b){this.x=a.x*b.x;this.y=
a.y*b.y;this.z=a.z*b.z;return this}applyEuler(euler){return this.applyQuaternion(_quaternion$4.setFromEuler(euler))}applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis,angle))}applyMatrix3(m){const x=this.x,y=this.y,z=this.z;m=m.elements;this.x=m[0]*x+m[3]*y+m[6]*z;this.y=m[1]*x+m[4]*y+m[7]*z;this.z=m[2]*x+m[5]*y+m[8]*z;return this}applyNormalMatrix(m){return this.applyMatrix3(m).normalize()}applyMatrix4(m){const x=this.x,y=this.y,z=this.z;m=m.elements;const w=
1/(m[3]*x+m[7]*y+m[11]*z+m[15]);this.x=(m[0]*x+m[4]*y+m[8]*z+m[12])*w;this.y=(m[1]*x+m[5]*y+m[9]*z+m[13])*w;this.z=(m[2]*x+m[6]*y+m[10]*z+m[14])*w;return this}applyQuaternion(q){var x=this.x;const y=this.y,z=this.z,qx=q.x,qy=q.y,qz=q.z;q=q.w;const ix=q*x+qy*z-qz*y,iy=q*y+qz*x-qx*z,iz=q*z+qx*y-qy*x;x=-qx*x-qy*y-qz*z;this.x=ix*q+x*-qx+iy*-qz-iz*-qy;this.y=iy*q+x*-qy+iz*-qx-ix*-qz;this.z=iz*q+x*-qz+ix*-qy-iy*-qx;return this}project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)}unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)}transformDirection(m){const x=
this.x,y=this.y,z=this.z;m=m.elements;this.x=m[0]*x+m[4]*y+m[8]*z;this.y=m[1]*x+m[5]*y+m[9]*z;this.z=m[2]*x+m[6]*y+m[10]*z;return this.normalize()}divide(v){this.x/=v.x;this.y/=v.y;this.z/=v.z;return this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}min(v){this.x=Math.min(this.x,v.x);this.y=Math.min(this.y,v.y);this.z=Math.min(this.z,v.z);return this}max(v){this.x=Math.max(this.x,v.x);this.y=Math.max(this.y,v.y);this.z=Math.max(this.z,v.z);return this}clamp(min,max){this.x=Math.max(min.x,
Math.min(max.x,this.x));this.y=Math.max(min.y,Math.min(max.y,this.y));this.z=Math.max(min.z,Math.min(max.z,this.z));return this}clampScalar(minVal,maxVal){this.x=Math.max(minVal,Math.min(maxVal,this.x));this.y=Math.max(minVal,Math.min(maxVal,this.y));this.z=Math.max(minVal,Math.min(maxVal,this.z));return this}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(Math.max(min,Math.min(max,length)))}floor(){this.x=Math.floor(this.x);this.y=Math.floor(this.y);
this.z=Math.floor(this.z);return this}ceil(){this.x=Math.ceil(this.x);this.y=Math.ceil(this.y);this.z=Math.ceil(this.z);return this}round(){this.x=Math.round(this.x);this.y=Math.round(this.y);this.z=Math.round(this.z);return this}roundToZero(){this.x=0>this.x?Math.ceil(this.x):Math.floor(this.x);this.y=0>this.y?Math.ceil(this.y):Math.floor(this.y);this.z=0>this.z?Math.ceil(this.z):Math.floor(this.z);return this}negate(){this.x=-this.x;this.y=-this.y;this.z=-this.z;return this}dot(v){return this.x*
v.x+this.y*v.y+this.z*v.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v,alpha){this.x+=(v.x-this.x)*alpha;this.y+=(v.y-this.y)*alpha;this.z+=(v.z-this.z)*alpha;return this}lerpVectors(v1,v2,alpha){this.x=v1.x+(v2.x-
v1.x)*alpha;this.y=v1.y+(v2.y-v1.y)*alpha;this.z=v1.z+(v2.z-v1.z)*alpha;return this}cross(v){return this.crossVectors(this,v)}crossVectors(a,b){const ax=a.x,ay=a.y;a=a.z;const bx=b.x,by=b.y;b=b.z;this.x=ay*b-a*by;this.y=a*bx-ax*b;this.z=ax*by-ay*bx;return this}projectOnVector(v){var denominator=v.lengthSq();if(0===denominator)return this.set(0,0,0);denominator=v.dot(this)/denominator;return this.copy(v).multiplyScalar(denominator)}projectOnPlane(planeNormal){_vector$c.copy(this).projectOnVector(planeNormal);
return this.sub(_vector$c)}reflect(normal){return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)))}angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(0===denominator)return Math.PI/2;v=this.dot(v)/denominator;return Math.acos(clamp(v,-1,1))}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y;v=this.z-v.z;return dx*dx+dy*dy+v*v}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+
Math.abs(this.z-v.z)}setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta)}setFromSphericalCoords(radius,phi,theta){const sinPhiRadius=Math.sin(phi)*radius;this.x=sinPhiRadius*Math.sin(theta);this.y=Math.cos(phi)*radius;this.z=sinPhiRadius*Math.cos(theta);return this}setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y)}setFromCylindricalCoords(radius,theta,y){this.x=radius*Math.sin(theta);this.y=y;this.z=radius*Math.cos(theta);return this}setFromMatrixPosition(m){m=
m.elements;this.x=m[12];this.y=m[13];this.z=m[14];return this}setFromMatrixScale(m){const sx=this.setFromMatrixColumn(m,0).length(),sy=this.setFromMatrixColumn(m,1).length();m=this.setFromMatrixColumn(m,2).length();this.x=sx;this.y=sy;this.z=m;return this}setFromMatrixColumn(m,index){return this.fromArray(m.elements,4*index)}setFromMatrix3Column(m,index){return this.fromArray(m.elements,3*index)}setFromEuler(e){this.x=e._x;this.y=e._y;this.z=e._z;return this}equals(v){return v.x===this.x&&v.y===this.y&&
v.z===this.z}fromArray(array,offset=0){this.x=array[offset];this.y=array[offset+1];this.z=array[offset+2];return this}toArray(array=[],offset=0){array[offset]=this.x;array[offset+1]=this.y;array[offset+2]=this.z;return array}fromBufferAttribute(attribute,index){this.x=attribute.getX(index);this.y=attribute.getY(index);this.z=attribute.getZ(index);return this}random(){this.x=Math.random();this.y=Math.random();this.z=Math.random();return this}randomDirection(){const u=2*(Math.random()-.5),t=Math.random()*
Math.PI*2,f=Math.sqrt(1-Math.pow(u,2));this.x=f*Math.cos(t);this.y=f*Math.sin(t);this.z=u;return this}*[Symbol.iterator](){yield this.x;yield this.y;yield this.z}}const _vector$c=new Vector3,_quaternion$4=new Quaternion;class Box3{constructor(min=new Vector3(Infinity,Infinity,Infinity),max=new Vector3(-Infinity,-Infinity,-Infinity)){this.isBox3=!0;this.min=min;this.max=max}set(min,max){this.min.copy(min);this.max.copy(max);return this}setFromArray(array){let minX=Infinity,minY=Infinity,minZ=Infinity,
maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;for(let i=0,l=array.length;i<l;i+=3){const x=array[i],y=array[i+1],z=array[i+2];x<minX&&(minX=x);y<minY&&(minY=y);z<minZ&&(minZ=z);x>maxX&&(maxX=x);y>maxY&&(maxY=y);z>maxZ&&(maxZ=z)}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this}setFromBufferAttribute(attribute){let minX=Infinity,minY=Infinity,minZ=Infinity,maxX=-Infinity,maxY=-Infinity,maxZ=-Infinity;for(let i=0,l=attribute.count;i<l;i++){const x=attribute.getX(i),y=attribute.getY(i),
z=attribute.getZ(i);x<minX&&(minX=x);y<minY&&(minY=y);z<minZ&&(minZ=z);x>maxX&&(maxX=x);y>maxY&&(maxY=y);z>maxZ&&(maxZ=z)}this.min.set(minX,minY,minZ);this.max.set(maxX,maxY,maxZ);return this}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++)this.expandByPoint(points[i]);return this}setFromCenterAndSize(center,size){size=_vector$b.copy(size).multiplyScalar(.5);this.min.copy(center).sub(size);this.max.copy(center).add(size);return this}setFromObject(object,precise=!1){this.makeEmpty();
return this.expandByObject(object,precise)}clone(){return(new this.constructor).copy(this)}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this}makeEmpty(){this.min.x=this.min.y=this.min.z=Infinity;this.max.x=this.max.y=this.max.z=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?
target.set(0,0,0):target.subVectors(this.max,this.min)}expandByPoint(point){this.min.min(point);this.max.max(point);return this}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this}expandByObject(object,precise=!1){object.updateWorldMatrix(!1,!1);var geometry=object.geometry;if(void 0!==geometry)if(precise&&void 0!=geometry.attributes&&void 0!==geometry.attributes.position){geometry=geometry.attributes.position;
for(let i=0,l=geometry.count;i<l;i++)_vector$b.fromBufferAttribute(geometry,i).applyMatrix4(object.matrixWorld),this.expandByPoint(_vector$b)}else null===geometry.boundingBox&&geometry.computeBoundingBox(),_box$3.copy(geometry.boundingBox),_box$3.applyMatrix4(object.matrixWorld),this.union(_box$3);object=object.children;for(let i=0,l=object.length;i<l;i++)this.expandByObject(object[i],precise);return this}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>
this.max.y||point.z<this.min.z||point.z>this.max.z?!1:!0}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(box){return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>
this.max.y||box.max.z<this.min.z||box.min.z>this.max.z?!1:!0}intersectsSphere(sphere){this.clampPoint(sphere.center,_vector$b);return _vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius}intersectsPlane(plane){let min,max;0<plane.normal.x?(min=plane.normal.x*this.min.x,max=plane.normal.x*this.max.x):(min=plane.normal.x*this.max.x,max=plane.normal.x*this.min.x);0<plane.normal.y?(min+=plane.normal.y*this.min.y,max+=plane.normal.y*this.max.y):(min+=plane.normal.y*this.max.y,max+=plane.normal.y*
this.min.y);0<plane.normal.z?(min+=plane.normal.z*this.min.z,max+=plane.normal.z*this.max.z):(min+=plane.normal.z*this.max.z,max+=plane.normal.z*this.min.z);return min<=-plane.constant&&max>=-plane.constant}intersectsTriangle(triangle){if(this.isEmpty())return!1;this.getCenter(_center);_extents.subVectors(this.max,_center);_v0$2.subVectors(triangle.a,_center);_v1$7.subVectors(triangle.b,_center);_v2$4.subVectors(triangle.c,_center);_f0.subVectors(_v1$7,_v0$2);_f1.subVectors(_v2$4,_v1$7);_f2.subVectors(_v0$2,
_v2$4);triangle=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];if(!satForAxes(triangle,_v0$2,_v1$7,_v2$4,_extents))return!1;triangle=[1,0,0,0,1,0,0,0,1];if(!satForAxes(triangle,_v0$2,_v1$7,_v2$4,_extents))return!1;_triangleNormal.crossVectors(_f0,_f1);triangle=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z];return satForAxes(triangle,_v0$2,_v1$7,_v2$4,_extents)}clampPoint(point,target){return target.copy(point).clamp(this.min,
this.max)}distanceToPoint(point){return _vector$b.copy(point).clamp(this.min,this.max).sub(point).length()}getBoundingSphere(target){this.getCenter(target.center);target.radius=.5*this.getSize(_vector$b).length();return target}intersect(box){this.min.max(box.min);this.max.min(box.max);this.isEmpty()&&this.makeEmpty();return this}union(box){this.min.min(box.min);this.max.max(box.max);return this}applyMatrix4(matrix){if(this.isEmpty())return this;_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix);
_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix);_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix);_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix);_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix);_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix);_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix);_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix);this.setFromPoints(_points);
return this}translate(offset){this.min.add(offset);this.max.add(offset);return this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}const _points=[new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3,new Vector3],_vector$b=new Vector3,_box$3=new Box3,_v0$2=new Vector3,_v1$7=new Vector3,_v2$4=new Vector3,_f0=new Vector3,_f1=new Vector3,_f2=new Vector3,_center=new Vector3,_extents=new Vector3,_triangleNormal=new Vector3,_testAxis=new Vector3,_box$2=
new Box3,_v1$6=new Vector3,_v2$3=new Vector3;class Sphere{constructor(center=new Vector3,radius=-1){this.center=center;this.radius=radius}set(center,radius){this.center.copy(center);this.radius=radius;return this}setFromPoints(points,optionalCenter){const center=this.center;void 0!==optionalCenter?center.copy(optionalCenter):_box$2.setFromPoints(points).getCenter(center);optionalCenter=0;for(let i=0,il=points.length;i<il;i++)optionalCenter=Math.max(optionalCenter,center.distanceToSquared(points[i]));
this.radius=Math.sqrt(optionalCenter);return this}copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this}isEmpty(){return 0>this.radius}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(point){return point.distanceTo(this.center)-this.radius}intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=
radiusSum*radiusSum}intersectsBox(box){return box.intersectsSphere(this)}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius}clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);deltaLengthSq>this.radius*this.radius&&(target.sub(this.center).normalize(),target.multiplyScalar(this.radius).add(this.center));return target}getBoundingBox(target){if(this.isEmpty())return target.makeEmpty(),target;target.set(this.center,
this.center);target.expandByScalar(this.radius);return target}applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius*=matrix.getMaxScaleOnAxis();return this}translate(offset){this.center.add(offset);return this}expandByPoint(point){if(this.isEmpty())return this.center.copy(point),this.radius=0,this;_v1$6.subVectors(point,this.center);point=_v1$6.lengthSq();if(point>this.radius*this.radius){point=Math.sqrt(point);const delta=.5*(point-this.radius);this.center.addScaledVector(_v1$6,delta/
point);this.radius+=delta}return this}union(sphere){if(sphere.isEmpty())return this;if(this.isEmpty())return this.copy(sphere),this;!0===this.center.equals(sphere.center)?this.radius=Math.max(this.radius,sphere.radius):(_v2$3.subVectors(sphere.center,this.center).setLength(sphere.radius),this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3)),this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3)));return this}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius}clone(){return(new this.constructor).copy(this)}}
const _vector$a=new Vector3,_segCenter=new Vector3,_segDir=new Vector3,_diff=new Vector3,_edge1=new Vector3,_edge2=new Vector3,_normal$1=new Vector3;class Ray{constructor(origin=new Vector3,direction=new Vector3(0,0,-1)){this.origin=origin;this.direction=direction}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this}at(t,target){return target.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(v){this.direction.copy(v).sub(this.origin).normalize();
return this}recast(t){this.origin.copy(this.at(t,_vector$a));return this}closestPointToPoint(point,target){target.subVectors(point,this.origin);point=target.dot(this.direction);return 0>point?target.copy(this.origin):target.copy(this.direction).multiplyScalar(point).add(this.origin)}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point))}distanceSqToPoint(point){const directionDistance=_vector$a.subVectors(point,this.origin).dot(this.direction);if(0>directionDistance)return this.origin.distanceToSquared(point);
_vector$a.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector$a.distanceToSquared(point)}distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){_segCenter.copy(v0).add(v1).multiplyScalar(.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);var segExtent=.5*v0.distanceTo(v1),a01=-this.direction.dot(_segDir);const b0=_diff.dot(this.direction),b1=-_diff.dot(_segDir),c=_diff.lengthSq(),det=Math.abs(1-a01*a01);let extDet;0<det?
(v0=a01*b1-b0,v1=a01*b0-b1,extDet=segExtent*det,0<=v0?v1>=-extDet?v1<=extDet?(segExtent=1/det,v0*=segExtent,v1*=segExtent,a01=v0*(v0+a01*v1+2*b0)+v1*(a01*v0+v1+2*b1)+c):(v1=segExtent,v0=Math.max(0,-(a01*v1+b0)),a01=-v0*v0+v1*(v1+2*b1)+c):(v1=-segExtent,v0=Math.max(0,-(a01*v1+b0)),a01=-v0*v0+v1*(v1+2*b1)+c):v1<=-extDet?(v0=Math.max(0,-(-a01*segExtent+b0)),v1=0<v0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),a01=-v0*v0+v1*(v1+2*b1)+c):v1<=extDet?(v0=0,v1=Math.min(Math.max(-segExtent,-b1),
segExtent),a01=v1*(v1+2*b1)+c):(v0=Math.max(0,-(a01*segExtent+b0)),v1=0<v0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),a01=-v0*v0+v1*(v1+2*b1)+c)):(v1=0<a01?-segExtent:segExtent,v0=Math.max(0,-(a01*v1+b0)),a01=-v0*v0+v1*(v1+2*b1)+c);optionalPointOnRay&&optionalPointOnRay.copy(this.direction).multiplyScalar(v0).add(this.origin);optionalPointOnSegment&&optionalPointOnSegment.copy(_segDir).multiplyScalar(v1).add(_segCenter);return a01}intersectSphere(sphere,target){_vector$a.subVectors(sphere.center,
this.origin);var tca=_vector$a.dot(this.direction),d2=_vector$a.dot(_vector$a)-tca*tca;sphere=sphere.radius*sphere.radius;if(d2>sphere)return null;sphere=Math.sqrt(sphere-d2);d2=tca-sphere;tca+=sphere;return 0>d2&&0>tca?null:0>d2?this.at(tca,target):this.at(d2,target)}intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius}distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(0===denominator)return 0===plane.distanceToPoint(this.origin)?
0:null;plane=-(this.origin.dot(plane.normal)+plane.constant)/denominator;return 0<=plane?plane:null}intersectPlane(plane,target){plane=this.distanceToPlane(plane);return null===plane?null:this.at(plane,target)}intersectsPlane(plane){const distToPoint=plane.distanceToPoint(this.origin);return 0===distToPoint||0>plane.normal.dot(this.direction)*distToPoint?!0:!1}intersectBox(box,target){let tmin;var tmax=1/this.direction.x;var tymax=1/this.direction.y;const invdirz=1/this.direction.z,origin=this.origin;
0<=tmax?(tmin=(box.min.x-origin.x)*tmax,tmax*=box.max.x-origin.x):(tmin=(box.max.x-origin.x)*tmax,tmax*=box.min.x-origin.x);if(0<=tymax){var tymin=(box.min.y-origin.y)*tymax;tymax*=box.max.y-origin.y}else tymin=(box.max.y-origin.y)*tymax,tymax*=box.min.y-origin.y;if(tmin>tymax||tymin>tmax)return null;if(tymin>tmin||isNaN(tmin))tmin=tymin;if(tymax<tmax||isNaN(tmax))tmax=tymax;0<=invdirz?(tymin=(box.min.z-origin.z)*invdirz,box=(box.max.z-origin.z)*invdirz):(tymin=(box.max.z-origin.z)*invdirz,box=(box.min.z-
origin.z)*invdirz);if(tmin>box||tymin>tmax)return null;if(tymin>tmin||tmin!==tmin)tmin=tymin;if(box<tmax||tmax!==tmax)tmax=box;return 0>tmax?null:this.at(0<=tmin?tmin:tmax,target)}intersectsBox(box){return null!==this.intersectBox(box,_vector$a)}intersectTriangle(a,b,c,backfaceCulling,target){_edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal$1.crossVectors(_edge1,_edge2);b=this.direction.dot(_normal$1);if(0<b){if(backfaceCulling)return null;backfaceCulling=1}else if(0>b)backfaceCulling=-1,b=-b;
else return null;_diff.subVectors(this.origin,a);a=backfaceCulling*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(0>a)return null;c=backfaceCulling*this.direction.dot(_edge1.cross(_diff));if(0>c||a+c>b)return null;a=-backfaceCulling*_diff.dot(_normal$1);return 0>a?null:this.at(a/b,target)}applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}
class Matrix4{constructor(){Matrix4.prototype.isMatrix4=!0;this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1]}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;te[0]=n11;te[4]=n12;te[8]=n13;te[12]=n14;te[1]=n21;te[5]=n22;te[9]=n23;te[13]=n24;te[2]=n31;te[6]=n32;te[10]=n33;te[14]=n34;te[3]=n41;te[7]=n42;te[11]=n43;te[15]=n44;return this}identity(){this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);return this}clone(){return(new Matrix4).fromArray(this.elements)}copy(m){const te=
this.elements;m=m.elements;te[0]=m[0];te[1]=m[1];te[2]=m[2];te[3]=m[3];te[4]=m[4];te[5]=m[5];te[6]=m[6];te[7]=m[7];te[8]=m[8];te[9]=m[9];te[10]=m[10];te[11]=m[11];te[12]=m[12];te[13]=m[13];te[14]=m[14];te[15]=m[15];return this}copyPosition(m){const te=this.elements;m=m.elements;te[12]=m[12];te[13]=m[13];te[14]=m[14];return this}setFromMatrix3(m){m=m.elements;this.set(m[0],m[3],m[6],0,m[1],m[4],m[7],0,m[2],m[5],m[8],0,0,0,0,1);return this}extractBasis(xAxis,yAxis,zAxis){xAxis.setFromMatrixColumn(this,
0);yAxis.setFromMatrixColumn(this,1);zAxis.setFromMatrixColumn(this,2);return this}makeBasis(xAxis,yAxis,zAxis){this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1);return this}extractRotation(m){const te=this.elements,me=m.elements,scaleX=1/_v1$5.setFromMatrixColumn(m,0).length(),scaleY=1/_v1$5.setFromMatrixColumn(m,1).length();m=1/_v1$5.setFromMatrixColumn(m,2).length();te[0]=me[0]*scaleX;te[1]=me[1]*scaleX;te[2]=me[2]*scaleX;te[3]=0;te[4]=me[4]*scaleY;
te[5]=me[5]*scaleY;te[6]=me[6]*scaleY;te[7]=0;te[8]=me[8]*m;te[9]=me[9]*m;te[10]=me[10]*m;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this}makeRotationFromEuler(euler){const te=this.elements;var x=euler.x,y=euler.y,z=euler.z;const a=Math.cos(x);x=Math.sin(x);const c=Math.cos(y);y=Math.sin(y);const e=Math.cos(z);z=Math.sin(z);if("XYZ"===euler.order){euler=a*e;var af=a*z,be=x*e,bf=x*z;te[0]=c*e;te[4]=-c*z;te[8]=y;te[1]=af+be*y;te[5]=euler-bf*y;te[9]=-x*c;te[2]=bf-euler*y;te[6]=be+af*y;te[10]=
a*c}else"YXZ"===euler.order?(euler=c*e,af=c*z,be=y*e,bf=y*z,te[0]=euler+bf*x,te[4]=be*x-af,te[8]=a*y,te[1]=a*z,te[5]=a*e,te[9]=-x,te[2]=af*x-be,te[6]=bf+euler*x,te[10]=a*c):"ZXY"===euler.order?(euler=c*e,af=c*z,be=y*e,bf=y*z,te[0]=euler-bf*x,te[4]=-a*z,te[8]=be+af*x,te[1]=af+be*x,te[5]=a*e,te[9]=bf-euler*x,te[2]=-a*y,te[6]=x,te[10]=a*c):"ZYX"===euler.order?(euler=a*e,af=a*z,be=x*e,bf=x*z,te[0]=c*e,te[4]=be*y-af,te[8]=euler*y+bf,te[1]=c*z,te[5]=bf*y+euler,te[9]=af*y-be,te[2]=-y,te[6]=x*c,te[10]=a*
c):"YZX"===euler.order?(euler=a*c,af=a*y,be=x*c,bf=x*y,te[0]=c*e,te[4]=bf-euler*z,te[8]=be*z+af,te[1]=z,te[5]=a*e,te[9]=-x*e,te[2]=-y*e,te[6]=af*z+be,te[10]=euler-bf*z):"XZY"===euler.order&&(euler=a*c,af=a*y,be=x*c,bf=x*y,te[0]=c*e,te[4]=-z,te[8]=y*e,te[1]=euler*z+bf,te[5]=a*e,te[9]=af*z-be,te[2]=be*z-af,te[6]=x*e,te[10]=bf*z+euler);te[3]=0;te[7]=0;te[11]=0;te[12]=0;te[13]=0;te[14]=0;te[15]=1;return this}makeRotationFromQuaternion(q){return this.compose(_zero,q,_one)}lookAt(eye,target,up){const te=
this.elements;_z.subVectors(eye,target);0===_z.lengthSq()&&(_z.z=1);_z.normalize();_x.crossVectors(up,_z);0===_x.lengthSq()&&(1===Math.abs(up.z)?_z.x+=1E-4:_z.z+=1E-4,_z.normalize(),_x.crossVectors(up,_z));_x.normalize();_y.crossVectors(_z,_x);te[0]=_x.x;te[4]=_y.x;te[8]=_z.x;te[1]=_x.y;te[5]=_y.y;te[9]=_z.y;te[2]=_x.z;te[6]=_y.z;te[10]=_z.z;return this}multiply(m){return this.multiplyMatrices(this,m)}premultiply(m){return this.multiplyMatrices(m,this)}multiplyMatrices(a,b){var ae=a.elements,be=b.elements;
b=this.elements;a=ae[0];const a12=ae[4],a13=ae[8],a14=ae[12],a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13],a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14],a41=ae[3],a42=ae[7],a43=ae[11];ae=ae[15];const b11=be[0],b12=be[4],b13=be[8],b14=be[12],b21=be[1],b22=be[5],b23=be[9],b24=be[13],b31=be[2],b32=be[6],b33=be[10],b34=be[14],b41=be[3],b42=be[7],b43=be[11];be=be[15];b[0]=a*b11+a12*b21+a13*b31+a14*b41;b[4]=a*b12+a12*b22+a13*b32+a14*b42;b[8]=a*b13+a12*b23+a13*b33+a14*b43;b[12]=a*b14+a12*b24+a13*b34+a14*be;b[1]=
a21*b11+a22*b21+a23*b31+a24*b41;b[5]=a21*b12+a22*b22+a23*b32+a24*b42;b[9]=a21*b13+a22*b23+a23*b33+a24*b43;b[13]=a21*b14+a22*b24+a23*b34+a24*be;b[2]=a31*b11+a32*b21+a33*b31+a34*b41;b[6]=a31*b12+a32*b22+a33*b32+a34*b42;b[10]=a31*b13+a32*b23+a33*b33+a34*b43;b[14]=a31*b14+a32*b24+a33*b34+a34*be;b[3]=a41*b11+a42*b21+a43*b31+ae*b41;b[7]=a41*b12+a42*b22+a43*b32+ae*b42;b[11]=a41*b13+a42*b23+a43*b33+ae*b43;b[15]=a41*b14+a42*b24+a43*b34+ae*be;return this}multiplyScalar(s){const te=this.elements;te[0]*=s;te[4]*=
s;te[8]*=s;te[12]*=s;te[1]*=s;te[5]*=s;te[9]*=s;te[13]*=s;te[2]*=s;te[6]*=s;te[10]*=s;te[14]*=s;te[3]*=s;te[7]*=s;te[11]*=s;te[15]*=s;return this}determinant(){const te=this.elements,n11=te[0],n12=te[4],n13=te[8],n14=te[12],n21=te[1],n22=te[5],n23=te[9],n24=te[13],n31=te[2],n32=te[6],n33=te[10],n34=te[14];return te[3]*(+n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*n22*n34-n12*n23*n34)+te[7]*(+n11*n23*n34-n11*n24*n33+n14*n21*n33-n13*n21*n34+n13*n24*n31-n14*n23*n31)+te[11]*(+n11*n24*n32-n11*
n22*n34-n14*n21*n32+n12*n21*n34+n14*n22*n31-n12*n24*n31)+te[15]*(-n13*n22*n31-n11*n23*n32+n11*n22*n33+n13*n21*n32-n12*n21*n33+n12*n23*n31)}transpose(){const te=this.elements;let tmp;tmp=te[1];te[1]=te[4];te[4]=tmp;tmp=te[2];te[2]=te[8];te[8]=tmp;tmp=te[6];te[6]=te[9];te[9]=tmp;tmp=te[3];te[3]=te[12];te[12]=tmp;tmp=te[7];te[7]=te[13];te[13]=tmp;tmp=te[11];te[11]=te[14];te[14]=tmp;return this}setPosition(x,y,z){const te=this.elements;x.isVector3?(te[12]=x.x,te[13]=x.y,te[14]=x.z):(te[12]=x,te[13]=y,
te[14]=z);return this}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t11=n23*n34*n42-n24*n33*n42+n24*n32*n43-n22*n34*n43-n23*n32*n44+n22*n33*n44,t12=n14*n33*n42-n13*n34*n42-n14*n32*n43+n12*n34*n43+n13*n32*n44-n12*n33*n44,t13=n13*n24*n42-n14*n23*n42+n14*n22*n43-n12*n24*n43-n13*n22*n44+n12*n23*n44,t14=n14*n23*n32-n13*n24*n32-n14*n22*n33+n12*n24*n33+n13*
n22*n34-n12*n23*n34;var det=n11*t11+n21*t12+n31*t13+n41*t14;if(0===det)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);det=1/det;te[0]=t11*det;te[1]=(n24*n33*n41-n23*n34*n41-n24*n31*n43+n21*n34*n43+n23*n31*n44-n21*n33*n44)*det;te[2]=(n22*n34*n41-n24*n32*n41+n24*n31*n42-n21*n34*n42-n22*n31*n44+n21*n32*n44)*det;te[3]=(n23*n32*n41-n22*n33*n41-n23*n31*n42+n21*n33*n42+n22*n31*n43-n21*n32*n43)*det;te[4]=t12*det;te[5]=(n13*n34*n41-n14*n33*n41+n14*n31*n43-n11*n34*n43-n13*n31*n44+n11*n33*n44)*det;te[6]=(n14*
n32*n41-n12*n34*n41-n14*n31*n42+n11*n34*n42+n12*n31*n44-n11*n32*n44)*det;te[7]=(n12*n33*n41-n13*n32*n41+n13*n31*n42-n11*n33*n42-n12*n31*n43+n11*n32*n43)*det;te[8]=t13*det;te[9]=(n14*n23*n41-n13*n24*n41-n14*n21*n43+n11*n24*n43+n13*n21*n44-n11*n23*n44)*det;te[10]=(n12*n24*n41-n14*n22*n41+n14*n21*n42-n11*n24*n42-n12*n21*n44+n11*n22*n44)*det;te[11]=(n13*n22*n41-n12*n23*n41-n13*n21*n42+n11*n23*n42+n12*n21*n43-n11*n22*n43)*det;te[12]=t14*det;te[13]=(n13*n24*n31-n14*n23*n31+n14*n21*n33-n11*n24*n33-n13*n21*
n34+n11*n23*n34)*det;te[14]=(n14*n22*n31-n12*n24*n31-n14*n21*n32+n11*n24*n32+n12*n21*n34-n11*n22*n34)*det;te[15]=(n12*n23*n31-n13*n22*n31+n13*n21*n32-n11*n23*n32-n12*n21*n33+n11*n22*n33)*det;return this}scale(v){const te=this.elements,x=v.x,y=v.y;v=v.z;te[0]*=x;te[4]*=y;te[8]*=v;te[1]*=x;te[5]*=y;te[9]*=v;te[2]*=x;te[6]*=y;te[10]*=v;te[3]*=x;te[7]*=y;te[11]*=v;return this}getMaxScaleOnAxis(){const te=this.elements;return Math.sqrt(Math.max(te[0]*te[0]+te[1]*te[1]+te[2]*te[2],te[4]*te[4]+te[5]*te[5]+
te[6]*te[6],te[8]*te[8]+te[9]*te[9]+te[10]*te[10]))}makeTranslation(x,y,z){this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1);return this}makeRotationX(theta){const c=Math.cos(theta);theta=Math.sin(theta);this.set(1,0,0,0,0,c,-theta,0,0,theta,c,0,0,0,0,1);return this}makeRotationY(theta){const c=Math.cos(theta);theta=Math.sin(theta);this.set(c,0,theta,0,0,1,0,0,-theta,0,c,0,0,0,0,1);return this}makeRotationZ(theta){const c=Math.cos(theta);theta=Math.sin(theta);this.set(c,-theta,0,0,theta,c,0,0,0,0,1,0,0,0,
0,1);return this}makeRotationAxis(axis,angle){const c=Math.cos(angle);angle=Math.sin(angle);const t=1-c,x=axis.x,y=axis.y;axis=axis.z;const tx=t*x,ty=t*y;this.set(tx*x+c,tx*y-angle*axis,tx*axis+angle*y,0,tx*y+angle*axis,ty*y+c,ty*axis-angle*x,0,tx*axis-angle*y,ty*axis+angle*x,t*axis*axis+c,0,0,0,0,1);return this}makeScale(x,y,z){this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1);return this}makeShear(xy,xz,yx,yz,zx,zy){this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1);return this}compose(position,quaternion,
scale){const te=this.elements;var x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w,x2=x+x,y2=y+y,z2=z+z;quaternion=x*x2;const xy=x*y2;x*=z2;const yy=y*y2;y*=z2;z*=z2;x2*=w;y2*=w;w*=z2;z2=scale.x;const sy=scale.y;scale=scale.z;te[0]=(1-(yy+z))*z2;te[1]=(xy+w)*z2;te[2]=(x-y2)*z2;te[3]=0;te[4]=(xy-w)*sy;te[5]=(1-(quaternion+z))*sy;te[6]=(y+x2)*sy;te[7]=0;te[8]=(x+y2)*scale;te[9]=(y-x2)*scale;te[10]=(1-(quaternion+yy))*scale;te[11]=0;te[12]=position.x;te[13]=position.y;te[14]=position.z;
te[15]=1;return this}decompose(position,quaternion,scale){var te=this.elements;let sx=_v1$5.set(te[0],te[1],te[2]).length();const sy=_v1$5.set(te[4],te[5],te[6]).length(),sz=_v1$5.set(te[8],te[9],te[10]).length();0>this.determinant()&&(sx=-sx);position.x=te[12];position.y=te[13];position.z=te[14];_m1$2.copy(this);position=1/sx;te=1/sy;const invSZ=1/sz;_m1$2.elements[0]*=position;_m1$2.elements[1]*=position;_m1$2.elements[2]*=position;_m1$2.elements[4]*=te;_m1$2.elements[5]*=te;_m1$2.elements[6]*=
te;_m1$2.elements[8]*=invSZ;_m1$2.elements[9]*=invSZ;_m1$2.elements[10]*=invSZ;quaternion.setFromRotationMatrix(_m1$2);scale.x=sx;scale.y=sy;scale.z=sz;return this}makePerspective(left,right,top,bottom,near,far){const te=this.elements;te[0]=2*near/(right-left);te[4]=0;te[8]=(right+left)/(right-left);te[12]=0;te[1]=0;te[5]=2*near/(top-bottom);te[9]=(top+bottom)/(top-bottom);te[13]=0;te[2]=0;te[6]=0;te[10]=-(far+near)/(far-near);te[14]=-2*far*near/(far-near);te[3]=0;te[7]=0;te[11]=-1;te[15]=0;return this}makeOrthographic(left,
right,top,bottom,near,far){const te=this.elements,w=1/(right-left),h=1/(top-bottom),p=1/(far-near);te[0]=2*w;te[4]=0;te[8]=0;te[12]=-((right+left)*w);te[1]=0;te[5]=2*h;te[9]=0;te[13]=-((top+bottom)*h);te[2]=0;te[6]=0;te[10]=-2*p;te[14]=-((far+near)*p);te[3]=0;te[7]=0;te[11]=0;te[15]=1;return this}equals(matrix){const te=this.elements;matrix=matrix.elements;for(let i=0;16>i;i++)if(te[i]!==matrix[i])return!1;return!0}fromArray(array,offset=0){for(let i=0;16>i;i++)this.elements[i]=array[i+offset];return this}toArray(array=
[],offset=0){const te=this.elements;array[offset]=te[0];array[offset+1]=te[1];array[offset+2]=te[2];array[offset+3]=te[3];array[offset+4]=te[4];array[offset+5]=te[5];array[offset+6]=te[6];array[offset+7]=te[7];array[offset+8]=te[8];array[offset+9]=te[9];array[offset+10]=te[10];array[offset+11]=te[11];array[offset+12]=te[12];array[offset+13]=te[13];array[offset+14]=te[14];array[offset+15]=te[15];return array}}const _v1$5=new Vector3,_m1$2=new Matrix4,_zero=new Vector3(0,0,0),_one=new Vector3(1,1,1),
_x=new Vector3,_y=new Vector3,_z=new Vector3,_matrix$1=new Matrix4,_quaternion$3=new Quaternion;class Euler{constructor(x=0,y=0,z=0,order=Euler.DefaultOrder){this.isEuler=!0;this._x=x;this._y=y;this._z=z;this._order=order}get x(){return this._x}set x(value){this._x=value;this._onChangeCallback()}get y(){return this._y}set y(value){this._y=value;this._onChangeCallback()}get z(){return this._z}set z(value){this._z=value;this._onChangeCallback()}get order(){return this._order}set order(value){this._order=
value;this._onChangeCallback()}set(x,y,z,order=this._order){this._x=x;this._y=y;this._z=z;this._order=order;this._onChangeCallback();return this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(euler){this._x=euler._x;this._y=euler._y;this._z=euler._z;this._order=euler._order;this._onChangeCallback();return this}setFromRotationMatrix(m,order=this._order,update=!0){var te=m.elements;m=te[0];const m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6];te=
te[10];switch(order){case "XYZ":this._y=Math.asin(clamp(m13,-1,1));.9999999>Math.abs(m13)?(this._x=Math.atan2(-m23,te),this._z=Math.atan2(-m12,m)):(this._x=Math.atan2(m32,m22),this._z=0);break;case "YXZ":this._x=Math.asin(-clamp(m23,-1,1));.9999999>Math.abs(m23)?(this._y=Math.atan2(m13,te),this._z=Math.atan2(m21,m22)):(this._y=Math.atan2(-m31,m),this._z=0);break;case "ZXY":this._x=Math.asin(clamp(m32,-1,1));.9999999>Math.abs(m32)?(this._y=Math.atan2(-m31,te),this._z=Math.atan2(-m12,m22)):(this._y=
0,this._z=Math.atan2(m21,m));break;case "ZYX":this._y=Math.asin(-clamp(m31,-1,1));.9999999>Math.abs(m31)?(this._x=Math.atan2(m32,te),this._z=Math.atan2(m21,m)):(this._x=0,this._z=Math.atan2(-m12,m22));break;case "YZX":this._z=Math.asin(clamp(m21,-1,1));.9999999>Math.abs(m21)?(this._x=Math.atan2(-m23,m22),this._y=Math.atan2(-m31,m)):(this._x=0,this._y=Math.atan2(m13,te));break;case "XZY":this._z=Math.asin(-clamp(m12,-1,1));.9999999>Math.abs(m12)?(this._x=Math.atan2(m32,m22),this._y=Math.atan2(m13,
m)):(this._x=Math.atan2(-m23,te),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+order)}this._order=order;!0===update&&this._onChangeCallback();return this}setFromQuaternion(q,order,update){_matrix$1.makeRotationFromQuaternion(q);return this.setFromRotationMatrix(_matrix$1,order,update)}setFromVector3(v,order=this._order){return this.set(v.x,v.y,v.z,order)}reorder(newOrder){_quaternion$3.setFromEuler(this);return this.setFromQuaternion(_quaternion$3,
newOrder)}equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order}fromArray(array){this._x=array[0];this._y=array[1];this._z=array[2];void 0!==array[3]&&(this._order=array[3]);this._onChangeCallback();return this}toArray(array=[],offset=0){array[offset]=this._x;array[offset+1]=this._y;array[offset+2]=this._z;array[offset+3]=this._order;return array}_onChange(callback){this._onChangeCallback=callback;return this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x;
yield this._y;yield this._z;yield this._order}toVector3(){console.error("THREE.Euler: .toVector3() has been removed. Use Vector3.setFromEuler() instead")}}Euler.DefaultOrder="XYZ";Euler.RotationOrders="XYZ YZX ZXY XZY YXZ ZYX".split(" ");class Layers{constructor(){this.mask=1}set(channel){this.mask=(1<<channel|0)>>>0}enable(channel){this.mask=this.mask|1<<channel|0}enableAll(){this.mask=-1}toggle(channel){this.mask^=1<<channel|0}disable(channel){this.mask&=~(1<<channel|0)}disableAll(){this.mask=0}test(layers){return 0!==
(this.mask&layers.mask)}isEnabled(channel){return 0!==(this.mask&(1<<channel|0))}}let _object3DId=0;const _v1$4=new Vector3,_q1=new Quaternion,_m1$1=new Matrix4,_target=new Vector3,_position$3=new Vector3,_scale$2=new Vector3,_quaternion$2=new Quaternion,_xAxis=new Vector3(1,0,0),_yAxis=new Vector3(0,1,0),_zAxis=new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"};class Object3D extends EventDispatcher{constructor(){super();this.isObject3D=!0;Object.defineProperty(this,"id",
{value:_object3DId++});this.uuid=generateUUID();this.name="";this.type="Object3D";this.parent=null;this.children=[];this.up=Object3D.DefaultUp.clone();const position=new Vector3,rotation=new Euler,quaternion=new Quaternion,scale=new Vector3(1,1,1);rotation._onChange(function(){quaternion.setFromEuler(rotation,!1)});quaternion._onChange(function(){rotation.setFromQuaternion(quaternion,void 0,!1)});Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:position},rotation:{configurable:!0,
enumerable:!0,value:rotation},quaternion:{configurable:!0,enumerable:!0,value:quaternion},scale:{configurable:!0,enumerable:!0,value:scale},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}});this.matrix=new Matrix4;this.matrixWorld=new Matrix4;this.matrixAutoUpdate=Object3D.DefaultMatrixAutoUpdate;this.matrixWorldNeedsUpdate=!1;this.matrixWorldAutoUpdate=Object3D.DefaultMatrixWorldAutoUpdate;this.layers=new Layers;this.visible=!0;this.receiveShadow=this.castShadow=!1;this.frustumCulled=
!0;this.renderOrder=0;this.animations=[];this.userData={}}onBeforeRender(){}onAfterRender(){}applyMatrix4(matrix){this.matrixAutoUpdate&&this.updateMatrix();this.matrix.premultiply(matrix);this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(q){this.quaternion.premultiply(q);return this}setRotationFromAxisAngle(axis,angle){this.quaternion.setFromAxisAngle(axis,angle)}setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,!0)}setRotationFromMatrix(m){this.quaternion.setFromRotationMatrix(m)}setRotationFromQuaternion(q){this.quaternion.copy(q)}rotateOnAxis(axis,
angle){_q1.setFromAxisAngle(axis,angle);this.quaternion.multiply(_q1);return this}rotateOnWorldAxis(axis,angle){_q1.setFromAxisAngle(axis,angle);this.quaternion.premultiply(_q1);return this}rotateX(angle){return this.rotateOnAxis(_xAxis,angle)}rotateY(angle){return this.rotateOnAxis(_yAxis,angle)}rotateZ(angle){return this.rotateOnAxis(_zAxis,angle)}translateOnAxis(axis,distance){_v1$4.copy(axis).applyQuaternion(this.quaternion);this.position.add(_v1$4.multiplyScalar(distance));return this}translateX(distance){return this.translateOnAxis(_xAxis,
distance)}translateY(distance){return this.translateOnAxis(_yAxis,distance)}translateZ(distance){return this.translateOnAxis(_zAxis,distance)}localToWorld(vector){return vector.applyMatrix4(this.matrixWorld)}worldToLocal(vector){return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert())}lookAt(x,y,z){x.isVector3?_target.copy(x):_target.set(x,y,z);x=this.parent;this.updateWorldMatrix(!0,!1);_position$3.setFromMatrixPosition(this.matrixWorld);this.isCamera||this.isLight?_m1$1.lookAt(_position$3,
_target,this.up):_m1$1.lookAt(_target,_position$3,this.up);this.quaternion.setFromRotationMatrix(_m1$1);x&&(_m1$1.extractRotation(x.matrixWorld),_q1.setFromRotationMatrix(_m1$1),this.quaternion.premultiply(_q1.invert()))}add(object){if(1<arguments.length){for(let i=0;i<arguments.length;i++)this.add(arguments[i]);return this}if(object===this)return console.error("THREE.Object3D.add: object can't be added as a child of itself.",object),this;object&&object.isObject3D?(null!==object.parent&&object.parent.remove(object),
object.parent=this,this.children.push(object),object.dispatchEvent(_addedEvent)):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",object);return this}remove(object){if(1<arguments.length){for(var i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}i=this.children.indexOf(object);-1!==i&&(object.parent=null,this.children.splice(i,1),object.dispatchEvent(_removedEvent));return this}removeFromParent(){const parent=this.parent;null!==parent&&parent.remove(this);
return this}clear(){for(let i=0;i<this.children.length;i++){const object=this.children[i];object.parent=null;object.dispatchEvent(_removedEvent)}this.children.length=0;return this}attach(object){this.updateWorldMatrix(!0,!1);_m1$1.copy(this.matrixWorld).invert();null!==object.parent&&(object.parent.updateWorldMatrix(!0,!1),_m1$1.multiply(object.parent.matrixWorld));object.applyMatrix4(_m1$1);this.add(object);object.updateWorldMatrix(!1,!0);return this}getObjectById(id){return this.getObjectByProperty("id",
id)}getObjectByName(name){return this.getObjectByProperty("name",name)}getObjectByProperty(name,value){if(this[name]===value)return this;for(let i=0,l=this.children.length;i<l;i++){const object=this.children[i].getObjectByProperty(name,value);if(void 0!==object)return object}}getWorldPosition(target){this.updateWorldMatrix(!0,!1);return target.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(target){this.updateWorldMatrix(!0,!1);this.matrixWorld.decompose(_position$3,target,_scale$2);return target}getWorldScale(target){this.updateWorldMatrix(!0,
!1);this.matrixWorld.decompose(_position$3,_quaternion$2,target);return target}getWorldDirection(target){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(callback){callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++)children[i].traverse(callback)}traverseVisible(callback){if(!1!==this.visible){callback(this);var children=this.children;for(let i=0,l=children.length;i<l;i++)children[i].traverseVisible(callback)}}traverseAncestors(callback){const parent=
this.parent;null!==parent&&(callback(parent),parent.traverseAncestors(callback))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(force){this.matrixAutoUpdate&&this.updateMatrix();if(this.matrixWorldNeedsUpdate||force)null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,force=!0;const children=this.children;for(let i=0,
l=children.length;i<l;i++){const child=children[i];!0!==child.matrixWorldAutoUpdate&&!0!==force||child.updateMatrixWorld(force)}}updateWorldMatrix(updateParents,updateChildren){const parent=this.parent;!0===updateParents&&null!==parent&&!0===parent.matrixWorldAutoUpdate&&parent.updateWorldMatrix(!0,!1);this.matrixAutoUpdate&&this.updateMatrix();null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix);if(!0===updateChildren){updateParents=
this.children;for(let i=0,l=updateParents.length;i<l;i++)updateChildren=updateParents[i],!0===updateChildren.matrixWorldAutoUpdate&&updateChildren.updateWorldMatrix(!1,!0)}}toJSON(meta){function serialize(library,element){void 0===library[element.uuid]&&(library[element.uuid]=element.toJSON(meta));return element.uuid}function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data)}return values}var isRootObject=void 0===meta||"string"===
typeof meta;const output={};isRootObject&&(meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},output.metadata={version:4.5,type:"Object",generator:"Object3D.toJSON"});const object={};object.uuid=this.uuid;object.type=this.type;""!==this.name&&(object.name=this.name);!0===this.castShadow&&(object.castShadow=!0);!0===this.receiveShadow&&(object.receiveShadow=!0);!1===this.visible&&(object.visible=!1);!1===this.frustumCulled&&(object.frustumCulled=!1);
0!==this.renderOrder&&(object.renderOrder=this.renderOrder);"{}"!==JSON.stringify(this.userData)&&(object.userData=this.userData);object.layers=this.layers.mask;object.matrix=this.matrix.toArray();!1===this.matrixAutoUpdate&&(object.matrixAutoUpdate=!1);this.isInstancedMesh&&(object.type="InstancedMesh",object.count=this.count,object.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(object.instanceColor=this.instanceColor.toJSON()));if(this.isScene)this.background&&(this.background.isColor?
object.background=this.background.toJSON():this.background.isTexture&&(object.background=this.background.toJSON(meta).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(object.environment=this.environment.toJSON(meta).uuid);else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);var parameters=this.geometry.parameters;if(void 0!==parameters&&void 0!==parameters.shapes)if(parameters=parameters.shapes,
Array.isArray(parameters))for(let i=0,l=parameters.length;i<l;i++)serialize(meta.shapes,parameters[i]);else serialize(meta.shapes,parameters)}this.isSkinnedMesh&&(object.bindMode=this.bindMode,object.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(serialize(meta.skeletons,this.skeleton),object.skeleton=this.skeleton.uuid));if(void 0!==this.material)if(Array.isArray(this.material)){parameters=[];for(let i=0,l=this.material.length;i<l;i++)parameters.push(serialize(meta.materials,this.material[i]));
object.material=parameters}else object.material=serialize(meta.materials,this.material);if(0<this.children.length)for(object.children=[],parameters=0;parameters<this.children.length;parameters++)object.children.push(this.children[parameters].toJSON(meta).object);if(0<this.animations.length)for(object.animations=[],parameters=0;parameters<this.animations.length;parameters++)object.animations.push(serialize(meta.animations,this.animations[parameters]));if(isRootObject){isRootObject=extractFromCache(meta.geometries);
parameters=extractFromCache(meta.materials);const textures=extractFromCache(meta.textures),images=extractFromCache(meta.images),shapes=extractFromCache(meta.shapes),skeletons=extractFromCache(meta.skeletons),animations=extractFromCache(meta.animations),nodes=extractFromCache(meta.nodes);0<isRootObject.length&&(output.geometries=isRootObject);0<parameters.length&&(output.materials=parameters);0<textures.length&&(output.textures=textures);0<images.length&&(output.images=images);0<shapes.length&&(output.shapes=
shapes);0<skeletons.length&&(output.skeletons=skeletons);0<animations.length&&(output.animations=animations);0<nodes.length&&(output.nodes=nodes)}output.object=object;return output}clone(recursive){return(new this.constructor).copy(this,recursive)}copy(source,recursive=!0){this.name=source.name;this.up.copy(source.up);this.position.copy(source.position);this.rotation.order=source.rotation.order;this.quaternion.copy(source.quaternion);this.scale.copy(source.scale);this.matrix.copy(source.matrix);this.matrixWorld.copy(source.matrixWorld);
this.matrixAutoUpdate=source.matrixAutoUpdate;this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate;this.matrixWorldAutoUpdate=source.matrixWorldAutoUpdate;this.layers.mask=source.layers.mask;this.visible=source.visible;this.castShadow=source.castShadow;this.receiveShadow=source.receiveShadow;this.frustumCulled=source.frustumCulled;this.renderOrder=source.renderOrder;this.userData=JSON.parse(JSON.stringify(source.userData));if(!0===recursive)for(recursive=0;recursive<source.children.length;recursive++)this.add(source.children[recursive].clone());
return this}}Object3D.DefaultUp=new Vector3(0,1,0);Object3D.DefaultMatrixAutoUpdate=!0;Object3D.DefaultMatrixWorldAutoUpdate=!0;const _v0$1=new Vector3,_v1$3=new Vector3,_v2$2=new Vector3,_v3$1=new Vector3,_vab=new Vector3,_vac=new Vector3,_vbc=new Vector3,_vap=new Vector3,_vbp=new Vector3,_vcp=new Vector3;class Triangle{constructor(a=new Vector3,b=new Vector3,c=new Vector3){this.a=a;this.b=b;this.c=c}static getNormal(a,b,c,target){target.subVectors(c,b);_v0$1.subVectors(a,b);target.cross(_v0$1);
a=target.lengthSq();return 0<a?target.multiplyScalar(1/Math.sqrt(a)):target.set(0,0,0)}static getBarycoord(point,a,b,c,target){_v0$1.subVectors(c,a);_v1$3.subVectors(b,a);_v2$2.subVectors(point,a);point=_v0$1.dot(_v0$1);a=_v0$1.dot(_v1$3);b=_v0$1.dot(_v2$2);var dot11=_v1$3.dot(_v1$3);c=_v1$3.dot(_v2$2);var denom=point*dot11-a*a;if(0===denom)return target.set(-2,-1,-1);denom=1/denom;dot11=(dot11*b-a*c)*denom;point=(point*c-a*b)*denom;return target.set(1-dot11-point,point,dot11)}static containsPoint(point,
a,b,c){this.getBarycoord(point,a,b,c,_v3$1);return 0<=_v3$1.x&&0<=_v3$1.y&&1>=_v3$1.x+_v3$1.y}static getUV(point,p1,p2,p3,uv1,uv2,uv3,target){this.getBarycoord(point,p1,p2,p3,_v3$1);target.set(0,0);target.addScaledVector(uv1,_v3$1.x);target.addScaledVector(uv2,_v3$1.y);target.addScaledVector(uv3,_v3$1.z);return target}static isFrontFacing(a,b,c,direction){_v0$1.subVectors(c,b);_v1$3.subVectors(a,b);return 0>_v0$1.cross(_v1$3).dot(direction)?!0:!1}set(a,b,c){this.a.copy(a);this.b.copy(b);this.c.copy(c);
return this}setFromPointsAndIndices(points,i0,i1,i2){this.a.copy(points[i0]);this.b.copy(points[i1]);this.c.copy(points[i2]);return this}setFromAttributeAndIndices(attribute,i0,i1,i2){this.a.fromBufferAttribute(attribute,i0);this.b.fromBufferAttribute(attribute,i1);this.c.fromBufferAttribute(attribute,i2);return this}clone(){return(new this.constructor).copy(this)}copy(triangle){this.a.copy(triangle.a);this.b.copy(triangle.b);this.c.copy(triangle.c);return this}getArea(){_v0$1.subVectors(this.c,this.b);
_v1$3.subVectors(this.a,this.b);return.5*_v0$1.cross(_v1$3).length()}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target)}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target)}getUV(point,uv1,uv2,uv3,target){return Triangle.getUV(point,this.a,this.b,this.c,uv1,uv2,uv3,target)}containsPoint(point){return Triangle.containsPoint(point,
this.a,this.b,this.c)}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction)}intersectsBox(box){return box.intersectsTriangle(this)}closestPointToPoint(p,target){const a=this.a;var b=this.b,c=this.c;_vab.subVectors(b,a);_vac.subVectors(c,a);_vap.subVectors(p,a);var d1=_vab.dot(_vap),d2=_vac.dot(_vap);if(0>=d1&&0>=d2)return target.copy(a);_vbp.subVectors(p,b);const d3=_vab.dot(_vbp),d4=_vac.dot(_vbp);if(0<=d3&&d4<=d3)return target.copy(b);var w=d1*d4-d3*d2;if(0>=w&&
0<=d1&&0>=d3)return b=d1/(d1-d3),target.copy(a).addScaledVector(_vab,b);_vcp.subVectors(p,c);p=_vab.dot(_vcp);const d6=_vac.dot(_vcp);if(0<=d6&&p<=d6)return target.copy(c);d1=p*d2-d1*d6;if(0>=d1&&0<=d2&&0>=d6)return w=d2/(d2-d6),target.copy(a).addScaledVector(_vac,w);d2=d3*d6-p*d4;if(0>=d2&&0<=d4-d3&&0<=p-d6)return _vbc.subVectors(c,b),w=(d4-d3)/(d4-d3+(p-d6)),target.copy(b).addScaledVector(_vbc,w);c=1/(d2+d1+w);b=d1*c;w*=c;return target.copy(a).addScaledVector(_vab,b).addScaledVector(_vac,w)}equals(triangle){return triangle.a.equals(this.a)&&
triangle.b.equals(this.b)&&triangle.c.equals(this.c)}}let materialId=0;class Material extends EventDispatcher{constructor(){super();this.isMaterial=!0;Object.defineProperty(this,"id",{value:materialId++});this.uuid=generateUUID();this.name="";this.type="Material";this.blending=1;this.side=0;this.vertexColors=!1;this.opacity=1;this.transparent=!1;this.blendSrc=204;this.blendDst=205;this.blendEquation=100;this.blendEquationAlpha=this.blendDstAlpha=this.blendSrcAlpha=null;this.depthFunc=3;this.depthWrite=
this.depthTest=!0;this.stencilWriteMask=255;this.stencilFunc=519;this.stencilRef=0;this.stencilFuncMask=255;this.stencilZPass=this.stencilZFail=this.stencilFail=7680;this.stencilWrite=!1;this.clippingPlanes=null;this.clipShadows=this.clipIntersection=!1;this.shadowSide=null;this.colorWrite=!0;this.precision=null;this.polygonOffset=!1;this.polygonOffsetUnits=this.polygonOffsetFactor=0;this.premultipliedAlpha=this.alphaToCoverage=this.dithering=!1;this.toneMapped=this.visible=!0;this.userData={};this._alphaTest=
this.version=0}get alphaTest(){return this._alphaTest}set alphaTest(value){0<this._alphaTest!==0<value&&this.version++;this._alphaTest=value}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(values){if(void 0!==values)for(const key in values){const newValue=values[key];if(void 0===newValue){console.warn("THREE.Material: '"+key+"' parameter is undefined.");continue}const currentValue=this[key];void 0===currentValue?console.warn("THREE."+
this.type+": '"+key+"' is not a property of this material."):currentValue&&currentValue.isColor?currentValue.set(newValue):currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3?currentValue.copy(newValue):this[key]=newValue}}toJSON(meta){function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata;values.push(data)}return values}var isRootObject=void 0===meta||"string"===typeof meta;isRootObject&&(meta={textures:{},images:{}});const data$jscomp$0=
{metadata:{version:4.5,type:"Material",generator:"Material.toJSON"}};data$jscomp$0.uuid=this.uuid;data$jscomp$0.type=this.type;""!==this.name&&(data$jscomp$0.name=this.name);this.color&&this.color.isColor&&(data$jscomp$0.color=this.color.getHex());void 0!==this.roughness&&(data$jscomp$0.roughness=this.roughness);void 0!==this.metalness&&(data$jscomp$0.metalness=this.metalness);void 0!==this.sheen&&(data$jscomp$0.sheen=this.sheen);this.sheenColor&&this.sheenColor.isColor&&(data$jscomp$0.sheenColor=
this.sheenColor.getHex());void 0!==this.sheenRoughness&&(data$jscomp$0.sheenRoughness=this.sheenRoughness);this.emissive&&this.emissive.isColor&&(data$jscomp$0.emissive=this.emissive.getHex());this.emissiveIntensity&&1!==this.emissiveIntensity&&(data$jscomp$0.emissiveIntensity=this.emissiveIntensity);this.specular&&this.specular.isColor&&(data$jscomp$0.specular=this.specular.getHex());void 0!==this.specularIntensity&&(data$jscomp$0.specularIntensity=this.specularIntensity);this.specularColor&&this.specularColor.isColor&&
(data$jscomp$0.specularColor=this.specularColor.getHex());void 0!==this.shininess&&(data$jscomp$0.shininess=this.shininess);void 0!==this.clearcoat&&(data$jscomp$0.clearcoat=this.clearcoat);void 0!==this.clearcoatRoughness&&(data$jscomp$0.clearcoatRoughness=this.clearcoatRoughness);this.clearcoatMap&&this.clearcoatMap.isTexture&&(data$jscomp$0.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid);this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(data$jscomp$0.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid);
this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(data$jscomp$0.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid,data$jscomp$0.clearcoatNormalScale=this.clearcoatNormalScale.toArray());void 0!==this.iridescence&&(data$jscomp$0.iridescence=this.iridescence);void 0!==this.iridescenceIOR&&(data$jscomp$0.iridescenceIOR=this.iridescenceIOR);void 0!==this.iridescenceThicknessRange&&(data$jscomp$0.iridescenceThicknessRange=this.iridescenceThicknessRange);this.iridescenceMap&&this.iridescenceMap.isTexture&&
(data$jscomp$0.iridescenceMap=this.iridescenceMap.toJSON(meta).uuid);this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(data$jscomp$0.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(meta).uuid);this.map&&this.map.isTexture&&(data$jscomp$0.map=this.map.toJSON(meta).uuid);this.matcap&&this.matcap.isTexture&&(data$jscomp$0.matcap=this.matcap.toJSON(meta).uuid);this.alphaMap&&this.alphaMap.isTexture&&(data$jscomp$0.alphaMap=this.alphaMap.toJSON(meta).uuid);this.lightMap&&
this.lightMap.isTexture&&(data$jscomp$0.lightMap=this.lightMap.toJSON(meta).uuid,data$jscomp$0.lightMapIntensity=this.lightMapIntensity);this.aoMap&&this.aoMap.isTexture&&(data$jscomp$0.aoMap=this.aoMap.toJSON(meta).uuid,data$jscomp$0.aoMapIntensity=this.aoMapIntensity);this.bumpMap&&this.bumpMap.isTexture&&(data$jscomp$0.bumpMap=this.bumpMap.toJSON(meta).uuid,data$jscomp$0.bumpScale=this.bumpScale);this.normalMap&&this.normalMap.isTexture&&(data$jscomp$0.normalMap=this.normalMap.toJSON(meta).uuid,
data$jscomp$0.normalMapType=this.normalMapType,data$jscomp$0.normalScale=this.normalScale.toArray());this.displacementMap&&this.displacementMap.isTexture&&(data$jscomp$0.displacementMap=this.displacementMap.toJSON(meta).uuid,data$jscomp$0.displacementScale=this.displacementScale,data$jscomp$0.displacementBias=this.displacementBias);this.roughnessMap&&this.roughnessMap.isTexture&&(data$jscomp$0.roughnessMap=this.roughnessMap.toJSON(meta).uuid);this.metalnessMap&&this.metalnessMap.isTexture&&(data$jscomp$0.metalnessMap=
this.metalnessMap.toJSON(meta).uuid);this.emissiveMap&&this.emissiveMap.isTexture&&(data$jscomp$0.emissiveMap=this.emissiveMap.toJSON(meta).uuid);this.specularMap&&this.specularMap.isTexture&&(data$jscomp$0.specularMap=this.specularMap.toJSON(meta).uuid);this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(data$jscomp$0.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid);this.specularColorMap&&this.specularColorMap.isTexture&&(data$jscomp$0.specularColorMap=this.specularColorMap.toJSON(meta).uuid);
this.envMap&&this.envMap.isTexture&&(data$jscomp$0.envMap=this.envMap.toJSON(meta).uuid,void 0!==this.combine&&(data$jscomp$0.combine=this.combine));void 0!==this.envMapIntensity&&(data$jscomp$0.envMapIntensity=this.envMapIntensity);void 0!==this.reflectivity&&(data$jscomp$0.reflectivity=this.reflectivity);void 0!==this.refractionRatio&&(data$jscomp$0.refractionRatio=this.refractionRatio);this.gradientMap&&this.gradientMap.isTexture&&(data$jscomp$0.gradientMap=this.gradientMap.toJSON(meta).uuid);
void 0!==this.transmission&&(data$jscomp$0.transmission=this.transmission);this.transmissionMap&&this.transmissionMap.isTexture&&(data$jscomp$0.transmissionMap=this.transmissionMap.toJSON(meta).uuid);void 0!==this.thickness&&(data$jscomp$0.thickness=this.thickness);this.thicknessMap&&this.thicknessMap.isTexture&&(data$jscomp$0.thicknessMap=this.thicknessMap.toJSON(meta).uuid);void 0!==this.attenuationDistance&&Infinity!==this.attenuationDistance&&(data$jscomp$0.attenuationDistance=this.attenuationDistance);
void 0!==this.attenuationColor&&(data$jscomp$0.attenuationColor=this.attenuationColor.getHex());void 0!==this.size&&(data$jscomp$0.size=this.size);null!==this.shadowSide&&(data$jscomp$0.shadowSide=this.shadowSide);void 0!==this.sizeAttenuation&&(data$jscomp$0.sizeAttenuation=this.sizeAttenuation);1!==this.blending&&(data$jscomp$0.blending=this.blending);0!==this.side&&(data$jscomp$0.side=this.side);this.vertexColors&&(data$jscomp$0.vertexColors=!0);1>this.opacity&&(data$jscomp$0.opacity=this.opacity);
!0===this.transparent&&(data$jscomp$0.transparent=this.transparent);data$jscomp$0.depthFunc=this.depthFunc;data$jscomp$0.depthTest=this.depthTest;data$jscomp$0.depthWrite=this.depthWrite;data$jscomp$0.colorWrite=this.colorWrite;data$jscomp$0.stencilWrite=this.stencilWrite;data$jscomp$0.stencilWriteMask=this.stencilWriteMask;data$jscomp$0.stencilFunc=this.stencilFunc;data$jscomp$0.stencilRef=this.stencilRef;data$jscomp$0.stencilFuncMask=this.stencilFuncMask;data$jscomp$0.stencilFail=this.stencilFail;
data$jscomp$0.stencilZFail=this.stencilZFail;data$jscomp$0.stencilZPass=this.stencilZPass;void 0!==this.rotation&&0!==this.rotation&&(data$jscomp$0.rotation=this.rotation);!0===this.polygonOffset&&(data$jscomp$0.polygonOffset=!0);0!==this.polygonOffsetFactor&&(data$jscomp$0.polygonOffsetFactor=this.polygonOffsetFactor);0!==this.polygonOffsetUnits&&(data$jscomp$0.polygonOffsetUnits=this.polygonOffsetUnits);void 0!==this.linewidth&&1!==this.linewidth&&(data$jscomp$0.linewidth=this.linewidth);void 0!==
this.dashSize&&(data$jscomp$0.dashSize=this.dashSize);void 0!==this.gapSize&&(data$jscomp$0.gapSize=this.gapSize);void 0!==this.scale&&(data$jscomp$0.scale=this.scale);!0===this.dithering&&(data$jscomp$0.dithering=!0);0<this.alphaTest&&(data$jscomp$0.alphaTest=this.alphaTest);!0===this.alphaToCoverage&&(data$jscomp$0.alphaToCoverage=this.alphaToCoverage);!0===this.premultipliedAlpha&&(data$jscomp$0.premultipliedAlpha=this.premultipliedAlpha);!0===this.wireframe&&(data$jscomp$0.wireframe=this.wireframe);
1<this.wireframeLinewidth&&(data$jscomp$0.wireframeLinewidth=this.wireframeLinewidth);"round"!==this.wireframeLinecap&&(data$jscomp$0.wireframeLinecap=this.wireframeLinecap);"round"!==this.wireframeLinejoin&&(data$jscomp$0.wireframeLinejoin=this.wireframeLinejoin);!0===this.flatShading&&(data$jscomp$0.flatShading=this.flatShading);!1===this.visible&&(data$jscomp$0.visible=!1);!1===this.toneMapped&&(data$jscomp$0.toneMapped=!1);!1===this.fog&&(data$jscomp$0.fog=!1);"{}"!==JSON.stringify(this.userData)&&
(data$jscomp$0.userData=this.userData);isRootObject&&(isRootObject=extractFromCache(meta.textures),meta=extractFromCache(meta.images),0<isRootObject.length&&(data$jscomp$0.textures=isRootObject),0<meta.length&&(data$jscomp$0.images=meta));return data$jscomp$0}clone(){return(new this.constructor).copy(this)}copy(source){this.name=source.name;this.blending=source.blending;this.side=source.side;this.vertexColors=source.vertexColors;this.opacity=source.opacity;this.transparent=source.transparent;this.blendSrc=
source.blendSrc;this.blendDst=source.blendDst;this.blendEquation=source.blendEquation;this.blendSrcAlpha=source.blendSrcAlpha;this.blendDstAlpha=source.blendDstAlpha;this.blendEquationAlpha=source.blendEquationAlpha;this.depthFunc=source.depthFunc;this.depthTest=source.depthTest;this.depthWrite=source.depthWrite;this.stencilWriteMask=source.stencilWriteMask;this.stencilFunc=source.stencilFunc;this.stencilRef=source.stencilRef;this.stencilFuncMask=source.stencilFuncMask;this.stencilFail=source.stencilFail;
this.stencilZFail=source.stencilZFail;this.stencilZPass=source.stencilZPass;this.stencilWrite=source.stencilWrite;const srcPlanes=source.clippingPlanes;let dstPlanes=null;if(null!==srcPlanes){const n=srcPlanes.length;dstPlanes=Array(n);for(let i=0;i!==n;++i)dstPlanes[i]=srcPlanes[i].clone()}this.clippingPlanes=dstPlanes;this.clipIntersection=source.clipIntersection;this.clipShadows=source.clipShadows;this.shadowSide=source.shadowSide;this.colorWrite=source.colorWrite;this.precision=source.precision;
this.polygonOffset=source.polygonOffset;this.polygonOffsetFactor=source.polygonOffsetFactor;this.polygonOffsetUnits=source.polygonOffsetUnits;this.dithering=source.dithering;this.alphaTest=source.alphaTest;this.alphaToCoverage=source.alphaToCoverage;this.premultipliedAlpha=source.premultipliedAlpha;this.visible=source.visible;this.toneMapped=source.toneMapped;this.userData=JSON.parse(JSON.stringify(source.userData));return this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(value){!0===
value&&this.version++}}class MeshBasicMaterial extends Material{constructor(parameters){super();this.isMeshBasicMaterial=!0;this.type="MeshBasicMaterial";this.color=new Color(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);
this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;this.fog=source.fog;return this}}const _vector$9=new Vector3,_vector2$1=new Vector2;class BufferAttribute{constructor(array,itemSize,normalized){if(Array.isArray(array))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0;this.name="";this.array=array;this.itemSize=itemSize;this.count=void 0!==array?array.length/itemSize:0;this.normalized=!0===normalized;this.usage=35044;this.updateRange={offset:0,count:-1};
this.version=0}onUploadCallback(){}set needsUpdate(value){!0===value&&this.version++}setUsage(value){this.usage=value;return this}copy(source){this.name=source.name;this.array=new source.array.constructor(source.array);this.itemSize=source.itemSize;this.count=source.count;this.normalized=source.normalized;this.usage=source.usage;return this}copyAt(index1,attribute,index2){index1*=this.itemSize;index2*=attribute.itemSize;for(let i=0,l=this.itemSize;i<l;i++)this.array[index1+i]=attribute.array[index2+
i];return this}copyArray(array){this.array.set(array);return this}applyMatrix3(m){if(2===this.itemSize)for(let i=0,l=this.count;i<l;i++)_vector2$1.fromBufferAttribute(this,i),_vector2$1.applyMatrix3(m),this.setXY(i,_vector2$1.x,_vector2$1.y);else if(3===this.itemSize)for(let i=0,l=this.count;i<l;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.applyMatrix3(m),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyMatrix4(m){for(let i=0,l=this.count;i<l;i++)_vector$9.fromBufferAttribute(this,
i),_vector$9.applyMatrix4(m),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.applyNormalMatrix(m),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}transformDirection(m){for(let i=0,l=this.count;i<l;i++)_vector$9.fromBufferAttribute(this,i),_vector$9.transformDirection(m),this.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z);return this}set(value,offset=0){this.array.set(value,
offset);return this}getX(index){index=this.array[index*this.itemSize];this.normalized&&(index=denormalize(index,this.array));return index}setX(index,x){this.normalized&&(x=normalize(x,this.array));this.array[index*this.itemSize]=x;return this}getY(index){index=this.array[index*this.itemSize+1];this.normalized&&(index=denormalize(index,this.array));return index}setY(index,y){this.normalized&&(y=normalize(y,this.array));this.array[index*this.itemSize+1]=y;return this}getZ(index){index=this.array[index*
this.itemSize+2];this.normalized&&(index=denormalize(index,this.array));return index}setZ(index,z){this.normalized&&(z=normalize(z,this.array));this.array[index*this.itemSize+2]=z;return this}getW(index){index=this.array[index*this.itemSize+3];this.normalized&&(index=denormalize(index,this.array));return index}setW(index,w){this.normalized&&(w=normalize(w,this.array));this.array[index*this.itemSize+3]=w;return this}setXY(index,x,y){index*=this.itemSize;this.normalized&&(x=normalize(x,this.array),
y=normalize(y,this.array));this.array[index+0]=x;this.array[index+1]=y;return this}setXYZ(index,x,y,z){index*=this.itemSize;this.normalized&&(x=normalize(x,this.array),y=normalize(y,this.array),z=normalize(z,this.array));this.array[index+0]=x;this.array[index+1]=y;this.array[index+2]=z;return this}setXYZW(index,x,y,z,w){index*=this.itemSize;this.normalized&&(x=normalize(x,this.array),y=normalize(y,this.array),z=normalize(z,this.array),w=normalize(w,this.array));this.array[index+0]=x;this.array[index+
1]=y;this.array[index+2]=z;this.array[index+3]=w;return this}onUpload(callback){this.onUploadCallback=callback;return this}clone(){return(new this.constructor(this.array,this.itemSize)).copy(this)}toJSON(){const data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};""!==this.name&&(data.name=this.name);35044!==this.usage&&(data.usage=this.usage);if(0!==this.updateRange.offset||-1!==this.updateRange.count)data.updateRange=this.updateRange;
return data}copyColorsArray(){console.error("THREE.BufferAttribute: copyColorsArray() was removed in r144.")}copyVector2sArray(){console.error("THREE.BufferAttribute: copyVector2sArray() was removed in r144.")}copyVector3sArray(){console.error("THREE.BufferAttribute: copyVector3sArray() was removed in r144.")}copyVector4sArray(){console.error("THREE.BufferAttribute: copyVector4sArray() was removed in r144.")}}class Int8BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Int8Array(array),
itemSize,normalized)}}class Uint8BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint8Array(array),itemSize,normalized)}}class Uint8ClampedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint8ClampedArray(array),itemSize,normalized)}}class Int16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Int16Array(array),itemSize,normalized)}}class Uint16BufferAttribute extends BufferAttribute{constructor(array,
itemSize,normalized){super(new Uint16Array(array),itemSize,normalized)}}class Int32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Int32Array(array),itemSize,normalized)}}class Uint32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized)}}class Float16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized);this.isFloat16BufferAttribute=
!0}}class Float32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized)}}class Float64BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float64Array(array),itemSize,normalized)}}let _id$1=0;const _m1=new Matrix4,_obj=new Object3D,_offset=new Vector3,_box$1=new Box3,_boxMorphTargets=new Box3,_vector$8=new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super();this.isBufferGeometry=
!0;Object.defineProperty(this,"id",{value:_id$1++});this.uuid=generateUUID();this.name="";this.type="BufferGeometry";this.index=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=!1;this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity};this.userData={}}getIndex(){return this.index}setIndex(index){Array.isArray(index)?this.index=new (arrayNeedsUint32(index)?Uint32BufferAttribute:Uint16BufferAttribute)(index,1):this.index=index;return this}getAttribute(name){return this.attributes[name]}setAttribute(name,
attribute){this.attributes[name]=attribute;return this}deleteAttribute(name){delete this.attributes[name];return this}hasAttribute(name){return void 0!==this.attributes[name]}addGroup(start,count,materialIndex=0){this.groups.push({start,count,materialIndex})}clearGroups(){this.groups=[]}setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count}applyMatrix4(matrix){var position=this.attributes.position;void 0!==position&&(position.applyMatrix4(matrix),position.needsUpdate=!0);
position=this.attributes.normal;if(void 0!==position){const normalMatrix=(new Matrix3).getNormalMatrix(matrix);position.applyNormalMatrix(normalMatrix);position.needsUpdate=!0}position=this.attributes.tangent;void 0!==position&&(position.transformDirection(matrix),position.needsUpdate=!0);null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this}applyQuaternion(q){_m1.makeRotationFromQuaternion(q);this.applyMatrix4(_m1);return this}rotateX(angle){_m1.makeRotationX(angle);
this.applyMatrix4(_m1);return this}rotateY(angle){_m1.makeRotationY(angle);this.applyMatrix4(_m1);return this}rotateZ(angle){_m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this}translate(x,y,z){_m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this}scale(x,y,z){_m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this}lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this}center(){this.computeBoundingBox();this.boundingBox.getCenter(_offset).negate();
this.translate(_offset.x,_offset.y,_offset.z);return this}setFromPoints(points){const position=[];for(let i=0,l=points.length;i<l;i++){const point=points[i];position.push(point.x,point.y,point.z||0)}this.setAttribute("position",new Float32BufferAttribute(position,3));return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute)console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
this),this.boundingBox.set(new Vector3(-Infinity,-Infinity,-Infinity),new Vector3(Infinity,Infinity,Infinity));else{if(void 0!==position){if(this.boundingBox.setFromBufferAttribute(position),morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++)_box$1.setFromBufferAttribute(morphAttributesPosition[i]),this.morphTargetsRelative?(_vector$8.addVectors(this.boundingBox.min,_box$1.min),this.boundingBox.expandByPoint(_vector$8),_vector$8.addVectors(this.boundingBox.max,_box$1.max),
this.boundingBox.expandByPoint(_vector$8)):(this.boundingBox.expandByPoint(_box$1.min),this.boundingBox.expandByPoint(_box$1.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const position=
this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute)console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new Vector3,Infinity);else if(position){const center=this.boundingSphere.center;_box$1.setFromBufferAttribute(position);if(morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<
il;i++)_boxMorphTargets.setFromBufferAttribute(morphAttributesPosition[i]),this.morphTargetsRelative?(_vector$8.addVectors(_box$1.min,_boxMorphTargets.min),_box$1.expandByPoint(_vector$8),_vector$8.addVectors(_box$1.max,_boxMorphTargets.max),_box$1.expandByPoint(_vector$8)):(_box$1.expandByPoint(_boxMorphTargets.min),_box$1.expandByPoint(_boxMorphTargets.max));_box$1.getCenter(center);let maxRadiusSq=0;for(let i=0,il=position.count;i<il;i++)_vector$8.fromBufferAttribute(position,i),maxRadiusSq=Math.max(maxRadiusSq,
center.distanceToSquared(_vector$8));if(morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i],morphTargetsRelative=this.morphTargetsRelative;for(let j=0,jl=morphAttribute.count;j<jl;j++)_vector$8.fromBufferAttribute(morphAttribute,j),morphTargetsRelative&&(_offset.fromBufferAttribute(position,j),_vector$8.add(_offset)),maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$8))}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);
isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){function handleTriangle(a,b,c){vA.fromArray(positions,3*a);vB.fromArray(positions,3*b);vC.fromArray(positions,3*c);uvA.fromArray(uvs,2*a);uvB.fromArray(uvs,2*b);uvC.fromArray(uvs,2*c);vB.sub(vA);vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);const r=1/(uvB.x*uvC.y-uvC.x*uvB.y);isFinite(r)&&(sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,
-uvB.y).multiplyScalar(r),tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r),tan1[a].add(sdir),tan1[b].add(sdir),tan1[c].add(sdir),tan2[a].add(tdir),tan2[b].add(tdir),tan2[c].add(tdir))}function handleVertex(v){n.fromArray(normals,3*v);n2.copy(n);var t=tan1[v];tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();tmp2.crossVectors(n2,t);t=tmp2.dot(tan2[v]);tangents[4*v]=tmp.x;tangents[4*v+1]=tmp.y;tangents[4*v+2]=tmp.z;tangents[4*v+3]=0>t?-1:1}var index=this.index,
attributes=this.attributes;if(null===index||void 0===attributes.position||void 0===attributes.normal||void 0===attributes.uv)console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");else{index=index.array;var positions=attributes.position.array,normals=attributes.normal.array,uvs=attributes.uv.array;attributes=positions.length/3;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*
attributes),4));var tangents=this.getAttribute("tangent").array,tan1=[],tan2=[];for(var i$jscomp$0=0;i$jscomp$0<attributes;i$jscomp$0++)tan1[i$jscomp$0]=new Vector3,tan2[i$jscomp$0]=new Vector3;var vA=new Vector3,vB=new Vector3,vC=new Vector3,uvA=new Vector2,uvB=new Vector2,uvC=new Vector2,sdir=new Vector3,tdir=new Vector3;attributes=this.groups;0===attributes.length&&(attributes=[{start:0,count:index.length}]);for(let i=0,il=attributes.length;i<il;++i){var group=attributes[i];i$jscomp$0=group.start;
group=group.count;for(let j=i$jscomp$0,jl=i$jscomp$0+group;j<jl;j+=3)handleTriangle(index[j+0],index[j+1],index[j+2])}var tmp=new Vector3,tmp2=new Vector3,n=new Vector3,n2=new Vector3;for(let i=0,il=attributes.length;i<il;++i){group=attributes[i];i$jscomp$0=group.start;group=group.count;for(let j=i$jscomp$0,jl=i$jscomp$0+group;j<jl;j+=3)handleVertex(index[j+0]),handleVertex(index[j+1]),handleVertex(index[j+2])}}}computeVertexNormals(){const index=this.index,positionAttribute=this.getAttribute("position");
if(void 0!==positionAttribute){let normalAttribute=this.getAttribute("normal");if(void 0===normalAttribute)normalAttribute=new BufferAttribute(new Float32Array(3*positionAttribute.count),3),this.setAttribute("normal",normalAttribute);else for(let i=0,il=normalAttribute.count;i<il;i++)normalAttribute.setXYZ(i,0,0,0);const pA=new Vector3,pB=new Vector3,pC=new Vector3,nA=new Vector3,nB=new Vector3,nC=new Vector3,cb=new Vector3,ab=new Vector3;if(index)for(let i=0,il=index.count;i<il;i+=3){const vA=index.getX(i+
0),vB=index.getX(i+1),vC=index.getX(i+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,
nC.x,nC.y,nC.z)}else for(let i=0,il=positionAttribute.count;i<il;i+=3)pA.fromBufferAttribute(positionAttribute,i+0),pB.fromBufferAttribute(positionAttribute,i+1),pC.fromBufferAttribute(positionAttribute,i+2),cb.subVectors(pC,pB),ab.subVectors(pA,pB),cb.cross(ab),normalAttribute.setXYZ(i+0,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i+1,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i+2,cb.x,cb.y,cb.z);this.normalizeNormals();normalAttribute.needsUpdate=!0}}merge(){console.error("THREE.BufferGeometry.merge() has been removed. Use THREE.BufferGeometryUtils.mergeBufferGeometries() instead.");
return this}normalizeNormals(){const normals=this.attributes.normal;for(let i=0,il=normals.count;i<il;i++)_vector$8.fromBufferAttribute(normals,i),_vector$8.normalize(),normals.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z)}toNonIndexed(){function convertBufferAttribute(attribute,indices){const array=attribute.array,itemSize=attribute.itemSize,normalized=attribute.normalized,array2=new array.constructor(indices.length*itemSize);let index,index2=0;for(let i=0,l=indices.length;i<l;i++){index=attribute.isInterleavedBufferAttribute?
indices[i]*attribute.data.stride+attribute.offset:indices[i]*itemSize;for(let j=0;j<itemSize;j++)array2[index2++]=array[index++]}return new BufferAttribute(array2,itemSize,normalized)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const geometry2=new BufferGeometry;var indices$jscomp$0=this.index.array,attributes=this.attributes;for(var name in attributes){var newAttribute=convertBufferAttribute(attributes[name],indices$jscomp$0);
geometry2.setAttribute(name,newAttribute)}attributes=this.morphAttributes;for(var name$jscomp$0 in attributes){name=[];newAttribute=attributes[name$jscomp$0];for(let i=0,il=newAttribute.length;i<il;i++){const newAttribute$jscomp$0=convertBufferAttribute(newAttribute[i],indices$jscomp$0);name.push(newAttribute$jscomp$0)}geometry2.morphAttributes[name$jscomp$0]=name}geometry2.morphTargetsRelative=this.morphTargetsRelative;indices$jscomp$0=this.groups;for(let i=0,l=indices$jscomp$0.length;i<l;i++)name$jscomp$0=
indices$jscomp$0[i],geometry2.addGroup(name$jscomp$0.start,name$jscomp$0.count,name$jscomp$0.materialIndex);return geometry2}toJSON(){const data={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};data.uuid=this.uuid;data.type=this.type;""!==this.name&&(data.name=this.name);0<Object.keys(this.userData).length&&(data.userData=this.userData);if(void 0!==this.parameters){var parameters=this.parameters;for(var key in parameters)void 0!==parameters[key]&&(data[key]=parameters[key]);
return data}data.data={attributes:{}};key=this.index;null!==key&&(data.data.index={type:key.array.constructor.name,array:Array.prototype.slice.call(key.array)});key=this.attributes;for(var key$jscomp$0 in key)data.data.attributes[key$jscomp$0]=key[key$jscomp$0].toJSON(data.data);key$jscomp$0={};key=!1;for(parameters in this.morphAttributes){const attributeArray=this.morphAttributes[parameters],array=[];for(let i=0,il=attributeArray.length;i<il;i++)array.push(attributeArray[i].toJSON(data.data));0<
array.length&&(key$jscomp$0[parameters]=array,key=!0)}key&&(data.data.morphAttributes=key$jscomp$0,data.data.morphTargetsRelative=this.morphTargetsRelative);parameters=this.groups;0<parameters.length&&(data.data.groups=JSON.parse(JSON.stringify(parameters)));parameters=this.boundingSphere;null!==parameters&&(data.data.boundingSphere={center:parameters.center.toArray(),radius:parameters.radius});return data}clone(){return(new this.constructor).copy(this)}copy(source){this.index=null;this.attributes=
{};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;var data={};this.name=source.name;var index=source.index;null!==index&&this.setIndex(index.clone(data));index=source.attributes;for(var name in index)this.setAttribute(name,index[name].clone(data));name=source.morphAttributes;for(var name$jscomp$0 in name){index=[];const morphAttribute=name[name$jscomp$0];for(let i=0,l=morphAttribute.length;i<l;i++)index.push(morphAttribute[i].clone(data));this.morphAttributes[name$jscomp$0]=
index}this.morphTargetsRelative=source.morphTargetsRelative;data=source.groups;for(let i=0,l=data.length;i<l;i++)name$jscomp$0=data[i],this.addGroup(name$jscomp$0.start,name$jscomp$0.count,name$jscomp$0.materialIndex);data=source.boundingBox;null!==data&&(this.boundingBox=data.clone());data=source.boundingSphere;null!==data&&(this.boundingSphere=data.clone());this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;this.userData=source.userData;void 0!==source.parameters&&
(this.parameters=Object.assign({},source.parameters));return this}dispose(){this.dispatchEvent({type:"dispose"})}}const _inverseMatrix$2=new Matrix4,_ray$2=new Ray,_sphere$3=new Sphere,_vA$1=new Vector3,_vB$1=new Vector3,_vC$1=new Vector3,_tempA=new Vector3,_tempB=new Vector3,_tempC=new Vector3,_morphA=new Vector3,_morphB=new Vector3,_morphC=new Vector3,_uvA$1=new Vector2,_uvB$1=new Vector2,_uvC$1=new Vector2,_intersectionPoint=new Vector3,_intersectionPointWorld=new Vector3;class Mesh extends Object3D{constructor(geometry=
new BufferGeometry,material=new MeshBasicMaterial){super();this.isMesh=!0;this.type="Mesh";this.geometry=geometry;this.material=material;this.updateMorphTargets()}copy(source,recursive){super.copy(source,recursive);void 0!==source.morphTargetInfluences&&(this.morphTargetInfluences=source.morphTargetInfluences.slice());void 0!==source.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary));this.material=source.material;this.geometry=source.geometry;return this}updateMorphTargets(){var morphAttributes=
this.geometry.morphAttributes,keys=Object.keys(morphAttributes);if(0<keys.length&&(morphAttributes=morphAttributes[keys[0]],void 0!==morphAttributes)){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttributes.length;m<ml;m++)keys=morphAttributes[m].name||String(m),this.morphTargetInfluences.push(0),this.morphTargetDictionary[keys]=m}}raycast(raycaster,intersects){var geometry=this.geometry;const material=this.material;var matrixWorld=this.matrixWorld;if(void 0!==material&&
(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere$3.copy(geometry.boundingSphere),_sphere$3.applyMatrix4(matrixWorld),!1!==raycaster.ray.intersectsSphere(_sphere$3)&&(_inverseMatrix$2.copy(matrixWorld).invert(),_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2),null===geometry.boundingBox||!1!==_ray$2.intersectsBox(geometry.boundingBox)))){var index=geometry.index;matrixWorld=geometry.attributes.position;var morphPosition=geometry.morphAttributes.position,morphTargetsRelative=
geometry.morphTargetsRelative,uv=geometry.attributes.uv,uv2=geometry.attributes.uv2,groups=geometry.groups;geometry=geometry.drawRange;if(null!==index)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){var group=groups[i],groupMaterial=material[group.materialIndex];var intersection=Math.max(group.start,geometry.start);var end=Math.min(index.count,Math.min(group.start+group.count,geometry.start+geometry.count));for(let j=intersection,jl=end;j<jl;j+=3){intersection=index.getX(j);end=
index.getX(j+1);const c=index.getX(j+2);if(intersection=checkBufferGeometryIntersection(this,groupMaterial,raycaster,_ray$2,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,intersection,end,c))intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=group.materialIndex,intersects.push(intersection)}}else{groups=Math.max(0,geometry.start);geometry=Math.min(index.count,geometry.start+geometry.count);for(let i=groups,il=geometry;i<il;i+=3)if(geometry=index.getX(i),groups=index.getX(i+
1),group=index.getX(i+2),intersection=checkBufferGeometryIntersection(this,material,raycaster,_ray$2,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,geometry,groups,group))intersection.faceIndex=Math.floor(i/3),intersects.push(intersection)}else if(void 0!==matrixWorld)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){index=groups[i];group=material[index.materialIndex];groupMaterial=Math.max(index.start,geometry.start);intersection=Math.min(matrixWorld.count,Math.min(index.start+
index.count,geometry.start+geometry.count));for(let j=groupMaterial,jl=intersection;j<jl;j+=3)if(intersection=checkBufferGeometryIntersection(this,group,raycaster,_ray$2,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,j,j+1,j+2))intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=index.materialIndex,intersects.push(intersection)}else{index=Math.max(0,geometry.start);geometry=Math.min(matrixWorld.count,geometry.start+geometry.count);for(let i=index,il=geometry;i<il;i+=3)if(intersection=
checkBufferGeometryIntersection(this,material,raycaster,_ray$2,matrixWorld,morphPosition,morphTargetsRelative,uv,uv2,i,i+1,i+2))intersection.faceIndex=Math.floor(i/3),intersects.push(intersection)}}}}class BoxGeometry extends BufferGeometry{constructor(width$jscomp$0=1,height$jscomp$0=1,depth$jscomp$0=1,widthSegments=1,heightSegments=1,depthSegments=1){function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){const segmentWidth=width/gridX,segmentHeight=height/gridY,widthHalf=
width/2,heightHalf=height/2,depthHalf=depth/2;height=gridX+1;const gridY1=gridY+1;let groupCount=width=0;const vector=new Vector3;for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<height;ix++)vector[u]=(ix*segmentWidth-widthHalf)*udir,vector[v]=y*vdir,vector[w]=depthHalf,vertices.push(vector.x,vector.y,vector.z),vector[u]=0,vector[v]=0,vector[w]=0<depth?1:-1,normals.push(vector.x,vector.y,vector.z),uvs.push(ix/gridX),uvs.push(1-iy/gridY),width+=1}for(u=0;u<gridY;u++)for(v=
0;v<gridX;v++)w=numberOfVertices+v+height*(u+1),udir=numberOfVertices+(v+1)+height*(u+1),vdir=numberOfVertices+(v+1)+height*u,indices.push(numberOfVertices+v+height*u,w,vdir),indices.push(w,udir,vdir),groupCount+=6;scope.addGroup(groupStart,groupCount,materialIndex);groupStart+=groupCount;numberOfVertices+=width}super();this.type="BoxGeometry";this.parameters={width:width$jscomp$0,height:height$jscomp$0,depth:depth$jscomp$0,widthSegments,heightSegments,depthSegments};const scope=this;widthSegments=
Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);depthSegments=Math.floor(depthSegments);const indices=[],vertices=[],normals=[],uvs=[];let numberOfVertices=0,groupStart=0;buildPlane("z","y","x",-1,-1,depth$jscomp$0,height$jscomp$0,width$jscomp$0,depthSegments,heightSegments,0);buildPlane("z","y","x",1,-1,depth$jscomp$0,height$jscomp$0,-width$jscomp$0,depthSegments,heightSegments,1);buildPlane("x","z","y",1,1,width$jscomp$0,depth$jscomp$0,height$jscomp$0,widthSegments,depthSegments,
2);buildPlane("x","z","y",1,-1,width$jscomp$0,depth$jscomp$0,-height$jscomp$0,widthSegments,depthSegments,3);buildPlane("x","y","z",1,-1,width$jscomp$0,height$jscomp$0,depth$jscomp$0,widthSegments,heightSegments,4);buildPlane("x","y","z",-1,-1,width$jscomp$0,height$jscomp$0,-depth$jscomp$0,widthSegments,heightSegments,5);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",
new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments)}}const UniformsUtils={clone:cloneUniforms,merge:mergeUniforms};class ShaderMaterial extends Material{constructor(parameters){super();this.isShaderMaterial=!0;this.type="ShaderMaterial";this.defines={};this.uniforms={};this.uniformsGroups=[];this.vertexShader="void main() {\n\tgl_Position \x3d projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
this.fragmentShader="void main() {\n\tgl_FragColor \x3d vec4( 1.0, 0.0, 0.0, 1.0 );\n}";this.linewidth=1;this.wireframe=!1;this.wireframeLinewidth=1;this.clipping=this.lights=this.fog=!1;this.extensions={derivatives:!1,fragDepth:!1,drawBuffers:!1,shaderTextureLOD:!1};this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv2:[0,0]};this.index0AttributeName=void 0;this.uniformsNeedUpdate=!1;this.glslVersion=null;void 0!==parameters&&this.setValues(parameters)}copy(source){super.copy(source);this.fragmentShader=
source.fragmentShader;this.vertexShader=source.vertexShader;this.uniforms=cloneUniforms(source.uniforms);var src=source.uniformsGroups;const dst=[];for(let u=0;u<src.length;u++)dst.push(src[u].clone());this.uniformsGroups=dst;this.defines=Object.assign({},source.defines);this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.fog=source.fog;this.lights=source.lights;this.clipping=source.clipping;this.extensions=Object.assign({},source.extensions);this.glslVersion=source.glslVersion;
return this}toJSON(meta){const data=super.toJSON(meta);data.glslVersion=this.glslVersion;data.uniforms={};for(const name in this.uniforms){const value=this.uniforms[name].value;data.uniforms[name]=value&&value.isTexture?{type:"t",value:value.toJSON(meta).uuid}:value&&value.isColor?{type:"c",value:value.getHex()}:value&&value.isVector2?{type:"v2",value:value.toArray()}:value&&value.isVector3?{type:"v3",value:value.toArray()}:value&&value.isVector4?{type:"v4",value:value.toArray()}:value&&value.isMatrix3?
{type:"m3",value:value.toArray()}:value&&value.isMatrix4?{type:"m4",value:value.toArray()}:{value}}0<Object.keys(this.defines).length&&(data.defines=this.defines);data.vertexShader=this.vertexShader;data.fragmentShader=this.fragmentShader;meta={};for(const key in this.extensions)!0===this.extensions[key]&&(meta[key]=!0);0<Object.keys(meta).length&&(data.extensions=meta);return data}}class Camera extends Object3D{constructor(){super();this.isCamera=!0;this.type="Camera";this.matrixWorldInverse=new Matrix4;
this.projectionMatrix=new Matrix4;this.projectionMatrixInverse=new Matrix4}copy(source,recursive){super.copy(source,recursive);this.matrixWorldInverse.copy(source.matrixWorldInverse);this.projectionMatrix.copy(source.projectionMatrix);this.projectionMatrixInverse.copy(source.projectionMatrixInverse);return this}getWorldDirection(target){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return target.set(-e[8],-e[9],-e[10]).normalize()}updateMatrixWorld(force){super.updateMatrixWorld(force);
this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren);this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return(new this.constructor).copy(this)}}class PerspectiveCamera extends Camera{constructor(fov=50,aspect=1,near=.1,far=2E3){super();this.isPerspectiveCamera=!0;this.type="PerspectiveCamera";this.fov=fov;this.zoom=1;this.near=near;this.far=far;this.focus=10;this.aspect=aspect;this.view=
null;this.filmGauge=35;this.filmOffset=0;this.updateProjectionMatrix()}copy(source,recursive){super.copy(source,recursive);this.fov=source.fov;this.zoom=source.zoom;this.near=source.near;this.far=source.far;this.focus=source.focus;this.aspect=source.aspect;this.view=null===source.view?null:Object.assign({},source.view);this.filmGauge=source.filmGauge;this.filmOffset=source.filmOffset;return this}setFocalLength(focalLength){focalLength=.5*this.getFilmHeight()/focalLength;this.fov=2*RAD2DEG*Math.atan(focalLength);
this.updateProjectionMatrix()}getFocalLength(){const vExtentSlope=Math.tan(.5*DEG2RAD*this.fov);return.5*this.getFilmHeight()/vExtentSlope}getEffectiveFOV(){return 2*RAD2DEG*Math.atan(Math.tan(.5*DEG2RAD*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight;null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,
offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()}updateProjectionMatrix(){const near=this.near;let top=near*Math.tan(.5*DEG2RAD*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-.5*width;var view=this.view;if(null!==this.view&&
this.view.enabled){const fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth;top-=view.offsetY*height/fullHeight;width*=view.width/fullWidth;height*=view.height/fullHeight}view=this.filmOffset;0!==view&&(left+=near*view/this.getFilmWidth());this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(meta){meta=super.toJSON(meta);meta.object.fov=this.fov;meta.object.zoom=
this.zoom;meta.object.near=this.near;meta.object.far=this.far;meta.object.focus=this.focus;meta.object.aspect=this.aspect;null!==this.view&&(meta.object.view=Object.assign({},this.view));meta.object.filmGauge=this.filmGauge;meta.object.filmOffset=this.filmOffset;return meta}}class CubeCamera extends Object3D{constructor(near,far,renderTarget){super();this.type="CubeCamera";this.renderTarget=renderTarget;renderTarget=new PerspectiveCamera(90,1,near,far);renderTarget.layers=this.layers;renderTarget.up.set(0,
-1,0);renderTarget.lookAt(new Vector3(1,0,0));this.add(renderTarget);renderTarget=new PerspectiveCamera(90,1,near,far);renderTarget.layers=this.layers;renderTarget.up.set(0,-1,0);renderTarget.lookAt(new Vector3(-1,0,0));this.add(renderTarget);renderTarget=new PerspectiveCamera(90,1,near,far);renderTarget.layers=this.layers;renderTarget.up.set(0,0,1);renderTarget.lookAt(new Vector3(0,1,0));this.add(renderTarget);renderTarget=new PerspectiveCamera(90,1,near,far);renderTarget.layers=this.layers;renderTarget.up.set(0,
0,-1);renderTarget.lookAt(new Vector3(0,-1,0));this.add(renderTarget);renderTarget=new PerspectiveCamera(90,1,near,far);renderTarget.layers=this.layers;renderTarget.up.set(0,-1,0);renderTarget.lookAt(new Vector3(0,0,1));this.add(renderTarget);near=new PerspectiveCamera(90,1,near,far);near.layers=this.layers;near.up.set(0,-1,0);near.lookAt(new Vector3(0,0,-1));this.add(near)}update(renderer,scene){null===this.parent&&this.updateMatrixWorld();const renderTarget=this.renderTarget,[cameraPX,cameraNX,
cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children,currentRenderTarget=renderer.getRenderTarget(),currentToneMapping=renderer.toneMapping,currentXrEnabled=renderer.xr.enabled;renderer.toneMapping=0;renderer.xr.enabled=!1;const generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=!1;renderer.setRenderTarget(renderTarget,0);renderer.render(scene,cameraPX);renderer.setRenderTarget(renderTarget,1);renderer.render(scene,cameraNX);renderer.setRenderTarget(renderTarget,
2);renderer.render(scene,cameraPY);renderer.setRenderTarget(renderTarget,3);renderer.render(scene,cameraNY);renderer.setRenderTarget(renderTarget,4);renderer.render(scene,cameraPZ);renderTarget.texture.generateMipmaps=generateMipmaps;renderer.setRenderTarget(renderTarget,5);renderer.render(scene,cameraNZ);renderer.setRenderTarget(currentRenderTarget);renderer.toneMapping=currentToneMapping;renderer.xr.enabled=currentXrEnabled;renderTarget.texture.needsPMREMUpdate=!0}}class CubeTexture extends Texture{constructor(images,
mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding){images=void 0!==images?images:[];super(images,void 0!==mapping?mapping:301,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.isCubeTexture=!0;this.flipY=!1}get images(){return this.image}set images(value){this.image=value}}class WebGLCubeRenderTarget extends WebGLRenderTarget{constructor(size=1,options={}){super(size,size,options);this.isWebGLCubeRenderTarget=!0;size={width:size,height:size,depth:1};this.texture=
new CubeTexture([size,size,size,size,size,size],options.mapping,options.wrapS,options.wrapT,options.magFilter,options.minFilter,options.format,options.type,options.anisotropy,options.encoding);this.texture.isRenderTargetTexture=!0;this.texture.generateMipmaps=void 0!==options.generateMipmaps?options.generateMipmaps:!1;this.texture.minFilter=void 0!==options.minFilter?options.minFilter:1006}fromEquirectangularTexture(renderer,texture){this.texture.type=texture.type;this.texture.encoding=texture.encoding;
this.texture.generateMipmaps=texture.generateMipmaps;this.texture.minFilter=texture.minFilter;this.texture.magFilter=texture.magFilter;var geometry=new BoxGeometry(5,5,5),material=new ShaderMaterial({name:"CubemapFromEquirect",uniforms:cloneUniforms({tEquirect:{value:null}}),vertexShader:"\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection \x3d transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include \x3cbegin_vertex\x3e\n\t\t\t\t\t#include \x3cproject_vertex\x3e\n\n\t\t\t\t}\n\t\t\t",
fragmentShader:"\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include \x3ccommon\x3e\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction \x3d normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV \x3d equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor \x3d texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",side:1,blending:0});material.uniforms.tEquirect.value=texture;geometry=new Mesh(geometry,material);material=texture.minFilter;1008===texture.minFilter&&
(texture.minFilter=1006);(new CubeCamera(1,10,this)).update(renderer,geometry);texture.minFilter=material;geometry.geometry.dispose();geometry.material.dispose();return this}clear(renderer,color,depth,stencil){const currentRenderTarget=renderer.getRenderTarget();for(let i=0;6>i;i++)renderer.setRenderTarget(this,i),renderer.clear(color,depth,stencil);renderer.setRenderTarget(currentRenderTarget)}}const _vector1=new Vector3,_vector2=new Vector3,_normalMatrix=new Matrix3;class Plane{constructor(normal=
new Vector3(1,0,0),constant=0){this.isPlane=!0;this.normal=normal;this.constant=constant}set(normal,constant){this.normal.copy(normal);this.constant=constant;return this}setComponents(x,y,z,w){this.normal.set(x,y,z);this.constant=w;return this}setFromNormalAndCoplanarPoint(normal,point){this.normal.copy(normal);this.constant=-point.dot(this.normal);return this}setFromCoplanarPoints(a,b,c){b=_vector1.subVectors(c,b).cross(_vector2.subVectors(a,b)).normalize();this.setFromNormalAndCoplanarPoint(b,a);
return this}copy(plane){this.normal.copy(plane.normal);this.constant=plane.constant;return this}normalize(){const inverseNormalLength=1/this.normal.length();this.normal.multiplyScalar(inverseNormalLength);this.constant*=inverseNormalLength;return this}negate(){this.constant*=-1;this.normal.negate();return this}distanceToPoint(point){return this.normal.dot(point)+this.constant}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius}projectPoint(point,target){return target.copy(this.normal).multiplyScalar(-this.distanceToPoint(point)).add(point)}intersectLine(line,
target){const direction=line.delta(_vector1);var denominator=this.normal.dot(direction);if(0===denominator)return 0===this.distanceToPoint(line.start)?target.copy(line.start):null;denominator=-(line.start.dot(this.normal)+this.constant)/denominator;return 0>denominator||1<denominator?null:target.copy(direction).multiplyScalar(denominator).add(line.start)}intersectsLine(line){const startSign=this.distanceToPoint(line.start);line=this.distanceToPoint(line.end);return 0>startSign&&0<line||0>line&&0<
startSign}intersectsBox(box){return box.intersectsPlane(this)}intersectsSphere(sphere){return sphere.intersectsPlane(this)}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(matrix,optionalNormalMatrix){optionalNormalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix);matrix=this.coplanarPoint(_vector1).applyMatrix4(matrix);optionalNormalMatrix=this.normal.applyMatrix3(optionalNormalMatrix).normalize();this.constant=-matrix.dot(optionalNormalMatrix);
return this}translate(offset){this.constant-=offset.dot(this.normal);return this}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const _sphere$2=new Sphere,_vector$7=new Vector3;class Frustum{constructor(p0=new Plane,p1=new Plane,p2=new Plane,p3=new Plane,p4=new Plane,p5=new Plane){this.planes=[p0,p1,p2,p3,p4,p5]}set(p0,p1,p2,p3,p4,p5){const planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);
planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this}copy(frustum){const planes=this.planes;for(let i=0;6>i;i++)planes[i].copy(frustum.planes[i]);return this}setFromProjectionMatrix(m){const planes=this.planes;var me=m.elements;m=me[0];const me1=me[1],me2=me[2],me3=me[3],me4=me[4],me5=me[5],me6=me[6],me7=me[7],me8=me[8],me9=me[9],me10=me[10],me11=me[11],me12=me[12],me13=me[13],me14=me[14];me=me[15];planes[0].setComponents(me3-m,me7-me4,me11-me8,me-me12).normalize();planes[1].setComponents(me3+
m,me7+me4,me11+me8,me+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+me10,me+me14).normalize();return this}intersectsObject(object){const geometry=object.geometry;null===geometry.boundingSphere&&geometry.computeBoundingSphere();_sphere$2.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
return this.intersectsSphere(_sphere$2)}intersectsSprite(sprite){_sphere$2.center.set(0,0,0);_sphere$2.radius=.7071067811865476;_sphere$2.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere$2)}intersectsSphere(sphere){const planes=this.planes,center=sphere.center;sphere=-sphere.radius;for(let i=0;6>i;i++)if(planes[i].distanceToPoint(center)<sphere)return!1;return!0}intersectsBox(box){const planes=this.planes;for(let i=0;6>i;i++){const plane=planes[i];_vector$7.x=0<plane.normal.x?
box.max.x:box.min.x;_vector$7.y=0<plane.normal.y?box.max.y:box.min.y;_vector$7.z=0<plane.normal.z?box.max.z:box.min.z;if(0>plane.distanceToPoint(_vector$7))return!1}return!0}containsPoint(point){const planes=this.planes;for(let i=0;6>i;i++)if(0>planes[i].distanceToPoint(point))return!1;return!0}clone(){return(new this.constructor).copy(this)}}class PlaneGeometry extends BufferGeometry{constructor(width=1,height=1,widthSegments=1,heightSegments=1){super();this.type="PlaneGeometry";this.parameters=
{width,height,widthSegments,heightSegments};var width_half=width/2,height_half=height/2;widthSegments=Math.floor(widthSegments);heightSegments=Math.floor(heightSegments);const gridX1=widthSegments+1;var gridY1=heightSegments+1,segment_width=width/widthSegments,segment_height=height/heightSegments;height=[];width=[];const normals=[],uvs=[];for(let iy=0;iy<gridY1;iy++){const y=iy*segment_height-height_half;for(let ix=0;ix<gridX1;ix++)width.push(ix*segment_width-width_half,-y,0),normals.push(0,0,1),
uvs.push(ix/widthSegments),uvs.push(1-iy/heightSegments)}for(width_half=0;width_half<heightSegments;width_half++)for(height_half=0;height_half<widthSegments;height_half++)gridY1=height_half+gridX1*(width_half+1),segment_width=height_half+1+gridX1*(width_half+1),segment_height=height_half+1+gridX1*width_half,height.push(height_half+gridX1*width_half,gridY1,segment_height),height.push(gridY1,segment_width,segment_height);this.setIndex(height);this.setAttribute("position",new Float32BufferAttribute(width,
3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments)}}const ShaderChunk={alphamap_fragment:"#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *\x3d texture2D( alphaMap, vUv ).g;\n#endif",alphamap_pars_fragment:"#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",alphatest_fragment:"#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a \x3c alphaTest ) discard;\n#endif",
alphatest_pars_fragment:"#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",aomap_fragment:"#ifdef USE_AOMAP\n\tfloat ambientOcclusion \x3d ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *\x3d ambientOcclusion;\n\t#if defined( USE_ENVMAP ) \x26\x26 defined( STANDARD )\n\t\tfloat dotNV \x3d saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *\x3d computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
aomap_pars_fragment:"#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",begin_vertex:"vec3 transformed \x3d vec3( position );",beginnormal_vertex:"vec3 objectNormal \x3d vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent \x3d vec3( tangent.xyz );\n#endif",bsdfs:"vec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel \x3d exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel \x3d exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n\t\tfloat x \x3d clamp( 1.0 - dotVH, 0.0, 1.0 );\n\t\tfloat x2 \x3d x * x;\n\t\tfloat x5 \x3d clamp( x * x2 * x2, 0.0, 0.9999 );\n\t\treturn ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 \x3d pow2( alpha );\n\tfloat gv \x3d dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl \x3d dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 \x3d pow2( alpha );\n\tfloat denom \x3d pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float roughness ) {\n\tfloat alpha \x3d pow2( roughness );\n\tvec3 halfDir \x3d normalize( lightDir + viewDir );\n\tfloat dotNL \x3d saturate( dot( normal, lightDir ) );\n\tfloat dotNV \x3d saturate( dot( normal, viewDir ) );\n\tfloat dotNH \x3d saturate( dot( normal, halfDir ) );\n\tfloat dotVH \x3d saturate( dot( viewDir, halfDir ) );\n\tvec3 F \x3d F_Schlick( f0, f90, dotVH );\n\tfloat V \x3d V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D \x3d D_GGX( alpha, dotNH );\n\treturn F * ( V * D );\n}\n#ifdef USE_IRIDESCENCE\n\tvec3 BRDF_GGX_Iridescence( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 f0, const in float f90, const in float iridescence, const in vec3 iridescenceFresnel, const in float roughness ) {\n\t\tfloat alpha \x3d pow2( roughness );\n\t\tvec3 halfDir \x3d normalize( lightDir + viewDir );\n\t\tfloat dotNL \x3d saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV \x3d saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH \x3d saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH \x3d saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F \x3d mix( F_Schlick( f0, f90, dotVH ), iridescenceFresnel, iridescence );\n\t\tfloat V \x3d V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D \x3d D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE \x3d 64.0;\n\tconst float LUT_SCALE \x3d ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS \x3d 0.5 / LUT_SIZE;\n\tfloat dotNV \x3d saturate( dot( N, V ) );\n\tvec2 uv \x3d vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv \x3d uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l \x3d length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x \x3d dot( v1, v2 );\n\tfloat y \x3d abs( x );\n\tfloat a \x3d 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b \x3d 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v \x3d a / b;\n\tfloat theta_sintheta \x3d ( x \x3e 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 \x3d rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 \x3d rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal \x3d cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) \x3c 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 \x3d normalize( V - N * dot( V, N ) );\n\tT2 \x3d - cross( N, T1 );\n\tmat3 mat \x3d mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] \x3d mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] \x3d mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] \x3d mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] \x3d mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] \x3d normalize( coords[ 0 ] );\n\tcoords[ 1 ] \x3d normalize( coords[ 1 ] );\n\tcoords[ 2 ] \x3d normalize( coords[ 2 ] );\n\tcoords[ 3 ] \x3d normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor \x3d vec3( 0.0 );\n\tvectorFormFactor +\x3d LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor +\x3d LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor +\x3d LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor +\x3d LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result \x3d LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir \x3d normalize( lightDir + viewDir );\n\tfloat dotNH \x3d saturate( dot( normal, halfDir ) );\n\tfloat dotVH \x3d saturate( dot( viewDir, halfDir ) );\n\tvec3 F \x3d F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G \x3d G_BlinnPhong_Implicit( );\n\tfloat D \x3d D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha \x3d pow2( roughness );\n\tfloat invAlpha \x3d 1.0 / alpha;\n\tfloat cos2h \x3d dotNH * dotNH;\n\tfloat sin2h \x3d max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir \x3d normalize( lightDir + viewDir );\n\tfloat dotNL \x3d saturate( dot( normal, lightDir ) );\n\tfloat dotNV \x3d saturate( dot( normal, viewDir ) );\n\tfloat dotNH \x3d saturate( dot( normal, halfDir ) );\n\tfloat D \x3d D_Charlie( sheenRoughness, dotNH );\n\tfloat V \x3d V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif",
iridescence_fragment:"#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 \x3d mat3(\n\t\t 3.2404542, -0.9692660,\t0.0556434,\n\t\t-1.5371385,\t1.8760108, -0.2040259,\n\t\t-0.4985314,\t0.0415560,\t1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 \x3d sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase \x3d 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val \x3d vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos \x3d vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var \x3d vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz \x3d val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x +\x3d 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /\x3d 1.0685e-7;\n\t\tvec3 rgb \x3d XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR \x3d mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq \x3d pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq \x3d 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq \x3c 0.0 ) {\n\t\t\t return vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 \x3d sqrt( cosTheta2Sq );\n\t\tfloat R0 \x3d IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 \x3d F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 \x3d R12;\n\t\tfloat T121 \x3d 1.0 - R12;\n\t\tfloat phi12 \x3d 0.0;\n\t\tif ( iridescenceIOR \x3c outsideIOR ) phi12 \x3d PI;\n\t\tfloat phi21 \x3d PI - phi12;\n\t\tvec3 baseIOR \x3d Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 \x3d IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 \x3d F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 \x3d vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] \x3c iridescenceIOR ) phi23[ 0 ] \x3d PI;\n\t\tif ( baseIOR[ 1 ] \x3c iridescenceIOR ) phi23[ 1 ] \x3d PI;\n\t\tif ( baseIOR[ 2 ] \x3c iridescenceIOR ) phi23[ 2 ] \x3d PI;\n\t\tfloat OPD \x3d 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi \x3d vec3( phi21 ) + phi23;\n\t\tvec3 R123 \x3d clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 \x3d sqrt( R123 );\n\t\tvec3 Rs \x3d pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 \x3d R12 + Rs;\n\t\tI \x3d C0;\n\t\tvec3 Cm \x3d Rs - T121;\n\t\tfor ( int m \x3d 1; m \x3c\x3d 2; ++ m ) {\n\t\t\tCm *\x3d r123;\n\t\t\tvec3 Sm \x3d 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI +\x3d Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
bumpmap_pars_fragment:"#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx \x3d dFdx( vUv );\n\t\tvec2 dSTdy \x3d dFdy( vUv );\n\t\tfloat Hll \x3d bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx \x3d bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy \x3d bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX \x3d dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY \x3d dFdy( surf_pos.xyz );\n\t\tvec3 vN \x3d surf_norm;\n\t\tvec3 R1 \x3d cross( vSigmaY, vN );\n\t\tvec3 R2 \x3d cross( vN, vSigmaX );\n\t\tfloat fDet \x3d dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad \x3d sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
clipping_planes_fragment:"#if NUM_CLIPPING_PLANES \x3e 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane \x3d clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) \x3e plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES \x3c NUM_CLIPPING_PLANES\n\t\tbool clipped \x3d true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i \x3d UNION_CLIPPING_PLANES; i \x3c NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane \x3d clippingPlanes[ i ];\n\t\t\tclipped \x3d ( dot( vClipPosition, plane.xyz ) \x3e plane.w ) \x26\x26 clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
clipping_planes_pars_fragment:"#if NUM_CLIPPING_PLANES \x3e 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",clipping_planes_pars_vertex:"#if NUM_CLIPPING_PLANES \x3e 0\n\tvarying vec3 vClipPosition;\n#endif",clipping_planes_vertex:"#if NUM_CLIPPING_PLANES \x3e 0\n\tvClipPosition \x3d - mvPosition.xyz;\n#endif",color_fragment:"#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *\x3d vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *\x3d vColor;\n#endif",
color_pars_fragment:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",color_pars_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",color_vertex:"#if defined( USE_COLOR_ALPHA )\n\tvColor \x3d vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor \x3d vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *\x3d color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *\x3d instanceColor.xyz;\n#endif",
common:"#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 \x3d x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a \x3d 12.9898, b \x3d 78.233, c \x3d 43758.5453;\n\thighp float dt \x3d dot( uv.xy, vec2( a,b ) ), sn \x3d mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent \x3d max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] \x3d vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] \x3d vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] \x3d vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights \x3d vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] \x3d\x3d - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u \x3d atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v \x3d asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}",
cube_uv_reflection_fragment:"#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection \x3d abs( direction );\n\t\tfloat face \x3d - 1.0;\n\t\tif ( absDirection.x \x3e absDirection.z ) {\n\t\t\tif ( absDirection.x \x3e absDirection.y )\n\t\t\t\tface \x3d direction.x \x3e 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface \x3d direction.y \x3e 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z \x3e absDirection.y )\n\t\t\t\tface \x3d direction.z \x3e 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface \x3d direction.y \x3e 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face \x3d\x3d 0.0 ) {\n\t\t\tuv \x3d vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face \x3d\x3d 1.0 ) {\n\t\t\tuv \x3d vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face \x3d\x3d 2.0 ) {\n\t\t\tuv \x3d vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face \x3d\x3d 3.0 ) {\n\t\t\tuv \x3d vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face \x3d\x3d 4.0 ) {\n\t\t\tuv \x3d vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv \x3d vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face \x3d getFace( direction );\n\t\tfloat filterInt \x3d max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt \x3d max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize \x3d exp2( mipInt );\n\t\tvec2 uv \x3d getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face \x3e 2.0 ) {\n\t\t\tuv.y +\x3d faceSize;\n\t\t\tface -\x3d 3.0;\n\t\t}\n\t\tuv.x +\x3d face * faceSize;\n\t\tuv.x +\x3d filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y +\x3d 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *\x3d CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *\x3d CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip \x3d 0.0;\n\t\tif ( roughness \x3e\x3d cubeUV_r1 ) {\n\t\t\tmip \x3d ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness \x3e\x3d cubeUV_r4 ) {\n\t\t\tmip \x3d ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness \x3e\x3d cubeUV_r5 ) {\n\t\t\tmip \x3d ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness \x3e\x3d cubeUV_r6 ) {\n\t\t\tmip \x3d ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip \x3d - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip \x3d clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF \x3d fract( mip );\n\t\tfloat mipInt \x3d floor( mip );\n\t\tvec3 color0 \x3d bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF \x3d\x3d 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 \x3d bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
defaultnormal_vertex:"vec3 transformedNormal \x3d objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m \x3d mat3( instanceMatrix );\n\ttransformedNormal /\x3d vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal \x3d m * transformedNormal;\n#endif\ntransformedNormal \x3d normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal \x3d - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent \x3d ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent \x3d - transformedTangent;\n\t#endif\n#endif",
displacementmap_pars_vertex:"#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",displacementmap_vertex:"#ifdef USE_DISPLACEMENTMAP\n\ttransformed +\x3d normalize( objectNormal ) * ( texture2D( displacementMap, vUv ).x * displacementScale + displacementBias );\n#endif",emissivemap_fragment:"#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor \x3d texture2D( emissiveMap, vUv );\n\ttotalEmissiveRadiance *\x3d emissiveColor.rgb;\n#endif",
emissivemap_pars_fragment:"#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",encodings_fragment:"gl_FragColor \x3d linearToOutputTexel( gl_FragColor );",encodings_pars_fragment:"vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",envmap_fragment:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag \x3d normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag \x3d normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal \x3d inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec \x3d reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec \x3d refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec \x3d vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor \x3d textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor \x3d vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight \x3d mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight \x3d mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight +\x3d envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
envmap_common_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",envmap_pars_fragment:"#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
envmap_pars_vertex:"#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",envmap_physical_pars_fragment:"#if defined( USE_ENVMAP )\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 worldNormal \x3d inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor \x3d textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 reflectVec \x3d reflect( - viewDir, normal );\n\t\t\treflectVec \x3d normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec \x3d inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor \x3d textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n#endif",
envmap_vertex:"#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition \x3d worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex \x3d normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex \x3d normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal \x3d inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect \x3d reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect \x3d refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
fog_vertex:"#ifdef USE_FOG\n\tvFogDepth \x3d - mvPosition.z;\n#endif",fog_pars_vertex:"#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",fog_fragment:"#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor \x3d 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor \x3d smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb \x3d mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",fog_pars_fragment:"#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
gradientmap_pars_fragment:"#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL \x3d dot( normal, lightDirection );\n\tvec2 coord \x3d vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw \x3d fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",lightmap_fragment:"#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel \x3d texture2D( lightMap, vUv2 );\n\tvec3 lightMapIrradiance \x3d lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse +\x3d lightMapIrradiance;\n#endif",
lightmap_pars_fragment:"#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",lights_lambert_fragment:"LambertMaterial material;\nmaterial.diffuseColor \x3d diffuseColor.rgb;\nmaterial.specularStrength \x3d specularStrength;",lights_lambert_pars_fragment:"varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL \x3d saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance \x3d dotNL * directLight.color;\n\treflectedLight.directDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert\n#define Material_LightProbeLOD( material )\t(0)",
lights_pars_begin:"uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x \x3d normal.x, y \x3d normal.y, z \x3d normal.z;\n\tvec3 result \x3d shCoefficients[ 0 ] * 0.886227;\n\tresult +\x3d shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult +\x3d shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult +\x3d shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult +\x3d shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult +\x3d shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult +\x3d shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult +\x3d shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult +\x3d shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal \x3d inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance \x3d shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance \x3d ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\tfloat distanceFalloff \x3d 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance \x3e 0.0 ) {\n\t\t\tdistanceFalloff *\x3d pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#else\n\t\tif ( cutoffDistance \x3e 0.0 \x26\x26 decayExponent \x3e 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS \x3e 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color \x3d directionalLight.color;\n\t\tlight.direction \x3d directionalLight.direction;\n\t\tlight.visible \x3d true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS \x3e 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector \x3d pointLight.position - geometry.position;\n\t\tlight.direction \x3d normalize( lVector );\n\t\tfloat lightDistance \x3d length( lVector );\n\t\tlight.color \x3d pointLight.color;\n\t\tlight.color *\x3d getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible \x3d ( light.color !\x3d vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS \x3e 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector \x3d spotLight.position - geometry.position;\n\t\tlight.direction \x3d normalize( lVector );\n\t\tfloat angleCos \x3d dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation \x3d getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation \x3e 0.0 ) {\n\t\t\tfloat lightDistance \x3d length( lVector );\n\t\t\tlight.color \x3d spotLight.color * spotAttenuation;\n\t\t\tlight.color *\x3d getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible \x3d ( light.color !\x3d vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color \x3d vec3( 0.0 );\n\t\t\tlight.visible \x3d false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS \x3e 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS \x3e 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL \x3d dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight \x3d 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance \x3d mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
lights_toon_fragment:"ToonMaterial material;\nmaterial.diffuseColor \x3d diffuseColor.rgb;",lights_toon_pars_fragment:"varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance \x3d getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon\n#define Material_LightProbeLOD( material )\t(0)",
lights_phong_fragment:"BlinnPhongMaterial material;\nmaterial.diffuseColor \x3d diffuseColor.rgb;\nmaterial.specularColor \x3d specular;\nmaterial.specularShininess \x3d shininess;\nmaterial.specularStrength \x3d specularStrength;",lights_phong_pars_fragment:"varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL \x3d saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance \x3d dotNL * directLight.color;\n\treflectedLight.directDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular +\x3d irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)",
lights_physical_fragment:"PhysicalMaterial material;\nmaterial.diffuseColor \x3d diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy \x3d max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness \x3d max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness \x3d max( roughnessFactor, 0.0525 );material.roughness +\x3d geometryRoughness;\nmaterial.roughness \x3d min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior \x3d ior;\n\t#ifdef SPECULAR\n\t\tfloat specularIntensityFactor \x3d specularIntensity;\n\t\tvec3 specularColorFactor \x3d specularColor;\n\t\t#ifdef USE_SPECULARINTENSITYMAP\n\t\t\tspecularIntensityFactor *\x3d texture2D( specularIntensityMap, vUv ).a;\n\t\t#endif\n\t\t#ifdef USE_SPECULARCOLORMAP\n\t\t\tspecularColorFactor *\x3d texture2D( specularColorMap, vUv ).rgb;\n\t\t#endif\n\t\tmaterial.specularF90 \x3d mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor \x3d 1.0;\n\t\tvec3 specularColorFactor \x3d vec3( 1.0 );\n\t\tmaterial.specularF90 \x3d 1.0;\n\t#endif\n\tmaterial.specularColor \x3d mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor \x3d mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 \x3d 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat \x3d clearcoat;\n\tmaterial.clearcoatRoughness \x3d clearcoatRoughness;\n\tmaterial.clearcoatF0 \x3d vec3( 0.04 );\n\tmaterial.clearcoatF90 \x3d 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *\x3d texture2D( clearcoatMap, vUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *\x3d texture2D( clearcoatRoughnessMap, vUv ).y;\n\t#endif\n\tmaterial.clearcoat \x3d saturate( material.clearcoat );\tmaterial.clearcoatRoughness \x3d max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness +\x3d geometryRoughness;\n\tmaterial.clearcoatRoughness \x3d min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence \x3d iridescence;\n\tmaterial.iridescenceIOR \x3d iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *\x3d texture2D( iridescenceMap, vUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness \x3d (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness \x3d iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor \x3d sheenColor;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tmaterial.sheenColor *\x3d texture2D( sheenColorMap, vUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness \x3d clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tmaterial.sheenRoughness *\x3d texture2D( sheenRoughnessMap, vUv ).a;\n\t#endif\n#endif",
lights_physical_pars_fragment:"struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n};\nvec3 clearcoatSpecular \x3d vec3( 0.0 );\nvec3 sheenSpecular \x3d vec3( 0.0 );\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV \x3d saturate( dot( normal, viewDir ) );\n\tfloat r2 \x3d roughness * roughness;\n\tfloat a \x3d roughness \x3c 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b \x3d roughness \x3c 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG \x3d exp( a * dotNV + b ) + ( roughness \x3c 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV \x3d saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 \x3d vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 \x3d vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r \x3d roughness * c0 + c1;\n\tfloat a004 \x3d min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab \x3d vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab \x3d DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab \x3d DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr \x3d mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr \x3d specularColor;\n\t#endif\n\tvec3 FssEss \x3d Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess \x3d fab.x + fab.y;\n\tfloat Ems \x3d 1.0 - Ess;\n\tvec3 Favg \x3d Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms \x3d FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter +\x3d FssEss;\n\tmultiScatter +\x3d Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS \x3e 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal \x3d geometry.normal;\n\t\tvec3 viewDir \x3d geometry.viewDir;\n\t\tvec3 position \x3d geometry.position;\n\t\tvec3 lightPos \x3d rectAreaLight.position;\n\t\tvec3 halfWidth \x3d rectAreaLight.halfWidth;\n\t\tvec3 halfHeight \x3d rectAreaLight.halfHeight;\n\t\tvec3 lightColor \x3d rectAreaLight.color;\n\t\tfloat roughness \x3d material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] \x3d lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] \x3d lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] \x3d lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] \x3d lightPos + halfWidth + halfHeight;\n\t\tvec2 uv \x3d LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 \x3d texture2D( ltc_1, uv );\n\t\tvec4 t2 \x3d texture2D( ltc_2, uv );\n\t\tmat3 mInv \x3d mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(\t\t0, 1,\t\t0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel \x3d ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular +\x3d lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse +\x3d lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL \x3d saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance \x3d dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc \x3d saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance \x3d dotNLcc * directLight.color;\n\t\tclearcoatSpecular +\x3d ccIrradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular +\x3d irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\treflectedLight.directSpecular +\x3d irradiance * BRDF_GGX_Iridescence( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness );\n\t#else\n\t\treflectedLight.directSpecular +\x3d irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularF90, material.roughness );\n\t#endif\n\treflectedLight.directDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse +\x3d irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular +\x3d clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular +\x3d irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering \x3d vec3( 0.0 );\n\tvec3 multiScattering \x3d vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance \x3d irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering \x3d singleScattering + multiScattering;\n\tvec3 diffuse \x3d material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular +\x3d radiance * singleScattering;\n\treflectedLight.indirectSpecular +\x3d multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse +\x3d diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
lights_fragment_begin:"\nGeometricContext geometry;\ngeometry.position \x3d - vViewPosition;\ngeometry.normal \x3d normal;\ngeometry.viewDir \x3d ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal \x3d clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi \x3d saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness \x3d\x3d 0.0 ) {\n\t\tmaterial.iridescence \x3d 0.0;\n\t} else {\n\t\tmaterial.iridescence \x3d saturate( material.iridescence );\n\t}\n\tif ( material.iridescence \x3e 0.0 ) {\n\t\tmaterial.iridescenceFresnel \x3d evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 \x3d Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) \x26\x26 NUM_POINT_LIGHT_SHADOWS \x3e 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight \x3d pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) \x26\x26 ( UNROLLED_LOOP_INDEX \x3c NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow \x3d pointLightShadows[ i ];\n\t\tdirectLight.color *\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) \x26\x26 NUM_SPOT_LIGHT_SHADOWS \x3e 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight \x3d spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX \x3c NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX \x3c NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX \x3c NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord \x3d vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap \x3d all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor \x3d texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color \x3d inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) \x26\x26 ( UNROLLED_LOOP_INDEX \x3c NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow \x3d spotLightShadows[ i ];\n\t\tdirectLight.color *\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) \x26\x26 NUM_DIR_LIGHT_SHADOWS \x3e 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight \x3d directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) \x26\x26 ( UNROLLED_LOOP_INDEX \x3c NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow \x3d directionalLightShadows[ i ];\n\t\tdirectLight.color *\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight \x3d rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance \x3d vec3( 0.0 );\n\tvec3 irradiance \x3d getAmbientLightIrradiance( ambientLightColor );\n\tirradiance +\x3d getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS \x3e 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i \x3d 0; i \x3c NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance +\x3d getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance \x3d vec3( 0.0 );\n\tvec3 clearcoatRadiance \x3d vec3( 0.0 );\n#endif",
lights_fragment_maps:"#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel \x3d texture2D( lightMap, vUv2 );\n\t\tvec3 lightMapIrradiance \x3d lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance +\x3d lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) \x26\x26 defined( STANDARD ) \x26\x26 defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance +\x3d getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) \x26\x26 defined( RE_IndirectSpecular )\n\tradiance +\x3d getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance +\x3d getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
lights_fragment_end:"#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",logdepthbuf_fragment:"#if defined( USE_LOGDEPTHBUF ) \x26\x26 defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT \x3d vIsPerspective \x3d\x3d 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
logdepthbuf_pars_fragment:"#if defined( USE_LOGDEPTHBUF ) \x26\x26 defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",logdepthbuf_pars_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",logdepthbuf_vertex:"#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth \x3d 1.0 + gl_Position.w;\n\t\tvIsPerspective \x3d float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z \x3d log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *\x3d gl_Position.w;\n\t\t}\n\t#endif\n#endif",
map_fragment:"#ifdef USE_MAP\n\tvec4 sampledDiffuseColor \x3d texture2D( map, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor \x3d vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t#endif\n\tdiffuseColor *\x3d sampledDiffuseColor;\n#endif",map_pars_fragment:"#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
map_particle_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tvec2 uv \x3d ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *\x3d texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *\x3d texture2D( alphaMap, uv ).g;\n#endif",map_particle_pars_fragment:"#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\tuniform mat3 uvTransform;\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
metalnessmap_fragment:"float metalnessFactor \x3d metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness \x3d texture2D( metalnessMap, vUv );\n\tmetalnessFactor *\x3d texelMetalness.b;\n#endif",metalnessmap_pars_fragment:"#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",morphcolor_vertex:"#if defined( USE_MORPHCOLORS ) \x26\x26 defined( MORPHTARGETS_TEXTURE )\n\tvColor *\x3d morphTargetBaseInfluence;\n\tfor ( int i \x3d 0; i \x3c MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] !\x3d 0.0 ) vColor +\x3d getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] !\x3d 0.0 ) vColor +\x3d getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
morphnormal_vertex:"#ifdef USE_MORPHNORMALS\n\tobjectNormal *\x3d morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i \x3d 0; i \x3c MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] !\x3d 0.0 ) objectNormal +\x3d getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal +\x3d morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal +\x3d morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal +\x3d morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal +\x3d morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
morphtarget_pars_vertex:"#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex \x3d vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y \x3d texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x \x3d texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV \x3d ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
morphtarget_vertex:"#ifdef USE_MORPHTARGETS\n\ttransformed *\x3d morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i \x3d 0; i \x3c MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] !\x3d 0.0 ) transformed +\x3d getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed +\x3d morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed +\x3d morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed +\x3d morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed +\x3d morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed +\x3d morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed +\x3d morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed +\x3d morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed +\x3d morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
normal_fragment_begin:"float faceDirection \x3d gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx \x3d dFdx( vViewPosition );\n\tvec3 fdy \x3d dFdy( vViewPosition );\n\tvec3 normal \x3d normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal \x3d normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal \x3d normal * faceDirection;\n\t#endif\n\t#ifdef USE_TANGENT\n\t\tvec3 tangent \x3d normalize( vTangent );\n\t\tvec3 bitangent \x3d normalize( vBitangent );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\ttangent \x3d tangent * faceDirection;\n\t\t\tbitangent \x3d bitangent * faceDirection;\n\t\t#endif\n\t\t#if defined( TANGENTSPACE_NORMALMAP ) || defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tmat3 vTBN \x3d mat3( tangent, bitangent, normal );\n\t\t#endif\n\t#endif\n#endif\nvec3 geometryNormal \x3d normal;",
normal_fragment_maps:"#ifdef OBJECTSPACE_NORMALMAP\n\tnormal \x3d texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal \x3d - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal \x3d normal * faceDirection;\n\t#endif\n\tnormal \x3d normalize( normalMatrix * normal );\n#elif defined( TANGENTSPACE_NORMALMAP )\n\tvec3 mapN \x3d texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *\x3d normalScale;\n\t#ifdef USE_TANGENT\n\t\tnormal \x3d normalize( vTBN * mapN );\n\t#else\n\t\tnormal \x3d perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal \x3d perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
normal_pars_fragment:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_pars_vertex:"#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",normal_vertex:"#ifndef FLAT_SHADED\n\tvNormal \x3d normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent \x3d normalize( transformedTangent );\n\t\tvBitangent \x3d normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
normalmap_pars_fragment:"#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef OBJECTSPACE_NORMALMAP\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) \x26\x26 ( defined ( TANGENTSPACE_NORMALMAP ) || defined ( USE_CLEARCOAT_NORMALMAP ) )\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm, vec3 mapN, float faceDirection ) {\n\t\tvec3 q0 \x3d dFdx( eye_pos.xyz );\n\t\tvec3 q1 \x3d dFdy( eye_pos.xyz );\n\t\tvec2 st0 \x3d dFdx( vUv.st );\n\t\tvec2 st1 \x3d dFdy( vUv.st );\n\t\tvec3 N \x3d surf_norm;\n\t\tvec3 q1perp \x3d cross( q1, N );\n\t\tvec3 q0perp \x3d cross( N, q0 );\n\t\tvec3 T \x3d q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B \x3d q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det \x3d max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale \x3d ( det \x3d\x3d 0.0 ) ? 0.0 : faceDirection * inversesqrt( det );\n\t\treturn normalize( T * ( mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z );\n\t}\n#endif",
clearcoat_normal_fragment_begin:"#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal \x3d geometryNormal;\n#endif",clearcoat_normal_fragment_maps:"#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN \x3d texture2D( clearcoatNormalMap, vUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *\x3d clearcoatNormalScale;\n\t#ifdef USE_TANGENT\n\t\tclearcoatNormal \x3d normalize( vTBN * clearcoatMapN );\n\t#else\n\t\tclearcoatNormal \x3d perturbNormal2Arb( - vViewPosition, clearcoatNormal, clearcoatMapN, faceDirection );\n\t#endif\n#endif",
clearcoat_pars_fragment:"#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif",iridescence_pars_fragment:"#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",output_fragment:"#ifdef OPAQUE\ndiffuseColor.a \x3d 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *\x3d material.transmissionAlpha + 0.1;\n#endif\ngl_FragColor \x3d vec4( outgoingLight, diffuseColor.a );",
packing:"vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale \x3d 256. / 255.;const float UnpackDownscale \x3d 255. / 256.;\nconst vec3 PackFactors \x3d vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors \x3d UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 \x3d 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r \x3d vec4( fract( v * PackFactors ), v );\n\tr.yzw -\x3d r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r \x3d vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}",
premultiplied_alpha_fragment:"#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *\x3d gl_FragColor.a;\n#endif",project_vertex:"vec4 mvPosition \x3d vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition \x3d instanceMatrix * mvPosition;\n#endif\nmvPosition \x3d modelViewMatrix * mvPosition;\ngl_Position \x3d projectionMatrix * mvPosition;",dithering_fragment:"#ifdef DITHERING\n\tgl_FragColor.rgb \x3d dithering( gl_FragColor.rgb );\n#endif",dithering_pars_fragment:"#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position \x3d rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB \x3d vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB \x3d mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
roughnessmap_fragment:"float roughnessFactor \x3d roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness \x3d texture2D( roughnessMap, vUv );\n\troughnessFactor *\x3d texelRoughness.g;\n#endif",roughnessmap_pars_fragment:"#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",shadowmap_pars_fragment:"#if NUM_SPOT_LIGHT_COORDS \x3e 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS \x3e 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS \x3e 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS \x3e 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS \x3e 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion \x3d 1.0;\n\t\tvec2 distribution \x3d texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow \x3d step( compare , distribution.x );\n\t\tif (hard_shadow !\x3d 1.0 ) {\n\t\t\tfloat distance \x3d compare - distribution.x ;\n\t\t\tfloat variance \x3d max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability \x3d variance / (variance + distance * distance );\t\t\tsoftness_probability \x3d clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion \x3d clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow \x3d 1.0;\n\t\tshadowCoord.xyz /\x3d shadowCoord.w;\n\t\tshadowCoord.z +\x3d shadowBias;\n\t\tbvec4 inFrustumVec \x3d bvec4 ( shadowCoord.x \x3e\x3d 0.0, shadowCoord.x \x3c\x3d 1.0, shadowCoord.y \x3e\x3d 0.0, shadowCoord.y \x3c\x3d 1.0 );\n\t\tbool inFrustum \x3d all( inFrustumVec );\n\t\tbvec2 frustumTestVec \x3d bvec2( inFrustum, shadowCoord.z \x3c\x3d 1.0 );\n\t\tbool frustumTest \x3d all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize \x3d vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 \x3d - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 \x3d - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 \x3d + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 \x3d + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 \x3d dx0 / 2.0;\n\t\t\tfloat dy2 \x3d dy0 / 2.0;\n\t\t\tfloat dx3 \x3d dx1 / 2.0;\n\t\t\tfloat dy3 \x3d dy1 / 2.0;\n\t\t\tshadow \x3d (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize \x3d vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx \x3d texelSize.x;\n\t\t\tfloat dy \x3d texelSize.y;\n\t\t\tvec2 uv \x3d shadowCoord.xy;\n\t\t\tvec2 f \x3d fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -\x3d f * texelSize;\n\t\t\tshadow \x3d (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t\tf.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow \x3d VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow \x3d texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV \x3d abs( v );\n\t\tfloat scaleToCube \x3d 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *\x3d scaleToCube;\n\t\tv *\x3d scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar \x3d v.xy;\n\t\tfloat almostATexel \x3d 1.5 * texelSizeY;\n\t\tfloat almostOne \x3d 1.0 - almostATexel;\n\t\tif ( absV.z \x3e\x3d almostOne ) {\n\t\t\tif ( v.z \x3e 0.0 )\n\t\t\t\tplanar.x \x3d 4.0 - v.x;\n\t\t} else if ( absV.x \x3e\x3d almostOne ) {\n\t\t\tfloat signX \x3d sign( v.x );\n\t\t\tplanar.x \x3d v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y \x3e\x3d almostOne ) {\n\t\t\tfloat signY \x3d sign( v.y );\n\t\t\tplanar.x \x3d v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y \x3d v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize \x3d vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition \x3d shadowCoord.xyz;\n\t\tfloat dp \x3d ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp +\x3d shadowBias;\n\t\tvec3 bd3D \x3d normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset \x3d vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
shadowmap_pars_vertex:"#if NUM_SPOT_LIGHT_COORDS \x3e 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS \x3e 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS \x3e 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS \x3e 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
shadowmap_vertex:"#if defined( USE_SHADOWMAP ) || ( NUM_SPOT_LIGHT_COORDS \x3e 0 )\n\t#if NUM_DIR_LIGHT_SHADOWS \x3e 0 || NUM_SPOT_LIGHT_COORDS \x3e 0 || NUM_POINT_LIGHT_SHADOWS \x3e 0\n\t\tvec3 shadowWorldNormal \x3d inverseTransformDirection( transformedNormal, viewMatrix );\n\t\tvec4 shadowWorldPosition;\n\t#endif\n\t#if NUM_DIR_LIGHT_SHADOWS \x3e 0\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition \x3d worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvDirectionalShadowCoord[ i ] \x3d directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_COORDS \x3e 0\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition \x3d worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) \x26\x26 UNROLLED_LOOP_INDEX \x3c NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz +\x3d shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] \x3d spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS \x3e 0\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tshadowWorldPosition \x3d worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\tvPointShadowCoord[ i ] \x3d pointShadowMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n#endif",
shadowmask_pars_fragment:"float getShadowMask() {\n\tfloat shadow \x3d 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS \x3e 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight \x3d directionalLightShadows[ i ];\n\t\tshadow *\x3d receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS \x3e 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight \x3d spotLightShadows[ i ];\n\t\tshadow *\x3d receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS \x3e 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight \x3d pointLightShadows[ i ];\n\t\tshadow *\x3d receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
skinbase_vertex:"#ifdef USE_SKINNING\n\tmat4 boneMatX \x3d getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY \x3d getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ \x3d getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW \x3d getBoneMatrix( skinIndex.w );\n#endif",skinning_pars_vertex:"#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j \x3d i * 4.0;\n\t\tfloat x \x3d mod( j, float( boneTextureSize ) );\n\t\tfloat y \x3d floor( j / float( boneTextureSize ) );\n\t\tfloat dx \x3d 1.0 / float( boneTextureSize );\n\t\tfloat dy \x3d 1.0 / float( boneTextureSize );\n\t\ty \x3d dy * ( y + 0.5 );\n\t\tvec4 v1 \x3d texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 \x3d texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 \x3d texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 \x3d texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone \x3d mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
skinning_vertex:"#ifdef USE_SKINNING\n\tvec4 skinVertex \x3d bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned \x3d vec4( 0.0 );\n\tskinned +\x3d boneMatX * skinVertex * skinWeight.x;\n\tskinned +\x3d boneMatY * skinVertex * skinWeight.y;\n\tskinned +\x3d boneMatZ * skinVertex * skinWeight.z;\n\tskinned +\x3d boneMatW * skinVertex * skinWeight.w;\n\ttransformed \x3d ( bindMatrixInverse * skinned ).xyz;\n#endif",skinnormal_vertex:"#ifdef USE_SKINNING\n\tmat4 skinMatrix \x3d mat4( 0.0 );\n\tskinMatrix +\x3d skinWeight.x * boneMatX;\n\tskinMatrix +\x3d skinWeight.y * boneMatY;\n\tskinMatrix +\x3d skinWeight.z * boneMatZ;\n\tskinMatrix +\x3d skinWeight.w * boneMatW;\n\tskinMatrix \x3d bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal \x3d vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent \x3d vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
specularmap_fragment:"float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular \x3d texture2D( specularMap, vUv );\n\tspecularStrength \x3d texelSpecular.r;\n#else\n\tspecularStrength \x3d 1.0;\n#endif",specularmap_pars_fragment:"#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",tonemapping_fragment:"#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb \x3d toneMapping( gl_FragColor.rgb );\n#endif",tonemapping_pars_fragment:"#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *\x3d toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *\x3d toneMappingExposure;\n\tcolor \x3d max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a \x3d v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b \x3d v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat \x3d mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat \x3d mat3(\n\t\tvec3(\t1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,\t1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,\t1.07602 )\n\t);\n\tcolor *\x3d toneMappingExposure / 0.6;\n\tcolor \x3d ACESInputMat * color;\n\tcolor \x3d RRTAndODTFit( color );\n\tcolor \x3d ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
transmission_fragment:"#ifdef USE_TRANSMISSION\n\tmaterial.transmission \x3d transmission;\n\tmaterial.transmissionAlpha \x3d 1.0;\n\tmaterial.thickness \x3d thickness;\n\tmaterial.attenuationDistance \x3d attenuationDistance;\n\tmaterial.attenuationColor \x3d attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *\x3d texture2D( transmissionMap, vUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *\x3d texture2D( thicknessMap, vUv ).g;\n\t#endif\n\tvec3 pos \x3d vWorldPosition;\n\tvec3 v \x3d normalize( cameraPosition - pos );\n\tvec3 n \x3d inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmission \x3d getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha \x3d mix( material.transmissionAlpha, transmission.a, material.transmission );\n\ttotalDiffuse \x3d mix( totalDiffuse, transmission.rgb, material.transmission );\n#endif",
transmission_pars_fragment:"#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector \x3d refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x \x3d length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y \x3d length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z \x3d length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat framebufferLod \x3d log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\t#ifdef texture2DLodEXT\n\t\t\treturn texture2DLodEXT( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#else\n\t\t\treturn texture2D( transmissionSamplerMap, fragCoord.xy, framebufferLod );\n\t\t#endif\n\t}\n\tvec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn radiance;\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient \x3d -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance \x3d exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance * radiance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay \x3d getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit \x3d position + transmissionRay;\n\t\tvec4 ndcPos \x3d projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords \x3d ndcPos.xy / ndcPos.w;\n\t\trefractionCoords +\x3d 1.0;\n\t\trefractionCoords /\x3d 2.0;\n\t\tvec4 transmittedLight \x3d getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 attenuatedColor \x3d applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 F \x3d EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );\n\t}\n#endif",
uv_pars_fragment:"#if ( defined( USE_UV ) \x26\x26 ! defined( UVS_VERTEX_ONLY ) )\n\tvarying vec2 vUv;\n#endif",uv_pars_vertex:"#ifdef USE_UV\n\t#ifdef UVS_VERTEX_ONLY\n\t\tvec2 vUv;\n\t#else\n\t\tvarying vec2 vUv;\n\t#endif\n\tuniform mat3 uvTransform;\n#endif",uv_vertex:"#ifdef USE_UV\n\tvUv \x3d ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif",uv2_pars_fragment:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif",uv2_pars_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n\tuniform mat3 uv2Transform;\n#endif",
uv2_vertex:"#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 \x3d ( uv2Transform * vec3( uv2, 1 ) ).xy;\n#endif",worldpos_vertex:"#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS \x3e 0\n\tvec4 worldPosition \x3d vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition \x3d instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition \x3d modelMatrix * worldPosition;\n#endif",background_vert:"varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv \x3d ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position \x3d vec4( position.xy, 1.0, 1.0 );\n}",
background_frag:"uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tgl_FragColor \x3d texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tgl_FragColor \x3d vec4( mix( pow( gl_FragColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), gl_FragColor.rgb * 0.0773993808, vec3( lessThanEqual( gl_FragColor.rgb, vec3( 0.04045 ) ) ) ), gl_FragColor.w );\n\t#endif\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n}",backgroundCube_vert:"varying vec3 vWorldDirection;\n#include \x3ccommon\x3e\nvoid main() {\n\tvWorldDirection \x3d transformDirection( position, modelMatrix );\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\tgl_Position.z \x3d gl_Position.w;\n}",
backgroundCube_frag:"#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nvarying vec3 vWorldDirection;\n#include \x3ccube_uv_reflection_fragment\x3e\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor \x3d textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor \x3d textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor \x3d vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\tgl_FragColor \x3d texColor;\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n}",
cube_vert:"varying vec3 vWorldDirection;\n#include \x3ccommon\x3e\nvoid main() {\n\tvWorldDirection \x3d transformDirection( position, modelMatrix );\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\tgl_Position.z \x3d gl_Position.w;\n}",cube_frag:"uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor \x3d textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor \x3d texColor;\n\tgl_FragColor.a *\x3d opacity;\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n}",
depth_vert:"#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include \x3cbeginnormal_vertex\x3e\n\t\t#include \x3cmorphnormal_vertex\x3e\n\t\t#include \x3cskinnormal_vertex\x3e\n\t#endif\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\tvHighPrecisionZW \x3d gl_Position.zw;\n}",
depth_frag:"#if DEPTH_PACKING \x3d\x3d 3200\n\tuniform float opacity;\n#endif\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( 1.0 );\n\t#if DEPTH_PACKING \x3d\x3d 3200\n\t\tdiffuseColor.a \x3d opacity;\n\t#endif\n\t#include \x3cmap_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3clogdepthbuf_fragment\x3e\n\tfloat fragCoordZ \x3d 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING \x3d\x3d 3200\n\t\tgl_FragColor \x3d vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING \x3d\x3d 3201\n\t\tgl_FragColor \x3d packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
distanceRGBA_vert:"#define DISTANCE\nvarying vec3 vWorldPosition;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include \x3cbeginnormal_vertex\x3e\n\t\t#include \x3cmorphnormal_vertex\x3e\n\t\t#include \x3cskinnormal_vertex\x3e\n\t#endif\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\tvWorldPosition \x3d worldPosition.xyz;\n}",
distanceRGBA_frag:"#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main () {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( 1.0 );\n\t#include \x3cmap_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\tfloat dist \x3d length( vWorldPosition - referencePosition );\n\tdist \x3d ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist \x3d saturate( dist );\n\tgl_FragColor \x3d packDepthToRGBA( dist );\n}",
equirect_vert:"varying vec3 vWorldDirection;\n#include \x3ccommon\x3e\nvoid main() {\n\tvWorldDirection \x3d transformDirection( position, modelMatrix );\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n}",equirect_frag:"uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include \x3ccommon\x3e\nvoid main() {\n\tvec3 direction \x3d normalize( vWorldDirection );\n\tvec2 sampleUV \x3d equirectUv( direction );\n\tgl_FragColor \x3d texture2D( tEquirect, sampleUV );\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n}",
linedashed_vert:"uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include \x3ccommon\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\tvLineDistance \x3d scale * lineDistance;\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
linedashed_frag:"uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include \x3ccommon\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tif ( mod( vLineDistance, totalSize ) \x3e dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight \x3d vec3( 0.0 );\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\toutgoingLight \x3d diffuseColor.rgb;\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n}",
meshbasic_vert:"#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cuv2_pars_vertex\x3e\n#include \x3cenvmap_pars_vertex\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cuv2_vertex\x3e\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include \x3cbeginnormal_vertex\x3e\n\t\t#include \x3cmorphnormal_vertex\x3e\n\t\t#include \x3cskinbase_vertex\x3e\n\t\t#include \x3cskinnormal_vertex\x3e\n\t\t#include \x3cdefaultnormal_vertex\x3e\n\t#endif\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cenvmap_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
meshbasic_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include \x3ccommon\x3e\n#include \x3cdithering_pars_fragment\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cuv2_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3caomap_pars_fragment\x3e\n#include \x3clightmap_pars_fragment\x3e\n#include \x3cenvmap_common_pars_fragment\x3e\n#include \x3cenvmap_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3cspecularmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3cspecularmap_fragment\x3e\n\tReflectedLight reflectedLight \x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel \x3d texture2D( lightMap, vUv2 );\n\t\treflectedLight.indirectDiffuse +\x3d lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse +\x3d vec3( 1.0 );\n\t#endif\n\t#include \x3caomap_fragment\x3e\n\treflectedLight.indirectDiffuse *\x3d diffuseColor.rgb;\n\tvec3 outgoingLight \x3d reflectedLight.indirectDiffuse;\n\t#include \x3cenvmap_fragment\x3e\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n\t#include \x3cdithering_fragment\x3e\n}",
meshlambert_vert:"#define LAMBERT\nvarying vec3 vViewPosition;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cuv2_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3cenvmap_pars_vertex\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cnormal_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3cshadowmap_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cuv2_vertex\x3e\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\tvViewPosition \x3d - mvPosition.xyz;\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cenvmap_vertex\x3e\n\t#include \x3cshadowmap_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
meshlambert_frag:"#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cdithering_pars_fragment\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cuv2_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3caomap_pars_fragment\x3e\n#include \x3clightmap_pars_fragment\x3e\n#include \x3cemissivemap_pars_fragment\x3e\n#include \x3cenvmap_common_pars_fragment\x3e\n#include \x3cenvmap_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3cbsdfs\x3e\n#include \x3clights_pars_begin\x3e\n#include \x3cnormal_pars_fragment\x3e\n#include \x3clights_lambert_pars_fragment\x3e\n#include \x3cshadowmap_pars_fragment\x3e\n#include \x3cbumpmap_pars_fragment\x3e\n#include \x3cnormalmap_pars_fragment\x3e\n#include \x3cspecularmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\tReflectedLight reflectedLight \x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance \x3d emissive;\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3cspecularmap_fragment\x3e\n\t#include \x3cnormal_fragment_begin\x3e\n\t#include \x3cnormal_fragment_maps\x3e\n\t#include \x3cemissivemap_fragment\x3e\n\t#include \x3clights_lambert_fragment\x3e\n\t#include \x3clights_fragment_begin\x3e\n\t#include \x3clights_fragment_maps\x3e\n\t#include \x3clights_fragment_end\x3e\n\t#include \x3caomap_fragment\x3e\n\tvec3 outgoingLight \x3d reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include \x3cenvmap_fragment\x3e\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n\t#include \x3cdithering_fragment\x3e\n}",
meshmatcap_vert:"#define MATCAP\nvarying vec3 vViewPosition;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cnormal_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n\tvViewPosition \x3d - mvPosition.xyz;\n}",
meshmatcap_frag:"#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include \x3ccommon\x3e\n#include \x3cdithering_pars_fragment\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3cnormal_pars_fragment\x3e\n#include \x3cbumpmap_pars_fragment\x3e\n#include \x3cnormalmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3cnormal_fragment_begin\x3e\n\t#include \x3cnormal_fragment_maps\x3e\n\tvec3 viewDir \x3d normalize( vViewPosition );\n\tvec3 x \x3d normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y \x3d cross( viewDir, x );\n\tvec2 uv \x3d vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor \x3d texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor \x3d vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight \x3d diffuseColor.rgb * matcapColor.rgb;\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n\t#include \x3cdithering_fragment\x3e\n}",
meshnormal_vert:"#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3cnormal_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvViewPosition \x3d - mvPosition.xyz;\n#endif\n}",
meshnormal_frag:"#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( TANGENTSPACE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#include \x3cpacking\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cnormal_pars_fragment\x3e\n#include \x3cbumpmap_pars_fragment\x3e\n#include \x3cnormalmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cnormal_fragment_begin\x3e\n\t#include \x3cnormal_fragment_maps\x3e\n\tgl_FragColor \x3d vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a \x3d 1.0;\n\t#endif\n}",
meshphong_vert:"#define PHONG\nvarying vec3 vViewPosition;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cuv2_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3cenvmap_pars_vertex\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cnormal_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3cshadowmap_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cuv2_vertex\x3e\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\tvViewPosition \x3d - mvPosition.xyz;\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cenvmap_vertex\x3e\n\t#include \x3cshadowmap_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
meshphong_frag:"#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cdithering_pars_fragment\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cuv2_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3caomap_pars_fragment\x3e\n#include \x3clightmap_pars_fragment\x3e\n#include \x3cemissivemap_pars_fragment\x3e\n#include \x3cenvmap_common_pars_fragment\x3e\n#include \x3cenvmap_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3cbsdfs\x3e\n#include \x3clights_pars_begin\x3e\n#include \x3cnormal_pars_fragment\x3e\n#include \x3clights_phong_pars_fragment\x3e\n#include \x3cshadowmap_pars_fragment\x3e\n#include \x3cbumpmap_pars_fragment\x3e\n#include \x3cnormalmap_pars_fragment\x3e\n#include \x3cspecularmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\tReflectedLight reflectedLight \x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance \x3d emissive;\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3cspecularmap_fragment\x3e\n\t#include \x3cnormal_fragment_begin\x3e\n\t#include \x3cnormal_fragment_maps\x3e\n\t#include \x3cemissivemap_fragment\x3e\n\t#include \x3clights_phong_fragment\x3e\n\t#include \x3clights_fragment_begin\x3e\n\t#include \x3clights_fragment_maps\x3e\n\t#include \x3clights_fragment_end\x3e\n\t#include \x3caomap_fragment\x3e\n\tvec3 outgoingLight \x3d reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include \x3cenvmap_fragment\x3e\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n\t#include \x3cdithering_fragment\x3e\n}",
meshphysical_vert:"#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cuv2_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cnormal_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3cshadowmap_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cuv2_vertex\x3e\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\tvViewPosition \x3d - mvPosition.xyz;\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cshadowmap_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n#ifdef USE_TRANSMISSION\n\tvWorldPosition \x3d worldPosition.xyz;\n#endif\n}",
meshphysical_frag:"#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cdithering_pars_fragment\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cuv2_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3caomap_pars_fragment\x3e\n#include \x3clightmap_pars_fragment\x3e\n#include \x3cemissivemap_pars_fragment\x3e\n#include \x3cbsdfs\x3e\n#include \x3ciridescence_fragment\x3e\n#include \x3ccube_uv_reflection_fragment\x3e\n#include \x3cenvmap_common_pars_fragment\x3e\n#include \x3cenvmap_physical_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3clights_pars_begin\x3e\n#include \x3cnormal_pars_fragment\x3e\n#include \x3clights_physical_pars_fragment\x3e\n#include \x3ctransmission_pars_fragment\x3e\n#include \x3cshadowmap_pars_fragment\x3e\n#include \x3cbumpmap_pars_fragment\x3e\n#include \x3cnormalmap_pars_fragment\x3e\n#include \x3cclearcoat_pars_fragment\x3e\n#include \x3ciridescence_pars_fragment\x3e\n#include \x3croughnessmap_pars_fragment\x3e\n#include \x3cmetalnessmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\tReflectedLight reflectedLight \x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance \x3d emissive;\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3croughnessmap_fragment\x3e\n\t#include \x3cmetalnessmap_fragment\x3e\n\t#include \x3cnormal_fragment_begin\x3e\n\t#include \x3cnormal_fragment_maps\x3e\n\t#include \x3cclearcoat_normal_fragment_begin\x3e\n\t#include \x3cclearcoat_normal_fragment_maps\x3e\n\t#include \x3cemissivemap_fragment\x3e\n\t#include \x3clights_physical_fragment\x3e\n\t#include \x3clights_fragment_begin\x3e\n\t#include \x3clights_fragment_maps\x3e\n\t#include \x3clights_fragment_end\x3e\n\t#include \x3caomap_fragment\x3e\n\tvec3 totalDiffuse \x3d reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular \x3d reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include \x3ctransmission_fragment\x3e\n\tvec3 outgoingLight \x3d totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp \x3d 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight \x3d outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc \x3d saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc \x3d F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight \x3d outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n\t#include \x3cdithering_fragment\x3e\n}",
meshtoon_vert:"#define TOON\nvarying vec3 vViewPosition;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cuv2_pars_vertex\x3e\n#include \x3cdisplacementmap_pars_vertex\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cnormal_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3cshadowmap_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\t#include \x3cuv2_vertex\x3e\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cdisplacementmap_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\tvViewPosition \x3d - mvPosition.xyz;\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cshadowmap_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
meshtoon_frag:"#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cdithering_pars_fragment\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cuv2_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3caomap_pars_fragment\x3e\n#include \x3clightmap_pars_fragment\x3e\n#include \x3cemissivemap_pars_fragment\x3e\n#include \x3cgradientmap_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3cbsdfs\x3e\n#include \x3clights_pars_begin\x3e\n#include \x3cnormal_pars_fragment\x3e\n#include \x3clights_toon_pars_fragment\x3e\n#include \x3cshadowmap_pars_fragment\x3e\n#include \x3cbumpmap_pars_fragment\x3e\n#include \x3cnormalmap_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\tReflectedLight reflectedLight \x3d ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance \x3d emissive;\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\t#include \x3cnormal_fragment_begin\x3e\n\t#include \x3cnormal_fragment_maps\x3e\n\t#include \x3cemissivemap_fragment\x3e\n\t#include \x3clights_toon_fragment\x3e\n\t#include \x3clights_fragment_begin\x3e\n\t#include \x3clights_fragment_maps\x3e\n\t#include \x3clights_fragment_end\x3e\n\t#include \x3caomap_fragment\x3e\n\tvec3 outgoingLight \x3d reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n\t#include \x3cdithering_fragment\x3e\n}",
points_vert:"uniform float size;\nuniform float scale;\n#include \x3ccommon\x3e\n#include \x3ccolor_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3ccolor_vertex\x3e\n\t#include \x3cmorphcolor_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\tgl_PointSize \x3d size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective \x3d isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *\x3d ( scale / - mvPosition.z );\n\t#endif\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
points_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include \x3ccommon\x3e\n#include \x3ccolor_pars_fragment\x3e\n#include \x3cmap_particle_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec3 outgoingLight \x3d vec3( 0.0 );\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_particle_fragment\x3e\n\t#include \x3ccolor_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\toutgoingLight \x3d diffuseColor.rgb;\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n\t#include \x3cpremultiplied_alpha_fragment\x3e\n}",
shadow_vert:"#include \x3ccommon\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3cmorphtarget_pars_vertex\x3e\n#include \x3cskinning_pars_vertex\x3e\n#include \x3cshadowmap_pars_vertex\x3e\nvoid main() {\n\t#include \x3cbeginnormal_vertex\x3e\n\t#include \x3cmorphnormal_vertex\x3e\n\t#include \x3cskinbase_vertex\x3e\n\t#include \x3cskinnormal_vertex\x3e\n\t#include \x3cdefaultnormal_vertex\x3e\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cmorphtarget_vertex\x3e\n\t#include \x3cskinning_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\t#include \x3cworldpos_vertex\x3e\n\t#include \x3cshadowmap_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
shadow_frag:"uniform vec3 color;\nuniform float opacity;\n#include \x3ccommon\x3e\n#include \x3cpacking\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3cbsdfs\x3e\n#include \x3clights_pars_begin\x3e\n#include \x3cshadowmap_pars_fragment\x3e\n#include \x3cshadowmask_pars_fragment\x3e\nvoid main() {\n\tgl_FragColor \x3d vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n}",sprite_vert:"uniform float rotation;\nuniform vec2 center;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_vertex\x3e\n#include \x3cfog_pars_vertex\x3e\n#include \x3clogdepthbuf_pars_vertex\x3e\n#include \x3cclipping_planes_pars_vertex\x3e\nvoid main() {\n\t#include \x3cuv_vertex\x3e\n\tvec4 mvPosition \x3d modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x \x3d length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y \x3d length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective \x3d isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *\x3d - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition \x3d ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x \x3d cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y \x3d sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy +\x3d rotatedPosition;\n\tgl_Position \x3d projectionMatrix * mvPosition;\n\t#include \x3clogdepthbuf_vertex\x3e\n\t#include \x3cclipping_planes_vertex\x3e\n\t#include \x3cfog_vertex\x3e\n}",
sprite_frag:"uniform vec3 diffuse;\nuniform float opacity;\n#include \x3ccommon\x3e\n#include \x3cuv_pars_fragment\x3e\n#include \x3cmap_pars_fragment\x3e\n#include \x3calphamap_pars_fragment\x3e\n#include \x3calphatest_pars_fragment\x3e\n#include \x3cfog_pars_fragment\x3e\n#include \x3clogdepthbuf_pars_fragment\x3e\n#include \x3cclipping_planes_pars_fragment\x3e\nvoid main() {\n\t#include \x3cclipping_planes_fragment\x3e\n\tvec3 outgoingLight \x3d vec3( 0.0 );\n\tvec4 diffuseColor \x3d vec4( diffuse, opacity );\n\t#include \x3clogdepthbuf_fragment\x3e\n\t#include \x3cmap_fragment\x3e\n\t#include \x3calphamap_fragment\x3e\n\t#include \x3calphatest_fragment\x3e\n\toutgoingLight \x3d diffuseColor.rgb;\n\t#include \x3coutput_fragment\x3e\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\t#include \x3cfog_fragment\x3e\n}"},
UniformsLib={common:{diffuse:{value:new Color(16777215)},opacity:{value:1},map:{value:null},uvTransform:{value:new Matrix3},uv2Transform:{value:new Matrix3},alphaMap:{value:null},alphaTest:{value:0}},specularmap:{specularMap:{value:null}},envmap:{envMap:{value:null},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1}},emissivemap:{emissiveMap:{value:null}},
bumpmap:{bumpMap:{value:null},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalScale:{value:new Vector2(1,1)}},displacementmap:{displacementMap:{value:null},displacementScale:{value:1},displacementBias:{value:0}},roughnessmap:{roughnessMap:{value:null}},metalnessmap:{metalnessMap:{value:null}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:2.5E-4},fogNear:{value:1},fogFar:{value:2E3},fogColor:{value:new Color(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},
directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},
spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},
points:{diffuse:{value:new Color(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3}},sprite:{diffuse:{value:new Color(16777215)},opacity:{value:1},center:{value:new Vector2(.5,.5)},rotation:{value:0},map:{value:null},alphaMap:{value:null},alphaTest:{value:0},uvTransform:{value:new Matrix3}}},ShaderLib={basic:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,
UniformsLib.lightmap,UniformsLib.fog]),vertexShader:ShaderChunk.meshbasic_vert,fragmentShader:ShaderChunk.meshbasic_frag},lambert:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshlambert_vert,fragmentShader:ShaderChunk.meshlambert_frag},
phong:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.specularmap,UniformsLib.envmap,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},specular:{value:new Color(1118481)},shininess:{value:30}}]),vertexShader:ShaderChunk.meshphong_vert,fragmentShader:ShaderChunk.meshphong_frag},standard:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.envmap,
UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.roughnessmap,UniformsLib.metalnessmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag},toon:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.aomap,UniformsLib.lightmap,UniformsLib.emissivemap,
UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.gradientmap,UniformsLib.fog,UniformsLib.lights,{emissive:{value:new Color(0)}}]),vertexShader:ShaderChunk.meshtoon_vert,fragmentShader:ShaderChunk.meshtoon_frag},matcap:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,UniformsLib.fog,{matcap:{value:null}}]),vertexShader:ShaderChunk.meshmatcap_vert,fragmentShader:ShaderChunk.meshmatcap_frag},points:{uniforms:mergeUniforms([UniformsLib.points,
UniformsLib.fog]),vertexShader:ShaderChunk.points_vert,fragmentShader:ShaderChunk.points_frag},dashed:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:ShaderChunk.linedashed_vert,fragmentShader:ShaderChunk.linedashed_frag},depth:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap]),vertexShader:ShaderChunk.depth_vert,fragmentShader:ShaderChunk.depth_frag},normal:{uniforms:mergeUniforms([UniformsLib.common,
UniformsLib.bumpmap,UniformsLib.normalmap,UniformsLib.displacementmap,{opacity:{value:1}}]),vertexShader:ShaderChunk.meshnormal_vert,fragmentShader:ShaderChunk.meshnormal_frag},sprite:{uniforms:mergeUniforms([UniformsLib.sprite,UniformsLib.fog]),vertexShader:ShaderChunk.sprite_vert,fragmentShader:ShaderChunk.sprite_frag},background:{uniforms:{uvTransform:{value:new Matrix3},t2D:{value:null}},vertexShader:ShaderChunk.background_vert,fragmentShader:ShaderChunk.background_frag},backgroundCube:{uniforms:{envMap:{value:null},
flipEnvMap:{value:-1},backgroundBlurriness:{value:0}},vertexShader:ShaderChunk.backgroundCube_vert,fragmentShader:ShaderChunk.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:ShaderChunk.cube_vert,fragmentShader:ShaderChunk.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:ShaderChunk.equirect_vert,fragmentShader:ShaderChunk.equirect_frag},distanceRGBA:{uniforms:mergeUniforms([UniformsLib.common,UniformsLib.displacementmap,
{referencePosition:{value:new Vector3},nearDistance:{value:1},farDistance:{value:1E3}}]),vertexShader:ShaderChunk.distanceRGBA_vert,fragmentShader:ShaderChunk.distanceRGBA_frag},shadow:{uniforms:mergeUniforms([UniformsLib.lights,UniformsLib.fog,{color:{value:new Color(0)},opacity:{value:1}}]),vertexShader:ShaderChunk.shadow_vert,fragmentShader:ShaderChunk.shadow_frag}};ShaderLib.physical={uniforms:mergeUniforms([ShaderLib.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatRoughness:{value:0},
clearcoatRoughnessMap:{value:null},clearcoatNormalScale:{value:new Vector2(1,1)},clearcoatNormalMap:{value:null},iridescence:{value:0},iridescenceMap:{value:null},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},sheen:{value:0},sheenColor:{value:new Color(0)},sheenColorMap:{value:null},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},transmission:{value:0},transmissionMap:{value:null},transmissionSamplerSize:{value:new Vector2},
transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},attenuationDistance:{value:0},attenuationColor:{value:new Color(0)},specularIntensity:{value:1},specularIntensityMap:{value:null},specularColor:{value:new Color(1,1,1)},specularColorMap:{value:null}}]),vertexShader:ShaderChunk.meshphysical_vert,fragmentShader:ShaderChunk.meshphysical_frag};class OrthographicCamera extends Camera{constructor(left=-1,right=1,top=1,bottom=-1,near=.1,far=2E3){super();this.isOrthographicCamera=
!0;this.type="OrthographicCamera";this.zoom=1;this.view=null;this.left=left;this.right=right;this.top=top;this.bottom=bottom;this.near=near;this.far=far;this.updateProjectionMatrix()}copy(source,recursive){super.copy(source,recursive);this.left=source.left;this.right=source.right;this.top=source.top;this.bottom=source.bottom;this.near=source.near;this.far=source.far;this.zoom=source.zoom;this.view=null===source.view?null:Object.assign({},source.view);return this}setViewOffset(fullWidth,fullHeight,
x,y,width,height){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1});this.view.enabled=!0;this.view.fullWidth=fullWidth;this.view.fullHeight=fullHeight;this.view.offsetX=x;this.view.offsetY=y;this.view.width=width;this.view.height=height;this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1);this.updateProjectionMatrix()}updateProjectionMatrix(){var dx=(this.right-this.left)/(2*this.zoom),dy=(this.top-this.bottom)/
(2*this.zoom),cx=(this.right+this.left)/2,cy=(this.top+this.bottom)/2;let left=cx-dx;cx+=dx;dx=cy+dy;dy=cy-dy;null!==this.view&&this.view.enabled&&(cy=(this.right-this.left)/this.view.fullWidth/this.zoom,dy=(this.top-this.bottom)/this.view.fullHeight/this.zoom,left+=cy*this.view.offsetX,cx=left+cy*this.view.width,dx-=dy*this.view.offsetY,dy=dx-dy*this.view.height);this.projectionMatrix.makeOrthographic(left,cx,dx,dy,this.near,this.far);this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(meta){meta=
super.toJSON(meta);meta.object.zoom=this.zoom;meta.object.left=this.left;meta.object.right=this.right;meta.object.top=this.top;meta.object.bottom=this.bottom;meta.object.near=this.near;meta.object.far=this.far;null!==this.view&&(meta.object.view=Object.assign({},this.view));return meta}}const EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],_flatCamera=new OrthographicCamera,_clearColor=new Color;let _oldTarget=null;const PHI=(1+Math.sqrt(5))/2,INV_PHI=1/PHI,_axisDirections=[new Vector3(1,1,1),new Vector3(-1,
1,1),new Vector3(1,1,-1),new Vector3(-1,1,-1),new Vector3(0,PHI,INV_PHI),new Vector3(0,PHI,-INV_PHI),new Vector3(INV_PHI,0,PHI),new Vector3(-INV_PHI,0,PHI),new Vector3(PHI,INV_PHI,0),new Vector3(-PHI,INV_PHI,0)];class PMREMGenerator{constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;this._cubeSize=this._lodMax=0;this._lodPlanes=[];this._sizeLods=[];this._sigmas=[];this._equirectMaterial=this._cubemapMaterial=this._blurMaterial=null;this._compileMaterial(this._blurMaterial)}fromScene(scene,
sigma=0,near=.1,far=100){_oldTarget=this._renderer.getRenderTarget();this._setSize(256);const cubeUVRenderTarget=this._allocateTargets();cubeUVRenderTarget.depthBuffer=!0;this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);0<sigma&&this._blur(cubeUVRenderTarget,0,0,sigma);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget}fromEquirectangular(equirectangular,renderTarget=null){return this._fromTexture(equirectangular,renderTarget)}fromCubemap(cubemap,
renderTarget=null){return this._fromTexture(cubemap,renderTarget)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose();null!==this._cubemapMaterial&&this._cubemapMaterial.dispose();null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(cubeSize){this._lodMax=
Math.floor(Math.log2(cubeSize));this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose();null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let i=0;i<this._lodPlanes.length;i++)this._lodPlanes[i].dispose()}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=!1;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height)}_fromTexture(texture,renderTarget){301===texture.mapping||
302===texture.mapping?this._setSize(0===texture.image.length?16:texture.image[0].width||texture.image[0].image.width):this._setSize(texture.image.width/4);_oldTarget=this._renderer.getRenderTarget();renderTarget=renderTarget||this._allocateTargets();this._textureToCubeUV(texture,renderTarget);this._applyPMREM(renderTarget);this._cleanup(renderTarget);return renderTarget}_allocateTargets(){const width=3*Math.max(this._cubeSize,112),height=4*this._cubeSize;var params={magFilter:1006,minFilter:1006,
generateMipmaps:!1,type:1016,format:1023,encoding:3E3,depthBuffer:!1};const cubeUVRenderTarget=_createRenderTarget(width,height,params);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==width){null!==this._pingPongRenderTarget&&this._dispose();this._pingPongRenderTarget=_createRenderTarget(width,height,params);var {_lodMax}=this;params=_lodMax;var lodPlanes=[];const sizeLods=[],sigmas=[];let lod=params;const totalLods=params-4+1+EXTRA_LOD_SIGMA.length;for(let i=0;i<totalLods;i++){var sizeLod=
Math.pow(2,lod);sizeLods.push(sizeLod);var sigma=1/sizeLod;i>params-4?sigma=EXTRA_LOD_SIGMA[i-params+4-1]:0===i&&(sigma=0);sigmas.push(sigma);sigma=1/(sizeLod-2);sizeLod=-sigma;sigma=1+sigma;var uv1=[sizeLod,sizeLod,sigma,sizeLod,sigma,sigma,sizeLod,sizeLod,sigma,sigma,sizeLod,sigma];sizeLod=new Float32Array(108);sigma=new Float32Array(72);const faceIndex=new Float32Array(36);for(let face=0;6>face;face++){const x=face%3*2/3-1,y=2<face?0:-1;sizeLod.set([x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,
0,x,y+1,0],18*face);sigma.set(uv1,12*face);faceIndex.set([face,face,face,face,face,face],6*face)}uv1=new BufferGeometry;uv1.setAttribute("position",new BufferAttribute(sizeLod,3));uv1.setAttribute("uv",new BufferAttribute(sigma,2));uv1.setAttribute("faceIndex",new BufferAttribute(faceIndex,1));lodPlanes.push(uv1);4<lod&&lod--}({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}={lodPlanes,sizeLods,sigmas});params=_lodMax;_lodMax=new Float32Array(20);lodPlanes=new Vector3(0,1,0);
this._blurMaterial=new ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/width,CUBEUV_TEXEL_HEIGHT:1/height,CUBEUV_MAX_MIP:`${params}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:_lodMax},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:lodPlanes}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include \x3ccube_uv_reflection_fragment\x3e\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta \x3d cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection \x3d vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis \x3d latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis \x3d vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis \x3d normalize( axis );\n\n\t\t\t\tgl_FragColor \x3d vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb +\x3d weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i \x3d 1; i \x3c n; i++ ) {\n\n\t\t\t\t\tif ( i \x3e\x3d samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta \x3d dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb +\x3d weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb +\x3d weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
blending:0,depthTest:!1,depthWrite:!1})}return cubeUVRenderTarget}_compileMaterial(material){material=new Mesh(this._lodPlanes[0],material);this._renderer.compile(material,_flatCamera)}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget){near=new PerspectiveCamera(90,1,near,far);far=[1,-1,1,1,1,1];const forwardSign=[1,1,1,-1,-1,-1],renderer=this._renderer,originalAutoClear=renderer.autoClear,toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);renderer.toneMapping=0;renderer.autoClear=
!1;var backgroundMaterial=new MeshBasicMaterial({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1});const backgroundBox=new Mesh(new BoxGeometry,backgroundMaterial);let useSolidColor=!1;const background=scene.background;background?background.isColor&&(backgroundMaterial.color.copy(background),scene.background=null,useSolidColor=!0):(backgroundMaterial.color.copy(_clearColor),useSolidColor=!0);for(backgroundMaterial=0;6>backgroundMaterial;backgroundMaterial++){const col=backgroundMaterial%
3;0===col?(near.up.set(0,far[backgroundMaterial],0),near.lookAt(forwardSign[backgroundMaterial],0,0)):1===col?(near.up.set(0,0,far[backgroundMaterial]),near.lookAt(0,forwardSign[backgroundMaterial],0)):(near.up.set(0,far[backgroundMaterial],0),near.lookAt(0,0,forwardSign[backgroundMaterial]));const size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,2<backgroundMaterial?size:0,size,size);renderer.setRenderTarget(cubeUVRenderTarget);useSolidColor&&renderer.render(backgroundBox,near);renderer.render(scene,
near)}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.autoClear=originalAutoClear;scene.background=background}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer;var isCubeTexture=301===texture.mapping||302===texture.mapping;isCubeTexture?(null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===texture.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&
(this._equirectMaterial=_getEquirectMaterial());const material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial;isCubeTexture=new Mesh(this._lodPlanes[0],material);material.uniforms.envMap.value=texture;texture=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*texture,2*texture);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(isCubeTexture,_flatCamera)}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer,autoClear=renderer.autoClear;renderer.autoClear=!1;for(let i=
1;i<this._lodPlanes.length;i++)this._blur(cubeUVRenderTarget,i-1,i,Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),_axisDirections[(i-1)%_axisDirections.length]);renderer.autoClear=autoClear}_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,"latitudinal",poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,
"longitudinal",poleAxis)}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer;var blurMaterial=this._blurMaterial;"latitudinal"!==direction&&"longitudinal"!==direction&&console.error("blur direction must be either latitudinal or longitudinal!");const blurMesh=new Mesh(this._lodPlanes[lodOut],blurMaterial);blurMaterial=blurMaterial.uniforms;var pixels=this._sizeLods[lodIn]-1;pixels=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/39;var sigmaPixels=
sigmaRadians/pixels;const samples=isFinite(sigmaRadians)?1+Math.floor(3*sigmaPixels):20;20<samples&&console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${20}`);sigmaRadians=[];let sum=0;for(let i=0;20>i;++i){var x=i/sigmaPixels;x=Math.exp(-x*x/2);sigmaRadians.push(x);0===i?sum+=x:i<samples&&(sum+=2*x)}for(sigmaPixels=0;sigmaPixels<sigmaRadians.length;sigmaPixels++)sigmaRadians[sigmaPixels]/=sum;blurMaterial.envMap.value=
targetIn.texture;blurMaterial.samples.value=samples;blurMaterial.weights.value=sigmaRadians;blurMaterial.latitudinal.value="latitudinal"===direction;poleAxis&&(blurMaterial.poleAxis.value=poleAxis);({_lodMax:targetIn}=this);blurMaterial.dTheta.value=pixels;blurMaterial.mipInt.value=targetIn-lodIn;lodIn=this._sizeLods[lodOut];_setViewport(targetOut,3*lodIn*(lodOut>targetIn-4?lodOut-targetIn+4:0),4*(this._cubeSize-lodIn),3*lodIn,2*lodIn);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,
_flatCamera)}}const emptyTexture=new Texture,emptyArrayTexture=new DataArrayTexture,empty3dTexture=new Data3DTexture,emptyCubeTexture=new CubeTexture,arrayCacheF32=[],arrayCacheI32=[],mat4array=new Float32Array(16),mat3array=new Float32Array(9),mat2array=new Float32Array(4);class SingleUniform{constructor(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=[];this.setValue=getSingularSetter(activeInfo.type)}}class PureArrayUniform{constructor(id,activeInfo,addr){this.id=id;this.addr=addr;this.cache=
[];this.size=activeInfo.size;this.setValue=getPureArraySetter(activeInfo.type)}}class StructuredUniform{constructor(id){this.id=id;this.seq=[];this.map={}}setValue(gl,value,textures){const seq=this.seq;for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];u.setValue(gl,value[u.id],textures)}}}const RePathPart=/(\w+)(\])?(\[|\.)?/g;class WebGLUniforms{constructor(gl,program){this.seq=[];this.map={};const n=gl.getProgramParameter(program,gl.ACTIVE_UNIFORMS);for(let i=0;i<n;++i){var info=gl.getActiveUniform(program,
i),addr=gl.getUniformLocation(program,info.name),container=this,path=info.name;const pathLength=path.length;for(RePathPart.lastIndex=0;;){const match=RePathPart.exec(path),matchEnd=RePathPart.lastIndex;var id=match[1],subscript=match[3];"]"===match[2]&&(id|=0);if(void 0===subscript||"["===subscript&&matchEnd+2===pathLength){path=container;info=void 0===subscript?new SingleUniform(id,info,addr):new PureArrayUniform(id,info,addr);path.seq.push(info);path.map[info.id]=info;break}else subscript=container.map[id],
void 0===subscript&&(subscript=new StructuredUniform(id),id=container,container=subscript,id.seq.push(container),id.map[container.id]=container),container=subscript}}}setValue(gl,name,value,textures){name=this.map[name];void 0!==name&&name.setValue(gl,value,textures)}setOptional(gl,object,name){object=object[name];void 0!==object&&this.setValue(gl,name,object)}static upload(gl,seq,values,textures){for(let i=0,n=seq.length;i!==n;++i){const u=seq[i],v=values[u.id];!1!==v.needsUpdate&&u.setValue(gl,
v.value,textures)}}static seqWithValue(seq,values){const r=[];for(let i=0,n=seq.length;i!==n;++i){const u=seq[i];u.id in values&&r.push(u)}return r}}let programIdCount=0;const includePattern=/^[ \t]*#include +<([\w\d./]+)>/gm,unrollLoopPattern=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;let _id=0;class WebGLShaderCache{constructor(){this.shaderCache=new Map;this.materialCache=new Map}update(material){var fragmentShader=
material.fragmentShader;const vertexShaderStage=this._getShaderStage(material.vertexShader);fragmentShader=this._getShaderStage(fragmentShader);material=this._getShaderCacheForMaterial(material);!1===material.has(vertexShaderStage)&&(material.add(vertexShaderStage),vertexShaderStage.usedTimes++);!1===material.has(fragmentShader)&&(material.add(fragmentShader),fragmentShader.usedTimes++);return this}remove(material){const materialShaders=this.materialCache.get(material);for(const shaderStage of materialShaders)shaderStage.usedTimes--,
0===shaderStage.usedTimes&&this.shaderCache.delete(shaderStage.code);this.materialCache.delete(material);return this}getVertexShaderID(material){return this._getShaderStage(material.vertexShader).id}getFragmentShaderID(material){return this._getShaderStage(material.fragmentShader).id}dispose(){this.shaderCache.clear();this.materialCache.clear()}_getShaderCacheForMaterial(material){const cache=this.materialCache;let set=cache.get(material);void 0===set&&(set=new Set,cache.set(material,set));return set}_getShaderStage(code){const cache=
this.shaderCache;let stage=cache.get(code);void 0===stage&&(stage=new WebGLShaderStage(code),cache.set(code,stage));return stage}}class WebGLShaderStage{constructor(code){this.id=_id++;this.code=code;this.usedTimes=0}}let nextVersion=0;class MeshDepthMaterial extends Material{constructor(parameters){super();this.isMeshDepthMaterial=!0;this.type="MeshDepthMaterial";this.depthPacking=3200;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=
!1;this.wireframeLinewidth=1;this.setValues(parameters)}copy(source){super.copy(source);this.depthPacking=source.depthPacking;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;return this}}class MeshDistanceMaterial extends Material{constructor(parameters){super();this.isMeshDistanceMaterial=
!0;this.type="MeshDistanceMaterial";this.referencePosition=new Vector3;this.nearDistance=1;this.farDistance=1E3;this.displacementMap=this.alphaMap=this.map=null;this.displacementScale=1;this.displacementBias=0;this.setValues(parameters)}copy(source){super.copy(source);this.referencePosition.copy(source.referencePosition);this.nearDistance=source.nearDistance;this.farDistance=source.farDistance;this.map=source.map;this.alphaMap=source.alphaMap;this.displacementMap=source.displacementMap;this.displacementScale=
source.displacementScale;this.displacementBias=source.displacementBias;return this}}class ArrayCamera extends PerspectiveCamera{constructor(array=[]){super();this.isArrayCamera=!0;this.cameras=array}}class Group extends Object3D{constructor(){super();this.isGroup=!0;this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._hand=this._grip=this._targetRay=null}getHandSpace(){null===this._hand&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=
!1,this._hand.joints={},this._hand.inputState={pinching:!1});return this._hand}getTargetRaySpace(){null===this._targetRay&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3);return this._targetRay}getGripSpace(){null===this._grip&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=
!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3);return this._grip}dispatchEvent(event){null!==this._targetRay&&this._targetRay.dispatchEvent(event);null!==this._grip&&this._grip.dispatchEvent(event);null!==this._hand&&this._hand.dispatchEvent(event);return this}disconnect(inputSource){this.dispatchEvent({type:"disconnected",data:inputSource});null!==this._targetRay&&(this._targetRay.visible=!1);null!==
this._grip&&(this._grip.visible=!1);null!==this._hand&&(this._hand.visible=!1);return this}update(inputSource,frame,referenceSpace){let inputPose=null,gripPose=null,handPose=null;const targetRay=this._targetRay,grip=this._grip,hand=this._hand;if(inputSource&&"visible-blurred"!==frame.session.visibilityState){if(hand&&inputSource.hand){handPose=!0;for(var inputjoint of inputSource.hand.values()){const jointPose=frame.getJointPose(inputjoint,referenceSpace);if(void 0===hand.joints[inputjoint.jointName]){var joint=
new Group;joint.matrixAutoUpdate=!1;joint.visible=!1;hand.joints[inputjoint.jointName]=joint;hand.add(joint)}joint=hand.joints[inputjoint.jointName];null!==jointPose&&(joint.matrix.fromArray(jointPose.transform.matrix),joint.matrix.decompose(joint.position,joint.rotation,joint.scale),joint.jointRadius=jointPose.radius);joint.visible=null!==jointPose}inputjoint=hand.joints["index-finger-tip"].position.distanceTo(hand.joints["thumb-tip"].position);hand.inputState.pinching&&.025<inputjoint?(hand.inputState.pinching=
!1,this.dispatchEvent({type:"pinchend",handedness:inputSource.handedness,target:this})):!hand.inputState.pinching&&.015>=inputjoint&&(hand.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:inputSource.handedness,target:this}))}else null!==grip&&inputSource.gripSpace&&(gripPose=frame.getPose(inputSource.gripSpace,referenceSpace),null!==gripPose&&(grip.matrix.fromArray(gripPose.transform.matrix),grip.matrix.decompose(grip.position,grip.rotation,grip.scale),gripPose.linearVelocity?
(grip.hasLinearVelocity=!0,grip.linearVelocity.copy(gripPose.linearVelocity)):grip.hasLinearVelocity=!1,gripPose.angularVelocity?(grip.hasAngularVelocity=!0,grip.angularVelocity.copy(gripPose.angularVelocity)):grip.hasAngularVelocity=!1));null!==targetRay&&(inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace),null===inputPose&&null!==gripPose&&(inputPose=gripPose),null!==inputPose&&(targetRay.matrix.fromArray(inputPose.transform.matrix),targetRay.matrix.decompose(targetRay.position,
targetRay.rotation,targetRay.scale),inputPose.linearVelocity?(targetRay.hasLinearVelocity=!0,targetRay.linearVelocity.copy(inputPose.linearVelocity)):targetRay.hasLinearVelocity=!1,inputPose.angularVelocity?(targetRay.hasAngularVelocity=!0,targetRay.angularVelocity.copy(inputPose.angularVelocity)):targetRay.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}null!==targetRay&&(targetRay.visible=null!==inputPose);null!==grip&&(grip.visible=null!==gripPose);null!==hand&&(hand.visible=null!==handPose);
return this}}class DepthTexture extends Texture{constructor(width,height,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format){format=void 0!==format?format:1026;if(1026!==format&&1027!==format)throw Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");void 0===type&&1026===format&&(type=1014);void 0===type&&1027===format&&(type=1020);super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.isDepthTexture=!0;this.image={width,height};
this.magFilter=void 0!==magFilter?magFilter:1003;this.minFilter=void 0!==minFilter?minFilter:1003;this.generateMipmaps=this.flipY=!1}}class WebXRManager extends EventDispatcher{constructor(renderer,gl){function onSessionEvent(event){var controllerIndex=controllerInputSources.indexOf(event.inputSource);-1!==controllerIndex&&(controllerIndex=controllers[controllerIndex],void 0!==controllerIndex&&controllerIndex.dispatchEvent({type:event.type,data:event.inputSource}))}function onSessionEnd(){session.removeEventListener("select",
onSessionEvent);session.removeEventListener("selectstart",onSessionEvent);session.removeEventListener("selectend",onSessionEvent);session.removeEventListener("squeeze",onSessionEvent);session.removeEventListener("squeezestart",onSessionEvent);session.removeEventListener("squeezeend",onSessionEvent);session.removeEventListener("end",onSessionEnd);session.removeEventListener("inputsourceschange",onInputSourcesChange);for(let i=0;i<controllers.length;i++){const inputSource=controllerInputSources[i];
null!==inputSource&&(controllerInputSources[i]=null,controllers[i].disconnect(inputSource))}_currentDepthFar=_currentDepthNear=null;renderer.setRenderTarget(initialRenderTarget);newRenderTarget=session=glBinding=glProjLayer=glBaseLayer=null;animation.stop();scope.isPresenting=!1;scope.dispatchEvent({type:"sessionend"})}function onInputSourcesChange(event){for(var i$jscomp$0=0;i$jscomp$0<event.removed.length;i$jscomp$0++){var inputSource=event.removed[i$jscomp$0],index=controllerInputSources.indexOf(inputSource);
0<=index&&(controllerInputSources[index]=null,controllers[index].dispatchEvent({type:"disconnected",data:inputSource}))}for(i$jscomp$0=0;i$jscomp$0<event.added.length;i$jscomp$0++){inputSource=event.added[i$jscomp$0];index=controllerInputSources.indexOf(inputSource);if(-1===index){for(let i=0;i<controllers.length;i++)if(i>=controllerInputSources.length){controllerInputSources.push(inputSource);index=i;break}else if(null===controllerInputSources[i]){controllerInputSources[i]=inputSource;index=i;break}if(-1===
index)break}(index=controllers[index])&&index.dispatchEvent({type:"connected",data:inputSource})}}function updateCamera(camera,parent){null===parent?camera.matrixWorld.copy(camera.matrix):camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix);camera.matrixWorldInverse.copy(camera.matrixWorld).invert()}super();const scope=this;let session=null,framebufferScaleFactor=1,referenceSpace=null,referenceSpaceType="local-floor",customReferenceSpace=null,pose=null,glBinding=null,glProjLayer=
null,glBaseLayer=null,xrFrame=null;const attributes=gl.getContextAttributes();let initialRenderTarget=null,newRenderTarget=null;const controllers=[],controllerInputSources=[],cameraL=new PerspectiveCamera;cameraL.layers.enable(1);cameraL.viewport=new Vector4;const cameraR=new PerspectiveCamera;cameraR.layers.enable(2);cameraR.viewport=new Vector4;const cameras=[cameraL,cameraR],cameraVR=new ArrayCamera;cameraVR.layers.enable(1);cameraVR.layers.enable(2);let _currentDepthNear=null,_currentDepthFar=
null;this.cameraAutoUpdate=!0;this.isPresenting=this.enabled=!1;this.getController=function(index){let controller=controllers[index];void 0===controller&&(controller=new WebXRController,controllers[index]=controller);return controller.getTargetRaySpace()};this.getControllerGrip=function(index){let controller=controllers[index];void 0===controller&&(controller=new WebXRController,controllers[index]=controller);return controller.getGripSpace()};this.getHand=function(index){let controller=controllers[index];
void 0===controller&&(controller=new WebXRController,controllers[index]=controller);return controller.getHandSpace()};this.setFramebufferScaleFactor=function(value){framebufferScaleFactor=value;!0===scope.isPresenting&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")};this.setReferenceSpaceType=function(value){referenceSpaceType=value;!0===scope.isPresenting&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")};this.getReferenceSpace=
function(){return customReferenceSpace||referenceSpace};this.setReferenceSpace=function(space){customReferenceSpace=space};this.getBaseLayer=function(){return null!==glProjLayer?glProjLayer:glBaseLayer};this.getBinding=function(){return glBinding};this.getFrame=function(){return xrFrame};this.getSession=function(){return session};this.setSession=function(value){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){session=value;if(null!==session){initialRenderTarget=
renderer.getRenderTarget();session.addEventListener("select",onSessionEvent);session.addEventListener("selectstart",onSessionEvent);session.addEventListener("selectend",onSessionEvent);session.addEventListener("squeeze",onSessionEvent);session.addEventListener("squeezestart",onSessionEvent);session.addEventListener("squeezeend",onSessionEvent);session.addEventListener("end",onSessionEnd);session.addEventListener("inputsourceschange",onInputSourcesChange);!0!==attributes.xrCompatible&&(yield gl.makeXRCompatible());
if(void 0===session.renderState.layers||!1===renderer.capabilities.isWebGL2)glBaseLayer=new XRWebGLLayer(session,gl,{antialias:void 0===session.renderState.layers?attributes.antialias:!0,alpha:attributes.alpha,depth:attributes.depth,stencil:attributes.stencil,framebufferScaleFactor}),session.updateRenderState({baseLayer:glBaseLayer}),newRenderTarget=new WebGLRenderTarget(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,{format:1023,type:1009,encoding:renderer.outputEncoding,stencilBuffer:attributes.stencil});
else{let depthFormat=null,depthType=null;var glDepthFormat=null;attributes.depth&&(glDepthFormat=attributes.stencil?gl.DEPTH24_STENCIL8:gl.DEPTH_COMPONENT24,depthFormat=attributes.stencil?1027:1026,depthType=attributes.stencil?1020:1014);glDepthFormat={colorFormat:gl.RGBA8,depthFormat:glDepthFormat,scaleFactor:framebufferScaleFactor};glBinding=new XRWebGLBinding(session,gl);glProjLayer=glBinding.createProjectionLayer(glDepthFormat);session.updateRenderState({layers:[glProjLayer]});newRenderTarget=
new WebGLRenderTarget(glProjLayer.textureWidth,glProjLayer.textureHeight,{format:1023,type:1009,depthTexture:new DepthTexture(glProjLayer.textureWidth,glProjLayer.textureHeight,depthType,void 0,void 0,void 0,void 0,void 0,void 0,depthFormat),stencilBuffer:attributes.stencil,encoding:renderer.outputEncoding,samples:attributes.antialias?4:0});renderer.properties.get(newRenderTarget).__ignoreDepthValues=glProjLayer.ignoreDepthValues}newRenderTarget.isXRRenderTarget=!0;$jscomp$async$this.setFoveation(1);
customReferenceSpace=null;referenceSpace=yield session.requestReferenceSpace(referenceSpaceType);animation.setContext(session);animation.start();scope.isPresenting=!0;scope.dispatchEvent({type:"sessionstart"})}})};const cameraLPos=new Vector3,cameraRPos=new Vector3;this.updateCamera=function(camera){if(null!==session){cameraVR.near=cameraR.near=cameraL.near=camera.near;cameraVR.far=cameraR.far=cameraL.far=camera.far;if(_currentDepthNear!==cameraVR.near||_currentDepthFar!==cameraVR.far)session.updateRenderState({depthNear:cameraVR.near,
depthFar:cameraVR.far}),_currentDepthNear=cameraVR.near,_currentDepthFar=cameraVR.far;var parent=camera.parent,cameras=cameraVR.cameras;updateCamera(cameraVR,parent);for(var i$jscomp$0=0;i$jscomp$0<cameras.length;i$jscomp$0++)updateCamera(cameras[i$jscomp$0],parent);cameraVR.matrixWorld.decompose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);camera.matrix.copy(cameraVR.matrix);camera.matrix.decompose(camera.position,camera.quaternion,camera.scale);camera=camera.children;for(let i=0,l=camera.length;i<
l;i++)camera[i].updateMatrixWorld(!0);if(2===cameras.length){cameraLPos.setFromMatrixPosition(cameraL.matrixWorld);cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);cameras=cameraLPos.distanceTo(cameraRPos);var projL=cameraL.projectionMatrix.elements,projR=cameraR.projectionMatrix.elements,near=projL[14]/(projL[10]-1);camera=projL[14]/(projL[10]+1);parent=(projL[9]+1)/projL[5];i$jscomp$0=(projL[9]-1)/projL[5];var leftFov=(projL[8]-1)/projL[0],rightFov=(projR[8]+1)/projR[0];projR=near*leftFov;
projL=near*rightFov;rightFov=cameras/(-leftFov+rightFov);leftFov=rightFov*-leftFov;cameraL.matrixWorld.decompose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);cameraVR.translateX(leftFov);cameraVR.translateZ(rightFov);cameraVR.matrixWorld.compose(cameraVR.position,cameraVR.quaternion,cameraVR.scale);cameraVR.matrixWorldInverse.copy(cameraVR.matrixWorld).invert();near+=rightFov;rightFov=camera+rightFov;cameraVR.projectionMatrix.makePerspective(projR-leftFov,projL+(cameras-leftFov),parent*camera/
rightFov*near,i$jscomp$0*camera/rightFov*near,near,rightFov)}else cameraVR.projectionMatrix.copy(cameraL.projectionMatrix)}};this.getCamera=function(){return cameraVR};this.getFoveation=function(){if(null!==glProjLayer)return glProjLayer.fixedFoveation;if(null!==glBaseLayer)return glBaseLayer.fixedFoveation};this.setFoveation=function(foveation){null!==glProjLayer&&(glProjLayer.fixedFoveation=foveation);null!==glBaseLayer&&void 0!==glBaseLayer.fixedFoveation&&(glBaseLayer.fixedFoveation=foveation)};
let onAnimationFrameCallback=null;const animation=new WebGLAnimation;animation.setAnimationLoop(function(time,frame){pose=frame.getViewerPose(customReferenceSpace||referenceSpace);xrFrame=frame;if(null!==pose){var views=pose.views;null!==glBaseLayer&&(renderer.setRenderTargetFramebuffer(newRenderTarget,glBaseLayer.framebuffer),renderer.setRenderTarget(newRenderTarget));var cameraVRNeedsUpdate=!1;views.length!==cameraVR.cameras.length&&(cameraVR.cameras.length=0,cameraVRNeedsUpdate=!0);for(var i=0;i<
views.length;i++){const view=views[i];let viewport;if(null!==glBaseLayer)viewport=glBaseLayer.getViewport(view);else{var glSubImage=glBinding.getViewSubImage(glProjLayer,view);viewport=glSubImage.viewport;0===i&&(renderer.setRenderTargetTextures(newRenderTarget,glSubImage.colorTexture,glProjLayer.ignoreDepthValues?void 0:glSubImage.depthStencilTexture),renderer.setRenderTarget(newRenderTarget))}glSubImage=cameras[i];void 0===glSubImage&&(glSubImage=new PerspectiveCamera,glSubImage.layers.enable(i),
glSubImage.viewport=new Vector4,cameras[i]=glSubImage);glSubImage.matrix.fromArray(view.transform.matrix);glSubImage.projectionMatrix.fromArray(view.projectionMatrix);glSubImage.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height);0===i&&cameraVR.matrix.copy(glSubImage.matrix);!0===cameraVRNeedsUpdate&&cameraVR.cameras.push(glSubImage)}}for(views=0;views<controllers.length;views++)cameraVRNeedsUpdate=controllerInputSources[views],i=controllers[views],null!==cameraVRNeedsUpdate&&void 0!==
i&&i.update(cameraVRNeedsUpdate,frame,customReferenceSpace||referenceSpace);onAnimationFrameCallback&&onAnimationFrameCallback(time,frame);xrFrame=null});this.setAnimationLoop=function(callback){onAnimationFrameCallback=callback};this.dispose=function(){}}}class WebGL1Renderer extends WebGLRenderer{}WebGL1Renderer.prototype.isWebGL1Renderer=!0;class FogExp2{constructor(color,density=2.5E-4){this.isFogExp2=!0;this.name="";this.color=new Color(color);this.density=density}clone(){return new FogExp2(this.color,
this.density)}toJSON(){return{type:"FogExp2",color:this.color.getHex(),density:this.density}}}class Fog{constructor(color,near=1,far=1E3){this.isFog=!0;this.name="";this.color=new Color(color);this.near=near;this.far=far}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super();this.isScene=!0;this.type="Scene";this.fog=this.environment=this.background=null;this.backgroundBlurriness=
0;this.overrideMaterial=null;"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(source,recursive){super.copy(source,recursive);null!==source.background&&(this.background=source.background.clone());null!==source.environment&&(this.environment=source.environment.clone());null!==source.fog&&(this.fog=source.fog.clone());this.backgroundBlurriness=source.backgroundBlurriness;null!==source.overrideMaterial&&(this.overrideMaterial=source.overrideMaterial.clone());
this.matrixAutoUpdate=source.matrixAutoUpdate;return this}toJSON(meta){meta=super.toJSON(meta);null!==this.fog&&(meta.object.fog=this.fog.toJSON());0<this.backgroundBlurriness&&(meta.backgroundBlurriness=this.backgroundBlurriness);return meta}get autoUpdate(){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.");return this.matrixWorldAutoUpdate}set autoUpdate(value){console.warn("THREE.Scene: autoUpdate was renamed to matrixWorldAutoUpdate in r144.");this.matrixWorldAutoUpdate=
value}}class InterleavedBuffer{constructor(array,stride){this.isInterleavedBuffer=!0;this.array=array;this.stride=stride;this.count=void 0!==array?array.length/stride:0;this.usage=35044;this.updateRange={offset:0,count:-1};this.version=0;this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(value){!0===value&&this.version++}setUsage(value){this.usage=value;return this}copy(source){this.array=new source.array.constructor(source.array);this.count=source.count;this.stride=source.stride;this.usage=
source.usage;return this}copyAt(index1,attribute,index2){index1*=this.stride;index2*=attribute.stride;for(let i=0,l=this.stride;i<l;i++)this.array[index1+i]=attribute.array[index2+i];return this}set(value,offset=0){this.array.set(value,offset);return this}clone(data){void 0===data.arrayBuffers&&(data.arrayBuffers={});void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID());void 0===data.arrayBuffers[this.array.buffer._uuid]&&(data.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);
data=new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);data=new this.constructor(data,this.stride);data.setUsage(this.usage);return data}onUpload(callback){this.onUploadCallback=callback;return this}toJSON(data){void 0===data.arrayBuffers&&(data.arrayBuffers={});void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID());void 0===data.arrayBuffers[this.array.buffer._uuid]&&(data.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer)));
return{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$6=new Vector3;class InterleavedBufferAttribute{constructor(interleavedBuffer,itemSize,offset,normalized=!1){this.isInterleavedBufferAttribute=!0;this.name="";this.data=interleavedBuffer;this.itemSize=itemSize;this.offset=offset;this.normalized=!0===normalized}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(value){this.data.needsUpdate=value}applyMatrix4(m){for(let i=
0,l=this.data.count;i<l;i++)_vector$6.fromBufferAttribute(this,i),_vector$6.applyMatrix4(m),this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);return this}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++)_vector$6.fromBufferAttribute(this,i),_vector$6.applyNormalMatrix(m),this.setXYZ(i,_vector$6.x,_vector$6.y,_vector$6.z);return this}transformDirection(m){for(let i=0,l=this.count;i<l;i++)_vector$6.fromBufferAttribute(this,i),_vector$6.transformDirection(m),this.setXYZ(i,_vector$6.x,_vector$6.y,
_vector$6.z);return this}setX(index,x){this.normalized&&(x=normalize(x,this.array));this.data.array[index*this.data.stride+this.offset]=x;return this}setY(index,y){this.normalized&&(y=normalize(y,this.array));this.data.array[index*this.data.stride+this.offset+1]=y;return this}setZ(index,z){this.normalized&&(z=normalize(z,this.array));this.data.array[index*this.data.stride+this.offset+2]=z;return this}setW(index,w){this.normalized&&(w=normalize(w,this.array));this.data.array[index*this.data.stride+
this.offset+3]=w;return this}getX(index){index=this.data.array[index*this.data.stride+this.offset];this.normalized&&(index=denormalize(index,this.array));return index}getY(index){index=this.data.array[index*this.data.stride+this.offset+1];this.normalized&&(index=denormalize(index,this.array));return index}getZ(index){index=this.data.array[index*this.data.stride+this.offset+2];this.normalized&&(index=denormalize(index,this.array));return index}getW(index){index=this.data.array[index*this.data.stride+
this.offset+3];this.normalized&&(index=denormalize(index,this.array));return index}setXY(index,x,y){index=index*this.data.stride+this.offset;this.normalized&&(x=normalize(x,this.array),y=normalize(y,this.array));this.data.array[index+0]=x;this.data.array[index+1]=y;return this}setXYZ(index,x,y,z){index=index*this.data.stride+this.offset;this.normalized&&(x=normalize(x,this.array),y=normalize(y,this.array),z=normalize(z,this.array));this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+
2]=z;return this}setXYZW(index,x,y,z,w){index=index*this.data.stride+this.offset;this.normalized&&(x=normalize(x,this.array),y=normalize(y,this.array),z=normalize(z,this.array),w=normalize(w,this.array));this.data.array[index+0]=x;this.data.array[index+1]=y;this.data.array[index+2]=z;this.data.array[index+3]=w;return this}clone(data){if(void 0===data){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will deinterleave buffer data.");data=[];for(let i=0;i<
this.count;i++){const index=i*this.data.stride+this.offset;for(let j=0;j<this.itemSize;j++)data.push(this.data.array[index+j])}return new BufferAttribute(new this.array.constructor(data),this.itemSize,this.normalized)}void 0===data.interleavedBuffers&&(data.interleavedBuffers={});void 0===data.interleavedBuffers[this.data.uuid]&&(data.interleavedBuffers[this.data.uuid]=this.data.clone(data));return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(data){if(void 0===
data){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will deinterleave buffer data.");data=[];for(let i=0;i<this.count;i++){const index=i*this.data.stride+this.offset;for(let j=0;j<this.itemSize;j++)data.push(this.data.array[index+j])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:data,normalized:this.normalized}}void 0===data.interleavedBuffers&&(data.interleavedBuffers={});void 0===data.interleavedBuffers[this.data.uuid]&&
(data.interleavedBuffers[this.data.uuid]=this.data.toJSON(data));return{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class SpriteMaterial extends Material{constructor(parameters){super();this.isSpriteMaterial=!0;this.type="SpriteMaterial";this.color=new Color(16777215);this.alphaMap=this.map=null;this.rotation=0;this.fog=this.transparent=this.sizeAttenuation=!0;this.setValues(parameters)}copy(source){super.copy(source);
this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.rotation=source.rotation;this.sizeAttenuation=source.sizeAttenuation;this.fog=source.fog;return this}}let _geometry;const _intersectPoint=new Vector3,_worldScale=new Vector3,_mvPosition=new Vector3,_alignedPosition=new Vector2,_rotatedPosition=new Vector2,_viewWorldMatrix=new Matrix4,_vA=new Vector3,_vB=new Vector3,_vC=new Vector3,_uvA=new Vector2,_uvB=new Vector2,_uvC=new Vector2;class Sprite extends Object3D{constructor(material){super();
this.isSprite=!0;this.type="Sprite";if(void 0===_geometry){_geometry=new BufferGeometry;var float32Array=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]);float32Array=new InterleavedBuffer(float32Array,5);_geometry.setIndex([0,1,2,0,2,3]);_geometry.setAttribute("position",new InterleavedBufferAttribute(float32Array,3,0,!1));_geometry.setAttribute("uv",new InterleavedBufferAttribute(float32Array,2,3,!1))}this.geometry=_geometry;this.material=void 0!==material?material:new SpriteMaterial;
this.center=new Vector2(.5,.5)}raycast(raycaster,intersects){null===raycaster.camera&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');_worldScale.setFromMatrixScale(this.matrixWorld);_viewWorldMatrix.copy(raycaster.camera.matrixWorld);this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld);_mvPosition.setFromMatrixPosition(this.modelViewMatrix);raycaster.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&
_worldScale.multiplyScalar(-_mvPosition.z);var rotation=this.material.rotation;let cos;if(0!==rotation){cos=Math.cos(rotation);var sin=Math.sin(rotation)}rotation=this.center;transformVertex(_vA.set(-.5,-.5,0),_mvPosition,rotation,_worldScale,sin,cos);transformVertex(_vB.set(.5,-.5,0),_mvPosition,rotation,_worldScale,sin,cos);transformVertex(_vC.set(.5,.5,0),_mvPosition,rotation,_worldScale,sin,cos);_uvA.set(0,0);_uvB.set(1,0);_uvC.set(1,1);let intersect=raycaster.ray.intersectTriangle(_vA,_vB,_vC,
!1,_intersectPoint);if(null===intersect&&(transformVertex(_vB.set(-.5,.5,0),_mvPosition,rotation,_worldScale,sin,cos),_uvB.set(0,1),intersect=raycaster.ray.intersectTriangle(_vA,_vC,_vB,!1,_intersectPoint),null===intersect))return;sin=raycaster.ray.origin.distanceTo(_intersectPoint);sin<raycaster.near||sin>raycaster.far||intersects.push({distance:sin,point:_intersectPoint.clone(),uv:Triangle.getUV(_intersectPoint,_vA,_vB,_vC,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(source,recursive){super.copy(source,
recursive);void 0!==source.center&&this.center.copy(source.center);this.material=source.material;return this}}const _v1$2=new Vector3,_v2$1=new Vector3;class LOD extends Object3D{constructor(){super();this._currentLevel=0;this.type="LOD";Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}});this.autoUpdate=!0}copy(source){super.copy(source,!1);const levels=source.levels;for(let i=0,l=levels.length;i<l;i++){const level=levels[i];this.addLevel(level.object.clone(),level.distance)}this.autoUpdate=
source.autoUpdate;return this}addLevel(object,distance=0){distance=Math.abs(distance);const levels=this.levels;let l;for(l=0;l<levels.length&&!(distance<levels[l].distance);l++);levels.splice(l,0,{distance,object});this.add(object);return this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(distance){const levels=this.levels;if(0<levels.length){let i,l;i=1;for(l=levels.length;i<l&&!(distance<levels[i].distance);i++);return levels[i-1].object}return null}raycast(raycaster,intersects){if(0<
this.levels.length){_v1$2.setFromMatrixPosition(this.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(distance).raycast(raycaster,intersects)}}update(camera){const levels=this.levels;if(1<levels.length){_v1$2.setFromMatrixPosition(camera.matrixWorld);_v2$1.setFromMatrixPosition(this.matrixWorld);camera=_v1$2.distanceTo(_v2$1)/camera.zoom;levels[0].object.visible=!0;let i,l;i=1;for(l=levels.length;i<l;i++)if(camera>=levels[i].distance)levels[i-1].object.visible=
!1,levels[i].object.visible=!0;else break;for(this._currentLevel=i-1;i<l;i++)levels[i].object.visible=!1}}toJSON(meta){meta=super.toJSON(meta);!1===this.autoUpdate&&(meta.object.autoUpdate=!1);meta.object.levels=[];const levels=this.levels;for(let i=0,l=levels.length;i<l;i++){const level=levels[i];meta.object.levels.push({object:level.object.uuid,distance:level.distance})}return meta}}const _basePosition=new Vector3,_skinIndex=new Vector4,_skinWeight=new Vector4,_vector$5=new Vector3,_matrix=new Matrix4;
class SkinnedMesh extends Mesh{constructor(geometry,material){super(geometry,material);this.isSkinnedMesh=!0;this.type="SkinnedMesh";this.bindMode="attached";this.bindMatrix=new Matrix4;this.bindMatrixInverse=new Matrix4}copy(source,recursive){super.copy(source,recursive);this.bindMode=source.bindMode;this.bindMatrix.copy(source.bindMatrix);this.bindMatrixInverse.copy(source.bindMatrixInverse);this.skeleton=source.skeleton;return this}bind(skeleton,bindMatrix){this.skeleton=skeleton;void 0===bindMatrix&&
(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),bindMatrix=this.matrixWorld);this.bindMatrix.copy(bindMatrix);this.bindMatrixInverse.copy(bindMatrix).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const vector=new Vector4,skinWeight=this.geometry.attributes.skinWeight;for(let i=0,l=skinWeight.count;i<l;i++){vector.fromBufferAttribute(skinWeight,i);const scale=1/vector.manhattanLength();Infinity!==scale?vector.multiplyScalar(scale):vector.set(1,0,0,0);skinWeight.setXYZW(i,
vector.x,vector.y,vector.z,vector.w)}}updateMatrixWorld(force){super.updateMatrixWorld(force);"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}boneTransform(index,target){const skeleton=this.skeleton;var geometry=this.geometry;_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex,index);_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight,
index);_basePosition.copy(target).applyMatrix4(this.bindMatrix);target.set(0,0,0);for(index=0;4>index;index++)if(geometry=_skinWeight.getComponent(index),0!==geometry){const boneIndex=_skinIndex.getComponent(index);_matrix.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld,skeleton.boneInverses[boneIndex]);target.addScaledVector(_vector$5.copy(_basePosition).applyMatrix4(_matrix),geometry)}return target.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super();this.isBone=
!0;this.type="Bone"}}class DataTexture extends Texture{constructor(data=null,width=1,height=1,format,type,mapping,wrapS,wrapT,magFilter=1003,minFilter=1003,anisotropy,encoding){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.isDataTexture=!0;this.image={data,width,height};this.flipY=this.generateMipmaps=!1;this.unpackAlignment=1}}const _offsetMatrix=new Matrix4,_identityMatrix=new Matrix4;class Skeleton{constructor(bones=[],boneInverses=[]){this.uuid=generateUUID();
this.bones=bones.slice(0);this.boneInverses=boneInverses;this.boneTexture=this.boneMatrices=null;this.boneTextureSize=0;this.frame=-1;this.init()}init(){const bones=this.bones,boneInverses=this.boneInverses;this.boneMatrices=new Float32Array(16*bones.length);if(0===boneInverses.length)this.calculateInverses();else if(bones.length!==boneInverses.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.");this.boneInverses=[];for(let i=0,il=this.bones.length;i<
il;i++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let i=0,il=this.bones.length;i<il;i++){const inverse=new Matrix4;this.bones[i]&&inverse.copy(this.bones[i].matrixWorld).invert();this.boneInverses.push(inverse)}}pose(){for(let i=0,il=this.bones.length;i<il;i++){var bone=this.bones[i];bone&&bone.matrixWorld.copy(this.boneInverses[i]).invert()}for(let i=0,il=this.bones.length;i<il;i++)if(bone=this.bones[i])bone.parent&&bone.parent.isBone?(bone.matrix.copy(bone.parent.matrixWorld).invert(),
bone.matrix.multiply(bone.matrixWorld)):bone.matrix.copy(bone.matrixWorld),bone.matrix.decompose(bone.position,bone.quaternion,bone.scale)}update(){const bones=this.bones,boneInverses=this.boneInverses,boneMatrices=this.boneMatrices,boneTexture=this.boneTexture;for(let i=0,il=bones.length;i<il;i++)_offsetMatrix.multiplyMatrices(bones[i]?bones[i].matrixWorld:_identityMatrix,boneInverses[i]),_offsetMatrix.toArray(boneMatrices,16*i);null!==boneTexture&&(boneTexture.needsUpdate=!0)}clone(){return new Skeleton(this.bones,
this.boneInverses)}computeBoneTexture(){let size=Math.sqrt(4*this.bones.length);size=ceilPowerOfTwo(size);size=Math.max(size,4);const boneMatrices=new Float32Array(size*size*4);boneMatrices.set(this.boneMatrices);const boneTexture=new DataTexture(boneMatrices,size,size,1023,1015);boneTexture.needsUpdate=!0;this.boneMatrices=boneMatrices;this.boneTexture=boneTexture;this.boneTextureSize=size;return this}getBoneByName(name){for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];if(bone.name===
name)return bone}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(json,bones){this.uuid=json.uuid;for(let i=0,l=json.bones.length;i<l;i++){const uuid=json.bones[i];let bone=bones[uuid];void 0===bone&&(console.warn("THREE.Skeleton: No bone found with UUID:",uuid),bone=new Bone);this.bones.push(bone);this.boneInverses.push((new Matrix4).fromArray(json.boneInverses[i]))}this.init();return this}toJSON(){const data={metadata:{version:4.5,type:"Skeleton",generator:"Skeleton.toJSON"},
bones:[],boneInverses:[]};data.uuid=this.uuid;const bones=this.bones,boneInverses=this.boneInverses;for(let i=0,l=bones.length;i<l;i++)data.bones.push(bones[i].uuid),data.boneInverses.push(boneInverses[i].toArray());return data}}class InstancedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized,meshPerAttribute=1){super(array,itemSize,normalized);this.isInstancedBufferAttribute=!0;this.meshPerAttribute=meshPerAttribute}copy(source){super.copy(source);this.meshPerAttribute=
source.meshPerAttribute;return this}toJSON(){const data=super.toJSON();data.meshPerAttribute=this.meshPerAttribute;data.isInstancedBufferAttribute=!0;return data}}const _instanceLocalMatrix=new Matrix4,_instanceWorldMatrix=new Matrix4,_instanceIntersects=[],_identity=new Matrix4,_mesh=new Mesh;class InstancedMesh extends Mesh{constructor(geometry,material,count){super(geometry,material);this.isInstancedMesh=!0;this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(16*count),16);this.instanceColor=
null;this.count=count;this.frustumCulled=!1;for(geometry=0;geometry<count;geometry++)this.setMatrixAt(geometry,_identity)}copy(source,recursive){super.copy(source,recursive);this.instanceMatrix.copy(source.instanceMatrix);null!==source.instanceColor&&(this.instanceColor=source.instanceColor.clone());this.count=source.count;return this}getColorAt(index,color){color.fromArray(this.instanceColor.array,3*index)}getMatrixAt(index,matrix){matrix.fromArray(this.instanceMatrix.array,16*index)}raycast(raycaster,
intersects){const matrixWorld=this.matrixWorld,raycastTimes=this.count;_mesh.geometry=this.geometry;_mesh.material=this.material;if(void 0!==_mesh.material)for(let instanceId=0;instanceId<raycastTimes;instanceId++){this.getMatrixAt(instanceId,_instanceLocalMatrix);_instanceWorldMatrix.multiplyMatrices(matrixWorld,_instanceLocalMatrix);_mesh.matrixWorld=_instanceWorldMatrix;_mesh.raycast(raycaster,_instanceIntersects);for(let i=0,l=_instanceIntersects.length;i<l;i++){const intersect=_instanceIntersects[i];
intersect.instanceId=instanceId;intersect.object=this;intersects.push(intersect)}_instanceIntersects.length=0}}setColorAt(index,color){null===this.instanceColor&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(3*this.instanceMatrix.count),3));color.toArray(this.instanceColor.array,3*index)}setMatrixAt(index,matrix){matrix.toArray(this.instanceMatrix.array,16*index)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"})}}class LineBasicMaterial extends Material{constructor(parameters){super();
this.isLineBasicMaterial=!0;this.type="LineBasicMaterial";this.color=new Color(16777215);this.linewidth=1;this.linejoin=this.linecap="round";this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);this.color.copy(source.color);this.linewidth=source.linewidth;this.linecap=source.linecap;this.linejoin=source.linejoin;this.fog=source.fog;return this}}const _start$1=new Vector3,_end$1=new Vector3,_inverseMatrix$1=new Matrix4,_ray$1=new Ray,_sphere$1=new Sphere;class Line extends Object3D{constructor(geometry=
new BufferGeometry,material=new LineBasicMaterial){super();this.isLine=!0;this.type="Line";this.geometry=geometry;this.material=material;this.updateMorphTargets()}copy(source,recursive){super.copy(source,recursive);this.material=source.material;this.geometry=source.geometry;return this}computeLineDistances(){const geometry=this.geometry;if(null===geometry.index){const positionAttribute=geometry.attributes.position,lineDistances=[0];for(let i=1,l=positionAttribute.count;i<l;i++)_start$1.fromBufferAttribute(positionAttribute,
i-1),_end$1.fromBufferAttribute(positionAttribute,i),lineDistances[i]=lineDistances[i-1],lineDistances[i]+=_start$1.distanceTo(_end$1);geometry.setAttribute("lineDistance",new Float32BufferAttribute(lineDistances,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(raycaster,intersects){var geometry=this.geometry,matrixWorld=this.matrixWorld,threshold=raycaster.params.Line.threshold,drawRange=geometry.drawRange;
null===geometry.boundingSphere&&geometry.computeBoundingSphere();_sphere$1.copy(geometry.boundingSphere);_sphere$1.applyMatrix4(matrixWorld);_sphere$1.radius+=threshold;if(!1!==raycaster.ray.intersectsSphere(_sphere$1)){_inverseMatrix$1.copy(matrixWorld).invert();_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);matrixWorld=threshold/((this.scale.x+this.scale.y+this.scale.z)/3);matrixWorld*=matrixWorld;threshold=new Vector3;var vEnd=new Vector3,interSegment=new Vector3,interRay=new Vector3,
step=this.isLineSegments?2:1,index=geometry.index;geometry=geometry.attributes.position;if(null!==index){var start=Math.max(0,drawRange.start);drawRange=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,l=drawRange-1;i<l;i+=step)drawRange=index.getX(i),start=index.getX(i+1),threshold.fromBufferAttribute(geometry,drawRange),vEnd.fromBufferAttribute(geometry,start),_ray$1.distanceSqToSegment(threshold,vEnd,interRay,interSegment)>matrixWorld||(interRay.applyMatrix4(this.matrixWorld),
drawRange=raycaster.ray.origin.distanceTo(interRay),drawRange<raycaster.near||drawRange>raycaster.far||intersects.push({distance:drawRange,point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this}))}else{index=Math.max(0,drawRange.start);drawRange=Math.min(geometry.count,drawRange.start+drawRange.count);for(let i=index,l=drawRange-1;i<l;i+=step)threshold.fromBufferAttribute(geometry,i),vEnd.fromBufferAttribute(geometry,i+1),_ray$1.distanceSqToSegment(threshold,
vEnd,interRay,interSegment)>matrixWorld||(interRay.applyMatrix4(this.matrixWorld),drawRange=raycaster.ray.origin.distanceTo(interRay),drawRange<raycaster.near||drawRange>raycaster.far||intersects.push({distance:drawRange,point:interSegment.clone().applyMatrix4(this.matrixWorld),index:i,face:null,faceIndex:null,object:this}))}}}updateMorphTargets(){var morphAttributes=this.geometry.morphAttributes,keys=Object.keys(morphAttributes);if(0<keys.length&&(morphAttributes=morphAttributes[keys[0]],void 0!==
morphAttributes)){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttributes.length;m<ml;m++)keys=morphAttributes[m].name||String(m),this.morphTargetInfluences.push(0),this.morphTargetDictionary[keys]=m}}}const _start=new Vector3,_end=new Vector3;class LineSegments extends Line{constructor(geometry,material){super(geometry,material);this.isLineSegments=!0;this.type="LineSegments"}computeLineDistances(){const geometry=this.geometry;if(null===geometry.index){const positionAttribute=
geometry.attributes.position,lineDistances=[];for(let i=0,l=positionAttribute.count;i<l;i+=2)_start.fromBufferAttribute(positionAttribute,i),_end.fromBufferAttribute(positionAttribute,i+1),lineDistances[i]=0===i?0:lineDistances[i-1],lineDistances[i+1]=lineDistances[i]+_start.distanceTo(_end);geometry.setAttribute("lineDistance",new Float32BufferAttribute(lineDistances,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}
class LineLoop extends Line{constructor(geometry,material){super(geometry,material);this.isLineLoop=!0;this.type="LineLoop"}}class PointsMaterial extends Material{constructor(parameters){super();this.isPointsMaterial=!0;this.type="PointsMaterial";this.color=new Color(16777215);this.alphaMap=this.map=null;this.size=1;this.fog=this.sizeAttenuation=!0;this.setValues(parameters)}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.alphaMap=source.alphaMap;this.size=source.size;
this.sizeAttenuation=source.sizeAttenuation;this.fog=source.fog;return this}}const _inverseMatrix=new Matrix4,_ray=new Ray,_sphere=new Sphere,_position$2=new Vector3;class Points extends Object3D{constructor(geometry=new BufferGeometry,material=new PointsMaterial){super();this.isPoints=!0;this.type="Points";this.geometry=geometry;this.material=material;this.updateMorphTargets()}copy(source,recursive){super.copy(source,recursive);this.material=source.material;this.geometry=source.geometry;return this}raycast(raycaster,
intersects){var geometry=this.geometry;const matrixWorld=this.matrixWorld;var threshold=raycaster.params.Points.threshold,drawRange=geometry.drawRange;null===geometry.boundingSphere&&geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere);_sphere.applyMatrix4(matrixWorld);_sphere.radius+=threshold;if(!1!==raycaster.ray.intersectsSphere(_sphere)){_inverseMatrix.copy(matrixWorld).invert();_ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);threshold/=(this.scale.x+this.scale.y+this.scale.z)/
3;threshold*=threshold;var index=geometry.index;geometry=geometry.attributes.position;if(null!==index){const start=Math.max(0,drawRange.start);drawRange=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,il=drawRange;i<il;i++)drawRange=index.getX(i),_position$2.fromBufferAttribute(geometry,drawRange),testPoint(_position$2,drawRange,threshold,matrixWorld,raycaster,intersects,this)}else{index=Math.max(0,drawRange.start);drawRange=Math.min(geometry.count,drawRange.start+drawRange.count);
for(let i=index,l=drawRange;i<l;i++)_position$2.fromBufferAttribute(geometry,i),testPoint(_position$2,i,threshold,matrixWorld,raycaster,intersects,this)}}}updateMorphTargets(){var morphAttributes=this.geometry.morphAttributes,keys=Object.keys(morphAttributes);if(0<keys.length&&(morphAttributes=morphAttributes[keys[0]],void 0!==morphAttributes)){this.morphTargetInfluences=[];this.morphTargetDictionary={};for(let m=0,ml=morphAttributes.length;m<ml;m++)keys=morphAttributes[m].name||String(m),this.morphTargetInfluences.push(0),
this.morphTargetDictionary[keys]=m}}}class VideoTexture extends Texture{constructor(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){function updateVideo(){scope.needsUpdate=!0;video.requestVideoFrameCallback(updateVideo)}super(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.isVideoTexture=!0;this.minFilter=void 0!==minFilter?minFilter:1006;this.magFilter=void 0!==magFilter?magFilter:1006;this.generateMipmaps=!1;const scope=this;"requestVideoFrameCallback"in
video&&video.requestVideoFrameCallback(updateVideo)}clone(){return(new this.constructor(this.image)).copy(this)}update(){const video=this.image;!1==="requestVideoFrameCallback"in video&&video.readyState>=video.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class FramebufferTexture extends Texture{constructor(width,height,format){super({width,height});this.isFramebufferTexture=!0;this.format=format;this.minFilter=this.magFilter=1003;this.generateMipmaps=!1;this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(mipmaps,
width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,encoding){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,encoding);this.isCompressedTexture=!0;this.image={width,height};this.mipmaps=mipmaps;this.generateMipmaps=this.flipY=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(mipmaps,width,height,depth,format,type){super(mipmaps,width,height,format,type);this.isCompressedArrayTexture=!0;this.image.depth=depth;this.wrapR=1001}}
class CanvasTexture extends Texture{constructor(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy){super(canvas,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy);this.needsUpdate=this.isCanvasTexture=!0}}class Curve{constructor(){this.type="Curve";this.arcLengthDivisions=200}getPoint(){console.warn("THREE.Curve: .getPoint() not implemented.");return null}getPointAt(u,optionalTarget){u=this.getUtoTmapping(u);return this.getPoint(u,optionalTarget)}getPoints(divisions=
5){const points=[];for(let d=0;d<=divisions;d++)points.push(this.getPoint(d/divisions));return points}getSpacedPoints(divisions=5){const points=[];for(let d=0;d<=divisions;d++)points.push(this.getPointAt(d/divisions));return points}getLength(){const lengths=this.getLengths();return lengths[lengths.length-1]}getLengths(divisions=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const cache=
[];let current,last=this.getPoint(0),sum=0;cache.push(0);for(let p=1;p<=divisions;p++)current=this.getPoint(p/divisions),sum+=current.distanceTo(last),cache.push(sum),last=current;return this.cacheArcLengths=cache}updateArcLengths(){this.needsUpdate=!0;this.getLengths()}getUtoTmapping(u,distance){const arcLengths=this.getLengths(),il=arcLengths.length;distance=distance?distance:u*arcLengths[il-1];var low=0;let high=il-1,comparison;for(;low<=high;)if(u=Math.floor(low+(high-low)/2),comparison=arcLengths[u]-
distance,0>comparison)low=u+1;else if(0<comparison)high=u-1;else{high=u;break}u=high;if(arcLengths[u]===distance)return u/(il-1);low=arcLengths[u];return(u+(distance-low)/(arcLengths[u+1]-low))/(il-1)}getTangent(t,optionalTarget){var t1=t-1E-4;t+=1E-4;0>t1&&(t1=0);1<t&&(t=1);t1=this.getPoint(t1);t=this.getPoint(t);optionalTarget=optionalTarget||(t1.isVector2?new Vector2:new Vector3);optionalTarget.copy(t).sub(t1).normalize();return optionalTarget}getTangentAt(u,optionalTarget){u=this.getUtoTmapping(u);
return this.getTangent(u,optionalTarget)}computeFrenetFrames(segments,closed){var normal=new Vector3;const tangents=[],normals=[],binormals=[];var vec=new Vector3;const mat=new Matrix4;for(var i=0;i<=segments;i++)tangents[i]=this.getTangentAt(i/segments,new Vector3);normals[0]=new Vector3;binormals[0]=new Vector3;i=Number.MAX_VALUE;const tx=Math.abs(tangents[0].x),ty=Math.abs(tangents[0].y),tz=Math.abs(tangents[0].z);tx<=i&&(i=tx,normal.set(1,0,0));ty<=i&&(i=ty,normal.set(0,1,0));tz<=i&&normal.set(0,
0,1);vec.crossVectors(tangents[0],normal).normalize();normals[0].crossVectors(tangents[0],vec);binormals[0].crossVectors(tangents[0],normals[0]);for(normal=1;normal<=segments;normal++)normals[normal]=normals[normal-1].clone(),binormals[normal]=binormals[normal-1].clone(),vec.crossVectors(tangents[normal-1],tangents[normal]),vec.length()>Number.EPSILON&&(vec.normalize(),i=Math.acos(clamp(tangents[normal-1].dot(tangents[normal]),-1,1)),normals[normal].applyMatrix4(mat.makeRotationAxis(vec,i))),binormals[normal].crossVectors(tangents[normal],
normals[normal]);if(!0===closed)for(closed=Math.acos(clamp(normals[0].dot(normals[segments]),-1,1)),closed/=segments,0<tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))&&(closed=-closed),vec=1;vec<=segments;vec++)normals[vec].applyMatrix4(mat.makeRotationAxis(tangents[vec],closed*vec)),binormals[vec].crossVectors(tangents[vec],normals[vec]);return{tangents,normals,binormals}}clone(){return(new this.constructor).copy(this)}copy(source){this.arcLengthDivisions=source.arcLengthDivisions;
return this}toJSON(){const data={metadata:{version:4.5,type:"Curve",generator:"Curve.toJSON"}};data.arcLengthDivisions=this.arcLengthDivisions;data.type=this.type;return data}fromJSON(json){this.arcLengthDivisions=json.arcLengthDivisions;return this}}class EllipseCurve extends Curve{constructor(aX=0,aY=0,xRadius=1,yRadius=1,aStartAngle=0,aEndAngle=2*Math.PI,aClockwise=!1,aRotation=0){super();this.isEllipseCurve=!0;this.type="EllipseCurve";this.aX=aX;this.aY=aY;this.xRadius=xRadius;this.yRadius=yRadius;
this.aStartAngle=aStartAngle;this.aEndAngle=aEndAngle;this.aClockwise=aClockwise;this.aRotation=aRotation}getPoint(t,optionalTarget){optionalTarget=optionalTarget||new Vector2;for(var twoPi=2*Math.PI,deltaAngle=this.aEndAngle-this.aStartAngle,samePoints=Math.abs(deltaAngle)<Number.EPSILON;0>deltaAngle;)deltaAngle+=twoPi;for(;deltaAngle>twoPi;)deltaAngle-=twoPi;deltaAngle<Number.EPSILON&&(deltaAngle=samePoints?0:twoPi);!0!==this.aClockwise||samePoints||(deltaAngle=deltaAngle===twoPi?-twoPi:deltaAngle-
twoPi);twoPi=this.aStartAngle+t*deltaAngle;t=this.aX+this.xRadius*Math.cos(twoPi);var y=this.aY+this.yRadius*Math.sin(twoPi);0!==this.aRotation&&(twoPi=Math.cos(this.aRotation),deltaAngle=Math.sin(this.aRotation),samePoints=t-this.aX,y-=this.aY,t=samePoints*twoPi-y*deltaAngle+this.aX,y=samePoints*deltaAngle+y*twoPi+this.aY);return optionalTarget.set(t,y)}copy(source){super.copy(source);this.aX=source.aX;this.aY=source.aY;this.xRadius=source.xRadius;this.yRadius=source.yRadius;this.aStartAngle=source.aStartAngle;
this.aEndAngle=source.aEndAngle;this.aClockwise=source.aClockwise;this.aRotation=source.aRotation;return this}toJSON(){const data=super.toJSON();data.aX=this.aX;data.aY=this.aY;data.xRadius=this.xRadius;data.yRadius=this.yRadius;data.aStartAngle=this.aStartAngle;data.aEndAngle=this.aEndAngle;data.aClockwise=this.aClockwise;data.aRotation=this.aRotation;return data}fromJSON(json){super.fromJSON(json);this.aX=json.aX;this.aY=json.aY;this.xRadius=json.xRadius;this.yRadius=json.yRadius;this.aStartAngle=
json.aStartAngle;this.aEndAngle=json.aEndAngle;this.aClockwise=json.aClockwise;this.aRotation=json.aRotation;return this}}class ArcCurve extends EllipseCurve{constructor(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){super(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);this.isArcCurve=!0;this.type="ArcCurve"}}const tmp$jscomp$0=new Vector3,px$jscomp$0=new CubicPoly,py=new CubicPoly,pz=new CubicPoly;class CatmullRomCurve3 extends Curve{constructor(points=[],closed=!1,curveType="centripetal",
tension=.5){super();this.isCatmullRomCurve3=!0;this.type="CatmullRomCurve3";this.points=points;this.closed=closed;this.curveType=curveType;this.tension=tension}getPoint(t,optionalTarget=new Vector3){var points=this.points,l=points.length;t*=l-(this.closed?0:1);var intPoint=Math.floor(t);t-=intPoint;this.closed?intPoint+=0<intPoint?0:(Math.floor(Math.abs(intPoint)/l)+1)*l:0===t&&intPoint===l-1&&(intPoint=l-2,t=1);let p0;this.closed||0<intPoint?p0=points[(intPoint-1)%l]:(tmp$jscomp$0.subVectors(points[0],
points[1]).add(points[0]),p0=tmp$jscomp$0);const p1=points[intPoint%l],p2=points[(intPoint+1)%l];this.closed||intPoint+2<l?points=points[(intPoint+2)%l]:(tmp$jscomp$0.subVectors(points[l-1],points[l-2]).add(points[l-1]),points=tmp$jscomp$0);if("centripetal"===this.curveType||"chordal"===this.curveType){var pow="chordal"===this.curveType?.5:.25;l=Math.pow(p0.distanceToSquared(p1),pow);intPoint=Math.pow(p1.distanceToSquared(p2),pow);pow=Math.pow(p2.distanceToSquared(points),pow);1E-4>intPoint&&(intPoint=
1);1E-4>l&&(l=intPoint);1E-4>pow&&(pow=intPoint);px$jscomp$0.initNonuniformCatmullRom(p0.x,p1.x,p2.x,points.x,l,intPoint,pow);py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,points.y,l,intPoint,pow);pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,points.z,l,intPoint,pow)}else"catmullrom"===this.curveType&&(px$jscomp$0.initCatmullRom(p0.x,p1.x,p2.x,points.x,this.tension),py.initCatmullRom(p0.y,p1.y,p2.y,points.y,this.tension),pz.initCatmullRom(p0.z,p1.z,p2.z,points.z,this.tension));optionalTarget.set(px$jscomp$0.calc(t),
py.calc(t),pz.calc(t));return optionalTarget}copy(source){super.copy(source);this.points=[];for(let i=0,l=source.points.length;i<l;i++)this.points.push(source.points[i].clone());this.closed=source.closed;this.curveType=source.curveType;this.tension=source.tension;return this}toJSON(){const data=super.toJSON();data.points=[];for(let i=0,l=this.points.length;i<l;i++)data.points.push(this.points[i].toArray());data.closed=this.closed;data.curveType=this.curveType;data.tension=this.tension;return data}fromJSON(json){super.fromJSON(json);
this.points=[];for(let i=0,l=json.points.length;i<l;i++){const point=json.points[i];this.points.push((new Vector3).fromArray(point))}this.closed=json.closed;this.curveType=json.curveType;this.tension=json.tension;return this}}class CubicBezierCurve extends Curve{constructor(v0=new Vector2,v1=new Vector2,v2=new Vector2,v3=new Vector2){super();this.isCubicBezierCurve=!0;this.type="CubicBezierCurve";this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3}getPoint(t,optionalTarget=new Vector2){const v0=this.v0,v1=
this.v1,v2=this.v2,v3=this.v3;optionalTarget.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y));return optionalTarget}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);
this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this}}class CubicBezierCurve3 extends Curve{constructor(v0=new Vector3,v1=new Vector3,v2=new Vector3,v3=new Vector3){super();this.isCubicBezierCurve3=!0;this.type="CubicBezierCurve3";this.v0=v0;this.v1=v1;this.v2=v2;this.v3=v3}getPoint(t,optionalTarget=new Vector3){const v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;optionalTarget.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z));
return optionalTarget}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);this.v3.copy(source.v3);return this}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();data.v3=this.v3.toArray();return data}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);this.v3.fromArray(json.v3);return this}}class LineCurve extends Curve{constructor(v1=
new Vector2,v2=new Vector2){super();this.isLineCurve=!0;this.type="LineCurve";this.v1=v1;this.v2=v2}getPoint(t,optionalTarget=new Vector2){1===t?optionalTarget.copy(this.v2):(optionalTarget.copy(this.v2).sub(this.v1),optionalTarget.multiplyScalar(t).add(this.v1));return optionalTarget}getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget)}getTangent(t,optionalTarget){t=optionalTarget||new Vector2;t.copy(this.v2).sub(this.v1).normalize();return t}copy(source){super.copy(source);this.v1.copy(source.v1);
this.v2.copy(source.v2);return this}toJSON(){const data=super.toJSON();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data}fromJSON(json){super.fromJSON(json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this}}class LineCurve3 extends Curve{constructor(v1=new Vector3,v2=new Vector3){super();this.isLineCurve3=!0;this.type="LineCurve3";this.v1=v1;this.v2=v2}getPoint(t,optionalTarget=new Vector3){1===t?optionalTarget.copy(this.v2):(optionalTarget.copy(this.v2).sub(this.v1),
optionalTarget.multiplyScalar(t).add(this.v1));return optionalTarget}getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget)}copy(source){super.copy(source);this.v1.copy(source.v1);this.v2.copy(source.v2);return this}toJSON(){const data=super.toJSON();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data}fromJSON(json){super.fromJSON(json);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this}}class QuadraticBezierCurve extends Curve{constructor(v0=new Vector2,v1=
new Vector2,v2=new Vector2){super();this.isQuadraticBezierCurve=!0;this.type="QuadraticBezierCurve";this.v0=v0;this.v1=v1;this.v2=v2}getPoint(t,optionalTarget=new Vector2){const v0=this.v0,v1=this.v1,v2=this.v2;optionalTarget.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y));return optionalTarget}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=
this.v1.toArray();data.v2=this.v2.toArray();return data}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this}}class QuadraticBezierCurve3 extends Curve{constructor(v0=new Vector3,v1=new Vector3,v2=new Vector3){super();this.isQuadraticBezierCurve3=!0;this.type="QuadraticBezierCurve3";this.v0=v0;this.v1=v1;this.v2=v2}getPoint(t,optionalTarget=new Vector3){const v0=this.v0,v1=this.v1,v2=this.v2;optionalTarget.set(QuadraticBezier(t,
v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z));return optionalTarget}copy(source){super.copy(source);this.v0.copy(source.v0);this.v1.copy(source.v1);this.v2.copy(source.v2);return this}toJSON(){const data=super.toJSON();data.v0=this.v0.toArray();data.v1=this.v1.toArray();data.v2=this.v2.toArray();return data}fromJSON(json){super.fromJSON(json);this.v0.fromArray(json.v0);this.v1.fromArray(json.v1);this.v2.fromArray(json.v2);return this}}class SplineCurve extends Curve{constructor(points=
[]){super();this.isSplineCurve=!0;this.type="SplineCurve";this.points=points}getPoint(t,optionalTarget=new Vector2){var points=this.points,p=(points.length-1)*t;t=Math.floor(p);p-=t;const p0=points[0===t?t:t-1],p1=points[t],p2=points[t>points.length-2?points.length-1:t+1];points=points[t>points.length-3?points.length-1:t+2];optionalTarget.set(CatmullRom(p,p0.x,p1.x,p2.x,points.x),CatmullRom(p,p0.y,p1.y,p2.y,points.y));return optionalTarget}copy(source){super.copy(source);this.points=[];for(let i=
0,l=source.points.length;i<l;i++)this.points.push(source.points[i].clone());return this}toJSON(){const data=super.toJSON();data.points=[];for(let i=0,l=this.points.length;i<l;i++)data.points.push(this.points[i].toArray());return data}fromJSON(json){super.fromJSON(json);this.points=[];for(let i=0,l=json.points.length;i<l;i++){const point=json.points[i];this.points.push((new Vector2).fromArray(point))}return this}}var Curves=Object.freeze({__proto__:null,ArcCurve,CatmullRomCurve3,CubicBezierCurve,CubicBezierCurve3,
EllipseCurve,LineCurve,LineCurve3,QuadraticBezierCurve,QuadraticBezierCurve3,SplineCurve});class CurvePath extends Curve{constructor(){super();this.type="CurvePath";this.curves=[];this.autoClose=!1}add(curve){this.curves.push(curve)}closePath(){const startPoint=this.curves[0].getPoint(0),endPoint=this.curves[this.curves.length-1].getPoint(1);startPoint.equals(endPoint)||this.curves.push(new LineCurve(endPoint,startPoint))}getPoint(t,optionalTarget){var d=t*this.getLength(),curveLengths=this.getCurveLengths();
for(t=0;t<curveLengths.length;){if(curveLengths[t]>=d)return d=curveLengths[t]-d,t=this.curves[t],curveLengths=t.getLength(),t.getPointAt(0===curveLengths?0:1-d/curveLengths,optionalTarget);t++}return null}getLength(){const lens=this.getCurveLengths();return lens[lens.length-1]}updateArcLengths(){this.needsUpdate=!0;this.cacheLengths=null;this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const lengths=[];let sums=
0;for(let i=0,l=this.curves.length;i<l;i++)sums+=this.curves[i].getLength(),lengths.push(sums);return this.cacheLengths=lengths}getSpacedPoints(divisions=40){const points=[];for(let i=0;i<=divisions;i++)points.push(this.getPoint(i/divisions));this.autoClose&&points.push(points[0]);return points}getPoints(divisions=12){const points=[];let last;for(let i=0,curves=this.curves;i<curves.length;i++){var curve=curves[i];curve=curve.getPoints(curve.isEllipseCurve?2*divisions:curve.isLineCurve||curve.isLineCurve3?
1:curve.isSplineCurve?divisions*curve.points.length:divisions);for(let j=0;j<curve.length;j++){const point=curve[j];last&&last.equals(point)||(points.push(point),last=point)}}this.autoClose&&1<points.length&&!points[points.length-1].equals(points[0])&&points.push(points[0]);return points}copy(source){super.copy(source);this.curves=[];for(let i=0,l=source.curves.length;i<l;i++)this.curves.push(source.curves[i].clone());this.autoClose=source.autoClose;return this}toJSON(){const data=super.toJSON();
data.autoClose=this.autoClose;data.curves=[];for(let i=0,l=this.curves.length;i<l;i++)data.curves.push(this.curves[i].toJSON());return data}fromJSON(json){super.fromJSON(json);this.autoClose=json.autoClose;this.curves=[];for(let i=0,l=json.curves.length;i<l;i++){const curve=json.curves[i];this.curves.push((new Curves[curve.type]).fromJSON(curve))}return this}}class Path extends CurvePath{constructor(points){super();this.type="Path";this.currentPoint=new Vector2;points&&this.setFromPoints(points)}setFromPoints(points){this.moveTo(points[0].x,
points[0].y);for(let i=1,l=points.length;i<l;i++)this.lineTo(points[i].x,points[i].y);return this}moveTo(x,y){this.currentPoint.set(x,y);return this}lineTo(x,y){const curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));this.curves.push(curve);this.currentPoint.set(x,y);return this}quadraticCurveTo(aCPx,aCPy,aX,aY){aCPx=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));this.curves.push(aCPx);this.currentPoint.set(aX,aY);return this}bezierCurveTo(aCP1x,
aCP1y,aCP2x,aCP2y,aX,aY){aCP1x=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));this.curves.push(aCP1x);this.currentPoint.set(aX,aY);return this}splineThru(pts){var npts=[this.currentPoint.clone()].concat(pts);npts=new SplineCurve(npts);this.curves.push(npts);this.currentPoint.copy(pts[pts.length-1]);return this}arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absarc(aX+this.currentPoint.x,aY+this.currentPoint.y,aRadius,aStartAngle,
aEndAngle,aClockwise);return this}absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise);return this}ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){this.absellipse(aX+this.currentPoint.x,aY+this.currentPoint.y,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);return this}absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){aX=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,
aEndAngle,aClockwise,aRotation);0<this.curves.length&&(aY=aX.getPoint(0),aY.equals(this.currentPoint)||this.lineTo(aY.x,aY.y));this.curves.push(aX);aX=aX.getPoint(1);this.currentPoint.copy(aX);return this}copy(source){super.copy(source);this.currentPoint.copy(source.currentPoint);return this}toJSON(){const data=super.toJSON();data.currentPoint=this.currentPoint.toArray();return data}fromJSON(json){super.fromJSON(json);this.currentPoint.fromArray(json.currentPoint);return this}}class LatheGeometry extends BufferGeometry{constructor(points=
[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],segments=12,phiStart=0,phiLength=2*Math.PI){super();this.type="LatheGeometry";this.parameters={points,segments,phiStart,phiLength};segments=Math.floor(segments);phiLength=clamp(phiLength,0,2*Math.PI);const indices=[],vertices=[],uvs=[];var initNormals=[];const normals=[];var inverseSegments=1/segments,vertex=new Vector3,uv=new Vector2,normal=new Vector3,curNormal=new Vector3,prevNormal=new Vector3;let dy;for(let j=0;j<=points.length-1;j++)switch(j){case 0:var dx=
points[j+1].x-points[j].x;dy=points[j+1].y-points[j].y;normal.x=1*dy;normal.y=-dx;normal.z=0*dy;prevNormal.copy(normal);normal.normalize();initNormals.push(normal.x,normal.y,normal.z);break;case points.length-1:initNormals.push(prevNormal.x,prevNormal.y,prevNormal.z);break;default:dx=points[j+1].x-points[j].x,dy=points[j+1].y-points[j].y,normal.x=1*dy,normal.y=-dx,normal.z=0*dy,curNormal.copy(normal),normal.x+=prevNormal.x,normal.y+=prevNormal.y,normal.z+=prevNormal.z,normal.normalize(),initNormals.push(normal.x,
normal.y,normal.z),prevNormal.copy(curNormal)}for(normal=0;normal<=segments;normal++)for(prevNormal=phiStart+normal*inverseSegments*phiLength,curNormal=Math.sin(prevNormal),prevNormal=Math.cos(prevNormal),dx=0;dx<=points.length-1;dx++)vertex.x=points[dx].x*curNormal,vertex.y=points[dx].y,vertex.z=points[dx].x*prevNormal,vertices.push(vertex.x,vertex.y,vertex.z),uv.x=normal/segments,uv.y=dx/(points.length-1),uvs.push(uv.x,uv.y),normals.push(initNormals[3*dx]*curNormal,initNormals[3*dx+1],initNormals[3*
dx]*prevNormal);for(phiStart=0;phiStart<segments;phiStart++)for(phiLength=0;phiLength<points.length-1;phiLength++)initNormals=phiLength+phiStart*points.length,inverseSegments=initNormals+points.length,vertex=initNormals+points.length+1,uv=initNormals+1,indices.push(initNormals,inverseSegments,uv),indices.push(vertex,uv,inverseSegments);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2));this.setAttribute("normal",
new Float32BufferAttribute(normals,3))}static fromJSON(data){return new LatheGeometry(data.points,data.segments,data.phiStart,data.phiLength)}}class CapsuleGeometry extends LatheGeometry{constructor(radius=1,length=1,capSegments=4,radialSegments=8){const path=new Path;path.absarc(0,-length/2,radius,1.5*Math.PI,0);path.absarc(0,length/2,radius,0,.5*Math.PI);super(path.getPoints(capSegments),radialSegments);this.type="CapsuleGeometry";this.parameters={radius,height:length,capSegments,radialSegments}}static fromJSON(data){return new CapsuleGeometry(data.radius,
data.length,data.capSegments,data.radialSegments)}}class CircleGeometry extends BufferGeometry{constructor(radius=1,segments=8,thetaStart=0,thetaLength=2*Math.PI){super();this.type="CircleGeometry";this.parameters={radius,segments,thetaStart,thetaLength};segments=Math.max(3,segments);const indices=[],vertices=[],normals=[],uvs=[],vertex=new Vector3,uv=new Vector2;vertices.push(0,0,0);normals.push(0,0,1);uvs.push(.5,.5);for(let s=0,i=3;s<=segments;s++,i+=3){const segment=thetaStart+s/segments*thetaLength;
vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);normals.push(0,0,1);uv.x=(vertices[i]/radius+1)/2;uv.y=(vertices[i+1]/radius+1)/2;uvs.push(uv.x,uv.y)}for(radius=1;radius<=segments;radius++)indices.push(radius,radius+1,0);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new CircleGeometry(data.radius,
data.segments,data.thetaStart,data.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(radiusTop=1,radiusBottom=1,height=1,radialSegments=8,heightSegments=1,openEnded=!1,thetaStart=0,thetaLength=2*Math.PI){function generateCap(top){const centerIndexStart=index;var uv=new Vector2,vertex=new Vector3;let groupCount=0;var radius=!0===top?radiusTop:radiusBottom;const sign=!0===top?1:-1;for(var x$jscomp$0=1;x$jscomp$0<=radialSegments;x$jscomp$0++)vertices.push(0,halfHeight*sign,0),normals.push(0,
sign,0),uvs.push(.5,.5),index++;x$jscomp$0=index;for(let x=0;x<=radialSegments;x++){var theta=x/radialSegments*thetaLength+thetaStart;const cosTheta=Math.cos(theta);theta=Math.sin(theta);vertex.x=radius*theta;vertex.y=halfHeight*sign;vertex.z=radius*cosTheta;vertices.push(vertex.x,vertex.y,vertex.z);normals.push(0,sign,0);uv.x=.5*cosTheta+.5;uv.y=.5*theta*sign+.5;uvs.push(uv.x,uv.y);index++}for(uv=0;uv<radialSegments;uv++)vertex=centerIndexStart+uv,radius=x$jscomp$0+uv,!0===top?indices.push(radius,
radius+1,vertex):indices.push(radius+1,radius,vertex),groupCount+=3;scope.addGroup(groupStart,groupCount,!0===top?1:2);groupStart+=groupCount}super();this.type="CylinderGeometry";this.parameters={radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength};const scope=this;radialSegments=Math.floor(radialSegments);heightSegments=Math.floor(heightSegments);const indices=[],vertices=[],normals=[],uvs=[];let index=0;const indexArray=[],halfHeight=height/2;let groupStart=
0;(function(){var normal=new Vector3,vertex=new Vector3;let groupCount=0;var slope=(radiusBottom-radiusTop)/height;for(var y=0;y<=heightSegments;y++){var indexRow=[];const v=y/heightSegments,radius=v*(radiusBottom-radiusTop)+radiusTop;for(let x=0;x<=radialSegments;x++){const u=x/radialSegments;var theta=u*thetaLength+thetaStart;const sinTheta=Math.sin(theta);theta=Math.cos(theta);vertex.x=radius*sinTheta;vertex.y=-v*height+halfHeight;vertex.z=radius*theta;vertices.push(vertex.x,vertex.y,vertex.z);
normal.set(sinTheta,slope,theta).normalize();normals.push(normal.x,normal.y,normal.z);uvs.push(u,1-v);indexRow.push(index++)}indexArray.push(indexRow)}for(normal=0;normal<radialSegments;normal++)for(vertex=0;vertex<heightSegments;vertex++)slope=indexArray[vertex+1][normal],y=indexArray[vertex+1][normal+1],indexRow=indexArray[vertex][normal+1],indices.push(indexArray[vertex][normal],slope,indexRow),indices.push(slope,y,indexRow),groupCount+=6;scope.addGroup(groupStart,groupCount,0);groupStart+=groupCount})();
!1===openEnded&&(0<radiusTop&&generateCap(!0),0<radiusBottom&&generateCap(!1));this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new CylinderGeometry(data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(radius=
1,height=1,radialSegments=8,heightSegments=1,openEnded=!1,thetaStart=0,thetaLength=2*Math.PI){super(0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength);this.type="ConeGeometry";this.parameters={radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength}}static fromJSON(data){return new ConeGeometry(data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(vertices=
[],indices=[],radius$jscomp$0=1,detail$jscomp$0=0){function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z)}function getVertexByIndex(index,vertex){index*=3;vertex.x=vertices[index+0];vertex.y=vertices[index+1];vertex.z=vertices[index+2]}function correctUV(uv,stride,vector,azimuth){0>azimuth&&1===uv.x&&(uvBuffer[stride]=uv.x-1);0===vector.x&&0===vector.z&&(uvBuffer[stride]=azimuth/2/Math.PI+.5)}super();this.type="PolyhedronGeometry";this.parameters={vertices,indices,radius:radius$jscomp$0,
detail:detail$jscomp$0};const vertexBuffer=[],uvBuffer=[];(function(detail){const a=new Vector3,b=new Vector3,c=new Vector3;for(let i$jscomp$0=0;i$jscomp$0<indices.length;i$jscomp$0+=3){getVertexByIndex(indices[i$jscomp$0+0],a);getVertexByIndex(indices[i$jscomp$0+1],b);getVertexByIndex(indices[i$jscomp$0+2],c);var a$jscomp$0=a,b$jscomp$0=b,c$jscomp$0=c;const cols=detail+1,v=[];for(let i=0;i<=cols;i++){v[i]=[];const aj=a$jscomp$0.clone().lerp(c$jscomp$0,i/cols),bj=b$jscomp$0.clone().lerp(c$jscomp$0,
i/cols),rows=cols-i;for(let j=0;j<=rows;j++)v[i][j]=0===j&&i===cols?aj:aj.clone().lerp(bj,j/rows)}for(a$jscomp$0=0;a$jscomp$0<cols;a$jscomp$0++)for(b$jscomp$0=0;b$jscomp$0<2*(cols-a$jscomp$0)-1;b$jscomp$0++)c$jscomp$0=Math.floor(b$jscomp$0/2),0===b$jscomp$0%2?(pushVertex(v[a$jscomp$0][c$jscomp$0+1]),pushVertex(v[a$jscomp$0+1][c$jscomp$0]),pushVertex(v[a$jscomp$0][c$jscomp$0])):(pushVertex(v[a$jscomp$0][c$jscomp$0+1]),pushVertex(v[a$jscomp$0+1][c$jscomp$0+1]),pushVertex(v[a$jscomp$0+1][c$jscomp$0]))}})(detail$jscomp$0);
(function(radius){const vertex=new Vector3;for(let i=0;i<vertexBuffer.length;i+=3)vertex.x=vertexBuffer[i+0],vertex.y=vertexBuffer[i+1],vertex.z=vertexBuffer[i+2],vertex.normalize().multiplyScalar(radius),vertexBuffer[i+0]=vertex.x,vertexBuffer[i+1]=vertex.y,vertexBuffer[i+2]=vertex.z})(radius$jscomp$0);(function(){var vertex=new Vector3;for(var i$jscomp$0=0;i$jscomp$0<vertexBuffer.length;i$jscomp$0+=3)vertex.x=vertexBuffer[i$jscomp$0+0],vertex.y=vertexBuffer[i$jscomp$0+1],vertex.z=vertexBuffer[i$jscomp$0+
2],uvBuffer.push(Math.atan2(vertex.z,-vertex.x)/2/Math.PI+.5,1-(Math.atan2(-vertex.y,Math.sqrt(vertex.x*vertex.x+vertex.z*vertex.z))/Math.PI+.5));vertex=new Vector3;i$jscomp$0=new Vector3;var c=new Vector3,centroid=new Vector3,uvA=new Vector2;const uvB=new Vector2,uvC=new Vector2;for(let i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){vertex.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]);i$jscomp$0.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]);c.set(vertexBuffer[i+6],vertexBuffer[i+
7],vertexBuffer[i+8]);uvA.set(uvBuffer[j+0],uvBuffer[j+1]);uvB.set(uvBuffer[j+2],uvBuffer[j+3]);uvC.set(uvBuffer[j+4],uvBuffer[j+5]);centroid.copy(vertex).add(i$jscomp$0).add(c).divideScalar(3);const azi=Math.atan2(centroid.z,-centroid.x);correctUV(uvA,j+0,vertex,azi);correctUV(uvB,j+2,i$jscomp$0,azi);correctUV(uvC,j+4,c,azi)}for(vertex=0;vertex<uvBuffer.length;vertex+=6)i$jscomp$0=uvBuffer[vertex+0],c=uvBuffer[vertex+2],centroid=uvBuffer[vertex+4],uvA=Math.min(i$jscomp$0,c,centroid),.9<Math.max(i$jscomp$0,
c,centroid)&&.1>uvA&&(.2>i$jscomp$0&&(uvBuffer[vertex+0]+=1),.2>c&&(uvBuffer[vertex+2]+=1),.2>centroid&&(uvBuffer[vertex+4]+=1))})();this.setAttribute("position",new Float32BufferAttribute(vertexBuffer,3));this.setAttribute("normal",new Float32BufferAttribute(vertexBuffer.slice(),3));this.setAttribute("uv",new Float32BufferAttribute(uvBuffer,2));0===detail$jscomp$0?this.computeVertexNormals():this.normalizeNormals()}static fromJSON(data){return new PolyhedronGeometry(data.vertices,data.indices,data.radius,
data.details)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t=(1+Math.sqrt(5))/2,r=1/t;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-t,0,-r,t,0,r,-t,0,r,t,-r,-t,0,-r,t,0,r,-t,0,r,t,0,-t,0,-r,t,0,-r,-t,0,r,t,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,
19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],radius,detail);this.type="DodecahedronGeometry";this.parameters={radius,detail}}static fromJSON(data){return new DodecahedronGeometry(data.radius,data.detail)}}const _v0=new Vector3,_v1$1=new Vector3,_normal=new Vector3,_triangle=new Triangle;class EdgesGeometry extends BufferGeometry{constructor(geometry=null,thresholdAngle=1){super();this.type="EdgesGeometry";this.parameters={geometry,thresholdAngle};if(null!==geometry){const precision=Math.pow(10,
4);thresholdAngle=Math.cos(DEG2RAD*thresholdAngle);const indexAttr=geometry.getIndex();geometry=geometry.getAttribute("position");const indexCount=indexAttr?indexAttr.count:geometry.count,indexArr=[0,0,0],vertKeys=["a","b","c"],hashes=Array(3),edgeData={},vertices=[];for(let i=0;i<indexCount;i+=3){indexAttr?(indexArr[0]=indexAttr.getX(i),indexArr[1]=indexAttr.getX(i+1),indexArr[2]=indexAttr.getX(i+2)):(indexArr[0]=i,indexArr[1]=i+1,indexArr[2]=i+2);const {a,b,c}=_triangle;a.fromBufferAttribute(geometry,
indexArr[0]);b.fromBufferAttribute(geometry,indexArr[1]);c.fromBufferAttribute(geometry,indexArr[2]);_triangle.getNormal(_normal);hashes[0]=`${Math.round(a.x*precision)},${Math.round(a.y*precision)},${Math.round(a.z*precision)}`;hashes[1]=`${Math.round(b.x*precision)},${Math.round(b.y*precision)},${Math.round(b.z*precision)}`;hashes[2]=`${Math.round(c.x*precision)},${Math.round(c.y*precision)},${Math.round(c.z*precision)}`;if(hashes[0]!==hashes[1]&&hashes[1]!==hashes[2]&&hashes[2]!==hashes[0])for(let j=
0;3>j;j++){const jNext=(j+1)%3;var vecHash0=hashes[j];const vecHash1=hashes[jNext],v0=_triangle[vertKeys[j]],v1=_triangle[vertKeys[jNext]],hash=`${vecHash0}_${vecHash1}`;vecHash0=`${vecHash1}_${vecHash0}`;vecHash0 in edgeData&&edgeData[vecHash0]?(_normal.dot(edgeData[vecHash0].normal)<=thresholdAngle&&(vertices.push(v0.x,v0.y,v0.z),vertices.push(v1.x,v1.y,v1.z)),edgeData[vecHash0]=null):hash in edgeData||(edgeData[hash]={index0:indexArr[j],index1:indexArr[jNext],normal:_normal.clone()})}}for(const key in edgeData)if(edgeData[key]){const {index0,
index1}=edgeData[key];_v0.fromBufferAttribute(geometry,index0);_v1$1.fromBufferAttribute(geometry,index1);vertices.push(_v0.x,_v0.y,_v0.z);vertices.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(vertices,3))}}}class Shape extends Path{constructor(points){super(points);this.uuid=generateUUID();this.type="Shape";this.holes=[]}getPointsHoles(divisions){const holesPts=[];for(let i=0,l=this.holes.length;i<l;i++)holesPts[i]=this.holes[i].getPoints(divisions);return holesPts}extractPoints(divisions){return{shape:this.getPoints(divisions),
holes:this.getPointsHoles(divisions)}}copy(source){super.copy(source);this.holes=[];for(let i=0,l=source.holes.length;i<l;i++)this.holes.push(source.holes[i].clone());return this}toJSON(){const data=super.toJSON();data.uuid=this.uuid;data.holes=[];for(let i=0,l=this.holes.length;i<l;i++)data.holes.push(this.holes[i].toJSON());return data}fromJSON(json){super.fromJSON(json);this.uuid=json.uuid;this.holes=[];for(let i=0,l=json.holes.length;i<l;i++){const hole=json.holes[i];this.holes.push((new Path).fromJSON(hole))}return this}}
const Earcut={triangulate:function(data,holeIndices,dim=2){var hasHoles=holeIndices&&holeIndices.length;const outerLen=hasHoles?holeIndices[0]*dim:data.length;var outerNode=linkedList(data,0,outerLen,dim,!0);const triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;let minX,minY;var maxX;if(hasHoles){var y=outerNode;outerNode=[];var len;hasHoles=0;for(len=holeIndices.length;hasHoles<len;hasHoles++){var start=holeIndices[hasHoles]*dim;var end=hasHoles<len-1?holeIndices[hasHoles+
1]*dim:data.length;var list=linkedList(data,start,end,dim,!1);list===list.next&&(list.steiner=!0);start=outerNode;end=start.push;var p=list,leftmost=list;do{if(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)leftmost=p;p=p.next}while(p!==list);end.call(start,leftmost)}outerNode.sort(compareX);for(hasHoles=0;hasHoles<outerNode.length;hasHoles++){len=void 0;holeIndices=outerNode[hasHoles];b:{start=y;end=-Infinity;list=holeIndices.x;p=holeIndices.y;do{if(p<=start.y&&p>=start.next.y&&start.next.y!==
start.y&&(leftmost=start.x+(p-start.y)*(start.next.x-start.x)/(start.next.y-start.y),leftmost<=list&&leftmost>end&&(end=leftmost,len=start.x<start.next.x?start:start.next,leftmost===list)))break b;start=start.next}while(start!==y);if(len){var stop=len,mx=len.x,my=len.y,tanMin=Infinity;start=len;do{if(list>=start.x&&start.x>=mx&&list!==start.x&&pointInTriangle(p<my?list:end,p,mx,my,p<my?end:list,p,start.x,start.y)){leftmost=Math.abs(p-start.y)/(list-start.x);var JSCompiler_temp;if((JSCompiler_temp=
locallyInside(start,holeIndices))&&!(JSCompiler_temp=leftmost<tanMin)&&(JSCompiler_temp=leftmost===tanMin)&&!(JSCompiler_temp=start.x>len.x)&&(JSCompiler_temp=start.x===len.x)){JSCompiler_temp=len;var p$jscomp$0=start;JSCompiler_temp=0>area(JSCompiler_temp.prev,JSCompiler_temp,p$jscomp$0.prev)&&0>area(p$jscomp$0.next,JSCompiler_temp,JSCompiler_temp.next)}JSCompiler_temp&&(len=start,tanMin=leftmost)}start=start.next}while(start!==stop)}else len=null}len&&(holeIndices=splitPolygon(len,holeIndices),
filterPoints(holeIndices,holeIndices.next),y=filterPoints(len,len.next))}outerNode=y}if(data.length>80*dim){minX=maxX=data[0];minY=hasHoles=data[1];for(len=dim;len<outerLen;len+=dim)holeIndices=data[len],y=data[len+1],holeIndices<minX&&(minX=holeIndices),y<minY&&(minY=y),holeIndices>maxX&&(maxX=holeIndices),y>hasHoles&&(hasHoles=y);maxX=Math.max(maxX-minX,hasHoles-minY);maxX=0!==maxX?32767/maxX:0}earcutLinked(outerNode,triangles,dim,minX,minY,maxX,0);return triangles}};class ShapeUtils{static area(contour){const n=
contour.length;let a=0;for(let p=n-1,q=0;q<n;p=q++)a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;return.5*a}static isClockWise(pts){return 0>ShapeUtils.area(pts)}static triangulateShape(contour,holes){var vertices=[];const holeIndices=[],faces=[];removeDupEndPts(contour);addContour(vertices,contour);contour=contour.length;holes.forEach(removeDupEndPts);for(let i=0;i<holes.length;i++)holeIndices.push(contour),contour+=holes[i].length,addContour(vertices,holes[i]);holes=Earcut.triangulate(vertices,
holeIndices);for(vertices=0;vertices<holes.length;vertices+=3)faces.push(holes.slice(vertices,vertices+3));return faces}}class ExtrudeGeometry extends BufferGeometry{constructor(shapes=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),options={}){function addShape(shape){function scalePt2(pt,vec,size){vec||console.error("THREE.ExtrudeGeometry: vec does not exist");return vec.clone().multiplyScalar(size).add(pt)}function getBevelVec(inPt,inPrev,inNext){var v_trans_y=
inPt.x-inPrev.x;var shrink_by=inPt.y-inPrev.y;var v_trans_x=inNext.x-inPt.x;var v_next_y=inNext.y-inPt.y,v_prev_lensq=v_trans_y*v_trans_y+shrink_by*shrink_by;if(Math.abs(v_trans_y*v_next_y-shrink_by*v_trans_x)>Number.EPSILON){const v_prev_len=Math.sqrt(v_prev_lensq),v_next_len=Math.sqrt(v_trans_x*v_trans_x+v_next_y*v_next_y);v_prev_lensq=inPrev.x-shrink_by/v_prev_len;inPrev=inPrev.y+v_trans_y/v_prev_len;v_next_y=((inNext.x-v_next_y/v_next_len-v_prev_lensq)*v_next_y-(inNext.y+v_trans_x/v_next_len-
inPrev)*v_trans_x)/(v_trans_y*v_next_y-shrink_by*v_trans_x);v_trans_x=v_prev_lensq+v_trans_y*v_next_y-inPt.x;v_trans_y=inPrev+shrink_by*v_next_y-inPt.y;shrink_by=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(2>=shrink_by)return new Vector2(v_trans_x,v_trans_y);shrink_by=Math.sqrt(shrink_by/2)}else inPt=!1,v_trans_y>Number.EPSILON?v_trans_x>Number.EPSILON&&(inPt=!0):v_trans_y<-Number.EPSILON?v_trans_x<-Number.EPSILON&&(inPt=!0):Math.sign(shrink_by)===Math.sign(v_next_y)&&(inPt=!0),inPt?(v_trans_x=-shrink_by,
shrink_by=Math.sqrt(v_prev_lensq)):(v_trans_x=v_trans_y,v_trans_y=shrink_by,shrink_by=Math.sqrt(v_prev_lensq/2));return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by)}function sidewalls(contour,layeroffset){let i=contour.length;for(;0<=--i;){const j=i;let k=i-1;0>k&&(k=contour.length-1);for(let s=0,sl=steps+2*bevelSegments;s<sl;s++){const slen1=vlen*s;var slen2=vlen*(s+1),b=layeroffset+k+slen1,c=layeroffset+k+slen2;slen2=layeroffset+j+slen2;addVertex(layeroffset+j+slen1);addVertex(b);addVertex(slen2);
addVertex(b);addVertex(c);addVertex(slen2);b=verticesArray.length/3;b=uvgen.generateSideWallUV(scope,verticesArray,b-6,b-3,b-2,b-1);addUV(b[0]);addUV(b[1]);addUV(b[3]);addUV(b[1]);addUV(b[2]);addUV(b[3])}}}function v(x,y,z){placeholder.push(x);placeholder.push(y);placeholder.push(z)}function f3(a,b,c){addVertex(a);addVertex(b);addVertex(c);a=verticesArray.length/3;a=uvgen.generateTopUV(scope,verticesArray,a-3,a-2,a-1);addUV(a[0]);addUV(a[1]);addUV(a[2])}function addVertex(index){verticesArray.push(placeholder[3*
index]);verticesArray.push(placeholder[3*index+1]);verticesArray.push(placeholder[3*index+2])}function addUV(vector2){uvArray.push(vector2.x);uvArray.push(vector2.y)}const placeholder=[];var curveSegments=void 0!==options.curveSegments?options.curveSegments:12;const steps=void 0!==options.steps?options.steps:1,depth=void 0!==options.depth?options.depth:1;let bevelEnabled=void 0!==options.bevelEnabled?options.bevelEnabled:!0,bevelThickness=void 0!==options.bevelThickness?options.bevelThickness:.2,
bevelSize=void 0!==options.bevelSize?options.bevelSize:bevelThickness-.1,bevelOffset=void 0!==options.bevelOffset?options.bevelOffset:0,bevelSegments=void 0!==options.bevelSegments?options.bevelSegments:3;var extrudePath=options.extrudePath;const uvgen=void 0!==options.UVGenerator?options.UVGenerator:WorldUVGenerator;let extrudePts,extrudeByPath=!1;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps);extrudeByPath=!0;bevelEnabled=!1;var splineTube=extrudePath.computeFrenetFrames(steps,!1);
var binormal=new Vector3;var normal=new Vector3;var position2=new Vector3}bevelEnabled||(bevelOffset=bevelSize=bevelThickness=bevelSegments=0);shape=shape.extractPoints(curveSegments);extrudePath=shape.shape;const holes=shape.holes;if(!ShapeUtils.isClockWise(extrudePath)){extrudePath=extrudePath.reverse();for(let h=0,hl=holes.length;h<hl;h++)shape=holes[h],ShapeUtils.isClockWise(shape)&&(holes[h]=shape.reverse())}const faces=ShapeUtils.triangulateShape(extrudePath,holes),contour$jscomp$0=extrudePath;
for(let h=0,hl=holes.length;h<hl;h++)extrudePath=extrudePath.concat(holes[h]);const vlen=extrudePath.length,flen=faces.length;shape=[];for(let i=0,il=contour$jscomp$0.length,j=il-1,k=i+1;i<il;i++,j++,k++)j===il&&(j=0),k===il&&(k=0),shape[i]=getBevelVec(contour$jscomp$0[i],contour$jscomp$0[j],contour$jscomp$0[k]);curveSegments=[];let verticesMovements=shape.concat();for(let h=0,hl=holes.length;h<hl;h++){var ahole$jscomp$0=holes[h];var oneHoleMovements=[];for(let i=0,il=ahole$jscomp$0.length,j=il-1,
k=i+1;i<il;i++,j++,k++)j===il&&(j=0),k===il&&(k=0),oneHoleMovements[i]=getBevelVec(ahole$jscomp$0[i],ahole$jscomp$0[j],ahole$jscomp$0[k]);curveSegments.push(oneHoleMovements);verticesMovements=verticesMovements.concat(oneHoleMovements)}for(ahole$jscomp$0=0;ahole$jscomp$0<bevelSegments;ahole$jscomp$0++){oneHoleMovements=ahole$jscomp$0/bevelSegments;var z$jscomp$0=bevelThickness*Math.cos(oneHoleMovements*Math.PI/2),bs=bevelSize*Math.sin(oneHoleMovements*Math.PI/2)+bevelOffset;for(let i=0,il=contour$jscomp$0.length;i<
il;i++)oneHoleMovements=scalePt2(contour$jscomp$0[i],shape[i],bs),v(oneHoleMovements.x,oneHoleMovements.y,-z$jscomp$0);for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];oneHoleMovements=curveSegments[h];for(let i=0,il=ahole.length;i<il;i++){const vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z$jscomp$0)}}}oneHoleMovements=bevelSize+bevelOffset;for(ahole$jscomp$0=0;ahole$jscomp$0<vlen;ahole$jscomp$0++)z$jscomp$0=bevelEnabled?scalePt2(extrudePath[ahole$jscomp$0],verticesMovements[ahole$jscomp$0],
oneHoleMovements):extrudePath[ahole$jscomp$0],extrudeByPath?(normal.copy(splineTube.normals[0]).multiplyScalar(z$jscomp$0.x),binormal.copy(splineTube.binormals[0]).multiplyScalar(z$jscomp$0.y),position2.copy(extrudePts[0]).add(normal).add(binormal),v(position2.x,position2.y,position2.z)):v(z$jscomp$0.x,z$jscomp$0.y,0);for(ahole$jscomp$0=1;ahole$jscomp$0<=steps;ahole$jscomp$0++)for(z$jscomp$0=0;z$jscomp$0<vlen;z$jscomp$0++)bs=bevelEnabled?scalePt2(extrudePath[z$jscomp$0],verticesMovements[z$jscomp$0],
oneHoleMovements):extrudePath[z$jscomp$0],extrudeByPath?(normal.copy(splineTube.normals[ahole$jscomp$0]).multiplyScalar(bs.x),binormal.copy(splineTube.binormals[ahole$jscomp$0]).multiplyScalar(bs.y),position2.copy(extrudePts[ahole$jscomp$0]).add(normal).add(binormal),v(position2.x,position2.y,position2.z)):v(bs.x,bs.y,depth/steps*ahole$jscomp$0);for(splineTube=bevelSegments-1;0<=splineTube;splineTube--){normal=splineTube/bevelSegments;binormal=bevelThickness*Math.cos(normal*Math.PI/2);normal=bevelSize*
Math.sin(normal*Math.PI/2)+bevelOffset;for(let i=0,il=contour$jscomp$0.length;i<il;i++)position2=scalePt2(contour$jscomp$0[i],shape[i],normal),v(position2.x,position2.y,depth+binormal);for(let h=0,hl=holes.length;h<hl;h++){position2=holes[h];oneHoleMovements=curveSegments[h];for(let i=0,il=position2.length;i<il;i++)extrudePath=scalePt2(position2[i],oneHoleMovements[i],normal),extrudeByPath?v(extrudePath.x,extrudePath.y+extrudePts[steps-1].y,extrudePts[steps-1].x+binormal):v(extrudePath.x,extrudePath.y,
depth+binormal)}}(function(){const start=verticesArray.length/3;if(bevelEnabled){var offset=0*vlen;for(var i=0;i<flen;i++){var face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset)}offset=vlen*(steps+2*bevelSegments);for(i=0;i<flen;i++)face=faces[i],f3(face[0]+offset,face[1]+offset,face[2]+offset)}else{for(offset=0;offset<flen;offset++)i=faces[offset],f3(i[2],i[1],i[0]);for(offset=0;offset<flen;offset++)i=faces[offset],f3(i[0]+vlen*steps,i[1]+vlen*steps,i[2]+vlen*steps)}scope.addGroup(start,
verticesArray.length/3-start,0)})();(function(){const start=verticesArray.length/3;let layeroffset=0;sidewalls(contour$jscomp$0,layeroffset);layeroffset+=contour$jscomp$0.length;for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];sidewalls(ahole,layeroffset);layeroffset+=ahole.length}scope.addGroup(start,verticesArray.length/3-start,1)})()}super();this.type="ExtrudeGeometry";this.parameters={shapes,options};shapes=Array.isArray(shapes)?shapes:[shapes];const scope=this,verticesArray=[],uvArray=
[];for(let i=0,l=shapes.length;i<l;i++)addShape(shapes[i]);this.setAttribute("position",new Float32BufferAttribute(verticesArray,3));this.setAttribute("uv",new Float32BufferAttribute(uvArray,2));this.computeVertexNormals()}toJSON(){const data=super.toJSON();var shapes=this.parameters.shapes,options=this.parameters.options;data.shapes=[];if(Array.isArray(shapes))for(let i=0,l=shapes.length;i<l;i++)data.shapes.push(shapes[i].uuid);else data.shapes.push(shapes.uuid);data.options=Object.assign({},options);
void 0!==options.extrudePath&&(data.options.extrudePath=options.extrudePath.toJSON());return data}static fromJSON(data,shapes){const geometryShapes=[];for(let j=0,jl=data.shapes.length;j<jl;j++)geometryShapes.push(shapes[data.shapes[j]]);shapes=data.options.extrudePath;void 0!==shapes&&(data.options.extrudePath=(new Curves[shapes.type]).fromJSON(shapes));return new ExtrudeGeometry(geometryShapes,data.options)}}const WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){geometry=
vertices[3*indexB];indexB=vertices[3*indexB+1];const c_x=vertices[3*indexC];indexC=vertices[3*indexC+1];return[new Vector2(vertices[3*indexA],vertices[3*indexA+1]),new Vector2(geometry,indexB),new Vector2(c_x,indexC)]},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){geometry=vertices[3*indexA];const a_y=vertices[3*indexA+1];indexA=vertices[3*indexA+2];const b_x=vertices[3*indexB],b_y=vertices[3*indexB+1];indexB=vertices[3*indexB+2];const c_x=vertices[3*indexC],c_y=vertices[3*
indexC+1];indexC=vertices[3*indexC+2];const d_x=vertices[3*indexD],d_y=vertices[3*indexD+1];vertices=vertices[3*indexD+2];return Math.abs(a_y-b_y)<Math.abs(geometry-b_x)?[new Vector2(geometry,1-indexA),new Vector2(b_x,1-indexB),new Vector2(c_x,1-indexC),new Vector2(d_x,1-vertices)]:[new Vector2(a_y,1-indexA),new Vector2(b_y,1-indexB),new Vector2(c_y,1-indexC),new Vector2(d_y,1-vertices)]}};class IcosahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t=(1+Math.sqrt(5))/
2;super([-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],radius,detail);this.type="IcosahedronGeometry";this.parameters={radius,detail}}static fromJSON(data){return new IcosahedronGeometry(data.radius,data.detail)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,
0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],radius,detail);this.type="OctahedronGeometry";this.parameters={radius,detail}}static fromJSON(data){return new OctahedronGeometry(data.radius,data.detail)}}class RingGeometry extends BufferGeometry{constructor(innerRadius=.5,outerRadius=1,thetaSegments=8,phiSegments=1,thetaStart=0,thetaLength=2*Math.PI){super();this.type="RingGeometry";this.parameters={innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength};thetaSegments=
Math.max(3,thetaSegments);phiSegments=Math.max(1,phiSegments);const indices=[],vertices=[],normals=[],uvs=[];var radius=innerRadius;innerRadius=(outerRadius-innerRadius)/phiSegments;var vertex=new Vector3,uv=new Vector2;for(let j=0;j<=phiSegments;j++){for(let i=0;i<=thetaSegments;i++){const segment=thetaStart+i/thetaSegments*thetaLength;vertex.x=radius*Math.cos(segment);vertex.y=radius*Math.sin(segment);vertices.push(vertex.x,vertex.y,vertex.z);normals.push(0,0,1);uv.x=(vertex.x/outerRadius+1)/2;
uv.y=(vertex.y/outerRadius+1)/2;uvs.push(uv.x,uv.y)}radius+=innerRadius}for(outerRadius=0;outerRadius<phiSegments;outerRadius++)for(thetaStart=outerRadius*(thetaSegments+1),thetaLength=0;thetaLength<thetaSegments;thetaLength++)radius=thetaLength+thetaStart,innerRadius=radius+thetaSegments+1,vertex=radius+thetaSegments+2,uv=radius+1,indices.push(radius,innerRadius,uv),indices.push(innerRadius,vertex,uv);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",
new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new RingGeometry(data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(shapes=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),curveSegments=12){function addShape(shape){const indexOffset=vertices.length/3;var points=shape.extractPoints(curveSegments);
shape=points.shape;var shapeHoles=points.holes;!1===ShapeUtils.isClockWise(shape)&&(shape=shape.reverse());for(let i=0,l=shapeHoles.length;i<l;i++)points=shapeHoles[i],!0===ShapeUtils.isClockWise(points)&&(shapeHoles[i]=points.reverse());points=ShapeUtils.triangulateShape(shape,shapeHoles);for(let i=0,l=shapeHoles.length;i<l;i++)shape=shape.concat(shapeHoles[i]);for(let i=0,l=shape.length;i<l;i++)shapeHoles=shape[i],vertices.push(shapeHoles.x,shapeHoles.y,0),normals.push(0,0,1),uvs.push(shapeHoles.x,
shapeHoles.y);for(let i=0,l=points.length;i<l;i++)shape=points[i],indices.push(shape[0]+indexOffset,shape[1]+indexOffset,shape[2]+indexOffset),groupCount+=3}super();this.type="ShapeGeometry";this.parameters={shapes,curveSegments};const indices=[],vertices=[],normals=[],uvs=[];let groupStart=0,groupCount=0;if(!1===Array.isArray(shapes))addShape(shapes);else for(let i=0;i<shapes.length;i++)addShape(shapes[i]),this.addGroup(groupStart,groupCount,i),groupStart+=groupCount,groupCount=0;this.setIndex(indices);
this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}toJSON(){const data=super.toJSON();var shapes=this.parameters.shapes;data.shapes=[];if(Array.isArray(shapes))for(let i=0,l=shapes.length;i<l;i++)data.shapes.push(shapes[i].uuid);else data.shapes.push(shapes.uuid);return data}static fromJSON(data,shapes){const geometryShapes=[];for(let j=0,jl=data.shapes.length;j<
jl;j++)geometryShapes.push(shapes[data.shapes[j]]);return new ShapeGeometry(geometryShapes,data.curveSegments)}}class SphereGeometry extends BufferGeometry{constructor(radius=1,widthSegments=32,heightSegments=16,phiStart=0,phiLength=2*Math.PI,thetaStart=0,thetaLength=Math.PI){super();this.type="SphereGeometry";this.parameters={radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength};widthSegments=Math.max(3,Math.floor(widthSegments));heightSegments=Math.max(2,Math.floor(heightSegments));
const thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);var index=0;const grid=[];var vertex=new Vector3;const normal=new Vector3,indices=[],vertices=[],normals=[],uvs=[];for(let iy=0;iy<=heightSegments;iy++){const verticesRow=[],v=iy/heightSegments;let uOffset=0;0==iy&&0==thetaStart?uOffset=.5/widthSegments:iy==heightSegments&&thetaEnd==Math.PI&&(uOffset=-.5/widthSegments);for(let ix=0;ix<=widthSegments;ix++){const u=ix/widthSegments;vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+
v*thetaLength);vertex.y=radius*Math.cos(thetaStart+v*thetaLength);vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength);vertices.push(vertex.x,vertex.y,vertex.z);normal.copy(vertex).normalize();normals.push(normal.x,normal.y,normal.z);uvs.push(u+uOffset,1-v);verticesRow.push(index++)}grid.push(verticesRow)}for(radius=0;radius<heightSegments;radius++)for(phiStart=0;phiStart<widthSegments;phiStart++)phiLength=grid[radius][phiStart+1],thetaLength=grid[radius][phiStart],index=
grid[radius+1][phiStart],vertex=grid[radius+1][phiStart+1],(0!==radius||0<thetaStart)&&indices.push(phiLength,thetaLength,vertex),(radius!==heightSegments-1||thetaEnd<Math.PI)&&indices.push(thetaLength,index,vertex);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new SphereGeometry(data.radius,data.widthSegments,
data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],radius,detail);this.type="TetrahedronGeometry";this.parameters={radius,detail}}static fromJSON(data){return new TetrahedronGeometry(data.radius,data.detail)}}class TorusGeometry extends BufferGeometry{constructor(radius=1,tube=.4,radialSegments=8,tubularSegments=6,arc=
2*Math.PI){super();this.type="TorusGeometry";this.parameters={radius,tube,radialSegments,tubularSegments,arc};radialSegments=Math.floor(radialSegments);tubularSegments=Math.floor(tubularSegments);const indices=[],vertices=[],normals=[],uvs=[];var center=new Vector3,vertex=new Vector3;const normal=new Vector3;for(let j=0;j<=radialSegments;j++)for(let i=0;i<=tubularSegments;i++){const u=i/tubularSegments*arc,v=j/radialSegments*Math.PI*2;vertex.x=(radius+tube*Math.cos(v))*Math.cos(u);vertex.y=(radius+
tube*Math.cos(v))*Math.sin(u);vertex.z=tube*Math.sin(v);vertices.push(vertex.x,vertex.y,vertex.z);center.x=radius*Math.cos(u);center.y=radius*Math.sin(u);normal.subVectors(vertex,center).normalize();normals.push(normal.x,normal.y,normal.z);uvs.push(i/tubularSegments);uvs.push(j/radialSegments)}for(radius=1;radius<=radialSegments;radius++)for(tube=1;tube<=tubularSegments;tube++)arc=(tubularSegments+1)*(radius-1)+tube-1,center=(tubularSegments+1)*(radius-1)+tube,vertex=(tubularSegments+1)*radius+tube,
indices.push((tubularSegments+1)*radius+tube-1,arc,vertex),indices.push(arc,center,vertex);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}static fromJSON(data){return new TorusGeometry(data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(radius$jscomp$0=
1,tube=.4,tubularSegments=64,radialSegments=8,p$jscomp$0=2,q$jscomp$0=3){function calculatePositionOnCurve(u,p,q,radius,position){const su=Math.sin(u);p=q/p*u;q=Math.cos(p);position.x=radius*(2+q)*.5*Math.cos(u);position.y=radius*(2+q)*su*.5;position.z=radius*Math.sin(p)*.5}super();this.type="TorusKnotGeometry";this.parameters={radius:radius$jscomp$0,tube,tubularSegments,radialSegments,p:p$jscomp$0,q:q$jscomp$0};tubularSegments=Math.floor(tubularSegments);radialSegments=Math.floor(radialSegments);
const indices=[],vertices=[],normals=[],uvs=[];var vertex=new Vector3;const normal=new Vector3,P1=new Vector3,P2=new Vector3,B=new Vector3,T=new Vector3,N=new Vector3;for(let i=0;i<=tubularSegments;++i){var u$jscomp$0=i/tubularSegments*p$jscomp$0*Math.PI*2;calculatePositionOnCurve(u$jscomp$0,p$jscomp$0,q$jscomp$0,radius$jscomp$0,P1);calculatePositionOnCurve(u$jscomp$0+.01,p$jscomp$0,q$jscomp$0,radius$jscomp$0,P2);T.subVectors(P2,P1);N.addVectors(P2,P1);B.crossVectors(T,N);N.crossVectors(B,T);B.normalize();
N.normalize();for(u$jscomp$0=0;u$jscomp$0<=radialSegments;++u$jscomp$0){var v=u$jscomp$0/radialSegments*Math.PI*2;const cx=-tube*Math.cos(v);v=tube*Math.sin(v);vertex.x=P1.x+(cx*N.x+v*B.x);vertex.y=P1.y+(cx*N.y+v*B.y);vertex.z=P1.z+(cx*N.z+v*B.z);vertices.push(vertex.x,vertex.y,vertex.z);normal.subVectors(vertex,P1).normalize();normals.push(normal.x,normal.y,normal.z);uvs.push(i/tubularSegments);uvs.push(u$jscomp$0/radialSegments)}}for(radius$jscomp$0=1;radius$jscomp$0<=tubularSegments;radius$jscomp$0++)for(tube=
1;tube<=radialSegments;tube++)p$jscomp$0=(radialSegments+1)*radius$jscomp$0+(tube-1),q$jscomp$0=(radialSegments+1)*radius$jscomp$0+tube,vertex=(radialSegments+1)*(radius$jscomp$0-1)+tube,indices.push((radialSegments+1)*(radius$jscomp$0-1)+(tube-1),p$jscomp$0,vertex),indices.push(p$jscomp$0,q$jscomp$0,vertex);this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,
2))}static fromJSON(data){return new TorusKnotGeometry(data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q)}}class TubeGeometry extends BufferGeometry{constructor(path=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),tubularSegments=64,radius=1,radialSegments=8,closed=!1){function generateSegment(i){P=path.getPointAt(i/tubularSegments,P);const N=frames.normals[i];i=frames.binormals[i];for(let j=0;j<=radialSegments;j++){var v=j/radialSegments*
Math.PI*2;const sin=Math.sin(v);v=-Math.cos(v);normal.x=v*N.x+sin*i.x;normal.y=v*N.y+sin*i.y;normal.z=v*N.z+sin*i.z;normal.normalize();normals.push(normal.x,normal.y,normal.z);vertex.x=P.x+radius*normal.x;vertex.y=P.y+radius*normal.y;vertex.z=P.z+radius*normal.z;vertices.push(vertex.x,vertex.y,vertex.z)}}super();this.type="TubeGeometry";this.parameters={path,tubularSegments,radius,radialSegments,closed};const frames=path.computeFrenetFrames(tubularSegments,closed);this.tangents=frames.tangents;this.normals=
frames.normals;this.binormals=frames.binormals;const vertex=new Vector3,normal=new Vector3,uv=new Vector2;let P=new Vector3;const vertices=[],normals=[],uvs=[],indices=[];(function(){for(var i=0;i<tubularSegments;i++)generateSegment(i);generateSegment(!1===closed?tubularSegments:0);for(i=0;i<=tubularSegments;i++)for(var j=0;j<=radialSegments;j++)uv.x=i/tubularSegments,uv.y=j/radialSegments,uvs.push(uv.x,uv.y);for(i=1;i<=tubularSegments;i++)for(j=1;j<=radialSegments;j++){const b=(radialSegments+1)*
i+(j-1),c=(radialSegments+1)*i+j,d=(radialSegments+1)*(i-1)+j;indices.push((radialSegments+1)*(i-1)+(j-1),b,d);indices.push(b,c,d)}})();this.setIndex(indices);this.setAttribute("position",new Float32BufferAttribute(vertices,3));this.setAttribute("normal",new Float32BufferAttribute(normals,3));this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}toJSON(){const data=super.toJSON();data.path=this.parameters.path.toJSON();return data}static fromJSON(data){return new TubeGeometry((new Curves[data.path.type]).fromJSON(data.path),
data.tubularSegments,data.radius,data.radialSegments,data.closed)}}class WireframeGeometry extends BufferGeometry{constructor(geometry=null){super();this.type="WireframeGeometry";this.parameters={geometry};if(null!==geometry){const vertices=[],edges=new Set,start=new Vector3,end=new Vector3;if(null!==geometry.index){var position=geometry.attributes.position,indices=geometry.index;geometry=geometry.groups;0===geometry.length&&(geometry=[{start:0,count:indices.count,materialIndex:0}]);for(let o=0,ol=
geometry.length;o<ol;++o){var group=geometry[o],groupStart=group.start;group=group.count;for(let i=groupStart,l=groupStart+group;i<l;i+=3)for(groupStart=0;3>groupStart;groupStart++){group=indices.getX(i+groupStart);const index2=indices.getX(i+(groupStart+1)%3);start.fromBufferAttribute(position,group);end.fromBufferAttribute(position,index2);!0===isUniqueEdge(start,end,edges)&&(vertices.push(start.x,start.y,start.z),vertices.push(end.x,end.y,end.z))}}}else{position=geometry.attributes.position;for(let i=
0,l=position.count/3;i<l;i++)for(indices=0;3>indices;indices++)geometry=3*i+(indices+1)%3,start.fromBufferAttribute(position,3*i+indices),end.fromBufferAttribute(position,geometry),!0===isUniqueEdge(start,end,edges)&&(vertices.push(start.x,start.y,start.z),vertices.push(end.x,end.y,end.z))}this.setAttribute("position",new Float32BufferAttribute(vertices,3))}}}var Geometries=Object.freeze({__proto__:null,BoxGeometry,CapsuleGeometry,CircleGeometry,ConeGeometry,CylinderGeometry,DodecahedronGeometry,
EdgesGeometry,ExtrudeGeometry,IcosahedronGeometry,LatheGeometry,OctahedronGeometry,PlaneGeometry,PolyhedronGeometry,RingGeometry,ShapeGeometry,SphereGeometry,TetrahedronGeometry,TorusGeometry,TorusKnotGeometry,TubeGeometry,WireframeGeometry});class ShadowMaterial extends Material{constructor(parameters){super();this.isShadowMaterial=!0;this.type="ShadowMaterial";this.color=new Color(0);this.fog=this.transparent=!0;this.setValues(parameters)}copy(source){super.copy(source);this.color.copy(source.color);
this.fog=source.fog;return this}}class RawShaderMaterial extends ShaderMaterial{constructor(parameters){super(parameters);this.isRawShaderMaterial=!0;this.type="RawShaderMaterial"}}class MeshStandardMaterial extends Material{constructor(parameters){super();this.isMeshStandardMaterial=!0;this.defines={STANDARD:""};this.type="MeshStandardMaterial";this.color=new Color(16777215);this.roughness=1;this.metalness=0;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=
1;this.emissive=new Color(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.envMap=this.alphaMap=this.metalnessMap=this.roughnessMap=null;this.envMapIntensity=1;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.flatShading=!1;this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);
this.defines={STANDARD:""};this.color.copy(source.color);this.roughness=source.roughness;this.metalness=source.metalness;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=
source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.roughnessMap=source.roughnessMap;this.metalnessMap=source.metalnessMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.envMapIntensity=source.envMapIntensity;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(parameters){super();this.isMeshPhysicalMaterial=!0;this.defines={STANDARD:"",PHYSICAL:""};this.type="MeshPhysicalMaterial";this.clearcoatMap=null;this.clearcoatRoughness=0;this.clearcoatRoughnessMap=null;this.clearcoatNormalScale=new Vector2(1,1);this.clearcoatNormalMap=null;this.ior=1.5;Object.defineProperty(this,
"reflectivity",{get:function(){return clamp(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(reflectivity){this.ior=(1+.4*reflectivity)/(1-.4*reflectivity)}});this.iridescenceMap=null;this.iridescenceIOR=1.3;this.iridescenceThicknessRange=[100,400];this.iridescenceThicknessMap=null;this.sheenColor=new Color(0);this.sheenColorMap=null;this.sheenRoughness=1;this.transmissionMap=this.sheenRoughnessMap=null;this.thickness=0;this.thicknessMap=null;this.attenuationDistance=Infinity;this.attenuationColor=
new Color(1,1,1);this.specularIntensity=1;this.specularIntensityMap=null;this.specularColor=new Color(1,1,1);this.specularColorMap=null;this._transmission=this._iridescence=this._clearcoat=this._sheen=0;this.setValues(parameters)}get sheen(){return this._sheen}set sheen(value){0<this._sheen!==0<value&&this.version++;this._sheen=value}get clearcoat(){return this._clearcoat}set clearcoat(value){0<this._clearcoat!==0<value&&this.version++;this._clearcoat=value}get iridescence(){return this._iridescence}set iridescence(value){0<
this._iridescence!==0<value&&this.version++;this._iridescence=value}get transmission(){return this._transmission}set transmission(value){0<this._transmission!==0<value&&this.version++;this._transmission=value}copy(source){super.copy(source);this.defines={STANDARD:"",PHYSICAL:""};this.clearcoat=source.clearcoat;this.clearcoatMap=source.clearcoatMap;this.clearcoatRoughness=source.clearcoatRoughness;this.clearcoatRoughnessMap=source.clearcoatRoughnessMap;this.clearcoatNormalMap=source.clearcoatNormalMap;
this.clearcoatNormalScale.copy(source.clearcoatNormalScale);this.ior=source.ior;this.iridescence=source.iridescence;this.iridescenceMap=source.iridescenceMap;this.iridescenceIOR=source.iridescenceIOR;this.iridescenceThicknessRange=[...source.iridescenceThicknessRange];this.iridescenceThicknessMap=source.iridescenceThicknessMap;this.sheen=source.sheen;this.sheenColor.copy(source.sheenColor);this.sheenColorMap=source.sheenColorMap;this.sheenRoughness=source.sheenRoughness;this.sheenRoughnessMap=source.sheenRoughnessMap;
this.transmission=source.transmission;this.transmissionMap=source.transmissionMap;this.thickness=source.thickness;this.thicknessMap=source.thicknessMap;this.attenuationDistance=source.attenuationDistance;this.attenuationColor.copy(source.attenuationColor);this.specularIntensity=source.specularIntensity;this.specularIntensityMap=source.specularIntensityMap;this.specularColor.copy(source.specularColor);this.specularColorMap=source.specularColorMap;return this}}class MeshPhongMaterial extends Material{constructor(parameters){super();
this.isMeshPhongMaterial=!0;this.type="MeshPhongMaterial";this.color=new Color(16777215);this.specular=new Color(1118481);this.shininess=30;this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.envMap=this.alphaMap=
this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.flatShading=!1;this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);this.color.copy(source.color);this.specular.copy(source.specular);this.shininess=source.shininess;this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=
source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=
source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this}}class MeshToonMaterial extends Material{constructor(parameters){super();this.isMeshToonMaterial=!0;this.defines=
{TOON:""};this.type="MeshToonMaterial";this.color=new Color(16777215);this.lightMap=this.gradientMap=this.map=null;this.lightMapIntensity=1;this.aoMap=null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.alphaMap=null;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=
this.wireframeLinecap="round";this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.gradientMap=source.gradientMap;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;
this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.alphaMap=source.alphaMap;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;this.wireframeLinejoin=source.wireframeLinejoin;this.fog=source.fog;return this}}class MeshNormalMaterial extends Material{constructor(parameters){super();
this.isMeshNormalMaterial=!0;this.type="MeshNormalMaterial";this.bumpMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.wireframe=!1;this.wireframeLinewidth=1;this.flatShading=!1;this.setValues(parameters)}copy(source){super.copy(source);this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);
this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.flatShading=source.flatShading;return this}}class MeshLambertMaterial extends Material{constructor(parameters){super();this.isMeshLambertMaterial=!0;this.type="MeshLambertMaterial";this.color=new Color(16777215);this.lightMap=this.map=null;this.lightMapIntensity=1;this.aoMap=
null;this.aoMapIntensity=1;this.emissive=new Color(0);this.emissiveIntensity=1;this.bumpMap=this.emissiveMap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=0;this.envMap=this.alphaMap=this.specularMap=null;this.combine=0;this.reflectivity=1;this.refractionRatio=.98;this.wireframe=!1;this.wireframeLinewidth=1;this.wireframeLinejoin=this.wireframeLinecap="round";this.flatShading=
!1;this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);this.color.copy(source.color);this.map=source.map;this.lightMap=source.lightMap;this.lightMapIntensity=source.lightMapIntensity;this.aoMap=source.aoMap;this.aoMapIntensity=source.aoMapIntensity;this.emissive.copy(source.emissive);this.emissiveMap=source.emissiveMap;this.emissiveIntensity=source.emissiveIntensity;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;
this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=source.displacementBias;this.specularMap=source.specularMap;this.alphaMap=source.alphaMap;this.envMap=source.envMap;this.combine=source.combine;this.reflectivity=source.reflectivity;this.refractionRatio=source.refractionRatio;this.wireframe=source.wireframe;this.wireframeLinewidth=source.wireframeLinewidth;this.wireframeLinecap=source.wireframeLinecap;
this.wireframeLinejoin=source.wireframeLinejoin;this.flatShading=source.flatShading;this.fog=source.fog;return this}}class MeshMatcapMaterial extends Material{constructor(parameters){super();this.isMeshMatcapMaterial=!0;this.defines={MATCAP:""};this.type="MeshMatcapMaterial";this.color=new Color(16777215);this.bumpMap=this.map=this.matcap=null;this.bumpScale=1;this.normalMap=null;this.normalMapType=0;this.normalScale=new Vector2(1,1);this.displacementMap=null;this.displacementScale=1;this.displacementBias=
0;this.alphaMap=null;this.flatShading=!1;this.fog=!0;this.setValues(parameters)}copy(source){super.copy(source);this.defines={MATCAP:""};this.color.copy(source.color);this.matcap=source.matcap;this.map=source.map;this.bumpMap=source.bumpMap;this.bumpScale=source.bumpScale;this.normalMap=source.normalMap;this.normalMapType=source.normalMapType;this.normalScale.copy(source.normalScale);this.displacementMap=source.displacementMap;this.displacementScale=source.displacementScale;this.displacementBias=
source.displacementBias;this.alphaMap=source.alphaMap;this.flatShading=source.flatShading;this.fog=source.fog;return this}}class LineDashedMaterial extends LineBasicMaterial{constructor(parameters){super();this.isLineDashedMaterial=!0;this.type="LineDashedMaterial";this.scale=1;this.dashSize=3;this.gapSize=1;this.setValues(parameters)}copy(source){super.copy(source);this.scale=source.scale;this.dashSize=source.dashSize;this.gapSize=source.gapSize;return this}}var AnimationUtils=Object.freeze({__proto__:null,
arraySlice,convertArray,isTypedArray,getKeyframeOrder,sortedArray,flattenJSON,subclip:function(sourceClip,name,startFrame,endFrame,fps=30){sourceClip=sourceClip.clone();sourceClip.name=name;name=[];for(let i=0;i<sourceClip.tracks.length;++i){const track=sourceClip.tracks[i],valueSize=track.getValueSize(),times=[],values=[];for(let j=0;j<track.times.length;++j){var frame=track.times[j]*fps;if(!(frame<startFrame||frame>=endFrame))for(times.push(track.times[j]),frame=0;frame<valueSize;++frame)values.push(track.values[j*
valueSize+frame])}0!==times.length&&(track.times=convertArray(times,track.times.constructor),track.values=convertArray(values,track.values.constructor),name.push(track))}sourceClip.tracks=name;startFrame=Infinity;for(endFrame=0;endFrame<sourceClip.tracks.length;++endFrame)startFrame>sourceClip.tracks[endFrame].times[0]&&(startFrame=sourceClip.tracks[endFrame].times[0]);for(endFrame=0;endFrame<sourceClip.tracks.length;++endFrame)sourceClip.tracks[endFrame].shift(-1*startFrame);sourceClip.resetDuration();
return sourceClip},makeClipAdditive:function(targetClip,referenceFrame=0,referenceClip=targetClip,fps=30){0>=fps&&(fps=30);const numTracks=referenceClip.tracks.length;referenceFrame/=fps;for(fps=0;fps<numTracks;++fps){const referenceTrack=referenceClip.tracks[fps],referenceTrackType=referenceTrack.ValueTypeName;if("bool"===referenceTrackType||"string"===referenceTrackType)continue;const targetTrack=targetClip.tracks.find(function(track){return track.name===referenceTrack.name&&track.ValueTypeName===
referenceTrackType});if(void 0===targetTrack)continue;var referenceOffset=0,referenceValueSize=referenceTrack.getValueSize();referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(referenceOffset=referenceValueSize/3);let targetOffset=0;const targetValueSize=targetTrack.getValueSize();targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(targetOffset=targetValueSize/3);var lastIndex=referenceTrack.times.length-1;if(referenceFrame<=referenceTrack.times[0])referenceOffset=
arraySlice(referenceTrack.values,referenceOffset,referenceValueSize-referenceOffset);else if(referenceFrame>=referenceTrack.times[lastIndex])lastIndex=lastIndex*referenceValueSize+referenceOffset,referenceOffset=arraySlice(referenceTrack.values,lastIndex,lastIndex+referenceValueSize-referenceOffset);else{lastIndex=referenceTrack.createInterpolant();var startIndex=referenceOffset;referenceOffset=referenceValueSize-referenceOffset;lastIndex.evaluate(referenceFrame);referenceOffset=arraySlice(lastIndex.resultBuffer,
startIndex,referenceOffset)}"quaternion"===referenceTrackType&&(new Quaternion).fromArray(referenceOffset).normalize().conjugate().toArray(referenceOffset);referenceValueSize=targetTrack.times.length;for(lastIndex=0;lastIndex<referenceValueSize;++lastIndex)if(startIndex=lastIndex*targetValueSize+targetOffset,"quaternion"===referenceTrackType)Quaternion.multiplyQuaternionsFlat(targetTrack.values,startIndex,referenceOffset,0,targetTrack.values,startIndex);else{const valueEnd=targetValueSize-2*targetOffset;
for(let k=0;k<valueEnd;++k)targetTrack.values[startIndex+k]-=referenceOffset[k]}}targetClip.blendMode=2501;return targetClip}});class Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions;this._cachedIndex=0;this.resultBuffer=void 0!==resultBuffer?resultBuffer:new sampleValues.constructor(sampleSize);this.sampleValues=sampleValues;this.valueSize=sampleSize;this.settings=null;this.DefaultSettings_={}}evaluate(t){const pp=this.parameterPositions;
let i1=this._cachedIndex;var t1=pp[i1],t0=pp[i1-1];a:{b:{c:{d:if(!(t<t1)){for(var giveUpAt=i1+2;;){if(void 0===t1){if(t<t0)break d;this._cachedIndex=i1=pp.length;return this.copySampleValue_(i1-1)}if(i1===giveUpAt)break;t0=t1;t1=pp[++i1];if(t<t1)break b}t0=pp.length;break c}if(t>=t0)break a;else{t1=pp[1];t<t1&&(i1=2,t0=t1);for(giveUpAt=i1-2;;){if(void 0===t0)return this._cachedIndex=0,this.copySampleValue_(0);if(i1===giveUpAt)break;t1=t0;t0=pp[--i1-1];if(t>=t0)break b}t0=i1;i1=0}}for(;i1<t0;)t1=i1+
t0>>>1,t<pp[t1]?t0=t1:i1=t1+1;t1=pp[i1];t0=pp[i1-1];if(void 0===t0)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===t1)return this._cachedIndex=i1=pp.length,this.copySampleValue_(i1-1)}this._cachedIndex=i1;this.intervalChanged_(i1,t0,t1)}return this.interpolate_(i1,t0,t,t1)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize;index*=stride;for(let i=0;i!==stride;++i)result[i]=
values[index+i];return result}interpolate_(){throw Error("call to abstract method");}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer);this._offsetNext=this._weightNext=this._offsetPrev=this._weightPrev=-0;this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(i1,t0,t1){var pp=this.parameterPositions;let iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],
tNext=pp[iNext];if(void 0===tPrev)switch(this.getSettings_().endingStart){case 2401:iPrev=i1;tPrev=2*t0-t1;break;case 2402:iPrev=pp.length-2;tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:iPrev=i1,tPrev=t1}if(void 0===tNext)switch(this.getSettings_().endingEnd){case 2401:iNext=i1;tNext=2*t1-t0;break;case 2402:iNext=1;tNext=t1+pp[1]-pp[0];break;default:iNext=i1-1,tNext=t0}i1=.5*(t1-t0);pp=this.valueSize;this._weightPrev=i1/(t0-tPrev);this._weightNext=i1/(tNext-t1);this._offsetPrev=iPrev*pp;this._offsetNext=
iNext*pp}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize;i1*=stride;const o0=i1-stride,oP=this._offsetPrev,oN=this._offsetNext;var wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0);t=p*p;t1=t*p;t0=-wP*t1+2*wP*t-wP*p;wP=(1+wP)*t1+(-1.5-2*wP)*t+(-.5+wP)*p+1;p=(-1-wN)*t1+(1.5+wN)*t+.5*p;wN=wN*t1-wN*t;for(t=0;t!==stride;++t)result[t]=t0*values[oP+t]+wP*values[o0+t]+p*values[i1+t]+wN*values[oN+t];return result}}class LinearInterpolant extends Interpolant{constructor(parameterPositions,
sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize;i1*=stride;const offset0=i1-stride;t0=(t-t0)/(t1-t0);t=1-t0;for(t1=0;t1!==stride;++t1)result[t1]=values[offset0+t1]*t+values[i1+t1]*t0;return result}}class DiscreteInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,
sampleSize,resultBuffer)}interpolate_(i1){return this.copySampleValue_(i1-1)}}class KeyframeTrack{constructor(name,times,values,interpolation){if(void 0===name)throw Error("THREE.KeyframeTrack: track name is undefined");if(void 0===times||0===times.length)throw Error("THREE.KeyframeTrack: no keyframes in track named "+name);this.name=name;this.times=convertArray(times,this.TimeBufferType);this.values=convertArray(values,this.ValueBufferType);this.setInterpolation(interpolation||this.DefaultInterpolation)}static toJSON(track){var trackType=
track.constructor;if(trackType.toJSON!==this.toJSON)trackType=trackType.toJSON(track);else{trackType={name:track.name,times:convertArray(track.times,Array),values:convertArray(track.values,Array)};const interpolation=track.getInterpolation();interpolation!==track.DefaultInterpolation&&(trackType.interpolation=interpolation)}trackType.type=track.ValueTypeName;return trackType}InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result)}InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,
this.values,this.getValueSize(),result)}InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result)}setInterpolation(interpolation){switch(interpolation){case 2300:var factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case 2301:factoryMethod=this.InterpolantFactoryMethodLinear;break;case 2302:factoryMethod=this.InterpolantFactoryMethodSmooth}if(void 0===factoryMethod){factoryMethod="unsupported interpolation for "+this.ValueTypeName+
" keyframe track named "+this.name;if(void 0===this.createInterpolant)if(interpolation!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw Error(factoryMethod);console.warn("THREE.KeyframeTrack:",factoryMethod);return this}this.createInterpolant=factoryMethod;return this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302}}getValueSize(){return this.values.length/
this.times.length}shift(timeOffset){if(0!==timeOffset){const times=this.times;for(let i=0,n=times.length;i!==n;++i)times[i]+=timeOffset}return this}scale(timeScale){if(1!==timeScale){const times=this.times;for(let i=0,n=times.length;i!==n;++i)times[i]*=timeScale}return this}trim(startTime,endTime){const times=this.times,nKeys=times.length;let from=0,to=nKeys-1;for(;from!==nKeys&&times[from]<startTime;)++from;for(;-1!==to&&times[to]>endTime;)--to;++to;if(0!==from||to!==nKeys)from>=to&&(to=Math.max(to,
1),from=to-1),startTime=this.getValueSize(),this.times=arraySlice(times,from,to),this.values=arraySlice(this.values,from*startTime,to*startTime);return this}validate(){let valid=!0;var valueSize=this.getValueSize();0!==valueSize-Math.floor(valueSize)&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),valid=!1);var times=this.times;valueSize=this.values;const nKeys=times.length;0===nKeys&&(console.error("THREE.KeyframeTrack: Track is empty.",this),valid=!1);let prevTime=null;
for(let i=0;i!==nKeys;i++){const currTime=times[i];if("number"===typeof currTime&&isNaN(currTime)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,i,currTime);valid=!1;break}if(null!==prevTime&&prevTime>currTime){console.error("THREE.KeyframeTrack: Out of order keys.",this,i,currTime,prevTime);valid=!1;break}prevTime=currTime}if(void 0!==valueSize&&isTypedArray(valueSize))for(let i=0,n=valueSize.length;i!==n;++i)if(times=valueSize[i],isNaN(times)){console.error("THREE.KeyframeTrack: Value is not a valid number.",
this,i,times);valid=!1;break}return valid}optimize(){const times=arraySlice(this.times),values=arraySlice(this.values),stride=this.getValueSize(),smoothInterpolation=2302===this.getInterpolation(),lastIndex=times.length-1;let writeIndex=1;for(let i=1;i<lastIndex;++i){var keep=!1,time=times[i];if(time!==times[i+1]&&(1!==i||time!==times[0]))if(smoothInterpolation)keep=!0;else{time=i*stride;var offsetP=time-stride;const offsetN=time+stride;for(let j=0;j!==stride;++j){const value=values[time+j];if(value!==
values[offsetP+j]||value!==values[offsetN+j]){keep=!0;break}}}if(keep){if(i!==writeIndex)for(times[writeIndex]=times[i],keep=i*stride,time=writeIndex*stride,offsetP=0;offsetP!==stride;++offsetP)values[time+offsetP]=values[keep+offsetP];++writeIndex}}if(0<lastIndex){times[writeIndex]=times[lastIndex];for(let readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j)values[writeOffset+j]=values[readOffset+j];++writeIndex}writeIndex!==times.length?(this.times=arraySlice(times,0,writeIndex),
this.values=arraySlice(values,0,writeIndex*stride)):(this.times=times,this.values=values);return this}clone(){var times=arraySlice(this.times,0);const values=arraySlice(this.values,0);times=new this.constructor(this.name,times,values);times.createInterpolant=this.createInterpolant;return times}}KeyframeTrack.prototype.TimeBufferType=Float32Array;KeyframeTrack.prototype.ValueBufferType=Float32Array;KeyframeTrack.prototype.DefaultInterpolation=2301;class BooleanKeyframeTrack extends KeyframeTrack{}
BooleanKeyframeTrack.prototype.ValueTypeName="bool";BooleanKeyframeTrack.prototype.ValueBufferType=Array;BooleanKeyframeTrack.prototype.DefaultInterpolation=2300;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0;BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{}NumberKeyframeTrack.prototype.ValueTypeName="number";
class QuaternionLinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize;t0=(t-t0)/(t1-t0);i1*=stride;for(t=i1+stride;i1!==t;i1+=4)Quaternion.slerpFlat(result,0,values,i1-stride,values,i1,t0);return result}}class QuaternionKeyframeTrack extends KeyframeTrack{InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,
this.values,this.getValueSize(),result)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion";QuaternionKeyframeTrack.prototype.DefaultInterpolation=2301;QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{}StringKeyframeTrack.prototype.ValueTypeName="string";StringKeyframeTrack.prototype.ValueBufferType=Array;StringKeyframeTrack.prototype.DefaultInterpolation=2300;StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=
void 0;StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(name,duration=-1,tracks,blendMode=2500){this.name=name;this.tracks=tracks;this.duration=duration;this.blendMode=blendMode;this.uuid=generateUUID();0>this.duration&&this.resetDuration()}static parse(json){var tracks=[];const jsonTracks=json.tracks,frameTime=1/(json.fps||1);for(let i=0,n=jsonTracks.length;i!==
n;++i){var JSCompiler_temp_const=tracks,JSCompiler_temp_const$jscomp$0=JSCompiler_temp_const.push;{var JSCompiler_inline_result=jsonTracks[i];if(void 0===JSCompiler_inline_result.type)throw Error("THREE.KeyframeTrack: track type undefined, can not parse");const trackType=getTrackTypeForValueTypeName(JSCompiler_inline_result.type);if(void 0===JSCompiler_inline_result.times){const times=[],values=[];flattenJSON(JSCompiler_inline_result.keys,times,values,"value");JSCompiler_inline_result.times=times;
JSCompiler_inline_result.values=values}JSCompiler_inline_result=void 0!==trackType.parse?trackType.parse(JSCompiler_inline_result):new trackType(JSCompiler_inline_result.name,JSCompiler_inline_result.times,JSCompiler_inline_result.values,JSCompiler_inline_result.interpolation)}JSCompiler_temp_const$jscomp$0.call(JSCompiler_temp_const,JSCompiler_inline_result.scale(frameTime))}tracks=new this(json.name,json.duration,tracks,json.blendMode);tracks.uuid=json.uuid;return tracks}static toJSON(clip){const tracks=
[],clipTracks=clip.tracks;clip={name:clip.name,duration:clip.duration,tracks,uuid:clip.uuid,blendMode:clip.blendMode};for(let i=0,n=clipTracks.length;i!==n;++i)tracks.push(KeyframeTrack.toJSON(clipTracks[i]));return clip}static CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){const numMorphTargets=morphTargetSequence.length,tracks=[];for(let i=0;i<numMorphTargets;i++){let times=[],values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets);values.push(0,1,
0);const order=getKeyframeOrder(times);times=sortedArray(times,1,order);values=sortedArray(values,1,order);noLoop||0!==times[0]||(times.push(numMorphTargets),values.push(values[0]));tracks.push((new NumberKeyframeTrack(".morphTargetInfluences["+morphTargetSequence[i].name+"]",times,values)).scale(1/fps))}return new this(name,-1,tracks)}static findByName(objectOrClipArray,name){let clipArray=objectOrClipArray;Array.isArray(objectOrClipArray)||(clipArray=objectOrClipArray.geometry&&objectOrClipArray.geometry.animations||
objectOrClipArray.animations);for(objectOrClipArray=0;objectOrClipArray<clipArray.length;objectOrClipArray++)if(clipArray[objectOrClipArray].name===name)return clipArray[objectOrClipArray];return null}static CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){const animationToMorphTargets={},pattern=/^([\w-]*?)([\d]+)$/;for(let i=0,il=morphTargets.length;i<il;i++){const morphTarget=morphTargets[i];var parts=morphTarget.name.match(pattern);if(parts&&1<parts.length){parts=parts[1];let animationMorphTargets=
animationToMorphTargets[parts];animationMorphTargets||(animationToMorphTargets[parts]=animationMorphTargets=[]);animationMorphTargets.push(morphTarget)}}morphTargets=[];for(const name in animationToMorphTargets)morphTargets.push(this.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));return morphTargets}static parseAnimation(animation,bones){if(!animation)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const addNonemptyTrack=function(trackType,
trackName,animationKeys,propertyName,destTracks){if(0!==animationKeys.length){const times=[],values=[];flattenJSON(animationKeys,times,values,propertyName);0!==times.length&&destTracks.push(new trackType(trackName,times,values))}},tracks=[],clipName=animation.name||"default",fps=animation.fps||30,blendMode=animation.blendMode;var duration=animation.length||-1;animation=animation.hierarchy||[];for(let h=0;h<animation.length;h++){const animationKeys=animation[h].keys;if(animationKeys&&0!==animationKeys.length)if(animationKeys[0].morphTargets){duration=
{};var k=void 0;for(k=0;k<animationKeys.length;k++)if(animationKeys[k].morphTargets)for(var m$jscomp$0=0;m$jscomp$0<animationKeys[k].morphTargets.length;m$jscomp$0++)duration[animationKeys[k].morphTargets[m$jscomp$0]]=-1;for(const morphTargetName in duration){m$jscomp$0=[];const values=[];for(let m=0;m!==animationKeys[k].morphTargets.length;++m){const animationKey=animationKeys[k];m$jscomp$0.push(animationKey.time);values.push(animationKey.morphTarget===morphTargetName?1:0)}tracks.push(new NumberKeyframeTrack(".morphTargetInfluence["+
morphTargetName+"]",m$jscomp$0,values))}duration=duration.length*fps}else k=".bones["+bones[h].name+"]",addNonemptyTrack(VectorKeyframeTrack,k+".position",animationKeys,"pos",tracks),addNonemptyTrack(QuaternionKeyframeTrack,k+".quaternion",animationKeys,"rot",tracks),addNonemptyTrack(VectorKeyframeTrack,k+".scale",animationKeys,"scl",tracks)}return 0===tracks.length?null:new this(clipName,duration,tracks,blendMode)}resetDuration(){var tracks=this.tracks;let duration=0;for(let i=0,n=tracks.length;i!==
n;++i)tracks=this.tracks[i],duration=Math.max(duration,tracks.times[tracks.times.length-1]);this.duration=duration;return this}trim(){for(let i=0;i<this.tracks.length;i++)this.tracks[i].trim(0,this.duration);return this}validate(){let valid=!0;for(let i=0;i<this.tracks.length;i++)valid=valid&&this.tracks[i].validate();return valid}optimize(){for(let i=0;i<this.tracks.length;i++)this.tracks[i].optimize();return this}clone(){const tracks=[];for(let i=0;i<this.tracks.length;i++)tracks.push(this.tracks[i].clone());
return new this.constructor(this.name,this.duration,tracks,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}const Cache={enabled:!1,files:{},add:function(key,file){!1!==this.enabled&&(this.files[key]=file)},get:function(key){if(!1!==this.enabled)return this.files[key]},remove:function(key){delete this.files[key]},clear:function(){this.files={}}};class LoadingManager{constructor(onLoad,onProgress,onError){const scope=this;let isLoading=!1,itemsLoaded=0,itemsTotal=0,urlModifier=void 0;
const handlers=[];this.onStart=void 0;this.onLoad=onLoad;this.onProgress=onProgress;this.onError=onError;this.itemStart=function(url){itemsTotal++;if(!1===isLoading&&void 0!==scope.onStart)scope.onStart(url,itemsLoaded,itemsTotal);isLoading=!0};this.itemEnd=function(url){itemsLoaded++;if(void 0!==scope.onProgress)scope.onProgress(url,itemsLoaded,itemsTotal);if(itemsLoaded===itemsTotal&&(isLoading=!1,void 0!==scope.onLoad))scope.onLoad()};this.itemError=function(url){if(void 0!==scope.onError)scope.onError(url)};
this.resolveURL=function(url){return urlModifier?urlModifier(url):url};this.setURLModifier=function(transform){urlModifier=transform;return this};this.addHandler=function(regex,loader){handlers.push(regex,loader);return this};this.removeHandler=function(regex){regex=handlers.indexOf(regex);-1!==regex&&handlers.splice(regex,2);return this};this.getHandler=function(file){for(let i=0,l=handlers.length;i<l;i+=2){const regex=handlers[i],loader=handlers[i+1];regex.global&&(regex.lastIndex=0);if(regex.test(file))return loader}return null}}}
const DefaultLoadingManager=new LoadingManager;class Loader{constructor(manager){this.manager=void 0!==manager?manager:DefaultLoadingManager;this.crossOrigin="anonymous";this.withCredentials=!1;this.resourcePath=this.path="";this.requestHeader={}}load(){}loadAsync(url,onProgress){const scope=this;return new Promise(function(resolve,reject){scope.load(url,resolve,onProgress,reject)})}parse(){}setCrossOrigin(crossOrigin){this.crossOrigin=crossOrigin;return this}setWithCredentials(value){this.withCredentials=
value;return this}setPath(path){this.path=path;return this}setResourcePath(resourcePath){this.resourcePath=resourcePath;return this}setRequestHeader(requestHeader){this.requestHeader=requestHeader;return this}}const loading={};class HttpError extends Error{constructor(message,response){super(message);this.response=response}}class FileLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){void 0===url&&(url="");void 0!==this.path&&(url=this.path+url);url=this.manager.resolveURL(url);
const cached=Cache.get(url);if(void 0!==cached)return this.manager.itemStart(url),setTimeout(()=>{onLoad&&onLoad(cached);this.manager.itemEnd(url)},0),cached;if(void 0!==loading[url])loading[url].push({onLoad,onProgress,onError});else{loading[url]=[];loading[url].push({onLoad,onProgress,onError});onProgress=new Request(url,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"});var mimeType=this.mimeType,responseType=this.responseType;fetch(onProgress).then(response=>
{if(200===response.status||0===response.status){0===response.status&&console.warn("THREE.FileLoader: HTTP Status 0 received.");if("undefined"===typeof ReadableStream||void 0===response.body||void 0===response.body.getReader)return response;const callbacks=loading[url],reader=response.body.getReader(),total=(response=response.headers.get("Content-Length"))?parseInt(response):0,lengthComputable=0!==total;let loaded=0;response=new ReadableStream({start(controller){function readData(){reader.read().then(({done,
value})=>{if(done)controller.close();else{loaded+=value.byteLength;done=new ProgressEvent("progress",{lengthComputable,loaded,total});for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onProgress)callback.onProgress(done)}controller.enqueue(value);readData()}})}readData()}});return new Response(response)}throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`,response);}).then(response=>{switch(responseType){case "arraybuffer":return response.arrayBuffer();
case "blob":return response.blob();case "document":return response.text().then(text=>(new DOMParser).parseFromString(text,mimeType));case "json":return response.json();default:if(void 0===mimeType)return response.text();var exec=/charset="?([^;"\s]*)"?/i.exec(mimeType);exec=exec&&exec[1]?exec[1].toLowerCase():void 0;const decoder=new TextDecoder(exec);return response.arrayBuffer().then(ab=>decoder.decode(ab))}}).then(data=>{Cache.add(url,data);const callbacks=loading[url];delete loading[url];for(let i=
0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onLoad)callback.onLoad(data)}}).catch(err=>{const callbacks=loading[url];if(void 0===callbacks)throw this.manager.itemError(url),err;delete loading[url];for(let i=0,il=callbacks.length;i<il;i++){const callback=callbacks[i];if(callback.onError)callback.onError(err)}this.manager.itemError(url)}).finally(()=>{this.manager.itemEnd(url)});this.manager.itemStart(url)}}setResponseType(value){this.responseType=value;return this}setMimeType(value){this.mimeType=
value;return this}}class AnimationLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}parse(json){const animations=[];for(let i=
0;i<json.length;i++){const clip=AnimationClip.parse(json[i]);animations.push(clip)}return animations}}class CompressedTextureLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){function loadTexture(i){loader.load(url[i],function(buffer){buffer=scope.parse(buffer,!0);images[i]={width:buffer.width,height:buffer.height,format:buffer.format,mipmaps:buffer.mipmaps};loaded+=1;6===loaded&&(1===buffer.mipmapCount&&(texture.minFilter=1006),texture.image=images,texture.format=
buffer.format,texture.needsUpdate=!0,onLoad&&onLoad(texture))},onProgress,onError)}const scope=this,images=[],texture=new CompressedTexture,loader=new FileLoader(this.manager);loader.setPath(this.path);loader.setResponseType("arraybuffer");loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(scope.withCredentials);let loaded=0;if(Array.isArray(url))for(let i=0,il=url.length;i<il;++i)loadTexture(i);else loader.load(url,function(buffer){buffer=scope.parse(buffer,!0);if(buffer.isCubemap){const faces=
buffer.mipmaps.length/buffer.mipmapCount;for(let f=0;f<faces;f++){images[f]={mipmaps:[]};for(let i=0;i<buffer.mipmapCount;i++)images[f].mipmaps.push(buffer.mipmaps[f*buffer.mipmapCount+i]),images[f].format=buffer.format,images[f].width=buffer.width,images[f].height=buffer.height}texture.image=images}else texture.image.width=buffer.width,texture.image.height=buffer.height,texture.mipmaps=buffer.mipmaps;1===buffer.mipmapCount&&(texture.minFilter=1006);texture.format=buffer.format;texture.needsUpdate=
!0;onLoad&&onLoad(texture)},onProgress,onError);return texture}}class ImageLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){function onImageLoad(){removeEventListeners();Cache.add(url,this);onLoad&&onLoad(this);scope.manager.itemEnd(url)}function onImageError(event){removeEventListeners();onError&&onError(event);scope.manager.itemError(url);scope.manager.itemEnd(url)}function removeEventListeners(){image.removeEventListener("load",onImageLoad,!1);image.removeEventListener("error",
onImageError,!1)}void 0!==this.path&&(url=this.path+url);url=this.manager.resolveURL(url);const scope=this,cached=Cache.get(url);if(void 0!==cached)return scope.manager.itemStart(url),setTimeout(function(){onLoad&&onLoad(cached);scope.manager.itemEnd(url)},0),cached;const image=createElementNS("img");image.addEventListener("load",onImageLoad,!1);image.addEventListener("error",onImageError,!1);"data:"!==url.slice(0,5)&&void 0!==this.crossOrigin&&(image.crossOrigin=this.crossOrigin);scope.manager.itemStart(url);
image.src=url;return image}}class CubeTextureLoader extends Loader{constructor(manager){super(manager)}load(urls,onLoad,onProgress,onError){function loadTexture(i){loader.load(urls[i],function(image){texture.images[i]=image;loaded++;6===loaded&&(texture.needsUpdate=!0,onLoad&&onLoad(texture))},void 0,onError)}const texture=new CubeTexture,loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);let loaded=0;for(onProgress=0;onProgress<urls.length;++onProgress)loadTexture(onProgress);
return texture}}class DataTextureLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,texture=new DataTexture,loader=new FileLoader(this.manager);loader.setResponseType("arraybuffer");loader.setRequestHeader(this.requestHeader);loader.setPath(this.path);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(buffer){if(buffer=scope.parse(buffer))void 0!==buffer.image?texture.image=buffer.image:void 0!==buffer.data&&(texture.image.width=
buffer.width,texture.image.height=buffer.height,texture.image.data=buffer.data),texture.wrapS=void 0!==buffer.wrapS?buffer.wrapS:1001,texture.wrapT=void 0!==buffer.wrapT?buffer.wrapT:1001,texture.magFilter=void 0!==buffer.magFilter?buffer.magFilter:1006,texture.minFilter=void 0!==buffer.minFilter?buffer.minFilter:1006,texture.anisotropy=void 0!==buffer.anisotropy?buffer.anisotropy:1,void 0!==buffer.encoding&&(texture.encoding=buffer.encoding),void 0!==buffer.flipY&&(texture.flipY=buffer.flipY),void 0!==
buffer.format&&(texture.format=buffer.format),void 0!==buffer.type&&(texture.type=buffer.type),void 0!==buffer.mipmaps&&(texture.mipmaps=buffer.mipmaps,texture.minFilter=1008),1===buffer.mipmapCount&&(texture.minFilter=1006),void 0!==buffer.generateMipmaps&&(texture.generateMipmaps=buffer.generateMipmaps),texture.needsUpdate=!0,onLoad&&onLoad(texture,buffer)},onProgress,onError);return texture}}class TextureLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const texture=
new Texture,loader=new ImageLoader(this.manager);loader.setCrossOrigin(this.crossOrigin);loader.setPath(this.path);loader.load(url,function(image){texture.image=image;texture.needsUpdate=!0;void 0!==onLoad&&onLoad(texture)},onProgress,onError);return texture}}class Light extends Object3D{constructor(color,intensity=1){super();this.isLight=!0;this.type="Light";this.color=new Color(color);this.intensity=intensity}dispose(){}copy(source,recursive){super.copy(source,recursive);this.color.copy(source.color);
this.intensity=source.intensity;return this}toJSON(meta){meta=super.toJSON(meta);meta.object.color=this.color.getHex();meta.object.intensity=this.intensity;void 0!==this.groundColor&&(meta.object.groundColor=this.groundColor.getHex());void 0!==this.distance&&(meta.object.distance=this.distance);void 0!==this.angle&&(meta.object.angle=this.angle);void 0!==this.decay&&(meta.object.decay=this.decay);void 0!==this.penumbra&&(meta.object.penumbra=this.penumbra);void 0!==this.shadow&&(meta.object.shadow=
this.shadow.toJSON());return meta}}class HemisphereLight extends Light{constructor(skyColor,groundColor,intensity){super(skyColor,intensity);this.isHemisphereLight=!0;this.type="HemisphereLight";this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.groundColor=new Color(groundColor)}copy(source,recursive){super.copy(source,recursive);this.groundColor.copy(source.groundColor);return this}}const _projScreenMatrix$1=new Matrix4,_lightPositionWorld$1=new Vector3,_lookTarget$1=new Vector3;class LightShadow{constructor(camera){this.camera=
camera;this.normalBias=this.bias=0;this.radius=1;this.blurSamples=8;this.mapSize=new Vector2(512,512);this.mapPass=this.map=null;this.matrix=new Matrix4;this.autoUpdate=!0;this.needsUpdate=!1;this._frustum=new Frustum;this._frameExtents=new Vector2(1,1);this._viewportCount=1;this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(light){const shadowCamera=this.camera,shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
shadowCamera.position.copy(_lightPositionWorld$1);_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);shadowCamera.lookAt(_lookTarget$1);shadowCamera.updateMatrixWorld();_projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);shadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1);shadowMatrix.multiply(_projScreenMatrix$1)}getViewport(viewportIndex){return this._viewports[viewportIndex]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&
this.map.dispose();this.mapPass&&this.mapPass.dispose()}copy(source){this.camera=source.camera.clone();this.bias=source.bias;this.radius=source.radius;this.mapSize.copy(source.mapSize);return this}clone(){return(new this.constructor).copy(this)}toJSON(){const object={};0!==this.bias&&(object.bias=this.bias);0!==this.normalBias&&(object.normalBias=this.normalBias);1!==this.radius&&(object.radius=this.radius);if(512!==this.mapSize.x||512!==this.mapSize.y)object.mapSize=this.mapSize.toArray();object.camera=
this.camera.toJSON(!1).object;delete object.camera.matrix;return object}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500));this.isSpotLightShadow=!0;this.focus=1}updateMatrices(light){const camera=this.camera,fov=2*RAD2DEG*light.angle*this.focus,aspect=this.mapSize.width/this.mapSize.height,far=light.distance||camera.far;if(fov!==camera.fov||aspect!==camera.aspect||far!==camera.far)camera.fov=fov,camera.aspect=aspect,camera.far=far,camera.updateProjectionMatrix();
super.updateMatrices(light)}copy(source){super.copy(source);this.focus=source.focus;return this}}class SpotLight extends Light{constructor(color,intensity,distance=0,angle=Math.PI/3,penumbra=0,decay=1){super(color,intensity);this.isSpotLight=!0;this.type="SpotLight";this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=new Object3D;this.distance=distance;this.angle=angle;this.penumbra=penumbra;this.decay=decay;this.map=null;this.shadow=new SpotLightShadow}get power(){return this.intensity*
Math.PI}set power(power){this.intensity=power/Math.PI}dispose(){this.shadow.dispose()}copy(source,recursive){super.copy(source,recursive);this.distance=source.distance;this.angle=source.angle;this.penumbra=source.penumbra;this.decay=source.decay;this.target=source.target.clone();this.shadow=source.shadow.clone();return this}}const _projScreenMatrix=new Matrix4,_lightPositionWorld=new Vector3,_lookTarget=new Vector3;class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,
1,.5,500));this.isPointLightShadow=!0;this._frameExtents=new Vector2(4,2);this._viewportCount=6;this._viewports=[new Vector4(2,1,1,1),new Vector4(0,1,1,1),new Vector4(3,1,1,1),new Vector4(1,1,1,1),new Vector4(3,0,1,1),new Vector4(1,0,1,1)];this._cubeDirections=[new Vector3(1,0,0),new Vector3(-1,0,0),new Vector3(0,0,1),new Vector3(0,0,-1),new Vector3(0,1,0),new Vector3(0,-1,0)];this._cubeUps=[new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,1,0),new Vector3(0,0,1),new Vector3(0,
0,-1)]}updateMatrices(light,viewportIndex=0){const camera=this.camera,shadowMatrix=this.matrix,far=light.distance||camera.far;far!==camera.far&&(camera.far=far,camera.updateProjectionMatrix());_lightPositionWorld.setFromMatrixPosition(light.matrixWorld);camera.position.copy(_lightPositionWorld);_lookTarget.copy(camera.position);_lookTarget.add(this._cubeDirections[viewportIndex]);camera.up.copy(this._cubeUps[viewportIndex]);camera.lookAt(_lookTarget);camera.updateMatrixWorld();shadowMatrix.makeTranslation(-_lightPositionWorld.x,
-_lightPositionWorld.y,-_lightPositionWorld.z);_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse);this._frustum.setFromProjectionMatrix(_projScreenMatrix)}}class PointLight extends Light{constructor(color,intensity,distance=0,decay=1){super(color,intensity);this.isPointLight=!0;this.type="PointLight";this.distance=distance;this.decay=decay;this.shadow=new PointLightShadow}get power(){return 4*this.intensity*Math.PI}set power(power){this.intensity=power/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(source,
recursive){super.copy(source,recursive);this.distance=source.distance;this.decay=source.decay;this.shadow=source.shadow.clone();return this}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500));this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(color,intensity){super(color,intensity);this.isDirectionalLight=!0;this.type="DirectionalLight";this.position.copy(Object3D.DefaultUp);this.updateMatrix();this.target=
new Object3D;this.shadow=new DirectionalLightShadow}dispose(){this.shadow.dispose()}copy(source){super.copy(source);this.target=source.target.clone();this.shadow=source.shadow.clone();return this}}class AmbientLight extends Light{constructor(color,intensity){super(color,intensity);this.isAmbientLight=!0;this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(color,intensity,width=10,height=10){super(color,intensity);this.isRectAreaLight=!0;this.type="RectAreaLight";this.width=width;
this.height=height}get power(){return this.intensity*this.width*this.height*Math.PI}set power(power){this.intensity=power/(this.width*this.height*Math.PI)}copy(source){super.copy(source);this.width=source.width;this.height=source.height;return this}toJSON(meta){meta=super.toJSON(meta);meta.object.width=this.width;meta.object.height=this.height;return meta}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0;this.coefficients=[];for(let i=0;9>i;i++)this.coefficients.push(new Vector3)}set(coefficients){for(let i=
0;9>i;i++)this.coefficients[i].copy(coefficients[i]);return this}zero(){for(let i=0;9>i;i++)this.coefficients[i].set(0,0,0);return this}getAt(normal,target){const x=normal.x,y=normal.y;normal=normal.z;const coeff=this.coefficients;target.copy(coeff[0]).multiplyScalar(.282095);target.addScaledVector(coeff[1],.488603*y);target.addScaledVector(coeff[2],.488603*normal);target.addScaledVector(coeff[3],.488603*x);target.addScaledVector(coeff[4],1.092548*x*y);target.addScaledVector(coeff[5],1.092548*y*normal);
target.addScaledVector(coeff[6],.315392*(3*normal*normal-1));target.addScaledVector(coeff[7],1.092548*x*normal);target.addScaledVector(coeff[8],.546274*(x*x-y*y));return target}getIrradianceAt(normal,target){const x=normal.x,y=normal.y;normal=normal.z;const coeff=this.coefficients;target.copy(coeff[0]).multiplyScalar(.886227);target.addScaledVector(coeff[1],1.023328*y);target.addScaledVector(coeff[2],1.023328*normal);target.addScaledVector(coeff[3],1.023328*x);target.addScaledVector(coeff[4],.858086*
x*y);target.addScaledVector(coeff[5],.858086*y*normal);target.addScaledVector(coeff[6],.743125*normal*normal-.247708);target.addScaledVector(coeff[7],.858086*x*normal);target.addScaledVector(coeff[8],.429043*(x*x-y*y));return target}add(sh){for(let i=0;9>i;i++)this.coefficients[i].add(sh.coefficients[i]);return this}addScaledSH(sh,s){for(let i=0;9>i;i++)this.coefficients[i].addScaledVector(sh.coefficients[i],s);return this}scale(s){for(let i=0;9>i;i++)this.coefficients[i].multiplyScalar(s);return this}lerp(sh,
alpha){for(let i=0;9>i;i++)this.coefficients[i].lerp(sh.coefficients[i],alpha);return this}equals(sh){for(let i=0;9>i;i++)if(!this.coefficients[i].equals(sh.coefficients[i]))return!1;return!0}copy(sh){return this.set(sh.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(array,offset=0){const coefficients=this.coefficients;for(let i=0;9>i;i++)coefficients[i].fromArray(array,offset+3*i);return this}toArray(array=[],offset=0){const coefficients=this.coefficients;for(let i=0;9>i;i++)coefficients[i].toArray(array,
offset+3*i);return array}static getBasisAt(normal,shBasis){const x=normal.x,y=normal.y;normal=normal.z;shBasis[0]=.282095;shBasis[1]=.488603*y;shBasis[2]=.488603*normal;shBasis[3]=.488603*x;shBasis[4]=1.092548*x*y;shBasis[5]=1.092548*y*normal;shBasis[6]=.315392*(3*normal*normal-1);shBasis[7]=1.092548*x*normal;shBasis[8]=.546274*(x*x-y*y)}}class LightProbe extends Light{constructor(sh=new SphericalHarmonics3,intensity=1){super(void 0,intensity);this.isLightProbe=!0;this.sh=sh}copy(source){super.copy(source);
this.sh.copy(source.sh);return this}fromJSON(json){this.intensity=json.intensity;this.sh.fromArray(json.sh);return this}toJSON(meta){meta=super.toJSON(meta);meta.object.sh=this.sh.toArray();return meta}}class MaterialLoader extends Loader{constructor(manager){super(manager);this.textures={}}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);
loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}parse(json){function getTexture(name){void 0===textures[name]&&console.warn("THREE.MaterialLoader: Undefined texture",name);return textures[name]}const textures=this.textures,material=MaterialLoader.createMaterialFromType(json.type);void 0!==json.uuid&&(material.uuid=json.uuid);void 0!==json.name&&(material.name=json.name);void 0!==
json.color&&void 0!==material.color&&material.color.setHex(json.color);void 0!==json.roughness&&(material.roughness=json.roughness);void 0!==json.metalness&&(material.metalness=json.metalness);void 0!==json.sheen&&(material.sheen=json.sheen);void 0!==json.sheenColor&&(material.sheenColor=(new Color).setHex(json.sheenColor));void 0!==json.sheenRoughness&&(material.sheenRoughness=json.sheenRoughness);void 0!==json.emissive&&void 0!==material.emissive&&material.emissive.setHex(json.emissive);void 0!==
json.specular&&void 0!==material.specular&&material.specular.setHex(json.specular);void 0!==json.specularIntensity&&(material.specularIntensity=json.specularIntensity);void 0!==json.specularColor&&void 0!==material.specularColor&&material.specularColor.setHex(json.specularColor);void 0!==json.shininess&&(material.shininess=json.shininess);void 0!==json.clearcoat&&(material.clearcoat=json.clearcoat);void 0!==json.clearcoatRoughness&&(material.clearcoatRoughness=json.clearcoatRoughness);void 0!==json.iridescence&&
(material.iridescence=json.iridescence);void 0!==json.iridescenceIOR&&(material.iridescenceIOR=json.iridescenceIOR);void 0!==json.iridescenceThicknessRange&&(material.iridescenceThicknessRange=json.iridescenceThicknessRange);void 0!==json.transmission&&(material.transmission=json.transmission);void 0!==json.thickness&&(material.thickness=json.thickness);void 0!==json.attenuationDistance&&(material.attenuationDistance=json.attenuationDistance);void 0!==json.attenuationColor&&void 0!==material.attenuationColor&&
material.attenuationColor.setHex(json.attenuationColor);void 0!==json.fog&&(material.fog=json.fog);void 0!==json.flatShading&&(material.flatShading=json.flatShading);void 0!==json.blending&&(material.blending=json.blending);void 0!==json.combine&&(material.combine=json.combine);void 0!==json.side&&(material.side=json.side);void 0!==json.shadowSide&&(material.shadowSide=json.shadowSide);void 0!==json.opacity&&(material.opacity=json.opacity);void 0!==json.transparent&&(material.transparent=json.transparent);
void 0!==json.alphaTest&&(material.alphaTest=json.alphaTest);void 0!==json.depthTest&&(material.depthTest=json.depthTest);void 0!==json.depthWrite&&(material.depthWrite=json.depthWrite);void 0!==json.colorWrite&&(material.colorWrite=json.colorWrite);void 0!==json.stencilWrite&&(material.stencilWrite=json.stencilWrite);void 0!==json.stencilWriteMask&&(material.stencilWriteMask=json.stencilWriteMask);void 0!==json.stencilFunc&&(material.stencilFunc=json.stencilFunc);void 0!==json.stencilRef&&(material.stencilRef=
json.stencilRef);void 0!==json.stencilFuncMask&&(material.stencilFuncMask=json.stencilFuncMask);void 0!==json.stencilFail&&(material.stencilFail=json.stencilFail);void 0!==json.stencilZFail&&(material.stencilZFail=json.stencilZFail);void 0!==json.stencilZPass&&(material.stencilZPass=json.stencilZPass);void 0!==json.wireframe&&(material.wireframe=json.wireframe);void 0!==json.wireframeLinewidth&&(material.wireframeLinewidth=json.wireframeLinewidth);void 0!==json.wireframeLinecap&&(material.wireframeLinecap=
json.wireframeLinecap);void 0!==json.wireframeLinejoin&&(material.wireframeLinejoin=json.wireframeLinejoin);void 0!==json.rotation&&(material.rotation=json.rotation);1!==json.linewidth&&(material.linewidth=json.linewidth);void 0!==json.dashSize&&(material.dashSize=json.dashSize);void 0!==json.gapSize&&(material.gapSize=json.gapSize);void 0!==json.scale&&(material.scale=json.scale);void 0!==json.polygonOffset&&(material.polygonOffset=json.polygonOffset);void 0!==json.polygonOffsetFactor&&(material.polygonOffsetFactor=
json.polygonOffsetFactor);void 0!==json.polygonOffsetUnits&&(material.polygonOffsetUnits=json.polygonOffsetUnits);void 0!==json.dithering&&(material.dithering=json.dithering);void 0!==json.alphaToCoverage&&(material.alphaToCoverage=json.alphaToCoverage);void 0!==json.premultipliedAlpha&&(material.premultipliedAlpha=json.premultipliedAlpha);void 0!==json.visible&&(material.visible=json.visible);void 0!==json.toneMapped&&(material.toneMapped=json.toneMapped);void 0!==json.userData&&(material.userData=
json.userData);void 0!==json.vertexColors&&(material.vertexColors="number"===typeof json.vertexColors?0<json.vertexColors?!0:!1:json.vertexColors);if(void 0!==json.uniforms)for(var name$jscomp$0 in json.uniforms){const uniform=json.uniforms[name$jscomp$0];material.uniforms[name$jscomp$0]={};switch(uniform.type){case "t":material.uniforms[name$jscomp$0].value=getTexture(uniform.value);break;case "c":material.uniforms[name$jscomp$0].value=(new Color).setHex(uniform.value);break;case "v2":material.uniforms[name$jscomp$0].value=
(new Vector2).fromArray(uniform.value);break;case "v3":material.uniforms[name$jscomp$0].value=(new Vector3).fromArray(uniform.value);break;case "v4":material.uniforms[name$jscomp$0].value=(new Vector4).fromArray(uniform.value);break;case "m3":material.uniforms[name$jscomp$0].value=(new Matrix3).fromArray(uniform.value);break;case "m4":material.uniforms[name$jscomp$0].value=(new Matrix4).fromArray(uniform.value);break;default:material.uniforms[name$jscomp$0].value=uniform.value}}void 0!==json.defines&&
(material.defines=json.defines);void 0!==json.vertexShader&&(material.vertexShader=json.vertexShader);void 0!==json.fragmentShader&&(material.fragmentShader=json.fragmentShader);void 0!==json.glslVersion&&(material.glslVersion=json.glslVersion);if(void 0!==json.extensions)for(const key in json.extensions)material.extensions[key]=json.extensions[key];void 0!==json.size&&(material.size=json.size);void 0!==json.sizeAttenuation&&(material.sizeAttenuation=json.sizeAttenuation);void 0!==json.map&&(material.map=
getTexture(json.map));void 0!==json.matcap&&(material.matcap=getTexture(json.matcap));void 0!==json.alphaMap&&(material.alphaMap=getTexture(json.alphaMap));void 0!==json.bumpMap&&(material.bumpMap=getTexture(json.bumpMap));void 0!==json.bumpScale&&(material.bumpScale=json.bumpScale);void 0!==json.normalMap&&(material.normalMap=getTexture(json.normalMap));void 0!==json.normalMapType&&(material.normalMapType=json.normalMapType);void 0!==json.normalScale&&(name$jscomp$0=json.normalScale,!1===Array.isArray(name$jscomp$0)&&
(name$jscomp$0=[name$jscomp$0,name$jscomp$0]),material.normalScale=(new Vector2).fromArray(name$jscomp$0));void 0!==json.displacementMap&&(material.displacementMap=getTexture(json.displacementMap));void 0!==json.displacementScale&&(material.displacementScale=json.displacementScale);void 0!==json.displacementBias&&(material.displacementBias=json.displacementBias);void 0!==json.roughnessMap&&(material.roughnessMap=getTexture(json.roughnessMap));void 0!==json.metalnessMap&&(material.metalnessMap=getTexture(json.metalnessMap));
void 0!==json.emissiveMap&&(material.emissiveMap=getTexture(json.emissiveMap));void 0!==json.emissiveIntensity&&(material.emissiveIntensity=json.emissiveIntensity);void 0!==json.specularMap&&(material.specularMap=getTexture(json.specularMap));void 0!==json.specularIntensityMap&&(material.specularIntensityMap=getTexture(json.specularIntensityMap));void 0!==json.specularColorMap&&(material.specularColorMap=getTexture(json.specularColorMap));void 0!==json.envMap&&(material.envMap=getTexture(json.envMap));
void 0!==json.envMapIntensity&&(material.envMapIntensity=json.envMapIntensity);void 0!==json.reflectivity&&(material.reflectivity=json.reflectivity);void 0!==json.refractionRatio&&(material.refractionRatio=json.refractionRatio);void 0!==json.lightMap&&(material.lightMap=getTexture(json.lightMap));void 0!==json.lightMapIntensity&&(material.lightMapIntensity=json.lightMapIntensity);void 0!==json.aoMap&&(material.aoMap=getTexture(json.aoMap));void 0!==json.aoMapIntensity&&(material.aoMapIntensity=json.aoMapIntensity);
void 0!==json.gradientMap&&(material.gradientMap=getTexture(json.gradientMap));void 0!==json.clearcoatMap&&(material.clearcoatMap=getTexture(json.clearcoatMap));void 0!==json.clearcoatRoughnessMap&&(material.clearcoatRoughnessMap=getTexture(json.clearcoatRoughnessMap));void 0!==json.clearcoatNormalMap&&(material.clearcoatNormalMap=getTexture(json.clearcoatNormalMap));void 0!==json.clearcoatNormalScale&&(material.clearcoatNormalScale=(new Vector2).fromArray(json.clearcoatNormalScale));void 0!==json.iridescenceMap&&
(material.iridescenceMap=getTexture(json.iridescenceMap));void 0!==json.iridescenceThicknessMap&&(material.iridescenceThicknessMap=getTexture(json.iridescenceThicknessMap));void 0!==json.transmissionMap&&(material.transmissionMap=getTexture(json.transmissionMap));void 0!==json.thicknessMap&&(material.thicknessMap=getTexture(json.thicknessMap));void 0!==json.sheenColorMap&&(material.sheenColorMap=getTexture(json.sheenColorMap));void 0!==json.sheenRoughnessMap&&(material.sheenRoughnessMap=getTexture(json.sheenRoughnessMap));
return material}setTextures(value){this.textures=value;return this}static createMaterialFromType(type){return new {ShadowMaterial,SpriteMaterial,RawShaderMaterial,ShaderMaterial,PointsMaterial,MeshPhysicalMaterial,MeshStandardMaterial,MeshPhongMaterial,MeshToonMaterial,MeshNormalMaterial,MeshLambertMaterial,MeshDepthMaterial,MeshDistanceMaterial,MeshBasicMaterial,MeshMatcapMaterial,LineDashedMaterial,LineBasicMaterial,Material}[type]}}class LoaderUtils{static decodeText(array){if("undefined"!==typeof TextDecoder)return(new TextDecoder).decode(array);
let s="";for(let i=0,il=array.length;i<il;i++)s+=String.fromCharCode(array[i]);try{return decodeURIComponent(escape(s))}catch(e){return s}}static extractUrlBase(url){const index=url.lastIndexOf("/");return-1===index?"./":url.slice(0,index+1)}static resolveURL(url,path){if("string"!==typeof url||""===url)return"";/^https?:\/\//i.test(path)&&/^\//.test(url)&&(path=path.replace(/(^https?:\/\/[^\/]+).*/i,"$1"));return/^(https?:)?\/\//i.test(url)||/^data:.*,.*$/i.test(url)||/^blob:.*$/i.test(url)?url:
path+url}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super();this.isInstancedBufferGeometry=!0;this.type="InstancedBufferGeometry";this.instanceCount=Infinity}copy(source){super.copy(source);this.instanceCount=source.instanceCount;return this}clone(){return(new this.constructor).copy(this)}toJSON(){const data=super.toJSON(this);data.instanceCount=this.instanceCount;data.isInstancedBufferGeometry=!0;return data}}class BufferGeometryLoader extends Loader{constructor(manager){super(manager)}load(url,
onLoad,onProgress,onError){const scope=this,loader=new FileLoader(scope.manager);loader.setPath(scope.path);loader.setRequestHeader(scope.requestHeader);loader.setWithCredentials(scope.withCredentials);loader.load(url,function(text){try{onLoad(scope.parse(JSON.parse(text)))}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}parse(json$jscomp$0){function getInterleavedBuffer(json,uuid){if(void 0!==interleavedBufferMap[uuid])return interleavedBufferMap[uuid];
const interleavedBuffer=json.interleavedBuffers[uuid];var JSCompiler_inline_result=interleavedBuffer.buffer;void 0!==arrayBufferMap[JSCompiler_inline_result]?JSCompiler_inline_result=arrayBufferMap[JSCompiler_inline_result]:(json=(new Uint32Array(json.arrayBuffers[JSCompiler_inline_result])).buffer,JSCompiler_inline_result=arrayBufferMap[JSCompiler_inline_result]=json);JSCompiler_inline_result=new TYPED_ARRAYS[interleavedBuffer.type](JSCompiler_inline_result);JSCompiler_inline_result=new InterleavedBuffer(JSCompiler_inline_result,
interleavedBuffer.stride);JSCompiler_inline_result.uuid=interleavedBuffer.uuid;return interleavedBufferMap[uuid]=JSCompiler_inline_result}const interleavedBufferMap={},arrayBufferMap={},geometry=json$jscomp$0.isInstancedBufferGeometry?new InstancedBufferGeometry:new BufferGeometry;var index=json$jscomp$0.data.index;void 0!==index&&(index=new TYPED_ARRAYS[index.type](index.array),geometry.setIndex(new BufferAttribute(index,1)));index=json$jscomp$0.data.attributes;for(var key in index){var attribute=
index[key],bufferAttribute=void 0;attribute.isInterleavedBufferAttribute?(bufferAttribute=getInterleavedBuffer(json$jscomp$0.data,attribute.data),bufferAttribute=new InterleavedBufferAttribute(bufferAttribute,attribute.itemSize,attribute.offset,attribute.normalized)):(bufferAttribute=new TYPED_ARRAYS[attribute.type](attribute.array),bufferAttribute=new (attribute.isInstancedBufferAttribute?InstancedBufferAttribute:BufferAttribute)(bufferAttribute,attribute.itemSize,attribute.normalized));void 0!==
attribute.name&&(bufferAttribute.name=attribute.name);void 0!==attribute.usage&&bufferAttribute.setUsage(attribute.usage);void 0!==attribute.updateRange&&(bufferAttribute.updateRange.offset=attribute.updateRange.offset,bufferAttribute.updateRange.count=attribute.updateRange.count);geometry.setAttribute(key,bufferAttribute)}if(key=json$jscomp$0.data.morphAttributes)for(var key$jscomp$0 in key){index=key[key$jscomp$0];attribute=[];for(let i=0,il=index.length;i<il;i++){bufferAttribute=index[i];var bufferAttribute$jscomp$0=
void 0;bufferAttribute.isInterleavedBufferAttribute?(bufferAttribute$jscomp$0=getInterleavedBuffer(json$jscomp$0.data,bufferAttribute.data),bufferAttribute$jscomp$0=new InterleavedBufferAttribute(bufferAttribute$jscomp$0,bufferAttribute.itemSize,bufferAttribute.offset,bufferAttribute.normalized)):(bufferAttribute$jscomp$0=new TYPED_ARRAYS[bufferAttribute.type](bufferAttribute.array),bufferAttribute$jscomp$0=new BufferAttribute(bufferAttribute$jscomp$0,bufferAttribute.itemSize,bufferAttribute.normalized));
void 0!==bufferAttribute.name&&(bufferAttribute$jscomp$0.name=bufferAttribute.name);attribute.push(bufferAttribute$jscomp$0)}geometry.morphAttributes[key$jscomp$0]=attribute}json$jscomp$0.data.morphTargetsRelative&&(geometry.morphTargetsRelative=!0);key$jscomp$0=json$jscomp$0.data.groups||json$jscomp$0.data.drawcalls||json$jscomp$0.data.offsets;if(void 0!==key$jscomp$0)for(let i=0,n=key$jscomp$0.length;i!==n;++i)key=key$jscomp$0[i],geometry.addGroup(key.start,key.count,key.materialIndex);key$jscomp$0=
json$jscomp$0.data.boundingSphere;void 0!==key$jscomp$0&&(key=new Vector3,void 0!==key$jscomp$0.center&&key.fromArray(key$jscomp$0.center),geometry.boundingSphere=new Sphere(key,key$jscomp$0.radius));json$jscomp$0.name&&(geometry.name=json$jscomp$0.name);json$jscomp$0.userData&&(geometry.userData=json$jscomp$0.userData);return geometry}}class ObjectLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this;var path=""===this.path?LoaderUtils.extractUrlBase(url):
this.path;this.resourcePath=this.resourcePath||path;path=new FileLoader(this.manager);path.setPath(this.path);path.setRequestHeader(this.requestHeader);path.setWithCredentials(this.withCredentials);path.load(url,function(text){let json=null;try{json=JSON.parse(text)}catch(error){void 0!==onError&&onError(error);console.error("THREE:ObjectLoader: Can't parse "+url+".",error.message);return}text=json.metadata;void 0===text||void 0===text.type||"geometry"===text.type.toLowerCase()?console.error("THREE.ObjectLoader: Can't load "+
url):scope.parse(json,onLoad)},onProgress,onError)}loadAsync(url,onProgress){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var path=""===$jscomp$async$this.path?LoaderUtils.extractUrlBase(url):$jscomp$async$this.path;$jscomp$async$this.resourcePath=$jscomp$async$this.resourcePath||path;path=new FileLoader($jscomp$async$this.manager);path.setPath($jscomp$async$this.path);path.setRequestHeader($jscomp$async$this.requestHeader);path.setWithCredentials($jscomp$async$this.withCredentials);
path=yield path.loadAsync(url,onProgress);path=JSON.parse(path);const metadata=path.metadata;if(void 0===metadata||void 0===metadata.type||"geometry"===metadata.type.toLowerCase())throw Error("THREE.ObjectLoader: Can't load "+url);return yield $jscomp$async$this.parseAsync(path)})}parse(json,onLoad){const animations=this.parseAnimations(json.animations);var shapes=this.parseShapes(json.shapes);const geometries=this.parseGeometries(json.geometries,shapes);shapes=this.parseImages(json.images,function(){void 0!==
onLoad&&onLoad(object)});const textures=this.parseTextures(json.textures,shapes),materials=this.parseMaterials(json.materials,textures),object=this.parseObject(json.object,geometries,materials,textures,animations);json=this.parseSkeletons(json.skeletons,object);this.bindSkeletons(object,json);if(void 0!==onLoad){json=!1;for(const uuid in shapes)if(shapes[uuid].data instanceof HTMLImageElement){json=!0;break}!1===json&&onLoad(object)}return object}parseAsync(json){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){var animations=
$jscomp$async$this.parseAnimations(json.animations),shapes=$jscomp$async$this.parseShapes(json.shapes);shapes=$jscomp$async$this.parseGeometries(json.geometries,shapes);var images=yield $jscomp$async$this.parseImagesAsync(json.images);images=$jscomp$async$this.parseTextures(json.textures,images);const materials=$jscomp$async$this.parseMaterials(json.materials,images);animations=$jscomp$async$this.parseObject(json.object,shapes,materials,images,animations);shapes=$jscomp$async$this.parseSkeletons(json.skeletons,
animations);$jscomp$async$this.bindSkeletons(animations,shapes);return animations})}parseShapes(json){const shapes={};if(void 0!==json)for(let i=0,l=json.length;i<l;i++){const shape=(new Shape).fromJSON(json[i]);shapes[shape.uuid]=shape}return shapes}parseSkeletons(json,object){const skeletons={},bones={};object.traverse(function(child){child.isBone&&(bones[child.uuid]=child)});if(void 0!==json)for(let i=0,l=json.length;i<l;i++)object=(new Skeleton).fromJSON(json[i],bones),skeletons[object.uuid]=
object;return skeletons}parseGeometries(json,shapes){const geometries={};if(void 0!==json){const bufferGeometryLoader=new BufferGeometryLoader;for(let i=0,l=json.length;i<l;i++){let geometry;const data=json[i];switch(data.type){case "BufferGeometry":case "InstancedBufferGeometry":geometry=bufferGeometryLoader.parse(data);break;default:data.type in Geometries?geometry=Geometries[data.type].fromJSON(data,shapes):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`)}geometry.uuid=
data.uuid;void 0!==data.name&&(geometry.name=data.name);!0===geometry.isBufferGeometry&&void 0!==data.userData&&(geometry.userData=data.userData);geometries[data.uuid]=geometry}}return geometries}parseMaterials(json,textures){const cache={},materials={};if(void 0!==json){const loader=new MaterialLoader;loader.setTextures(textures);for(let i=0,l=json.length;i<l;i++)textures=json[i],void 0===cache[textures.uuid]&&(cache[textures.uuid]=loader.parse(textures)),materials[textures.uuid]=cache[textures.uuid]}return materials}parseAnimations(json){const animations=
{};if(void 0!==json)for(let i=0;i<json.length;i++){const clip=AnimationClip.parse(json[i]);animations[clip.uuid]=clip}return animations}parseImages(json,onLoad){function loadImage(url){scope.manager.itemStart(url);return loader.load(url,function(){scope.manager.itemEnd(url)},void 0,function(){scope.manager.itemError(url);scope.manager.itemEnd(url)})}function deserializeImage(image){return"string"===typeof image?(image=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image)?image:scope.resourcePath+image,loadImage(image)):
image.data?{data:new TYPED_ARRAYS[image.type](image.data),width:image.width,height:image.height}:null}const scope=this,images={};let loader;if(void 0!==json&&0<json.length){onLoad=new LoadingManager(onLoad);loader=new ImageLoader(onLoad);loader.setCrossOrigin(this.crossOrigin);for(let i=0,il=json.length;i<il;i++){onLoad=json[i];var url$jscomp$0=onLoad.url;if(Array.isArray(url$jscomp$0)){const imageArray=[];for(let j=0,jl=url$jscomp$0.length;j<jl;j++){const deserializedImage=deserializeImage(url$jscomp$0[j]);
null!==deserializedImage&&(deserializedImage instanceof HTMLImageElement?imageArray.push(deserializedImage):imageArray.push(new DataTexture(deserializedImage.data,deserializedImage.width,deserializedImage.height)))}images[onLoad.uuid]=new Source(imageArray)}else url$jscomp$0=deserializeImage(onLoad.url),images[onLoad.uuid]=new Source(url$jscomp$0)}}return images}parseImagesAsync(json){const $jscomp$async$this=this;return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){function deserializeImage(image){return $jscomp.asyncExecutePromiseGeneratorFunction(function*(){if("string"===
typeof image){const path=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(image)?image:scope.resourcePath+image;return yield loader.loadAsync(path)}return image.data?{data:new TYPED_ARRAYS[image.type](image.data),width:image.width,height:image.height}:null})}const scope=$jscomp$async$this,images={};let loader;if(void 0!==json&&0<json.length){loader=new ImageLoader($jscomp$async$this.manager);loader.setCrossOrigin($jscomp$async$this.crossOrigin);for(let i=0,il=json.length;i<il;i++){const image=json[i];var url=image.url;
if(Array.isArray(url)){const imageArray=[];for(let j=0,jl=url.length;j<jl;j++){const deserializedImage=yield deserializeImage(url[j]);null!==deserializedImage&&(deserializedImage instanceof HTMLImageElement?imageArray.push(deserializedImage):imageArray.push(new DataTexture(deserializedImage.data,deserializedImage.width,deserializedImage.height)))}images[image.uuid]=new Source(imageArray)}else url=yield deserializeImage(image.url),images[image.uuid]=new Source(url)}}return images})}parseTextures(json,
images){function parseConstant(value,type){if("number"===typeof value)return value;console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",value);return type[value]}const textures={};if(void 0!==json)for(let i=0,l=json.length;i<l;i++){const data=json[i];void 0===data.image&&console.warn('THREE.ObjectLoader: No "image" specified for',data.uuid);void 0===images[data.image]&&console.warn("THREE.ObjectLoader: Undefined image",data.image);const source=images[data.image],image=
source.data;let texture;Array.isArray(image)?(texture=new CubeTexture,6===image.length&&(texture.needsUpdate=!0)):(texture=image&&image.data?new DataTexture:new Texture,image&&(texture.needsUpdate=!0));texture.source=source;texture.uuid=data.uuid;void 0!==data.name&&(texture.name=data.name);void 0!==data.mapping&&(texture.mapping=parseConstant(data.mapping,TEXTURE_MAPPING));void 0!==data.offset&&texture.offset.fromArray(data.offset);void 0!==data.repeat&&texture.repeat.fromArray(data.repeat);void 0!==
data.center&&texture.center.fromArray(data.center);void 0!==data.rotation&&(texture.rotation=data.rotation);void 0!==data.wrap&&(texture.wrapS=parseConstant(data.wrap[0],TEXTURE_WRAPPING),texture.wrapT=parseConstant(data.wrap[1],TEXTURE_WRAPPING));void 0!==data.format&&(texture.format=data.format);void 0!==data.type&&(texture.type=data.type);void 0!==data.encoding&&(texture.encoding=data.encoding);void 0!==data.minFilter&&(texture.minFilter=parseConstant(data.minFilter,TEXTURE_FILTER));void 0!==data.magFilter&&
(texture.magFilter=parseConstant(data.magFilter,TEXTURE_FILTER));void 0!==data.anisotropy&&(texture.anisotropy=data.anisotropy);void 0!==data.flipY&&(texture.flipY=data.flipY);void 0!==data.premultiplyAlpha&&(texture.premultiplyAlpha=data.premultiplyAlpha);void 0!==data.unpackAlignment&&(texture.unpackAlignment=data.unpackAlignment);void 0!==data.userData&&(texture.userData=data.userData);textures[data.uuid]=texture}return textures}parseObject(data,geometries,materials,textures,animations){function getGeometry(name){void 0===
geometries[name]&&console.warn("THREE.ObjectLoader: Undefined geometry",name);return geometries[name]}function getMaterial(name){if(void 0!==name){if(Array.isArray(name)){const array=[];for(let i=0,l=name.length;i<l;i++){const uuid=name[i];void 0===materials[uuid]&&console.warn("THREE.ObjectLoader: Undefined material",uuid);array.push(materials[uuid])}return array}void 0===materials[name]&&console.warn("THREE.ObjectLoader: Undefined material",name);return materials[name]}}function getTexture(uuid){void 0===
textures[uuid]&&console.warn("THREE.ObjectLoader: Undefined texture",uuid);return textures[uuid]}let material;switch(data.type){case "Scene":var object=new Scene;void 0!==data.background&&(Number.isInteger(data.background)?object.background=new Color(data.background):object.background=getTexture(data.background));void 0!==data.environment&&(object.environment=getTexture(data.environment));void 0!==data.fog&&("Fog"===data.fog.type?object.fog=new Fog(data.fog.color,data.fog.near,data.fog.far):"FogExp2"===
data.fog.type&&(object.fog=new FogExp2(data.fog.color,data.fog.density)));void 0!==data.backgroundBlurriness&&(object.backgroundBlurriness=data.backgroundBlurriness);break;case "PerspectiveCamera":object=new PerspectiveCamera(data.fov,data.aspect,data.near,data.far);void 0!==data.focus&&(object.focus=data.focus);void 0!==data.zoom&&(object.zoom=data.zoom);void 0!==data.filmGauge&&(object.filmGauge=data.filmGauge);void 0!==data.filmOffset&&(object.filmOffset=data.filmOffset);void 0!==data.view&&(object.view=
Object.assign({},data.view));break;case "OrthographicCamera":object=new OrthographicCamera(data.left,data.right,data.top,data.bottom,data.near,data.far);void 0!==data.zoom&&(object.zoom=data.zoom);void 0!==data.view&&(object.view=Object.assign({},data.view));break;case "AmbientLight":object=new AmbientLight(data.color,data.intensity);break;case "DirectionalLight":object=new DirectionalLight(data.color,data.intensity);break;case "PointLight":object=new PointLight(data.color,data.intensity,data.distance,
data.decay);break;case "RectAreaLight":object=new RectAreaLight(data.color,data.intensity,data.width,data.height);break;case "SpotLight":object=new SpotLight(data.color,data.intensity,data.distance,data.angle,data.penumbra,data.decay);break;case "HemisphereLight":object=new HemisphereLight(data.color,data.groundColor,data.intensity);break;case "LightProbe":object=(new LightProbe).fromJSON(data);break;case "SkinnedMesh":object=getGeometry(data.geometry);material=getMaterial(data.material);object=new SkinnedMesh(object,
material);void 0!==data.bindMode&&(object.bindMode=data.bindMode);void 0!==data.bindMatrix&&object.bindMatrix.fromArray(data.bindMatrix);void 0!==data.skeleton&&(object.skeleton=data.skeleton);break;case "Mesh":object=getGeometry(data.geometry);material=getMaterial(data.material);object=new Mesh(object,material);break;case "InstancedMesh":object=getGeometry(data.geometry);material=getMaterial(data.material);var instanceMatrix=data.instanceMatrix,instanceColor=data.instanceColor;object=new InstancedMesh(object,
material,data.count);object.instanceMatrix=new InstancedBufferAttribute(new Float32Array(instanceMatrix.array),16);void 0!==instanceColor&&(object.instanceColor=new InstancedBufferAttribute(new Float32Array(instanceColor.array),instanceColor.itemSize));break;case "LOD":object=new LOD;break;case "Line":object=new Line(getGeometry(data.geometry),getMaterial(data.material));break;case "LineLoop":object=new LineLoop(getGeometry(data.geometry),getMaterial(data.material));break;case "LineSegments":object=
new LineSegments(getGeometry(data.geometry),getMaterial(data.material));break;case "PointCloud":case "Points":object=new Points(getGeometry(data.geometry),getMaterial(data.material));break;case "Sprite":object=new Sprite(getMaterial(data.material));break;case "Group":object=new Group;break;case "Bone":object=new Bone;break;default:object=new Object3D}object.uuid=data.uuid;void 0!==data.name&&(object.name=data.name);void 0!==data.matrix?(object.matrix.fromArray(data.matrix),void 0!==data.matrixAutoUpdate&&
(object.matrixAutoUpdate=data.matrixAutoUpdate),object.matrixAutoUpdate&&object.matrix.decompose(object.position,object.quaternion,object.scale)):(void 0!==data.position&&object.position.fromArray(data.position),void 0!==data.rotation&&object.rotation.fromArray(data.rotation),void 0!==data.quaternion&&object.quaternion.fromArray(data.quaternion),void 0!==data.scale&&object.scale.fromArray(data.scale));void 0!==data.castShadow&&(object.castShadow=data.castShadow);void 0!==data.receiveShadow&&(object.receiveShadow=
data.receiveShadow);data.shadow&&(void 0!==data.shadow.bias&&(object.shadow.bias=data.shadow.bias),void 0!==data.shadow.normalBias&&(object.shadow.normalBias=data.shadow.normalBias),void 0!==data.shadow.radius&&(object.shadow.radius=data.shadow.radius),void 0!==data.shadow.mapSize&&object.shadow.mapSize.fromArray(data.shadow.mapSize),void 0!==data.shadow.camera&&(object.shadow.camera=this.parseObject(data.shadow.camera)));void 0!==data.visible&&(object.visible=data.visible);void 0!==data.frustumCulled&&
(object.frustumCulled=data.frustumCulled);void 0!==data.renderOrder&&(object.renderOrder=data.renderOrder);void 0!==data.userData&&(object.userData=data.userData);void 0!==data.layers&&(object.layers.mask=data.layers);if(void 0!==data.children)for(instanceMatrix=data.children,instanceColor=0;instanceColor<instanceMatrix.length;instanceColor++)object.add(this.parseObject(instanceMatrix[instanceColor],geometries,materials,textures,animations));if(void 0!==data.animations)for(instanceMatrix=data.animations,
instanceColor=0;instanceColor<instanceMatrix.length;instanceColor++)object.animations.push(animations[instanceMatrix[instanceColor]]);if("LOD"===data.type)for(void 0!==data.autoUpdate&&(object.autoUpdate=data.autoUpdate),data=data.levels,animations=0;animations<data.length;animations++)instanceMatrix=data[animations],instanceColor=object.getObjectByProperty("uuid",instanceMatrix.object),void 0!==instanceColor&&object.addLevel(instanceColor,instanceMatrix.distance);return object}bindSkeletons(object,
skeletons){0!==Object.keys(skeletons).length&&object.traverse(function(child){if(!0===child.isSkinnedMesh&&void 0!==child.skeleton){const skeleton=skeletons[child.skeleton];void 0===skeleton?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",child.skeleton):child.bind(skeleton,child.bindMatrix)}})}}const TEXTURE_MAPPING={UVMapping:300,CubeReflectionMapping:301,CubeRefractionMapping:302,EquirectangularReflectionMapping:303,EquirectangularRefractionMapping:304,CubeUVReflectionMapping:306},
TEXTURE_WRAPPING={RepeatWrapping:1E3,ClampToEdgeWrapping:1001,MirroredRepeatWrapping:1002},TEXTURE_FILTER={NearestFilter:1003,NearestMipmapNearestFilter:1004,NearestMipmapLinearFilter:1005,LinearFilter:1006,LinearMipmapNearestFilter:1007,LinearMipmapLinearFilter:1008};class ImageBitmapLoader extends Loader{constructor(manager){super(manager);this.isImageBitmapLoader=!0;"undefined"===typeof createImageBitmap&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported.");"undefined"===
typeof fetch&&console.warn("THREE.ImageBitmapLoader: fetch() not supported.");this.options={premultiplyAlpha:"none"}}setOptions(options){this.options=options;return this}load(url,onLoad,onProgress,onError){void 0===url&&(url="");void 0!==this.path&&(url=this.path+url);url=this.manager.resolveURL(url);const scope=this,cached=Cache.get(url);if(void 0!==cached)return scope.manager.itemStart(url),setTimeout(function(){onLoad&&onLoad(cached);scope.manager.itemEnd(url)},0),cached;onProgress={};onProgress.credentials=
"anonymous"===this.crossOrigin?"same-origin":"include";onProgress.headers=this.requestHeader;fetch(url,onProgress).then(function(res){return res.blob()}).then(function(blob){return createImageBitmap(blob,Object.assign(scope.options,{colorSpaceConversion:"none"}))}).then(function(imageBitmap){Cache.add(url,imageBitmap);onLoad&&onLoad(imageBitmap);scope.manager.itemEnd(url)}).catch(function(e){onError&&onError(e);scope.manager.itemError(url);scope.manager.itemEnd(url)});scope.manager.itemStart(url)}}
let _context;class AudioContext{static getContext(){void 0===_context&&(_context=new (window.AudioContext||window.webkitAudioContext));return _context}static setContext(value){_context=value}}class AudioLoader extends Loader{constructor(manager){super(manager)}load(url,onLoad,onProgress,onError){const scope=this,loader=new FileLoader(this.manager);loader.setResponseType("arraybuffer");loader.setPath(this.path);loader.setRequestHeader(this.requestHeader);loader.setWithCredentials(this.withCredentials);
loader.load(url,function(buffer){try{const bufferCopy=buffer.slice(0);AudioContext.getContext().decodeAudioData(bufferCopy,function(audioBuffer){onLoad(audioBuffer)})}catch(e){onError?onError(e):console.error(e),scope.manager.itemError(url)}},onProgress,onError)}}class HemisphereLightProbe extends LightProbe{constructor(skyColor,groundColor,intensity=1){super(void 0,intensity);this.isHemisphereLightProbe=!0;skyColor=(new Color).set(skyColor);intensity=(new Color).set(groundColor);groundColor=new Vector3(skyColor.r,
skyColor.g,skyColor.b);skyColor=new Vector3(intensity.r,intensity.g,intensity.b);intensity=Math.sqrt(Math.PI);const c1=intensity*Math.sqrt(.75);this.sh.coefficients[0].copy(groundColor).add(skyColor).multiplyScalar(intensity);this.sh.coefficients[1].copy(groundColor).sub(skyColor).multiplyScalar(c1)}}class AmbientLightProbe extends LightProbe{constructor(color,intensity=1){super(void 0,intensity);this.isAmbientLightProbe=!0;color=(new Color).set(color);this.sh.coefficients[0].set(color.r,color.g,
color.b).multiplyScalar(2*Math.sqrt(Math.PI))}}const _eyeRight=new Matrix4,_eyeLeft=new Matrix4,_projectionMatrix=new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera";this.aspect=1;this.eyeSep=.064;this.cameraL=new PerspectiveCamera;this.cameraL.layers.enable(1);this.cameraL.matrixAutoUpdate=!1;this.cameraR=new PerspectiveCamera;this.cameraR.layers.enable(2);this.cameraR.matrixAutoUpdate=!1;this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(camera){const cache=
this._cache;if(cache.focus!==camera.focus||cache.fov!==camera.fov||cache.aspect!==camera.aspect*this.aspect||cache.near!==camera.near||cache.far!==camera.far||cache.zoom!==camera.zoom||cache.eyeSep!==this.eyeSep){cache.focus=camera.focus;cache.fov=camera.fov;cache.aspect=camera.aspect*this.aspect;cache.near=camera.near;cache.far=camera.far;cache.zoom=camera.zoom;cache.eyeSep=this.eyeSep;_projectionMatrix.copy(camera.projectionMatrix);var eyeSepHalf=cache.eyeSep/2;const eyeSepOnProjection=eyeSepHalf*
cache.near/cache.focus,ymax=cache.near*Math.tan(DEG2RAD*cache.fov*.5)/cache.zoom;let xmax;_eyeLeft.elements[12]=-eyeSepHalf;_eyeRight.elements[12]=eyeSepHalf;eyeSepHalf=-ymax*cache.aspect+eyeSepOnProjection;xmax=ymax*cache.aspect+eyeSepOnProjection;_projectionMatrix.elements[0]=2*cache.near/(xmax-eyeSepHalf);_projectionMatrix.elements[8]=(xmax+eyeSepHalf)/(xmax-eyeSepHalf);this.cameraL.projectionMatrix.copy(_projectionMatrix);eyeSepHalf=-ymax*cache.aspect-eyeSepOnProjection;xmax=ymax*cache.aspect-
eyeSepOnProjection;_projectionMatrix.elements[0]=2*cache.near/(xmax-eyeSepHalf);_projectionMatrix.elements[8]=(xmax+eyeSepHalf)/(xmax-eyeSepHalf);this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight)}}class Clock{constructor(autoStart=!0){this.autoStart=autoStart;this.elapsedTime=this.oldTime=this.startTime=0;this.running=!1}start(){this.oldTime=this.startTime=
now$jscomp$0();this.elapsedTime=0;this.running=!0}stop(){this.getElapsedTime();this.autoStart=this.running=!1}getElapsedTime(){this.getDelta();return this.elapsedTime}getDelta(){let diff=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const newTime=now$jscomp$0();diff=(newTime-this.oldTime)/1E3;this.oldTime=newTime;this.elapsedTime+=diff}return diff}}const _position$1=new Vector3,_quaternion$1=new Quaternion,_scale$1=new Vector3,_orientation$1=new Vector3;class AudioListener extends Object3D{constructor(){super();
this.type="AudioListener";this.context=AudioContext.getContext();this.gain=this.context.createGain();this.gain.connect(this.context.destination);this.filter=null;this.timeDelta=0;this._clock=new Clock}getInput(){return this.gain}removeFilter(){null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null);return this}getFilter(){return this.filter}setFilter(value){null!==this.filter?(this.gain.disconnect(this.filter),
this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination);this.filter=value;this.gain.connect(this.filter);this.filter.connect(this.context.destination);return this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,.01);return this}updateMatrixWorld(force){super.updateMatrixWorld(force);force=this.context.listener;const up=this.up;this.timeDelta=this._clock.getDelta();this.matrixWorld.decompose(_position$1,
_quaternion$1,_scale$1);_orientation$1.set(0,0,-1).applyQuaternion(_quaternion$1);if(force.positionX){const endTime=this.context.currentTime+this.timeDelta;force.positionX.linearRampToValueAtTime(_position$1.x,endTime);force.positionY.linearRampToValueAtTime(_position$1.y,endTime);force.positionZ.linearRampToValueAtTime(_position$1.z,endTime);force.forwardX.linearRampToValueAtTime(_orientation$1.x,endTime);force.forwardY.linearRampToValueAtTime(_orientation$1.y,endTime);force.forwardZ.linearRampToValueAtTime(_orientation$1.z,
endTime);force.upX.linearRampToValueAtTime(up.x,endTime);force.upY.linearRampToValueAtTime(up.y,endTime);force.upZ.linearRampToValueAtTime(up.z,endTime)}else force.setPosition(_position$1.x,_position$1.y,_position$1.z),force.setOrientation(_orientation$1.x,_orientation$1.y,_orientation$1.z,up.x,up.y,up.z)}}class Audio extends Object3D{constructor(listener){super();this.type="Audio";this.listener=listener;this.context=listener.context;this.gain=this.context.createGain();this.gain.connect(listener.getInput());
this.autoplay=!1;this.buffer=null;this.detune=0;this.loop=!1;this.offset=this.loopEnd=this.loopStart=0;this.duration=void 0;this.playbackRate=1;this.isPlaying=!1;this.hasPlaybackControl=!0;this.source=null;this.sourceType="empty";this._progress=this._startedAt=0;this._connected=!1;this.filters=[]}getOutput(){return this.gain}setNodeSource(audioNode){this.hasPlaybackControl=!1;this.sourceType="audioNode";this.source=audioNode;this.connect();return this}setMediaElementSource(mediaElement){this.hasPlaybackControl=
!1;this.sourceType="mediaNode";this.source=this.context.createMediaElementSource(mediaElement);this.connect();return this}setMediaStreamSource(mediaStream){this.hasPlaybackControl=!1;this.sourceType="mediaStreamNode";this.source=this.context.createMediaStreamSource(mediaStream);this.connect();return this}setBuffer(audioBuffer){this.buffer=audioBuffer;this.sourceType="buffer";this.autoplay&&this.play();return this}play(delay=0){if(!0===this.isPlaying)console.warn("THREE.Audio: Audio is already playing.");
else if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this._startedAt=this.context.currentTime+delay,delay=this.context.createBufferSource(),delay.buffer=this.buffer,delay.loop=this.loop,delay.loopStart=this.loopStart,delay.loopEnd=this.loopEnd,delay.onended=this.onEnded.bind(this),delay.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=delay,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),
this.connect()}pause(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress%=this.duration||this.buffer.duration),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this._progress=
0,this.source.stop(),this.source.onended=null,this.isPlaying=!1,this}connect(){if(0<this.filters.length){this.source.connect(this.filters[0]);for(let i=1,l=this.filters.length;i<l;i++)this.filters[i-1].connect(this.filters[i]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());this._connected=!0;return this}disconnect(){if(0<this.filters.length){this.source.disconnect(this.filters[0]);for(let i=1,l=this.filters.length;i<l;i++)this.filters[i-1].disconnect(this.filters[i]);
this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());this._connected=!1;return this}getFilters(){return this.filters}setFilters(value){value||(value=[]);!0===this._connected?(this.disconnect(),this.filters=value.slice(),this.connect()):this.filters=value.slice();return this}setDetune(value){this.detune=value;if(void 0!==this.source.detune)return!0===this.isPlaying&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),
this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(filter){return this.setFilters(filter?[filter]:[])}setPlaybackRate(value){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.playbackRate=value,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return!1===this.hasPlaybackControl?
(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(value){if(!1===this.hasPlaybackControl)console.warn("THREE.Audio: this Audio has no playback control.");else return this.loop=value,!0===this.isPlaying&&(this.source.loop=this.loop),this}setLoopStart(value){this.loopStart=value;return this}setLoopEnd(value){this.loopEnd=value;return this}getVolume(){return this.gain.gain.value}setVolume(value){this.gain.gain.setTargetAtTime(value,this.context.currentTime,.01);
return this}}const _position=new Vector3,_quaternion=new Quaternion,_scale=new Vector3,_orientation=new Vector3;class PositionalAudio extends Audio{constructor(listener){super(listener);this.panner=this.context.createPanner();this.panner.panningModel="HRTF";this.panner.connect(this.gain)}disconnect(){super.disconnect();this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(value){this.panner.refDistance=value;return this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(value){this.panner.rolloffFactor=
value;return this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(value){this.panner.distanceModel=value;return this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(value){this.panner.maxDistance=value;return this}setDirectionalCone(coneInnerAngle,coneOuterAngle,coneOuterGain){this.panner.coneInnerAngle=coneInnerAngle;this.panner.coneOuterAngle=coneOuterAngle;this.panner.coneOuterGain=coneOuterGain;return this}updateMatrixWorld(force){super.updateMatrixWorld(force);
if(!0!==this.hasPlaybackControl||!1!==this.isPlaying)if(this.matrixWorld.decompose(_position,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion),force=this.panner,force.positionX){const endTime=this.context.currentTime+this.listener.timeDelta;force.positionX.linearRampToValueAtTime(_position.x,endTime);force.positionY.linearRampToValueAtTime(_position.y,endTime);force.positionZ.linearRampToValueAtTime(_position.z,endTime);force.orientationX.linearRampToValueAtTime(_orientation.x,
endTime);force.orientationY.linearRampToValueAtTime(_orientation.y,endTime);force.orientationZ.linearRampToValueAtTime(_orientation.z,endTime)}else force.setPosition(_position.x,_position.y,_position.z),force.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(audio,fftSize=2048){this.analyser=audio.context.createAnalyser();this.analyser.fftSize=fftSize;this.data=new Uint8Array(this.analyser.frequencyBinCount);audio.getOutput().connect(this.analyser)}getFrequencyData(){this.analyser.getByteFrequencyData(this.data);
return this.data}getAverageFrequency(){let value=0;const data=this.getFrequencyData();for(let i=0;i<data.length;i++)value+=data[i];return value/data.length}}class PropertyMixer{constructor(binding,typeName,valueSize){this.binding=binding;this.valueSize=valueSize;let setIdentity;switch(typeName){case "quaternion":binding=this._slerp;typeName=this._slerpAdditive;setIdentity=this._setAdditiveIdentityQuaternion;this.buffer=new Float64Array(6*valueSize);this._workIndex=5;break;case "string":case "bool":typeName=
binding=this._select;setIdentity=this._setAdditiveIdentityOther;this.buffer=Array(5*valueSize);break;default:binding=this._lerp,typeName=this._lerpAdditive,setIdentity=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*valueSize)}this._mixBufferRegion=binding;this._mixBufferRegionAdditive=typeName;this._setIdentity=setIdentity;this._origIndex=3;this._addIndex=4;this.referenceCount=this.useCount=this.cumulativeWeightAdditive=this.cumulativeWeight=0}accumulate(accuIndex,weight){const buffer=
this.buffer,stride=this.valueSize;accuIndex=accuIndex*stride+stride;var currentWeight=this.cumulativeWeight;if(0===currentWeight){for(currentWeight=0;currentWeight!==stride;++currentWeight)buffer[accuIndex+currentWeight]=buffer[currentWeight];currentWeight=weight}else currentWeight+=weight,this._mixBufferRegion(buffer,accuIndex,0,weight/currentWeight,stride);this.cumulativeWeight=currentWeight}accumulateAdditive(weight){const buffer=this.buffer,stride=this.valueSize,offset=stride*this._addIndex;0===
this.cumulativeWeightAdditive&&this._setIdentity();this._mixBufferRegionAdditive(buffer,offset,0,weight,stride);this.cumulativeWeightAdditive+=weight}apply(accuIndex){const stride=this.valueSize,buffer=this.buffer;accuIndex=accuIndex*stride+stride;const weight=this.cumulativeWeight,weightAdditive=this.cumulativeWeightAdditive,binding=this.binding;this.cumulativeWeightAdditive=this.cumulativeWeight=0;1>weight&&this._mixBufferRegion(buffer,accuIndex,stride*this._origIndex,1-weight,stride);0<weightAdditive&&
this._mixBufferRegionAdditive(buffer,accuIndex,this._addIndex*stride,1,stride);for(let i=stride,e=stride+stride;i!==e;++i)if(buffer[i]!==buffer[i+stride]){binding.setValue(buffer,accuIndex);break}}saveOriginalState(){const buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*this._origIndex;this.binding.getValue(buffer,originalValueOffset);for(let i=stride,e=originalValueOffset;i!==e;++i)buffer[i]=buffer[originalValueOffset+i%stride];this._setIdentity();this.cumulativeWeightAdditive=
this.cumulativeWeight=0}restoreOriginalState(){this.binding.setValue(this.buffer,3*this.valueSize)}_setAdditiveIdentityNumeric(){var startIndex=this._addIndex*this.valueSize;const endIndex=startIndex+this.valueSize;for(;startIndex<endIndex;startIndex++)this.buffer[startIndex]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric();this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const startIndex=this._origIndex*this.valueSize,targetIndex=this._addIndex*this.valueSize;
for(let i=0;i<this.valueSize;i++)this.buffer[targetIndex+i]=this.buffer[startIndex+i]}_select(buffer,dstOffset,srcOffset,t,stride){if(.5<=t)for(t=0;t!==stride;++t)buffer[dstOffset+t]=buffer[srcOffset+t]}_slerp(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t)}_slerpAdditive(buffer,dstOffset,srcOffset,t,stride){stride*=this._workIndex;Quaternion.multiplyQuaternionsFlat(buffer,stride,buffer,dstOffset,buffer,srcOffset);Quaternion.slerpFlat(buffer,
dstOffset,buffer,dstOffset,buffer,stride,t)}_lerp(buffer,dstOffset,srcOffset,t,stride){const s=1-t;for(let i=0;i!==stride;++i){const j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t}}_lerpAdditive(buffer,dstOffset,srcOffset,t,stride){for(let i=0;i!==stride;++i){const j=dstOffset+i;buffer[j]+=buffer[srcOffset+i]*t}}}const _reservedRe=RegExp("[\\[\\]\\.:\\/]","g"),_directoryRe=/((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]"),_nodeRe=/(WCOD+)?/.source.replace("WCOD","[^\\[\\]:\\/]"),
_objectRe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]"),_propertyRe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]"),_trackRe=new RegExp("^"+_directoryRe+_nodeRe+_objectRe+_propertyRe+"$"),_supportedObjectNames=["material","materials","bones","map"];class Composite{constructor(targetGroup,path,optionalParsedPath){optionalParsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup;this._bindings=targetGroup.subscribe_(path,optionalParsedPath)}getValue(array,
offset){this.bind();const binding=this._bindings[this._targetGroup.nCachedObjects_];void 0!==binding&&binding.getValue(array,offset)}setValue(array,offset){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i)bindings[i].setValue(array,offset)}bind(){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i)bindings[i].bind()}unbind(){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,
n=bindings.length;i!==n;++i)bindings[i].unbind()}}class PropertyBinding{constructor(rootNode,path,parsedPath){this.path=path;this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path);this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName)||rootNode;this.rootNode=rootNode;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}static create(root,path,parsedPath){return root&&root.isAnimationObjectGroup?new PropertyBinding.Composite(root,path,parsedPath):new PropertyBinding(root,
path,parsedPath)}static sanitizeNodeName(name){return name.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(trackName){var matches=_trackRe.exec(trackName);if(null===matches)throw Error("PropertyBinding: Cannot parse trackName: "+trackName);matches={nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],propertyIndex:matches[6]};const lastDot=matches.nodeName&&matches.nodeName.lastIndexOf(".");if(void 0!==lastDot&&-1!==lastDot){const objectName=matches.nodeName.substring(lastDot+
1);-1!==_supportedObjectNames.indexOf(objectName)&&(matches.nodeName=matches.nodeName.substring(0,lastDot),matches.objectName=objectName)}if(null===matches.propertyName||0===matches.propertyName.length)throw Error("PropertyBinding: can not parse propertyName from trackName: "+trackName);return matches}static findNode(root,nodeName){if(void 0===nodeName||""===nodeName||"."===nodeName||-1===nodeName||nodeName===root.name||nodeName===root.uuid)return root;if(root.skeleton){const bone=root.skeleton.getBoneByName(nodeName);
if(void 0!==bone)return bone}if(root.children){const searchNodeSubtree=function(children){for(let i=0;i<children.length;i++){var childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName||(childNode=searchNodeSubtree(childNode.children)))return childNode}return null};if(root=searchNodeSubtree(root.children))return root}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(buffer,offset){buffer[offset]=this.targetObject[this.propertyName]}_getValue_array(buffer,
offset){const source=this.resolvedProperty;for(let i=0,n=source.length;i!==n;++i)buffer[offset++]=source[i]}_getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset)}_setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset]}_setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(buffer,
offset){this.targetObject[this.propertyName]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i)dest[i]=buffer[offset++]}_setValue_array_setNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i)dest[i]=buffer[offset++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i=
0,n=dest.length;i!==n;++i)dest[i]=buffer[offset++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset]}_setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(buffer,
offset){this.resolvedProperty.fromArray(buffer,offset)}_setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset);this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(targetArray,offset){this.bind();this.getValue(targetArray,offset)}_setValue_unbound(sourceArray,offset){this.bind();this.setValue(sourceArray,offset)}bind(){let targetObject=
this.node;var parsedPath=this.parsedPath,objectName=parsedPath.objectName;const propertyName=parsedPath.propertyName;let propertyIndex=parsedPath.propertyIndex;targetObject||(this.node=targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName)||this.rootNode);this.getValue=this._getValue_unavailable;this.setValue=this._setValue_unavailable;if(targetObject){if(objectName){var objectIndex=parsedPath.objectIndex;switch(objectName){case "materials":if(!targetObject.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",
this);return}if(!targetObject.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}targetObject=targetObject.material.materials;break;case "bones":if(!targetObject.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}targetObject=targetObject.skeleton.bones;for(objectName=0;objectName<targetObject.length;objectName++)if(targetObject[objectName].name===
objectIndex){objectIndex=objectName;break}break;case "map":if("map"in targetObject){targetObject=targetObject.map;break}if(!targetObject.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!targetObject.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}targetObject=targetObject.material.map;break;default:if(void 0===targetObject[objectName]){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",
this);return}targetObject=targetObject[objectName]}if(void 0!==objectIndex){if(void 0===targetObject[objectIndex]){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,targetObject);return}targetObject=targetObject[objectIndex]}}objectIndex=targetObject[propertyName];if(void 0===objectIndex)console.error("THREE.PropertyBinding: Trying to update property for track: "+parsedPath.nodeName+"."+propertyName+" but it wasn't found.",targetObject);else{parsedPath=
this.Versioning.None;this.targetObject=targetObject;void 0!==targetObject.needsUpdate?parsedPath=this.Versioning.NeedsUpdate:void 0!==targetObject.matrixWorldNeedsUpdate&&(parsedPath=this.Versioning.MatrixWorldNeedsUpdate);objectName=this.BindingType.Direct;if(void 0!==propertyIndex){if("morphTargetInfluences"===propertyName){if(!targetObject.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!targetObject.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
this);return}void 0!==targetObject.morphTargetDictionary[propertyIndex]&&(propertyIndex=targetObject.morphTargetDictionary[propertyIndex])}objectName=this.BindingType.ArrayElement;this.resolvedProperty=objectIndex;this.propertyIndex=propertyIndex}else void 0!==objectIndex.fromArray&&void 0!==objectIndex.toArray?(objectName=this.BindingType.HasFromToArray,this.resolvedProperty=objectIndex):Array.isArray(objectIndex)?(objectName=this.BindingType.EntireArray,this.resolvedProperty=objectIndex):this.propertyName=
propertyName;this.getValue=this.GetterByBindingType[objectName];this.setValue=this.SetterByBindingTypeAndVersioning[objectName][parsedPath]}}else console.error("THREE.PropertyBinding: Trying to update node for track: "+this.path+" but it wasn't found.")}unbind(){this.node=null;this.getValue=this._getValue_unbound;this.setValue=this._setValue_unbound}}PropertyBinding.Composite=Composite;PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};PropertyBinding.prototype.Versioning=
{None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray];PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0;this.uuid=generateUUID();this._objects=Array.prototype.slice.call(arguments);this.nCachedObjects_=0;const indices={};this._indicesByUUID=indices;for(let i=0,n=arguments.length;i!==n;++i)indices[arguments[i].uuid]=i;this._paths=[];this._parsedPaths=[];this._bindings=[];this._bindingsIndicesByPath={};const scope=this;this.stats={objects:{get total(){return scope._objects.length},get inUse(){return this.total-scope.nCachedObjects_}},
get bindingsPerObject(){return scope._bindings.length}}}add(){const objects=this._objects,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;let knownObject=void 0,nObjects=objects.length,nCachedObjects=this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){const object=arguments[i];var uuid=object.uuid;let index=indicesByUUID[uuid];if(void 0===index){index=nObjects++;indicesByUUID[uuid]=index;objects.push(object);
for(let j=0,m=nBindings;j!==m;++j)bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]))}else if(index<nCachedObjects){knownObject=objects[index];const firstActiveIndex=--nCachedObjects;var lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[uuid]=firstActiveIndex;objects[firstActiveIndex]=object;for(let j=0,m=nBindings;j!==m;++j)uuid=bindings[j],lastCachedObject=uuid[index],uuid[index]=uuid[firstActiveIndex],
void 0===lastCachedObject&&(lastCachedObject=new PropertyBinding(object,paths[j],parsedPaths[j])),uuid[firstActiveIndex]=lastCachedObject}else objects[index]!==knownObject&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=nCachedObjects}remove(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=
this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){var object=arguments[i],uuid=object.uuid;const index=indicesByUUID[uuid];if(void 0!==index&&index>=nCachedObjects){const lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index;objects[index]=firstActiveObject;indicesByUUID[uuid]=lastCachedIndex;objects[lastCachedIndex]=object;for(let j=0,m=nBindings;j!==m;++j)object=bindings[j],uuid=object[index],object[index]=object[lastCachedIndex],
object[lastCachedIndex]=uuid}}this.nCachedObjects_=nCachedObjects}uncache(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_,nObjects=objects.length;for(let i=0,n=arguments.length;i!==n;++i){var uuid=arguments[i].uuid;const index=indicesByUUID[uuid];if(void 0!==index)if(delete indicesByUUID[uuid],index<nCachedObjects){uuid=--nCachedObjects;var lastCachedObject=objects[uuid],lastIndex=--nObjects,
lastObject=objects[lastIndex];indicesByUUID[lastCachedObject.uuid]=index;objects[index]=lastCachedObject;indicesByUUID[lastObject.uuid]=uuid;objects[uuid]=lastObject;objects.pop();for(let j=0,m=nBindings;j!==m;++j)lastCachedObject=bindings[j],lastObject=lastCachedObject[lastIndex],lastCachedObject[index]=lastCachedObject[uuid],lastCachedObject[uuid]=lastObject,lastCachedObject.pop()}else{uuid=--nObjects;lastIndex=objects[uuid];0<uuid&&(indicesByUUID[lastIndex.uuid]=index);objects[index]=lastIndex;
objects.pop();for(let j=0,m=nBindings;j!==m;++j)lastIndex=bindings[j],lastIndex[index]=lastIndex[uuid],lastIndex.pop()}}this.nCachedObjects_=nCachedObjects}subscribe_(path,parsedPath){const indicesByPath=this._bindingsIndicesByPath;let index=indicesByPath[path];const bindings=this._bindings;if(void 0!==index)return bindings[index];const paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nCachedObjects=this.nCachedObjects_,bindingsForPath=Array(objects.length);index=bindings.length;
indicesByPath[path]=index;paths.push(path);parsedPaths.push(parsedPath);bindings.push(bindingsForPath);for(let i=nCachedObjects,n=objects.length;i!==n;++i)bindingsForPath[i]=new PropertyBinding(objects[i],path,parsedPath);return bindingsForPath}unsubscribe_(path){const indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(void 0!==index){const paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex];
indicesByPath[path[lastBindingsIndex]]=index;bindings[index]=lastBindings;bindings.pop();parsedPaths[index]=parsedPaths[lastBindingsIndex];parsedPaths.pop();paths[index]=paths[lastBindingsIndex];paths.pop()}}}class AnimationAction{constructor(mixer,clip,localRoot=null,blendMode=clip.blendMode){this._mixer=mixer;this._clip=clip;this._localRoot=localRoot;this.blendMode=blendMode;mixer=clip.tracks;clip=mixer.length;localRoot=Array(clip);blendMode={endingStart:2400,endingEnd:2400};for(let i=0;i!==clip;++i){const interpolant=
mixer[i].createInterpolant(null);localRoot[i]=interpolant;interpolant.settings=blendMode}this._interpolantSettings=blendMode;this._interpolants=localRoot;this._propertyBindings=Array(clip);this._weightInterpolant=this._timeScaleInterpolant=this._byClipCacheIndex=this._cacheIndex=null;this.loop=2201;this._loopCount=-1;this._startTime=null;this.time=0;this._effectiveWeight=this.weight=this._effectiveTimeScale=this.timeScale=1;this.repetitions=Infinity;this.paused=!1;this.enabled=!0;this.clampWhenFinished=
!1;this.zeroSlopeAtEnd=this.zeroSlopeAtStart=!0}play(){this._mixer._activateAction(this);return this}stop(){this._mixer._deactivateAction(this);return this.reset()}reset(){this.paused=!1;this.enabled=!0;this.time=0;this._loopCount=-1;this._startTime=null;return this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(time){this._startTime=
time;return this}setLoop(mode,repetitions){this.loop=mode;this.repetitions=repetitions;return this}setEffectiveWeight(weight){this.weight=weight;this._effectiveWeight=this.enabled?weight:0;return this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(duration){return this._scheduleFading(duration,0,1)}fadeOut(duration){return this._scheduleFading(duration,1,0)}crossFadeFrom(fadeOutAction,duration,warp){fadeOutAction.fadeOut(duration);this.fadeIn(duration);if(warp){warp=this._clip.duration;
const fadeOutDuration=fadeOutAction._clip.duration,endStartRatio=warp/fadeOutDuration;fadeOutAction.warp(1,fadeOutDuration/warp,duration);this.warp(endStartRatio,1,duration)}return this}crossFadeTo(fadeInAction,duration,warp){return fadeInAction.crossFadeFrom(this,duration,warp)}stopFading(){const weightInterpolant=this._weightInterpolant;null!==weightInterpolant&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(weightInterpolant));return this}setEffectiveTimeScale(timeScale){this.timeScale=
timeScale;this._effectiveTimeScale=this.paused?0:timeScale;return this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(duration){this.timeScale=this._clip.duration/duration;return this.stopWarping()}syncWith(action){this.time=action.time;this.timeScale=action.timeScale;return this.stopWarping()}halt(duration){return this.warp(this._effectiveTimeScale,0,duration)}warp(startTimeScale,endTimeScale,duration){var mixer=this._mixer;const now=mixer.time,timeScale=this.timeScale;
var interpolant=this._timeScaleInterpolant;null===interpolant&&(this._timeScaleInterpolant=interpolant=mixer._lendControlInterpolant());mixer=interpolant.parameterPositions;interpolant=interpolant.sampleValues;mixer[0]=now;mixer[1]=now+duration;interpolant[0]=startTimeScale/timeScale;interpolant[1]=endTimeScale/timeScale;return this}stopWarping(){const timeScaleInterpolant=this._timeScaleInterpolant;null!==timeScaleInterpolant&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(timeScaleInterpolant));
return this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(time,deltaTime,timeDirection,accuIndex){if(this.enabled){var startTime=this._startTime;null!==startTime&&(deltaTime=(time-startTime)*timeDirection,0>deltaTime||0===timeDirection?deltaTime=0:(this._startTime=null,deltaTime*=timeDirection));deltaTime*=this._updateTimeScale(time);timeDirection=this._updateTime(deltaTime);time=this._updateWeight(time);if(0<time)switch(deltaTime=
this._interpolants,startTime=this._propertyBindings,this.blendMode){case 2501:for(let j=0,m=deltaTime.length;j!==m;++j)deltaTime[j].evaluate(timeDirection),startTime[j].accumulateAdditive(time);break;default:for(let j=0,m=deltaTime.length;j!==m;++j)deltaTime[j].evaluate(timeDirection),startTime[j].accumulate(accuIndex,time)}}else this._updateWeight(time)}_updateWeight(time){let weight=0;if(this.enabled){weight=this.weight;const interpolant=this._weightInterpolant;if(null!==interpolant){const interpolantValue=
interpolant.evaluate(time)[0];weight*=interpolantValue;time>interpolant.parameterPositions[1]&&(this.stopFading(),0===interpolantValue&&(this.enabled=!1))}}return this._effectiveWeight=weight}_updateTimeScale(time){let timeScale=0;if(!this.paused){timeScale=this.timeScale;const interpolant=this._timeScaleInterpolant;if(null!==interpolant){const interpolantValue=interpolant.evaluate(time)[0];timeScale*=interpolantValue;time>interpolant.parameterPositions[1]&&(this.stopWarping(),0===timeScale?this.paused=
!0:this.timeScale=timeScale)}}return this._effectiveTimeScale=timeScale}_updateTime(deltaTime){const duration=this._clip.duration;var loop=this.loop;let time=this.time+deltaTime,loopCount=this._loopCount;const pingPong=2202===loop;if(0===deltaTime)return-1===loopCount?time:pingPong&&1===(loopCount&1)?duration-time:time;if(2200===loop)a:{if(-1===loopCount&&(this._loopCount=0,this._setEndings(!0,!0,!1)),time>=duration)time=duration;else if(0>time)time=0;else{this.time=time;break a}this.clampWhenFinished?
this.paused=!0:this.enabled=!1;this.time=time;this._mixer.dispatchEvent({type:"finished",action:this,direction:0>deltaTime?-1:1})}else{-1===loopCount&&(0<=deltaTime?(loopCount=0,this._setEndings(!0,0===this.repetitions,pingPong)):this._setEndings(0===this.repetitions,!0,pingPong));if(time>=duration||0>time){loop=Math.floor(time/duration);time-=duration*loop;loopCount+=Math.abs(loop);const pending=this.repetitions-loopCount;0>=pending?(this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=
time=0<deltaTime?duration:0,this._mixer.dispatchEvent({type:"finished",action:this,direction:0<deltaTime?1:-1})):(1===pending?(deltaTime=0>deltaTime,this._setEndings(deltaTime,!deltaTime,pingPong)):this._setEndings(!1,!1,pingPong),this._loopCount=loopCount,this.time=time,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:loop}))}else this.time=time;if(pingPong&&1===(loopCount&1))return duration-time}return time}_setEndings(atStart,atEnd,pingPong){const settings=this._interpolantSettings;
pingPong?(settings.endingStart=2401,settings.endingEnd=2401):(settings.endingStart=atStart?this.zeroSlopeAtStart?2401:2400:2402,settings.endingEnd=atEnd?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(duration,weightNow,weightThen){var mixer=this._mixer;const now=mixer.time;var interpolant=this._weightInterpolant;null===interpolant&&(this._weightInterpolant=interpolant=mixer._lendControlInterpolant());mixer=interpolant.parameterPositions;interpolant=interpolant.sampleValues;mixer[0]=now;interpolant[0]=
weightNow;mixer[1]=now+duration;interpolant[1]=weightThen;return this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(root){super();this._root=root;this._initMemoryManager();this.time=this._accuIndex=0;this.timeScale=1}_bindAction(action,prototypeAction){const root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings;action=action._interpolants;const rootUuid=root.uuid;
var bindingsByRoot=this._bindingsByRootAndName;let bindingsByName=bindingsByRoot[rootUuid];void 0===bindingsByName&&(bindingsByName={},bindingsByRoot[rootUuid]=bindingsByName);for(bindingsByRoot=0;bindingsByRoot!==nTracks;++bindingsByRoot){const track=tracks[bindingsByRoot],trackName=track.name;let binding=bindingsByName[trackName];if(void 0!==binding)++binding.referenceCount;else{binding=bindings[bindingsByRoot];if(void 0!==binding){null===binding._cacheIndex&&(++binding.referenceCount,this._addInactiveBinding(binding,
rootUuid,trackName));continue}binding=new PropertyMixer(PropertyBinding.create(root,trackName,prototypeAction&&prototypeAction._propertyBindings[bindingsByRoot].binding.parsedPath),track.ValueTypeName,track.getValueSize());++binding.referenceCount;this._addInactiveBinding(binding,rootUuid,trackName)}bindings[bindingsByRoot]=binding;action[bindingsByRoot].resultBuffer=binding.buffer}}_activateAction(action){if(!this._isActiveAction(action)){if(null===action._cacheIndex){var rootUuid=(action._localRoot||
this._root).uuid,clipUuid=action._clip.uuid;const actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]);this._addInactiveAction(action,clipUuid,rootUuid)}rootUuid=action._propertyBindings;for(let i=0,n=rootUuid.length;i!==n;++i)clipUuid=rootUuid[i],0===clipUuid.useCount++&&(this._lendBinding(clipUuid),clipUuid.saveOriginalState());this._lendAction(action)}}_deactivateAction(action){if(this._isActiveAction(action)){const bindings=action._propertyBindings;
for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];0===--binding.useCount&&(binding.restoreOriginalState(),this._takeBackBinding(binding))}this._takeBackAction(action)}}_initMemoryManager(){this._actions=[];this._nActiveActions=0;this._actionsByClip={};this._bindings=[];this._nActiveBindings=0;this._bindingsByRootAndName={};this._controlInterpolants=[];this._nActiveControlInterpolants=0;const scope=this;this.stats={actions:{get total(){return scope._actions.length},get inUse(){return scope._nActiveActions}},
bindings:{get total(){return scope._bindings.length},get inUse(){return scope._nActiveBindings}},controlInterpolants:{get total(){return scope._controlInterpolants.length},get inUse(){return scope._nActiveControlInterpolants}}}}_isActiveAction(action){action=action._cacheIndex;return null!==action&&action<this._nActiveActions}_addInactiveAction(action,clipUuid,rootUuid){const actions=this._actions,actionsByClip=this._actionsByClip;let actionsForClip=actionsByClip[clipUuid];void 0===actionsForClip?
(actionsForClip={knownActions:[action],actionByRoot:{}},action._byClipCacheIndex=0,actionsByClip[clipUuid]=actionsForClip):(clipUuid=actionsForClip.knownActions,action._byClipCacheIndex=clipUuid.length,clipUuid.push(action));action._cacheIndex=actions.length;actions.push(action);actionsForClip.actionByRoot[rootUuid]=action}_removeInactiveAction(action){var actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=
lastInactiveAction;actions.pop();action._cacheIndex=null;actions=action._clip.uuid;lastInactiveAction=this._actionsByClip;cacheIndex=lastInactiveAction[actions];const knownActionsForClip=cacheIndex.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex;knownActionsForClip[byClipCacheIndex]=lastKnownAction;knownActionsForClip.pop();action._byClipCacheIndex=null;delete cacheIndex.actionByRoot[(action._localRoot||
this._root).uuid];0===knownActionsForClip.length&&delete lastInactiveAction[actions];this._removeInactiveBindingsForAction(action)}_removeInactiveBindingsForAction(action){action=action._propertyBindings;for(let i=0,n=action.length;i!==n;++i){const binding=action[i];0===--binding.referenceCount&&this._removeInactiveBinding(binding)}}_lendAction(action){const actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=
lastActiveIndex;actions[lastActiveIndex]=action;firstInactiveAction._cacheIndex=prevIndex;actions[prevIndex]=firstInactiveAction}_takeBackAction(action){const actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex;actions[firstInactiveIndex]=action;lastActiveAction._cacheIndex=prevIndex;actions[prevIndex]=lastActiveAction}_addInactiveBinding(binding,rootUuid,trackName){const bindingsByRoot=
this._bindingsByRootAndName,bindings=this._bindings;let bindingByName=bindingsByRoot[rootUuid];void 0===bindingByName&&(bindingByName={},bindingsByRoot[rootUuid]=bindingByName);bindingByName[trackName]=binding;binding._cacheIndex=bindings.length;bindings.push(binding)}_removeInactiveBinding(binding){const bindings=this._bindings;var propBinding=binding.binding;const rootUuid=propBinding.rootNode.uuid;propBinding=propBinding.path;const bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],
lastInactiveBinding=bindings[bindings.length-1];binding=binding._cacheIndex;lastInactiveBinding._cacheIndex=binding;bindings[binding]=lastInactiveBinding;bindings.pop();delete bindingByName[propBinding];0===Object.keys(bindingByName).length&&delete bindingsByRoot[rootUuid]}_lendBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex;bindings[lastActiveIndex]=
binding;firstInactiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=firstInactiveBinding}_takeBackBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex;bindings[firstInactiveIndex]=binding;lastActiveBinding._cacheIndex=prevIndex;bindings[prevIndex]=lastActiveBinding}_lendControlInterpolant(){const interpolants=this._controlInterpolants,lastActiveIndex=
this._nActiveControlInterpolants++;let interpolant=interpolants[lastActiveIndex];void 0===interpolant&&(interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),interpolant.__cacheIndex=lastActiveIndex,interpolants[lastActiveIndex]=interpolant);return interpolant}_takeBackControlInterpolant(interpolant){const interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=
interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex;interpolants[firstInactiveIndex]=interpolant;lastActiveInterpolant.__cacheIndex=prevIndex;interpolants[prevIndex]=lastActiveInterpolant}clipAction(clip,optionalRoot,blendMode){var root=optionalRoot||this._root;const rootUuid=root.uuid;root="string"===typeof clip?AnimationClip.findByName(root,clip):clip;clip=null!==root?root.uuid:clip;const actionsForClip=this._actionsByClip[clip];var prototypeAction=null;void 0===blendMode&&
(blendMode=null!==root?root.blendMode:2500);if(void 0!==actionsForClip){prototypeAction=actionsForClip.actionByRoot[rootUuid];if(void 0!==prototypeAction&&prototypeAction.blendMode===blendMode)return prototypeAction;prototypeAction=actionsForClip.knownActions[0];null===root&&(root=prototypeAction._clip)}if(null===root)return null;optionalRoot=new AnimationAction(this,root,optionalRoot,blendMode);this._bindAction(optionalRoot,prototypeAction);this._addInactiveAction(optionalRoot,clip,rootUuid);return optionalRoot}existingAction(clip,
optionalRoot){var root=optionalRoot||this._root;optionalRoot=root.uuid;root="string"===typeof clip?AnimationClip.findByName(root,clip):clip;clip=this._actionsByClip[root?root.uuid:clip];return void 0!==clip?clip.actionByRoot[optionalRoot]||null:null}stopAllAction(){const actions=this._actions;var nActions=this._nActiveActions;for(--nActions;0<=nActions;--nActions)actions[nActions].stop();return this}update(deltaTime){deltaTime*=this.timeScale;var actions=this._actions,nActions=this._nActiveActions;
const time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;for(let i=0;i!==nActions;++i)actions[i]._update(time,deltaTime,timeDirection,accuIndex);deltaTime=this._bindings;actions=this._nActiveBindings;for(nActions=0;nActions!==actions;++nActions)deltaTime[nActions].apply(accuIndex);return this}setTime(timeInSeconds){this.time=0;for(let i=0;i<this._actions.length;i++)this._actions[i].time=0;return this.update(timeInSeconds)}getRoot(){return this._root}uncacheClip(clip){const actions=
this._actions;clip=clip.uuid;const actionsByClip=this._actionsByClip;var actionsForClip=actionsByClip[clip];if(void 0!==actionsForClip){actionsForClip=actionsForClip.knownActions;for(let i=0,n=actionsForClip.length;i!==n;++i){const action=actionsForClip[i];this._deactivateAction(action);const cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null;action._byClipCacheIndex=null;lastInactiveAction._cacheIndex=cacheIndex;actions[cacheIndex]=lastInactiveAction;
actions.pop();this._removeInactiveBindingsForAction(action)}delete actionsByClip[clip]}}uncacheRoot(root){root=root.uuid;const actionsByClip=this._actionsByClip;for(var clipUuid in actionsByClip){const action=actionsByClip[clipUuid].actionByRoot[root];void 0!==action&&(this._deactivateAction(action),this._removeInactiveAction(action))}clipUuid=this._bindingsByRootAndName[root];if(void 0!==clipUuid)for(const trackName in clipUuid)root=clipUuid[trackName],root.restoreOriginalState(),this._removeInactiveBinding(root)}uncacheAction(clip,
optionalRoot){clip=this.existingAction(clip,optionalRoot);null!==clip&&(this._deactivateAction(clip),this._removeInactiveAction(clip))}}class Uniform{constructor(value){this.value=value}clone(){return new Uniform(void 0===this.value.clone?this.value:this.value.clone())}}let id$jscomp$0=0;class UniformsGroup extends EventDispatcher{constructor(){super();this.isUniformsGroup=!0;Object.defineProperty(this,"id",{value:id$jscomp$0++});this.name="";this.usage=35044;this.uniforms=[]}add(uniform){this.uniforms.push(uniform);
return this}remove(uniform){uniform=this.uniforms.indexOf(uniform);-1!==uniform&&this.uniforms.splice(uniform,1);return this}setName(name){this.name=name;return this}setUsage(value){this.usage=value;return this}dispose(){this.dispatchEvent({type:"dispose"});return this}copy(source){this.name=source.name;this.usage=source.usage;source=source.uniforms;this.uniforms.length=0;for(let i=0,l=source.length;i<l;i++)this.uniforms.push(source[i].clone());return this}clone(){return(new this.constructor).copy(this)}}
class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(array,stride,meshPerAttribute=1){super(array,stride);this.isInstancedInterleavedBuffer=!0;this.meshPerAttribute=meshPerAttribute}copy(source){super.copy(source);this.meshPerAttribute=source.meshPerAttribute;return this}clone(data){data=super.clone(data);data.meshPerAttribute=this.meshPerAttribute;return data}toJSON(data){data=super.toJSON(data);data.isInstancedInterleavedBuffer=!0;data.meshPerAttribute=this.meshPerAttribute;return data}}
class GLBufferAttribute{constructor(buffer,type,itemSize,elementSize,count){this.isGLBufferAttribute=!0;this.buffer=buffer;this.type=type;this.itemSize=itemSize;this.elementSize=elementSize;this.count=count;this.version=0}set needsUpdate(value){!0===value&&this.version++}setBuffer(buffer){this.buffer=buffer;return this}setType(type,elementSize){this.type=type;this.elementSize=elementSize;return this}setItemSize(itemSize){this.itemSize=itemSize;return this}setCount(count){this.count=count;return this}}
class Raycaster{constructor(origin,direction,near=0,far=Infinity){this.ray=new Ray(origin,direction);this.near=near;this.far=far;this.camera=null;this.layers=new Layers;this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(origin,direction){this.ray.set(origin,direction)}setFromCamera(coords,camera){camera.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(camera.matrixWorld),this.ray.direction.set(coords.x,coords.y,.5).unproject(camera).sub(this.ray.origin).normalize(),
this.camera=camera):camera.isOrthographicCamera?(this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera),this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld),this.camera=camera):console.error("THREE.Raycaster: Unsupported camera type: "+camera.type)}intersectObject(object,recursive=!0,intersects=[]){intersectObject(object,this,intersects,recursive);intersects.sort(ascSort);return intersects}intersectObjects(objects,recursive=!0,intersects=
[]){for(let i=0,l=objects.length;i<l;i++)intersectObject(objects[i],this,intersects,recursive);intersects.sort(ascSort);return intersects}}class Spherical{constructor(radius=1,phi=0,theta=0){this.radius=radius;this.phi=phi;this.theta=theta;return this}set(radius,phi,theta){this.radius=radius;this.phi=phi;this.theta=theta;return this}copy(other){this.radius=other.radius;this.phi=other.phi;this.theta=other.theta;return this}makeSafe(){this.phi=Math.max(1E-6,Math.min(Math.PI-1E-6,this.phi));return this}setFromVector3(v){return this.setFromCartesianCoords(v.x,
v.y,v.z)}setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+y*y+z*z);0===this.radius?this.phi=this.theta=0:(this.theta=Math.atan2(x,z),this.phi=Math.acos(clamp(y/this.radius,-1,1)));return this}clone(){return(new this.constructor).copy(this)}}class Cylindrical{constructor(radius=1,theta=0,y=0){this.radius=radius;this.theta=theta;this.y=y;return this}set(radius,theta,y){this.radius=radius;this.theta=theta;this.y=y;return this}copy(other){this.radius=other.radius;this.theta=other.theta;this.y=
other.y;return this}setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z)}setFromCartesianCoords(x,y,z){this.radius=Math.sqrt(x*x+z*z);this.theta=Math.atan2(x,z);this.y=y;return this}clone(){return(new this.constructor).copy(this)}}const _vector$4=new Vector2;class Box2{constructor(min=new Vector2(Infinity,Infinity),max=new Vector2(-Infinity,-Infinity)){this.isBox2=!0;this.min=min;this.max=max}set(min,max){this.min.copy(min);this.max.copy(max);return this}setFromPoints(points){this.makeEmpty();
for(let i=0,il=points.length;i<il;i++)this.expandByPoint(points[i]);return this}setFromCenterAndSize(center,size){size=_vector$4.copy(size).multiplyScalar(.5);this.min.copy(center).sub(size);this.max.copy(center).add(size);return this}clone(){return(new this.constructor).copy(this)}copy(box){this.min.copy(box.min);this.max.copy(box.max);return this}makeEmpty(){this.min.x=this.min.y=Infinity;this.max.x=this.max.y=-Infinity;return this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(target){return this.isEmpty()?
target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min)}expandByPoint(point){this.min.min(point);this.max.max(point);return this}expandByVector(vector){this.min.sub(vector);this.max.add(vector);return this}expandByScalar(scalar){this.min.addScalar(-scalar);this.max.addScalar(scalar);return this}containsPoint(point){return point.x<this.min.x||point.x>this.max.x||point.y<this.min.y||point.y>this.max.y?
!1:!0}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(box){return box.max.x<this.min.x||box.min.x>this.max.x||box.max.y<this.min.y||box.min.y>this.max.y?!1:!0}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max)}distanceToPoint(point){return _vector$4.copy(point).clamp(this.min,
this.max).sub(point).length()}intersect(box){this.min.max(box.min);this.max.min(box.max);return this}union(box){this.min.min(box.min);this.max.max(box.max);return this}translate(offset){this.min.add(offset);this.max.add(offset);return this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}}const _startP=new Vector3,_startEnd=new Vector3;class Line3{constructor(start=new Vector3,end=new Vector3){this.start=start;this.end=end}set(start,end){this.start.copy(start);this.end.copy(end);
return this}copy(line){this.start.copy(line.start);this.end.copy(line.end);return this}getCenter(target){return target.addVectors(this.start,this.end).multiplyScalar(.5)}delta(target){return target.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,target){return this.delta(target).multiplyScalar(t).add(this.start)}closestPointToPointParameter(point,clampToLine){_startP.subVectors(point,this.start);_startEnd.subVectors(this.end,
this.start);point=_startEnd.dot(_startEnd);point=_startEnd.dot(_startP)/point;clampToLine&&(point=clamp(point,0,1));return point}closestPointToPoint(point,clampToLine,target){point=this.closestPointToPointParameter(point,clampToLine);return this.delta(target).multiplyScalar(point).add(this.start)}applyMatrix4(matrix){this.start.applyMatrix4(matrix);this.end.applyMatrix4(matrix);return this}equals(line){return line.start.equals(this.start)&&line.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}}
const _vector$3=new Vector3;class SpotLightHelper extends Object3D{constructor(light,color){super();this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=!1;this.color=color;light=new BufferGeometry;color=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let i=0,j=1,l=32;i<l;i++,j++){const p1=i/l*Math.PI*2,p2=j/l*Math.PI*2;color.push(Math.cos(p1),Math.sin(p1),1,Math.cos(p2),Math.sin(p2),1)}light.setAttribute("position",new Float32BufferAttribute(color,
3));color=new LineBasicMaterial({fog:!1,toneMapped:!1});this.cone=new LineSegments(light,color);this.add(this.cone);this.update()}dispose(){this.cone.geometry.dispose();this.cone.material.dispose()}update(){this.light.updateMatrixWorld();const coneLength=this.light.distance?this.light.distance:1E3,coneWidth=coneLength*Math.tan(this.light.angle);this.cone.scale.set(coneWidth,coneWidth,coneLength);_vector$3.setFromMatrixPosition(this.light.target.matrixWorld);this.cone.lookAt(_vector$3);void 0!==this.color?
this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const _vector$2=new Vector3,_boneMatrix=new Matrix4,_matrixWorldInv=new Matrix4;class SkeletonHelper extends LineSegments{constructor(object){const bones=getBoneList(object),geometry=new BufferGeometry;var vertices=[];const colors=[],color1=new Color(0,0,1),color2=new Color(0,1,0);for(let i=0;i<bones.length;i++){const bone=bones[i];bone.parent&&bone.parent.isBone&&(vertices.push(0,0,0),vertices.push(0,0,0),colors.push(color1.r,
color1.g,color1.b),colors.push(color2.r,color2.g,color2.b))}geometry.setAttribute("position",new Float32BufferAttribute(vertices,3));geometry.setAttribute("color",new Float32BufferAttribute(colors,3));vertices=new LineBasicMaterial({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(geometry,vertices);this.isSkeletonHelper=!0;this.type="SkeletonHelper";this.root=object;this.bones=bones;this.matrix=object.matrixWorld;this.matrixAutoUpdate=!1}updateMatrixWorld(force){const bones=
this.bones,geometry=this.geometry,position=geometry.getAttribute("position");_matrixWorldInv.copy(this.root.matrixWorld).invert();for(let i=0,j=0;i<bones.length;i++){const bone=bones[i];bone.parent&&bone.parent.isBone&&(_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),position.setXYZ(j,_vector$2.x,_vector$2.y,_vector$2.z),_boneMatrix.multiplyMatrices(_matrixWorldInv,bone.parent.matrixWorld),_vector$2.setFromMatrixPosition(_boneMatrix),position.setXYZ(j+
1,_vector$2.x,_vector$2.y,_vector$2.z),j+=2)}geometry.getAttribute("position").needsUpdate=!0;super.updateMatrixWorld(force)}dispose(){this.geometry.dispose();this.material.dispose()}}class PointLightHelper extends Mesh{constructor(light,sphereSize,color){sphereSize=new SphereGeometry(sphereSize,4,2);const material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});super(sphereSize,material);this.light=light;this.light.updateMatrixWorld();this.color=color;this.type="PointLightHelper";this.matrix=
this.light.matrixWorld;this.matrixAutoUpdate=!1;this.update()}dispose(){this.geometry.dispose();this.material.dispose()}update(){void 0!==this.color?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const _vector$1=new Vector3,_color1=new Color,_color2=new Color;class HemisphereLightHelper extends Object3D{constructor(light,size,color){super();this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=!1;this.color=color;light=
new OctahedronGeometry(size);light.rotateY(.5*Math.PI);this.material=new MeshBasicMaterial({wireframe:!0,fog:!1,toneMapped:!1});void 0===this.color&&(this.material.vertexColors=!0);size=light.getAttribute("position");size=new Float32Array(3*size.count);light.setAttribute("color",new BufferAttribute(size,3));this.add(new Mesh(light,this.material));this.update()}dispose(){this.children[0].geometry.dispose();this.children[0].material.dispose()}update(){const mesh=this.children[0];if(void 0!==this.color)this.material.color.set(this.color);
else{const colors=mesh.geometry.getAttribute("color");_color1.copy(this.light.color);_color2.copy(this.light.groundColor);for(let i=0,l=colors.count;i<l;i++){const color=i<l/2?_color1:_color2;colors.setXYZ(i,color.r,color.g,color.b)}colors.needsUpdate=!0}mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate())}}class GridHelper extends LineSegments{constructor(size=10,divisions=10,color1=4473924,color2=8947848){color1=new Color(color1);color2=new Color(color2);const center=divisions/
2,step=size/divisions,halfSize=size/2;size=[];const colors=[];for(let i=0,j=0,k=-halfSize;i<=divisions;i++,k+=step){size.push(-halfSize,0,k,halfSize,0,k);size.push(k,0,-halfSize,k,0,halfSize);const color=i===center?color1:color2;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3;color.toArray(colors,j);j+=3}divisions=new BufferGeometry;divisions.setAttribute("position",new Float32BufferAttribute(size,3));divisions.setAttribute("color",new Float32BufferAttribute(colors,
3));color1=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(divisions,color1);this.type="GridHelper"}dispose(){this.geometry.dispose();this.material.dispose()}}class PolarGridHelper extends LineSegments{constructor(radius=10,sectors=16,rings=8,divisions=64,color1=4473924,color2=8947848){color1=new Color(color1);color2=new Color(color2);var vertices=[];const colors=[];if(1<sectors)for(var i=0;i<sectors;i++){var v=i/sectors*2*Math.PI,x$jscomp$0=Math.sin(v)*radius;v=Math.cos(v)*radius;vertices.push(0,
0,0);vertices.push(x$jscomp$0,0,v);x$jscomp$0=i&1?color1:color2;colors.push(x$jscomp$0.r,x$jscomp$0.g,x$jscomp$0.b);colors.push(x$jscomp$0.r,x$jscomp$0.g,x$jscomp$0.b)}for(sectors=0;sectors<rings;sectors++)for(i=sectors&1?color1:color2,x$jscomp$0=radius-radius/rings*sectors,v=0;v<divisions;v++){var v$jscomp$0=v/divisions*2*Math.PI;let x=Math.sin(v$jscomp$0)*x$jscomp$0;v$jscomp$0=Math.cos(v$jscomp$0)*x$jscomp$0;vertices.push(x,0,v$jscomp$0);colors.push(i.r,i.g,i.b);v$jscomp$0=(v+1)/divisions*2*Math.PI;
x=Math.sin(v$jscomp$0)*x$jscomp$0;v$jscomp$0=Math.cos(v$jscomp$0)*x$jscomp$0;vertices.push(x,0,v$jscomp$0);colors.push(i.r,i.g,i.b)}radius=new BufferGeometry;radius.setAttribute("position",new Float32BufferAttribute(vertices,3));radius.setAttribute("color",new Float32BufferAttribute(colors,3));vertices=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(radius,vertices);this.type="PolarGridHelper"}dispose(){this.geometry.dispose();this.material.dispose()}}const _v1=new Vector3,_v2=new Vector3,
_v3=new Vector3;class DirectionalLightHelper extends Object3D{constructor(light,size,color){super();this.light=light;this.light.updateMatrixWorld();this.matrix=light.matrixWorld;this.matrixAutoUpdate=!1;this.color=color;void 0===size&&(size=1);light=new BufferGeometry;light.setAttribute("position",new Float32BufferAttribute([-size,size,0,size,size,0,size,-size,0,-size,-size,0,-size,size,0],3));size=new LineBasicMaterial({fog:!1,toneMapped:!1});this.lightPlane=new Line(light,size);this.add(this.lightPlane);
light=new BufferGeometry;light.setAttribute("position",new Float32BufferAttribute([0,0,0,0,0,1],3));this.targetLine=new Line(light,size);this.add(this.targetLine);this.update()}dispose(){this.lightPlane.geometry.dispose();this.lightPlane.material.dispose();this.targetLine.geometry.dispose();this.targetLine.material.dispose()}update(){_v1.setFromMatrixPosition(this.light.matrixWorld);_v2.setFromMatrixPosition(this.light.target.matrixWorld);_v3.subVectors(_v2,_v1);this.lightPlane.lookAt(_v2);void 0!==
this.color?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color));this.targetLine.lookAt(_v2);this.targetLine.scale.z=_v3.length()}}const _vector=new Vector3,_camera=new Camera;class CameraHelper extends LineSegments{constructor(camera){function addLine(a,b){addPoint(a);addPoint(b)}function addPoint(id){vertices.push(0,0,0);colors.push(0,0,0);void 0===
pointMap[id]&&(pointMap[id]=[]);pointMap[id].push(vertices.length/3-1)}var geometry=new BufferGeometry,material=new LineBasicMaterial({color:16777215,vertexColors:!0,toneMapped:!1});const vertices=[],colors=[],pointMap={};addLine("n1","n2");addLine("n2","n4");addLine("n4","n3");addLine("n3","n1");addLine("f1","f2");addLine("f2","f4");addLine("f4","f3");addLine("f3","f1");addLine("n1","f1");addLine("n2","f2");addLine("n3","f3");addLine("n4","f4");addLine("p","n1");addLine("p","n2");addLine("p","n3");
addLine("p","n4");addLine("u1","u2");addLine("u2","u3");addLine("u3","u1");addLine("c","t");addLine("p","c");addLine("cn1","cn2");addLine("cn3","cn4");addLine("cf1","cf2");addLine("cf3","cf4");geometry.setAttribute("position",new Float32BufferAttribute(vertices,3));geometry.setAttribute("color",new Float32BufferAttribute(colors,3));super(geometry,material);this.type="CameraHelper";this.camera=camera;this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix();this.matrix=camera.matrixWorld;
this.matrixAutoUpdate=!1;this.pointMap=pointMap;this.update();camera=new Color(16755200);geometry=new Color(16711680);material=new Color(43775);const colorTarget=new Color(16777215),colorCross=new Color(3355443);this.setColors(camera,geometry,material,colorTarget,colorCross)}setColors(frustum,cone,up,target,cross){const colorAttribute=this.geometry.getAttribute("color");colorAttribute.setXYZ(0,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(1,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(2,
frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(3,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(4,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(5,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(6,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(7,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(8,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(9,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(10,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(11,frustum.r,
frustum.g,frustum.b);colorAttribute.setXYZ(12,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(13,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(14,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(15,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(16,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(17,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(18,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(19,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(20,frustum.r,
frustum.g,frustum.b);colorAttribute.setXYZ(21,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(22,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(23,frustum.r,frustum.g,frustum.b);colorAttribute.setXYZ(24,cone.r,cone.g,cone.b);colorAttribute.setXYZ(25,cone.r,cone.g,cone.b);colorAttribute.setXYZ(26,cone.r,cone.g,cone.b);colorAttribute.setXYZ(27,cone.r,cone.g,cone.b);colorAttribute.setXYZ(28,cone.r,cone.g,cone.b);colorAttribute.setXYZ(29,cone.r,cone.g,cone.b);colorAttribute.setXYZ(30,cone.r,
cone.g,cone.b);colorAttribute.setXYZ(31,cone.r,cone.g,cone.b);colorAttribute.setXYZ(32,up.r,up.g,up.b);colorAttribute.setXYZ(33,up.r,up.g,up.b);colorAttribute.setXYZ(34,up.r,up.g,up.b);colorAttribute.setXYZ(35,up.r,up.g,up.b);colorAttribute.setXYZ(36,up.r,up.g,up.b);colorAttribute.setXYZ(37,up.r,up.g,up.b);colorAttribute.setXYZ(38,target.r,target.g,target.b);colorAttribute.setXYZ(39,target.r,target.g,target.b);colorAttribute.setXYZ(40,cross.r,cross.g,cross.b);colorAttribute.setXYZ(41,cross.r,cross.g,
cross.b);colorAttribute.setXYZ(42,cross.r,cross.g,cross.b);colorAttribute.setXYZ(43,cross.r,cross.g,cross.b);colorAttribute.setXYZ(44,cross.r,cross.g,cross.b);colorAttribute.setXYZ(45,cross.r,cross.g,cross.b);colorAttribute.setXYZ(46,cross.r,cross.g,cross.b);colorAttribute.setXYZ(47,cross.r,cross.g,cross.b);colorAttribute.setXYZ(48,cross.r,cross.g,cross.b);colorAttribute.setXYZ(49,cross.r,cross.g,cross.b);colorAttribute.needsUpdate=!0}update(){const geometry=this.geometry,pointMap=this.pointMap;_camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);
setPoint("c",pointMap,geometry,_camera,0,0,-1);setPoint("t",pointMap,geometry,_camera,0,0,1);setPoint("n1",pointMap,geometry,_camera,-1,-1,-1);setPoint("n2",pointMap,geometry,_camera,1,-1,-1);setPoint("n3",pointMap,geometry,_camera,-1,1,-1);setPoint("n4",pointMap,geometry,_camera,1,1,-1);setPoint("f1",pointMap,geometry,_camera,-1,-1,1);setPoint("f2",pointMap,geometry,_camera,1,-1,1);setPoint("f3",pointMap,geometry,_camera,-1,1,1);setPoint("f4",pointMap,geometry,_camera,1,1,1);setPoint("u1",pointMap,
geometry,_camera,.7,1.1,-1);setPoint("u2",pointMap,geometry,_camera,-.7,1.1,-1);setPoint("u3",pointMap,geometry,_camera,0,2,-1);setPoint("cf1",pointMap,geometry,_camera,-1,0,1);setPoint("cf2",pointMap,geometry,_camera,1,0,1);setPoint("cf3",pointMap,geometry,_camera,0,-1,1);setPoint("cf4",pointMap,geometry,_camera,0,1,1);setPoint("cn1",pointMap,geometry,_camera,-1,0,-1);setPoint("cn2",pointMap,geometry,_camera,1,0,-1);setPoint("cn3",pointMap,geometry,_camera,0,-1,-1);setPoint("cn4",pointMap,geometry,
_camera,0,1,-1);geometry.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose();this.material.dispose()}}const _box=new Box3;class BoxHelper extends LineSegments{constructor(object,color=16776960){const indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),positions=new Float32Array(24),geometry=new BufferGeometry;geometry.setIndex(new BufferAttribute(indices,1));geometry.setAttribute("position",new BufferAttribute(positions,3));super(geometry,new LineBasicMaterial({color,
toneMapped:!1}));this.object=object;this.type="BoxHelper";this.matrixAutoUpdate=!1;this.update()}update(object){void 0!==object&&console.warn("THREE.BoxHelper: .update() has no longer arguments.");void 0!==this.object&&_box.setFromObject(this.object);if(!_box.isEmpty()){object=_box.min;var max=_box.max,position=this.geometry.attributes.position,array=position.array;array[0]=max.x;array[1]=max.y;array[2]=max.z;array[3]=object.x;array[4]=max.y;array[5]=max.z;array[6]=object.x;array[7]=object.y;array[8]=
max.z;array[9]=max.x;array[10]=object.y;array[11]=max.z;array[12]=max.x;array[13]=max.y;array[14]=object.z;array[15]=object.x;array[16]=max.y;array[17]=object.z;array[18]=object.x;array[19]=object.y;array[20]=object.z;array[21]=max.x;array[22]=object.y;array[23]=object.z;position.needsUpdate=!0;this.geometry.computeBoundingSphere()}}setFromObject(object){this.object=object;this.update();return this}copy(source,recursive){super.copy(source,recursive);this.object=source.object;return this}dispose(){this.geometry.dispose();
this.material.dispose()}}class Box3Helper extends LineSegments{constructor(box,color=16776960){const indices=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),geometry=new BufferGeometry;geometry.setIndex(new BufferAttribute(indices,1));geometry.setAttribute("position",new Float32BufferAttribute([1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],3));super(geometry,new LineBasicMaterial({color,toneMapped:!1}));this.box=box;this.type="Box3Helper";this.geometry.computeBoundingSphere()}updateMatrixWorld(force){const box=
this.box;box.isEmpty()||(box.getCenter(this.position),box.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(force))}dispose(){this.geometry.dispose();this.material.dispose()}}class PlaneHelper extends Line{constructor(plane,size=1,hex=16776960){const geometry=new BufferGeometry;geometry.setAttribute("position",new Float32BufferAttribute([1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],3));geometry.computeBoundingSphere();super(geometry,new LineBasicMaterial({color:hex,
toneMapped:!1}));this.type="PlaneHelper";this.plane=plane;this.size=size;plane=new BufferGeometry;plane.setAttribute("position",new Float32BufferAttribute([1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],3));plane.computeBoundingSphere();this.add(new Mesh(plane,new MeshBasicMaterial({color:hex,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(force){this.position.set(0,0,0);this.scale.set(.5*this.size,.5*this.size,1);this.lookAt(this.plane.normal);this.translateZ(-this.plane.constant);
super.updateMatrixWorld(force)}dispose(){this.geometry.dispose();this.material.dispose();this.children[0].geometry.dispose();this.children[0].material.dispose()}}const _axis=new Vector3;let _lineGeometry,_coneGeometry;class ArrowHelper extends Object3D{constructor(dir=new Vector3(0,0,1),origin=new Vector3(0,0,0),length=1,color=16776960,headLength=.2*length,headWidth=.2*headLength){super();this.type="ArrowHelper";void 0===_lineGeometry&&(_lineGeometry=new BufferGeometry,_lineGeometry.setAttribute("position",
new Float32BufferAttribute([0,0,0,0,1,0],3)),_coneGeometry=new CylinderGeometry(0,.5,1,5,1),_coneGeometry.translate(0,-.5,0));this.position.copy(origin);this.line=new Line(_lineGeometry,new LineBasicMaterial({color,toneMapped:!1}));this.line.matrixAutoUpdate=!1;this.add(this.line);this.cone=new Mesh(_coneGeometry,new MeshBasicMaterial({color,toneMapped:!1}));this.cone.matrixAutoUpdate=!1;this.add(this.cone);this.setDirection(dir);this.setLength(length,headLength,headWidth)}setDirection(dir){.99999<
dir.y?this.quaternion.set(0,0,0,1):-.99999>dir.y?this.quaternion.set(1,0,0,0):(_axis.set(dir.z,0,-dir.x).normalize(),this.quaternion.setFromAxisAngle(_axis,Math.acos(dir.y)))}setLength(length,headLength=.2*length,headWidth=.2*headLength){this.line.scale.set(1,Math.max(1E-4,length-headLength),1);this.line.updateMatrix();this.cone.scale.set(headWidth,headLength,headWidth);this.cone.position.y=length;this.cone.updateMatrix()}setColor(color){this.line.material.color.set(color);this.cone.material.color.set(color)}copy(source){super.copy(source,
!1);this.line.copy(source.line);this.cone.copy(source.cone);return this}dispose(){this.line.geometry.dispose();this.line.material.dispose();this.cone.geometry.dispose();this.cone.material.dispose()}}class AxesHelper extends LineSegments{constructor(size=1){var vertices=[0,0,0,size,0,0,0,0,0,0,size,0,0,0,0,0,0,size];size=new BufferGeometry;size.setAttribute("position",new Float32BufferAttribute(vertices,3));size.setAttribute("color",new Float32BufferAttribute([1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,
1],3));vertices=new LineBasicMaterial({vertexColors:!0,toneMapped:!1});super(size,vertices);this.type="AxesHelper"}setColors(xAxisColor,yAxisColor,zAxisColor){const color=new Color,array=this.geometry.attributes.color.array;color.set(xAxisColor);color.toArray(array,0);color.toArray(array,3);color.set(yAxisColor);color.toArray(array,6);color.toArray(array,9);color.set(zAxisColor);color.toArray(array,12);color.toArray(array,15);this.geometry.attributes.color.needsUpdate=!0;return this}dispose(){this.geometry.dispose();
this.material.dispose()}}class ShapePath{constructor(){this.type="ShapePath";this.color=new Color;this.subPaths=[];this.currentPath=null}moveTo(x,y){this.currentPath=new Path;this.subPaths.push(this.currentPath);this.currentPath.moveTo(x,y);return this}lineTo(x,y){this.currentPath.lineTo(x,y);return this}quadraticCurveTo(aCPx,aCPy,aX,aY){this.currentPath.quadraticCurveTo(aCPx,aCPy,aX,aY);return this}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){this.currentPath.bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,
aX,aY);return this}splineThru(pts){this.currentPath.splineThru(pts);return this}toShapes(isCCW){function toShapesNoHoles(inSubpaths){const shapes=[];for(let i=0,l=inSubpaths.length;i<l;i++){const tmpPath=inSubpaths[i],tmpShape=new Shape;tmpShape.curves=tmpPath.curves;shapes.push(tmpShape)}return shapes}function isPointInsidePolygon(inPt,inPolygon){const polyLen=inPolygon.length;let inside=!1;for(let p=polyLen-1,q=0;q<polyLen;p=q++){var edgeLowPt=inPolygon[p];let edgeHighPt=inPolygon[q],edgeDx=edgeHighPt.x-
edgeLowPt.x,edgeDy=edgeHighPt.y-edgeLowPt.y;if(Math.abs(edgeDy)>Number.EPSILON){if(0>edgeDy&&(edgeLowPt=inPolygon[q],edgeDx=-edgeDx,edgeHighPt=inPolygon[p],edgeDy=-edgeDy),!(inPt.y<edgeLowPt.y||inPt.y>edgeHighPt.y))if(inPt.y===edgeLowPt.y){if(inPt.x===edgeLowPt.x)return!0}else{edgeLowPt=edgeDy*(inPt.x-edgeLowPt.x)-edgeDx*(inPt.y-edgeLowPt.y);if(0===edgeLowPt)return!0;0>edgeLowPt||(inside=!inside)}}else if(inPt.y===edgeLowPt.y&&(edgeHighPt.x<=inPt.x&&inPt.x<=edgeLowPt.x||edgeLowPt.x<=inPt.x&&inPt.x<=
edgeHighPt.x))return!0}return inside}var isClockWise=ShapeUtils.isClockWise,subPaths=this.subPaths;if(0===subPaths.length)return[];const shapes$jscomp$0=[];if(1===subPaths.length){var tmpPath=subPaths[0];var tmpShape=new Shape;tmpShape.curves=tmpPath.curves;shapes$jscomp$0.push(tmpShape);return shapes$jscomp$0}var holesFirst=!isClockWise(subPaths[0].getPoints());holesFirst=isCCW?!holesFirst:holesFirst;tmpShape=[];const newShapes=[];let newShapeHoles=[];var mainIdx=0;let tmpPoints;newShapes[mainIdx]=
void 0;newShapeHoles[mainIdx]=[];for(let i=0,l=subPaths.length;i<l;i++){tmpPath=subPaths[i];tmpPoints=tmpPath.getPoints();var solid=isClockWise(tmpPoints);(solid=isCCW?!solid:solid)?(!holesFirst&&newShapes[mainIdx]&&mainIdx++,newShapes[mainIdx]={s:new Shape,p:tmpPoints},newShapes[mainIdx].s.curves=tmpPath.curves,holesFirst&&mainIdx++,newShapeHoles[mainIdx]=[]):newShapeHoles[mainIdx].push({h:tmpPath,p:tmpPoints[0]})}if(!newShapes[0])return toShapesNoHoles(subPaths);if(1<newShapes.length){tmpPath=!1;
isCCW=0;for(let sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++)tmpShape[sIdx]=[];for(let sIdx=0,sLen=newShapes.length;sIdx<sLen;sIdx++)for(isClockWise=newShapeHoles[sIdx],subPaths=0;subPaths<isClockWise.length;subPaths++){solid=isClockWise[subPaths];holesFirst=!0;for(mainIdx=0;mainIdx<newShapes.length;mainIdx++)isPointInsidePolygon(solid.p,newShapes[mainIdx].p)&&(sIdx!==mainIdx&&isCCW++,holesFirst?(holesFirst=!1,tmpShape[mainIdx].push(solid)):tmpPath=!0);holesFirst&&tmpShape[sIdx].push(solid)}0<isCCW&&
!1===tmpPath&&(newShapeHoles=tmpShape)}for(let i=0,il=newShapes.length;i<il;i++){tmpShape=newShapes[i].s;shapes$jscomp$0.push(tmpShape);tmpPath=newShapeHoles[i];for(let j=0,jl=tmpPath.length;j<jl;j++)tmpShape.holes.push(tmpPath[j].h)}return shapes$jscomp$0}}const _tables=function(){var buffer=new ArrayBuffer(4);const floatView=new Float32Array(buffer);buffer=new Uint32Array(buffer);const baseTable=new Uint32Array(512),shiftTable=new Uint32Array(512);for(var i=0;256>i;++i){var e$jscomp$0=i-127;-27>
e$jscomp$0?(baseTable[i]=0,baseTable[i|256]=32768,shiftTable[i]=24,shiftTable[i|256]=24):-14>e$jscomp$0?(baseTable[i]=1024>>-e$jscomp$0-14,baseTable[i|256]=1024>>-e$jscomp$0-14|32768,shiftTable[i]=-e$jscomp$0-1,shiftTable[i|256]=-e$jscomp$0-1):15>=e$jscomp$0?(baseTable[i]=e$jscomp$0+15<<10,baseTable[i|256]=e$jscomp$0+15<<10|32768,shiftTable[i]=13,shiftTable[i|256]=13):128>e$jscomp$0?(baseTable[i]=31744,baseTable[i|256]=64512,shiftTable[i]=24,shiftTable[i|256]=24):(baseTable[i]=31744,baseTable[i|256]=
64512,shiftTable[i]=13,shiftTable[i|256]=13)}i=new Uint32Array(2048);e$jscomp$0=new Uint32Array(64);const offsetTable=new Uint32Array(64);for(var i$jscomp$0=1;1024>i$jscomp$0;++i$jscomp$0){let m=i$jscomp$0<<13,e=0;for(;0===(m&8388608);)m<<=1,e-=8388608;m&=-8388609;e+=947912704;i[i$jscomp$0]=m|e}for(i$jscomp$0=1024;2048>i$jscomp$0;++i$jscomp$0)i[i$jscomp$0]=939524096+(i$jscomp$0-1024<<13);for(i$jscomp$0=1;31>i$jscomp$0;++i$jscomp$0)e$jscomp$0[i$jscomp$0]=i$jscomp$0<<23;e$jscomp$0[31]=1199570944;e$jscomp$0[32]=
2147483648;for(i$jscomp$0=33;63>i$jscomp$0;++i$jscomp$0)e$jscomp$0[i$jscomp$0]=2147483648+(i$jscomp$0-32<<23);e$jscomp$0[63]=3347054592;for(i$jscomp$0=1;64>i$jscomp$0;++i$jscomp$0)32!==i$jscomp$0&&(offsetTable[i$jscomp$0]=1024);return{floatView,uint32View:buffer,baseTable,shiftTable,mantissaTable:i,exponentTable:e$jscomp$0,offsetTable}}();var DataUtils=Object.freeze({__proto__:null,toHalfFloat:function(val){65504<Math.abs(val)&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range.");val=
clamp(val,-65504,65504);_tables.floatView[0]=val;val=_tables.uint32View[0];const e=val>>23&511;return _tables.baseTable[e]+((val&8388607)>>_tables.shiftTable[e])},fromHalfFloat:function(val){const m=val>>10;_tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[m]+(val&1023)]+_tables.exponentTable[m];return _tables.floatView[0]}});class WebGLMultisampleRenderTarget extends WebGLRenderTarget{constructor(width,height,options){console.error('THREE.WebGLMultisampleRenderTarget has been removed. Use a normal render target and set the "samples" property to greater 0 to enable multisampling.');
super(width,height,options);this.samples=4}}class DataTexture2DArray extends DataArrayTexture{constructor(data,width,height,depth){console.warn("THREE.DataTexture2DArray has been renamed to DataArrayTexture.");super(data,width,height,depth)}}class DataTexture3D extends Data3DTexture{constructor(data,width,height,depth){console.warn("THREE.DataTexture3D has been renamed to Data3DTexture.");super(data,width,height,depth)}}class BoxBufferGeometry extends BoxGeometry{constructor(width,height,depth,widthSegments,
heightSegments,depthSegments){console.warn("THREE.BoxBufferGeometry has been renamed to THREE.BoxGeometry.");super(width,height,depth,widthSegments,heightSegments,depthSegments)}}class CapsuleBufferGeometry extends CapsuleGeometry{constructor(radius,length,capSegments,radialSegments){console.warn("THREE.CapsuleBufferGeometry has been renamed to THREE.CapsuleGeometry.");super(radius,length,capSegments,radialSegments)}}class CircleBufferGeometry extends CircleGeometry{constructor(radius,segments,thetaStart,
thetaLength){console.warn("THREE.CircleBufferGeometry has been renamed to THREE.CircleGeometry.");super(radius,segments,thetaStart,thetaLength)}}class ConeBufferGeometry extends ConeGeometry{constructor(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){console.warn("THREE.ConeBufferGeometry has been renamed to THREE.ConeGeometry.");super(radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength)}}class CylinderBufferGeometry extends CylinderGeometry{constructor(radiusTop,
radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength){console.warn("THREE.CylinderBufferGeometry has been renamed to THREE.CylinderGeometry.");super(radiusTop,radiusBottom,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength)}}class DodecahedronBufferGeometry extends DodecahedronGeometry{constructor(radius,detail){console.warn("THREE.DodecahedronBufferGeometry has been renamed to THREE.DodecahedronGeometry.");super(radius,detail)}}class ExtrudeBufferGeometry extends ExtrudeGeometry{constructor(shapes,
options){console.warn("THREE.ExtrudeBufferGeometry has been renamed to THREE.ExtrudeGeometry.");super(shapes,options)}}class IcosahedronBufferGeometry extends IcosahedronGeometry{constructor(radius,detail){console.warn("THREE.IcosahedronBufferGeometry has been renamed to THREE.IcosahedronGeometry.");super(radius,detail)}}class LatheBufferGeometry extends LatheGeometry{constructor(points,segments,phiStart,phiLength){console.warn("THREE.LatheBufferGeometry has been renamed to THREE.LatheGeometry.");
super(points,segments,phiStart,phiLength)}}class OctahedronBufferGeometry extends OctahedronGeometry{constructor(radius,detail){console.warn("THREE.OctahedronBufferGeometry has been renamed to THREE.OctahedronGeometry.");super(radius,detail)}}class PlaneBufferGeometry extends PlaneGeometry{constructor(width,height,widthSegments,heightSegments){console.warn("THREE.PlaneBufferGeometry has been renamed to THREE.PlaneGeometry.");super(width,height,widthSegments,heightSegments)}}class PolyhedronBufferGeometry extends PolyhedronGeometry{constructor(vertices,
indices,radius,detail){console.warn("THREE.PolyhedronBufferGeometry has been renamed to THREE.PolyhedronGeometry.");super(vertices,indices,radius,detail)}}class RingBufferGeometry extends RingGeometry{constructor(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength){console.warn("THREE.RingBufferGeometry has been renamed to THREE.RingGeometry.");super(innerRadius,outerRadius,thetaSegments,phiSegments,thetaStart,thetaLength)}}class ShapeBufferGeometry extends ShapeGeometry{constructor(shapes,
curveSegments){console.warn("THREE.ShapeBufferGeometry has been renamed to THREE.ShapeGeometry.");super(shapes,curveSegments)}}class SphereBufferGeometry extends SphereGeometry{constructor(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength){console.warn("THREE.SphereBufferGeometry has been renamed to THREE.SphereGeometry.");super(radius,widthSegments,heightSegments,phiStart,phiLength,thetaStart,thetaLength)}}class TetrahedronBufferGeometry extends TetrahedronGeometry{constructor(radius,
detail){console.warn("THREE.TetrahedronBufferGeometry has been renamed to THREE.TetrahedronGeometry.");super(radius,detail)}}class TorusBufferGeometry extends TorusGeometry{constructor(radius,tube,radialSegments,tubularSegments,arc){console.warn("THREE.TorusBufferGeometry has been renamed to THREE.TorusGeometry.");super(radius,tube,radialSegments,tubularSegments,arc)}}class TorusKnotBufferGeometry extends TorusKnotGeometry{constructor(radius,tube,tubularSegments,radialSegments,p,q){console.warn("THREE.TorusKnotBufferGeometry has been renamed to THREE.TorusKnotGeometry.");
super(radius,tube,tubularSegments,radialSegments,p,q)}}class TubeBufferGeometry extends TubeGeometry{constructor(path,tubularSegments,radius,radialSegments,closed){console.warn("THREE.TubeBufferGeometry has been renamed to THREE.TubeGeometry.");super(path,tubularSegments,radius,radialSegments,closed)}}"undefined"!==typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"146"}}));"undefined"!==typeof window&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):
window.__THREE__="146");exports.ACESFilmicToneMapping=4;exports.AddEquation=100;exports.AddOperation=2;exports.AdditiveAnimationBlendMode=2501;exports.AdditiveBlending=2;exports.AlphaFormat=1021;exports.AlwaysDepth=1;exports.AlwaysStencilFunc=519;exports.AmbientLight=AmbientLight;exports.AmbientLightProbe=AmbientLightProbe;exports.AnimationClip=AnimationClip;exports.AnimationLoader=AnimationLoader;exports.AnimationMixer=AnimationMixer;exports.AnimationObjectGroup=AnimationObjectGroup;exports.AnimationUtils=
AnimationUtils;exports.ArcCurve=ArcCurve;exports.ArrayCamera=ArrayCamera;exports.ArrowHelper=ArrowHelper;exports.Audio=Audio;exports.AudioAnalyser=AudioAnalyser;exports.AudioContext=AudioContext;exports.AudioListener=AudioListener;exports.AudioLoader=AudioLoader;exports.AxesHelper=AxesHelper;exports.BackSide=1;exports.BasicDepthPacking=3200;exports.BasicShadowMap=0;exports.Bone=Bone;exports.BooleanKeyframeTrack=BooleanKeyframeTrack;exports.Box2=Box2;exports.Box3=Box3;exports.Box3Helper=Box3Helper;
exports.BoxBufferGeometry=BoxBufferGeometry;exports.BoxGeometry=BoxGeometry;exports.BoxHelper=BoxHelper;exports.BufferAttribute=BufferAttribute;exports.BufferGeometry=BufferGeometry;exports.BufferGeometryLoader=BufferGeometryLoader;exports.ByteType=1010;exports.Cache=Cache;exports.Camera=Camera;exports.CameraHelper=CameraHelper;exports.CanvasTexture=CanvasTexture;exports.CapsuleBufferGeometry=CapsuleBufferGeometry;exports.CapsuleGeometry=CapsuleGeometry;exports.CatmullRomCurve3=CatmullRomCurve3;exports.CineonToneMapping=
3;exports.CircleBufferGeometry=CircleBufferGeometry;exports.CircleGeometry=CircleGeometry;exports.ClampToEdgeWrapping=1001;exports.Clock=Clock;exports.Color=Color;exports.ColorKeyframeTrack=ColorKeyframeTrack;exports.ColorManagement=ColorManagement;exports.CompressedArrayTexture=CompressedArrayTexture;exports.CompressedTexture=CompressedTexture;exports.CompressedTextureLoader=CompressedTextureLoader;exports.ConeBufferGeometry=ConeBufferGeometry;exports.ConeGeometry=ConeGeometry;exports.CubeCamera=
CubeCamera;exports.CubeReflectionMapping=301;exports.CubeRefractionMapping=302;exports.CubeTexture=CubeTexture;exports.CubeTextureLoader=CubeTextureLoader;exports.CubeUVReflectionMapping=306;exports.CubicBezierCurve=CubicBezierCurve;exports.CubicBezierCurve3=CubicBezierCurve3;exports.CubicInterpolant=CubicInterpolant;exports.CullFaceBack=1;exports.CullFaceFront=2;exports.CullFaceFrontBack=3;exports.CullFaceNone=0;exports.Curve=Curve;exports.CurvePath=CurvePath;exports.CustomBlending=5;exports.CustomToneMapping=
5;exports.CylinderBufferGeometry=CylinderBufferGeometry;exports.CylinderGeometry=CylinderGeometry;exports.Cylindrical=Cylindrical;exports.Data3DTexture=Data3DTexture;exports.DataArrayTexture=DataArrayTexture;exports.DataTexture=DataTexture;exports.DataTexture2DArray=DataTexture2DArray;exports.DataTexture3D=DataTexture3D;exports.DataTextureLoader=DataTextureLoader;exports.DataUtils=DataUtils;exports.DecrementStencilOp=7683;exports.DecrementWrapStencilOp=34056;exports.DefaultLoadingManager=DefaultLoadingManager;
exports.DepthFormat=1026;exports.DepthStencilFormat=1027;exports.DepthTexture=DepthTexture;exports.DirectionalLight=DirectionalLight;exports.DirectionalLightHelper=DirectionalLightHelper;exports.DiscreteInterpolant=DiscreteInterpolant;exports.DodecahedronBufferGeometry=DodecahedronBufferGeometry;exports.DodecahedronGeometry=DodecahedronGeometry;exports.DoubleSide=2;exports.DstAlphaFactor=206;exports.DstColorFactor=208;exports.DynamicCopyUsage=35050;exports.DynamicDrawUsage=35048;exports.DynamicReadUsage=
35049;exports.EdgesGeometry=EdgesGeometry;exports.EllipseCurve=EllipseCurve;exports.EqualDepth=4;exports.EqualStencilFunc=514;exports.EquirectangularReflectionMapping=303;exports.EquirectangularRefractionMapping=304;exports.Euler=Euler;exports.EventDispatcher=EventDispatcher;exports.ExtrudeBufferGeometry=ExtrudeBufferGeometry;exports.ExtrudeGeometry=ExtrudeGeometry;exports.FileLoader=FileLoader;exports.Float16BufferAttribute=Float16BufferAttribute;exports.Float32BufferAttribute=Float32BufferAttribute;
exports.Float64BufferAttribute=Float64BufferAttribute;exports.FloatType=1015;exports.Fog=Fog;exports.FogExp2=FogExp2;exports.FramebufferTexture=FramebufferTexture;exports.FrontSide=0;exports.Frustum=Frustum;exports.GLBufferAttribute=GLBufferAttribute;exports.GLSL1="100";exports.GLSL3="300 es";exports.GreaterDepth=6;exports.GreaterEqualDepth=5;exports.GreaterEqualStencilFunc=518;exports.GreaterStencilFunc=516;exports.GridHelper=GridHelper;exports.Group=Group;exports.HalfFloatType=1016;exports.HemisphereLight=
HemisphereLight;exports.HemisphereLightHelper=HemisphereLightHelper;exports.HemisphereLightProbe=HemisphereLightProbe;exports.IcosahedronBufferGeometry=IcosahedronBufferGeometry;exports.IcosahedronGeometry=IcosahedronGeometry;exports.ImageBitmapLoader=ImageBitmapLoader;exports.ImageLoader=ImageLoader;exports.ImageUtils=ImageUtils;exports.ImmediateRenderObject=function(){console.error("THREE.ImmediateRenderObject has been removed.")};exports.IncrementStencilOp=7682;exports.IncrementWrapStencilOp=34055;
exports.InstancedBufferAttribute=InstancedBufferAttribute;exports.InstancedBufferGeometry=InstancedBufferGeometry;exports.InstancedInterleavedBuffer=InstancedInterleavedBuffer;exports.InstancedMesh=InstancedMesh;exports.Int16BufferAttribute=Int16BufferAttribute;exports.Int32BufferAttribute=Int32BufferAttribute;exports.Int8BufferAttribute=Int8BufferAttribute;exports.IntType=1013;exports.InterleavedBuffer=InterleavedBuffer;exports.InterleavedBufferAttribute=InterleavedBufferAttribute;exports.Interpolant=
Interpolant;exports.InterpolateDiscrete=2300;exports.InterpolateLinear=2301;exports.InterpolateSmooth=2302;exports.InvertStencilOp=5386;exports.KeepStencilOp=7680;exports.KeyframeTrack=KeyframeTrack;exports.LOD=LOD;exports.LatheBufferGeometry=LatheBufferGeometry;exports.LatheGeometry=LatheGeometry;exports.Layers=Layers;exports.LessDepth=2;exports.LessEqualDepth=3;exports.LessEqualStencilFunc=515;exports.LessStencilFunc=513;exports.Light=Light;exports.LightProbe=LightProbe;exports.Line=Line;exports.Line3=
Line3;exports.LineBasicMaterial=LineBasicMaterial;exports.LineCurve=LineCurve;exports.LineCurve3=LineCurve3;exports.LineDashedMaterial=LineDashedMaterial;exports.LineLoop=LineLoop;exports.LineSegments=LineSegments;exports.LinearEncoding=3E3;exports.LinearFilter=1006;exports.LinearInterpolant=LinearInterpolant;exports.LinearMipMapLinearFilter=1008;exports.LinearMipMapNearestFilter=1007;exports.LinearMipmapLinearFilter=1008;exports.LinearMipmapNearestFilter=1007;exports.LinearSRGBColorSpace="srgb-linear";
exports.LinearToneMapping=1;exports.Loader=Loader;exports.LoaderUtils=LoaderUtils;exports.LoadingManager=LoadingManager;exports.LoopOnce=2200;exports.LoopPingPong=2202;exports.LoopRepeat=2201;exports.LuminanceAlphaFormat=1025;exports.LuminanceFormat=1024;exports.MOUSE={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2};exports.Material=Material;exports.MaterialLoader=MaterialLoader;exports.MathUtils=MathUtils;exports.Matrix3=Matrix3;exports.Matrix4=Matrix4;exports.MaxEquation=104;exports.Mesh=Mesh;exports.MeshBasicMaterial=
MeshBasicMaterial;exports.MeshDepthMaterial=MeshDepthMaterial;exports.MeshDistanceMaterial=MeshDistanceMaterial;exports.MeshLambertMaterial=MeshLambertMaterial;exports.MeshMatcapMaterial=MeshMatcapMaterial;exports.MeshNormalMaterial=MeshNormalMaterial;exports.MeshPhongMaterial=MeshPhongMaterial;exports.MeshPhysicalMaterial=MeshPhysicalMaterial;exports.MeshStandardMaterial=MeshStandardMaterial;exports.MeshToonMaterial=MeshToonMaterial;exports.MinEquation=103;exports.MirroredRepeatWrapping=1002;exports.MixOperation=
1;exports.MultiplyBlending=4;exports.MultiplyOperation=0;exports.NearestFilter=1003;exports.NearestMipMapLinearFilter=1005;exports.NearestMipMapNearestFilter=1004;exports.NearestMipmapLinearFilter=1005;exports.NearestMipmapNearestFilter=1004;exports.NeverDepth=0;exports.NeverStencilFunc=512;exports.NoBlending=0;exports.NoColorSpace="";exports.NoToneMapping=0;exports.NormalAnimationBlendMode=2500;exports.NormalBlending=1;exports.NotEqualDepth=7;exports.NotEqualStencilFunc=517;exports.NumberKeyframeTrack=
NumberKeyframeTrack;exports.Object3D=Object3D;exports.ObjectLoader=ObjectLoader;exports.ObjectSpaceNormalMap=1;exports.OctahedronBufferGeometry=OctahedronBufferGeometry;exports.OctahedronGeometry=OctahedronGeometry;exports.OneFactor=201;exports.OneMinusDstAlphaFactor=207;exports.OneMinusDstColorFactor=209;exports.OneMinusSrcAlphaFactor=205;exports.OneMinusSrcColorFactor=203;exports.OrthographicCamera=OrthographicCamera;exports.PCFShadowMap=1;exports.PCFSoftShadowMap=2;exports.PMREMGenerator=PMREMGenerator;
exports.Path=Path;exports.PerspectiveCamera=PerspectiveCamera;exports.Plane=Plane;exports.PlaneBufferGeometry=PlaneBufferGeometry;exports.PlaneGeometry=PlaneGeometry;exports.PlaneHelper=PlaneHelper;exports.PointLight=PointLight;exports.PointLightHelper=PointLightHelper;exports.Points=Points;exports.PointsMaterial=PointsMaterial;exports.PolarGridHelper=PolarGridHelper;exports.PolyhedronBufferGeometry=PolyhedronBufferGeometry;exports.PolyhedronGeometry=PolyhedronGeometry;exports.PositionalAudio=PositionalAudio;
exports.PropertyBinding=PropertyBinding;exports.PropertyMixer=PropertyMixer;exports.QuadraticBezierCurve=QuadraticBezierCurve;exports.QuadraticBezierCurve3=QuadraticBezierCurve3;exports.Quaternion=Quaternion;exports.QuaternionKeyframeTrack=QuaternionKeyframeTrack;exports.QuaternionLinearInterpolant=QuaternionLinearInterpolant;exports.REVISION="146";exports.RGBADepthPacking=3201;exports.RGBAFormat=1023;exports.RGBAIntegerFormat=1033;exports.RGBA_ASTC_10x10_Format=37819;exports.RGBA_ASTC_10x5_Format=
37816;exports.RGBA_ASTC_10x6_Format=37817;exports.RGBA_ASTC_10x8_Format=37818;exports.RGBA_ASTC_12x10_Format=37820;exports.RGBA_ASTC_12x12_Format=37821;exports.RGBA_ASTC_4x4_Format=37808;exports.RGBA_ASTC_5x4_Format=37809;exports.RGBA_ASTC_5x5_Format=37810;exports.RGBA_ASTC_6x5_Format=37811;exports.RGBA_ASTC_6x6_Format=37812;exports.RGBA_ASTC_8x5_Format=37813;exports.RGBA_ASTC_8x6_Format=37814;exports.RGBA_ASTC_8x8_Format=37815;exports.RGBA_BPTC_Format=36492;exports.RGBA_ETC2_EAC_Format=37496;exports.RGBA_PVRTC_2BPPV1_Format=
35843;exports.RGBA_PVRTC_4BPPV1_Format=35842;exports.RGBA_S3TC_DXT1_Format=33777;exports.RGBA_S3TC_DXT3_Format=33778;exports.RGBA_S3TC_DXT5_Format=33779;exports.RGBFormat=1022;exports.RGB_ETC1_Format=36196;exports.RGB_ETC2_Format=37492;exports.RGB_PVRTC_2BPPV1_Format=35841;exports.RGB_PVRTC_4BPPV1_Format=35840;exports.RGB_S3TC_DXT1_Format=33776;exports.RGFormat=1030;exports.RGIntegerFormat=1031;exports.RawShaderMaterial=RawShaderMaterial;exports.Ray=Ray;exports.Raycaster=Raycaster;exports.RectAreaLight=
RectAreaLight;exports.RedFormat=1028;exports.RedIntegerFormat=1029;exports.ReinhardToneMapping=2;exports.RepeatWrapping=1E3;exports.ReplaceStencilOp=7681;exports.ReverseSubtractEquation=102;exports.RingBufferGeometry=RingBufferGeometry;exports.RingGeometry=RingGeometry;exports.SRGBColorSpace="srgb";exports.Scene=Scene;exports.ShaderChunk=ShaderChunk;exports.ShaderLib=ShaderLib;exports.ShaderMaterial=ShaderMaterial;exports.ShadowMaterial=ShadowMaterial;exports.Shape=Shape;exports.ShapeBufferGeometry=
ShapeBufferGeometry;exports.ShapeGeometry=ShapeGeometry;exports.ShapePath=ShapePath;exports.ShapeUtils=ShapeUtils;exports.ShortType=1011;exports.Skeleton=Skeleton;exports.SkeletonHelper=SkeletonHelper;exports.SkinnedMesh=SkinnedMesh;exports.Source=Source;exports.Sphere=Sphere;exports.SphereBufferGeometry=SphereBufferGeometry;exports.SphereGeometry=SphereGeometry;exports.Spherical=Spherical;exports.SphericalHarmonics3=SphericalHarmonics3;exports.SplineCurve=SplineCurve;exports.SpotLight=SpotLight;
exports.SpotLightHelper=SpotLightHelper;exports.Sprite=Sprite;exports.SpriteMaterial=SpriteMaterial;exports.SrcAlphaFactor=204;exports.SrcAlphaSaturateFactor=210;exports.SrcColorFactor=202;exports.StaticCopyUsage=35046;exports.StaticDrawUsage=35044;exports.StaticReadUsage=35045;exports.StereoCamera=StereoCamera;exports.StreamCopyUsage=35042;exports.StreamDrawUsage=35040;exports.StreamReadUsage=35041;exports.StringKeyframeTrack=StringKeyframeTrack;exports.SubtractEquation=101;exports.SubtractiveBlending=
3;exports.TOUCH={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3};exports.TangentSpaceNormalMap=0;exports.TetrahedronBufferGeometry=TetrahedronBufferGeometry;exports.TetrahedronGeometry=TetrahedronGeometry;exports.Texture=Texture;exports.TextureLoader=TextureLoader;exports.TorusBufferGeometry=TorusBufferGeometry;exports.TorusGeometry=TorusGeometry;exports.TorusKnotBufferGeometry=TorusKnotBufferGeometry;exports.TorusKnotGeometry=TorusKnotGeometry;exports.Triangle=Triangle;exports.TriangleFanDrawMode=2;exports.TriangleStripDrawMode=
1;exports.TrianglesDrawMode=0;exports.TubeBufferGeometry=TubeBufferGeometry;exports.TubeGeometry=TubeGeometry;exports.UVMapping=300;exports.Uint16BufferAttribute=Uint16BufferAttribute;exports.Uint32BufferAttribute=Uint32BufferAttribute;exports.Uint8BufferAttribute=Uint8BufferAttribute;exports.Uint8ClampedBufferAttribute=Uint8ClampedBufferAttribute;exports.Uniform=Uniform;exports.UniformsGroup=UniformsGroup;exports.UniformsLib=UniformsLib;exports.UniformsUtils=UniformsUtils;exports.UnsignedByteType=
1009;exports.UnsignedInt248Type=1020;exports.UnsignedIntType=1014;exports.UnsignedShort4444Type=1017;exports.UnsignedShort5551Type=1018;exports.UnsignedShortType=1012;exports.VSMShadowMap=3;exports.Vector2=Vector2;exports.Vector3=Vector3;exports.Vector4=Vector4;exports.VectorKeyframeTrack=VectorKeyframeTrack;exports.VideoTexture=VideoTexture;exports.WebGL1Renderer=WebGL1Renderer;exports.WebGL3DRenderTarget=WebGL3DRenderTarget;exports.WebGLArrayRenderTarget=WebGLArrayRenderTarget;exports.WebGLCubeRenderTarget=
WebGLCubeRenderTarget;exports.WebGLMultipleRenderTargets=WebGLMultipleRenderTargets;exports.WebGLMultisampleRenderTarget=WebGLMultisampleRenderTarget;exports.WebGLRenderTarget=WebGLRenderTarget;exports.WebGLRenderer=WebGLRenderer;exports.WebGLUtils=WebGLUtils;exports.WireframeGeometry=WireframeGeometry;exports.WrapAroundEnding=2402;exports.ZeroCurvatureEnding=2400;exports.ZeroFactor=200;exports.ZeroSlopeEnding=2401;exports.ZeroStencilOp=0;exports._SRGBAFormat=1035;exports.sRGBEncoding=3001;Object.defineProperty(exports,
"__esModule",{value:!0})})}
//# sourceMappingURL=module$node_modules$three$build$three.js.map
