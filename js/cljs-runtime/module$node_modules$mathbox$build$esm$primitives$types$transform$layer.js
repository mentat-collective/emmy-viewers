shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$transform$layer=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Layer=void 0;global=require("module$node_modules$mathbox$build$esm$primitives$types$transform$transform");class Layer extends global.Transform{static initClass(){this.traits=["node","vertex","layer"]}make(){this._listen("root","root.resize",this.update);return this.uniforms={layerScale:this._attributes.make(this._types.vec4()),
layerBias:this._attributes.make(this._types.vec4())}}update(){var camera=this._inherit("root").getCamera();const aspect=null!=camera.aspect?camera.aspect:1;camera=Math.tan((null!=camera.fov?camera.fov:1)*Math.PI/360);const _enum=this.node.attributes["layer.fit"].enum;let {fit}=this.props;const {depth}=this.props;switch(fit){case _enum.contain:fit=1<aspect?_enum.y:_enum.x;break;case _enum.cover:fit=1<aspect?_enum.x:_enum.y}switch(fit){case _enum.x:this.uniforms.layerScale.value.set(camera*aspect,camera*
aspect,1,1);break;case _enum.y:this.uniforms.layerScale.value.set(camera,camera,1,1)}return this.uniforms.layerBias.value.set(0,0,-depth,0)}change(changed,touched,init){if(changed["layer.fit"]||changed["layer.depth"]||init)return this.update()}vertex(shader,pass){return 2===pass?shader.pipe("layer.position",this.uniforms):3===pass?shader.pipe("root.position"):shader}}exports.Layer=Layer;Layer.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$transform$layer.js.map
