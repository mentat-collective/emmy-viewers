shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderLib$backgroundCube_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.vertex="\nvarying vec3 vWorldDirection;\n\n#include \x3ccommon\x3e\n\nvoid main() {\n\n\tvWorldDirection \x3d transformDirection( position, modelMatrix );\n\n\t#include \x3cbegin_vertex\x3e\n\t#include \x3cproject_vertex\x3e\n\n\tgl_Position.z \x3d gl_Position.w; // set z to camera.far\n\n}\n";exports.fragment=
"\n\n#ifdef ENVMAP_TYPE_CUBE\n\n\tuniform samplerCube envMap;\n\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\tuniform sampler2D envMap;\n\n#endif\n\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\n\nvarying vec3 vWorldDirection;\n\n#include \x3ccube_uv_reflection_fragment\x3e\n\nvoid main() {\n\n\t#ifdef ENVMAP_TYPE_CUBE\n\n\t\tvec4 texColor \x3d textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\n\t\tvec4 texColor \x3d textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\n\t#else\n\n\t\tvec4 texColor \x3d vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t#endif\n\n\tgl_FragColor \x3d texColor;\n\n\t#include \x3ctonemapping_fragment\x3e\n\t#include \x3cencodings_fragment\x3e\n\n}\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderLib$backgroundCube_glsl.js.map
