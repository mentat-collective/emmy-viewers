shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$present$play=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Play=void 0;global=require("module$node_modules$mathbox$build$esm$primitives$types$present$track");class Play extends global.Track{static initClass(){this.traits=["node","track","trigger","play","bind"]}init(){super.init();return this.start=this.skew=null}reset(go){null==go&&(go=!0);this.skew=go?0:null;return this.start=
null}make(){super.make();this._listen("slide","slide.step",e=>{const {trigger}=this.props;if(null!=trigger&&e.index===trigger)return this.reset();if(null!=trigger&&0===e.index)return this.reset(!1)});this.props.trigger&&null!=this._inherit("slide")||this.reset();const parentClock=this._inherit("clock");return this._listen(parentClock,"clock.tick",()=>{const {from,to,speed,pace,delay,realtime}=this.props;var time=parentClock.getTime();if(null!=this.skew){var now=realtime?time.time:time.clock;time=
realtime?time.delta:time.step;const ratio=speed/pace;null==this.start&&(this.start=now);this.skew+=time*(ratio-1);now=Math.max(0,now-this.start+this.skew-delay*ratio);this.props.loop&&(now%=to-from);this.playhead=Math.min(to,from+now)}else this.playhead=0;return this.update()})}update(){return super.update()}change(changed,touched,init){return changed["trigger.trigger"]||changed["play.realtime"]?this.rebuild():super.change(changed,touched,init)}}exports.Play=Play;Play.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$present$play.js.map
