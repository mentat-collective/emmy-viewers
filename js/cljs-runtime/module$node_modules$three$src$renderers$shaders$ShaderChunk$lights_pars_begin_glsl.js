shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$lights_pars_begin_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\nuniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\n\n// get the irradiance (radiance convolved with cosine lobe) at the point 'normal' on the unit sphere\n// source: https://graphics.stanford.edu/papers/envmap/envmap.pdf\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\n\t// normal is assumed to have unit length\n\n\tfloat x \x3d normal.x, y \x3d normal.y, z \x3d normal.z;\n\n\t// band 0\n\tvec3 result \x3d shCoefficients[ 0 ] * 0.886227;\n\n\t// band 1\n\tresult +\x3d shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult +\x3d shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult +\x3d shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\n\t// band 2\n\tresult +\x3d shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult +\x3d shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult +\x3d shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult +\x3d shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult +\x3d shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\n\treturn result;\n\n}\n\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\n\tvec3 worldNormal \x3d inverseTransformDirection( normal, viewMatrix );\n\n\tvec3 irradiance \x3d shGetIrradianceAt( worldNormal, lightProbe );\n\n\treturn irradiance;\n\n}\n\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\n\tvec3 irradiance \x3d ambientLightColor;\n\n\treturn irradiance;\n\n}\n\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\n\t#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\n\t\t// based upon Frostbite 3 Moving to Physically-based Rendering\n\t\t// page 32, equation 26: E[window1]\n\t\t// https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf\n\t\tfloat distanceFalloff \x3d 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\n\t\tif ( cutoffDistance \x3e 0.0 ) {\n\n\t\t\tdistanceFalloff *\x3d pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\n\t\t}\n\n\t\treturn distanceFalloff;\n\n\t#else\n\n\t\tif ( cutoffDistance \x3e 0.0 \x26\x26 decayExponent \x3e 0.0 ) {\n\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\n\t\t}\n\n\t\treturn 1.0;\n\n\t#endif\n\n}\n\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n\n}\n\n#if NUM_DIR_LIGHTS \x3e 0\n\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tlight.color \x3d directionalLight.color;\n\t\tlight.direction \x3d directionalLight.direction;\n\t\tlight.visible \x3d true;\n\n\t}\n\n#endif\n\n\n#if NUM_POINT_LIGHTS \x3e 0\n\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector \x3d pointLight.position - geometry.position;\n\n\t\tlight.direction \x3d normalize( lVector );\n\n\t\tfloat lightDistance \x3d length( lVector );\n\n\t\tlight.color \x3d pointLight.color;\n\t\tlight.color *\x3d getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible \x3d ( light.color !\x3d vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n\n#if NUM_SPOT_LIGHTS \x3e 0\n\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\n\t// light is an out parameter as having it as a return value caused compiler errors on some devices\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\n\t\tvec3 lVector \x3d spotLight.position - geometry.position;\n\n\t\tlight.direction \x3d normalize( lVector );\n\n\t\tfloat angleCos \x3d dot( light.direction, spotLight.direction );\n\n\t\tfloat spotAttenuation \x3d getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\n\t\tif ( spotAttenuation \x3e 0.0 ) {\n\n\t\t\tfloat lightDistance \x3d length( lVector );\n\n\t\t\tlight.color \x3d spotLight.color * spotAttenuation;\n\t\t\tlight.color *\x3d getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible \x3d ( light.color !\x3d vec3( 0.0 ) );\n\n\t\t} else {\n\n\t\t\tlight.color \x3d vec3( 0.0 );\n\t\t\tlight.visible \x3d false;\n\n\t\t}\n\n\t}\n\n#endif\n\n\n#if NUM_RECT_AREA_LIGHTS \x3e 0\n\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\n\t// Pre-computed values of LinearTransformedCosine approximation of BRDF\n\t// BRDF approximation Texture is 64x64\n\tuniform sampler2D ltc_1; // RGBA Float\n\tuniform sampler2D ltc_2; // RGBA Float\n\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n\n#endif\n\n\n#if NUM_HEMI_LIGHTS \x3e 0\n\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\n\t\tfloat dotNL \x3d dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight \x3d 0.5 * dotNL + 0.5;\n\n\t\tvec3 irradiance \x3d mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\n\t\treturn irradiance;\n\n\t}\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$lights_pars_begin_glsl.js.map
