shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$lights_fragment_begin_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\n/**\n * This is a template that can be used to light a material, it uses pluggable\n * RenderEquations (RE)for specific lighting scenarios.\n *\n * Instructions for use:\n * - Ensure that both RE_Direct, RE_IndirectDiffuse and RE_IndirectSpecular are defined\n * - If you have defined an RE_IndirectSpecular, you need to also provide a Material_LightProbeLOD. \x3c---- ???\n * - Create a material parameter that is to be passed as the third parameter to your lighting functions.\n *\n * TODO:\n * - Add area light support.\n * - Add sphere light support.\n * - Add diffuse light probe (irradiance cubemap) support.\n */\n\nGeometricContext geometry;\n\ngeometry.position \x3d - vViewPosition;\ngeometry.normal \x3d normal;\ngeometry.viewDir \x3d ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n\n#ifdef USE_CLEARCOAT\n\n\tgeometry.clearcoatNormal \x3d clearcoatNormal;\n\n#endif\n\nIncidentLight directLight;\n\n#if ( NUM_POINT_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct )\n\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) \x26\x26 NUM_POINT_LIGHT_SHADOWS \x3e 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_POINT_LIGHTS; i ++ ) {\n\n\t\tpointLight \x3d pointLights[ i ];\n\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) \x26\x26 ( UNROLLED_LOOP_INDEX \x3c NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow \x3d pointLightShadows[ i ];\n\t\tdirectLight.color *\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_SPOT_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct )\n\n\tSpotLight spotLight;\n\t#if defined( USE_SHADOWMAP ) \x26\x26 NUM_SPOT_LIGHT_SHADOWS \x3e 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\tspotLight \x3d spotLights[ i ];\n\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) \x26\x26 ( UNROLLED_LOOP_INDEX \x3c NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow \x3d spotLightShadows[ i ];\n\t\tdirectLight.color *\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_DIR_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct )\n\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) \x26\x26 NUM_DIR_LIGHT_SHADOWS \x3e 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_DIR_LIGHTS; i ++ ) {\n\n\t\tdirectionalLight \x3d directionalLights[ i ];\n\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\n\t\t#if defined( USE_SHADOWMAP ) \x26\x26 ( UNROLLED_LOOP_INDEX \x3c NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow \x3d directionalLightShadows[ i ];\n\t\tdirectLight.color *\x3d all( bvec2( directLight.visible, receiveShadow ) ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if ( NUM_RECT_AREA_LIGHTS \x3e 0 ) \x26\x26 defined( RE_Direct_RectArea )\n\n\tRectAreaLight rectAreaLight;\n\n\t#pragma unroll_loop_start\n\tfor ( int i \x3d 0; i \x3c NUM_RECT_AREA_LIGHTS; i ++ ) {\n\n\t\trectAreaLight \x3d rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\n\t}\n\t#pragma unroll_loop_end\n\n#endif\n\n#if defined( RE_IndirectDiffuse )\n\n\tvec3 iblIrradiance \x3d vec3( 0.0 );\n\n\tvec3 irradiance \x3d getAmbientLightIrradiance( ambientLightColor );\n\n\tirradiance +\x3d getLightProbeIrradiance( lightProbe, geometry.normal );\n\n\t#if ( NUM_HEMI_LIGHTS \x3e 0 )\n\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i \x3d 0; i \x3c NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\tirradiance +\x3d getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\n\t\t}\n\t\t#pragma unroll_loop_end\n\n\t#endif\n\n#endif\n\n#if defined( RE_IndirectSpecular )\n\n\tvec3 radiance \x3d vec3( 0.0 );\n\tvec3 clearcoatRadiance \x3d vec3( 0.0 );\n\n#endif\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$lights_fragment_begin_glsl.js.map
