shadow$provide.module$node_modules$$codemirror$language$dist$index_cjs=function(global,require,module,exports){function defineLanguageFacet(baseData){return state$jscomp$0.Facet.define({combine:baseData?values=>values.concat(baseData):void 0})}function languageDataFacetAt(state,pos,side){let topLang=state.facet(language);if(!topLang)return null;let facet=topLang.data;if(topLang.allowsNesting)for(state=syntaxTree(state).topNode;state;state=state.enter(pos,side,common.IterMode.ExcludeBuffers))facet=
state.type.prop(languageDataProp)||facet;return facet}function syntaxTree(state){return(state=state.field(Language.state,!1))?state.tree:common.Tree.empty}function ensureSyntaxTree(state,upto,timeout=50){var _a;return(state=null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context)?state.isDone(upto)||state.work(timeout,upto)?state.tree:null:null}function cutFragments(fragments,from,to){return common.TreeFragment.applyChanges(fragments,[{fromA:from,toA:to,fromB:from,toB:to}])}function getIndentUnit(state){let unit=
state.facet(indentUnit);return 9==unit.charCodeAt(0)?state.tabSize*unit.length:unit.length}function indentString(state,cols){let result="",ts=state.tabSize;if(9==state.facet(indentUnit).charCodeAt(0))for(;cols>=ts;)result+="\t",cols-=ts;for(state=0;state<cols;state++)result+=" ";return result}function getIndentation(context,pos){context instanceof state$jscomp$0.EditorState&&(context=new IndentContext(context));for(var service of context.state.facet(indentService)){let result=service(context,pos);
if(null!=result)return result}return pos=(service=syntaxTree(context.state))?indentFrom(service.resolveInner(pos).enterUnfinishedNodesBefore(pos),pos,context):null}function indentStrategy(tree){var strategy=tree.type.prop(indentNodeProp);if(strategy)return strategy;strategy=tree.firstChild;let close;if(strategy&&(close=strategy.type.prop(common.NodeProp.closedBy))){let last=tree.lastChild,closed=last&&-1<close.indexOf(last.name);return cx=>delimitedStrategy(cx,!0,1,void 0,!closed||cx.pos==cx.options.simulateBreak&&
cx.options.simulateDoubleBreak?void 0:last.from)}return null==tree.parent?topIndent:null}function indentFrom(node,pos,base){for(;node;node=node.parent){let strategy=indentStrategy(node);if(strategy)return strategy(TreeIndentContext.create(base,pos,node))}return null}function topIndent(){return 0}function delimitedStrategy(context,align,units,closing,closedAt){var after=context.textAfter,space=after.match(/^\s*/)[0].length;closing=closing&&after.slice(space,space+closing.length)==closing||closedAt==
context.pos+space;if(align)a:if(align=context.node,closedAt=align.childAfter(align.from),after=align.lastChild,closedAt){space=context.options.simulateBreak;var openLine=context.state.doc.lineAt(closedAt.from);space=null==space||space<=openLine.from?openLine.to:Math.min(openLine.to,space);for(openLine=closedAt.to;;){openLine=align.childAfter(openLine);if(!openLine||openLine==after){align=null;break a}if(!openLine.type.isSkipped){align=openLine.from<space?closedAt:null;break a}openLine=openLine.to}}else align=
null;else align=null;return align?closing?context.column(align.from):context.column(align.to):context.baseIndent+(closing?0:context.unit*units)}function foldable(state,lineStart,lineEnd){for(var service of state.facet(foldService)){var result=service(state,lineStart,lineEnd);if(result)return result}result=syntaxTree(state);if(result.length<lineEnd)state=null;else{var inner=result.resolveInner(lineEnd);for(service=null;inner;inner=inner.parent)if(!(inner.to<=lineEnd||inner.from>lineEnd)){if(service&&
inner.from<lineStart)break;var prop=inner.type.prop(foldNodeProp),JSCompiler_temp;(JSCompiler_temp=prop)&&!(JSCompiler_temp=inner.to<result.length-50||result.length==state.doc.length)&&(JSCompiler_temp=inner.lastChild,JSCompiler_temp=!(JSCompiler_temp&&JSCompiler_temp.to==inner.to&&JSCompiler_temp.type.isError));JSCompiler_temp&&(prop=prop(inner,state))&&prop.from<=lineEnd&&prop.from>=lineStart&&prop.to>lineEnd&&(service=prop)}state=service}return state}function mapRange(range,mapping){let from=mapping.mapPos(range.from,
1);range=mapping.mapPos(range.to,-1);return from>=range?void 0:{from,to:range}}function selectedLines(view){let lines=[];for(let {head}of view.state.selection.ranges)lines.some(l=>l.from<=head&&l.to>=head)||lines.push(view.lineBlockAt(head));return lines}function findFold(state,from$jscomp$0,to$jscomp$0){var _a;let found=null;null===(_a=state.field(foldState,!1))||void 0===_a?void 0:_a.between(from$jscomp$0,to$jscomp$0,(from,to)=>{if(!found||found.from>from)found={from,to}});return found}function foldExists(folded,
from,to){let found=!1;folded.between(from,from,(a,b)=>{a==from&&b==to&&(found=!0)});return found}function maybeEnable(state$1,other){return state$1.field(foldState,!1)?other:other.concat(state$jscomp$0.StateEffect.appendConfig.of(codeFolding()))}function announceFold(view$1,range,fold=!0){let lineFrom=view$1.state.doc.lineAt(range.from).number;range=view$1.state.doc.lineAt(range.to).number;return view$jscomp$0.EditorView.announce.of(`${view$1.state.phrase(fold?"Folded lines":"Unfolded lines")} ${lineFrom} ${view$1.state.phrase("to")} ${range}.`)}
function codeFolding(config){let result=[foldState,baseTheme$1];config&&result.push(foldConfig.of(config));return result}function getHighlighters(state){let main=state.facet(highlighterFacet);return main.length?main:state.facet(fallbackHighlighter)}function defaultRenderMatch(match){let decorations=[],mark=match.matched?matchingMark:nonmatchingMark;decorations.push(mark.range(match.start.from,match.start.to));match.end&&decorations.push(mark.range(match.end.from,match.end.to));return decorations}
function matchingNodes(node,dir,brackets){let byProp=node.prop(0>dir?common.NodeProp.openedBy:common.NodeProp.closedBy);return byProp?byProp:1==node.name.length&&(node=brackets.indexOf(node.name),-1<node&&node%2==(0>dir?1:0))?[brackets[node+dir]]:null}function matchBrackets(state,pos$jscomp$0,dir,config={}){var maxScanDistance=config.maxScanDistance||1E4;config=config.brackets||"()[]{}";var tree=syntaxTree(state),node=tree.resolveInner(pos$jscomp$0,dir);for(var cur=node;cur;cur=cur.parent){var matches=
matchingNodes(cur.type,dir,config);if(matches&&cur.from<cur.to){a:{pos$jscomp$0=dir;dir=cur;maxScanDistance=matches;cur=dir.parent;tree={from:dir.from,to:dir.to};matches=0;if((cur=null===cur||void 0===cur?void 0:cur.cursor())&&(0>pos$jscomp$0?cur.childBefore(dir.from):cur.childAfter(dir.to))){do if(0>pos$jscomp$0?cur.to<=dir.from:cur.from>=dir.to)if(0==matches&&-1<maxScanDistance.indexOf(cur.type.name)&&cur.from<cur.to){config={start:tree,end:{from:cur.from,to:cur.to},matched:!0};break a}else if(matchingNodes(cur.type,
pos$jscomp$0,config))matches++;else if(matchingNodes(cur.type,-pos$jscomp$0,config)){if(0==matches){config={start:tree,end:cur.from==cur.to?void 0:{from:cur.from,to:cur.to},matched:!1};break a}matches--}while(0>pos$jscomp$0?cur.prevSibling():cur.nextSibling())}config={start:tree,matched:!1}}return config}}a:if(matches=node.type,cur=0>dir?state.sliceDoc(pos$jscomp$0-1,pos$jscomp$0):state.sliceDoc(pos$jscomp$0,pos$jscomp$0+1),node=config.indexOf(cur),0>node||0==node%2!=0<dir)config=null;else{cur={from:0>
dir?pos$jscomp$0-1:pos$jscomp$0,to:0<dir?pos$jscomp$0+1:pos$jscomp$0};state=state.doc.iterRange(pos$jscomp$0,0<dir?state.doc.length:0);var depth=0;for(let distance=0;!state.next().done&&distance<=maxScanDistance;){let text=state.value;0>dir&&(distance+=text.length);let basePos=pos$jscomp$0+distance*dir;for(let pos=0<dir?0:text.length-1,end=0<dir?text.length:-1;pos!=end;pos+=dir){let found=config.indexOf(text[pos]);if(!(0>found||tree.resolveInner(basePos+pos,1).type!=matches))if(0==found%2==0<dir)depth++;
else if(1==depth){config={start:cur,end:{from:basePos+pos,to:basePos+pos+1},matched:found>>1==node>>1};break a}else depth--}0<dir&&(distance+=text.length)}config=state.done?{start:cur,matched:!1}:null}return config}function countCol(string,end,tabSize,startIndex=0,startValue=0){null==end&&(end=string.search(/[^\s\u00a0]/),-1==end&&(end=string.length));for(;startIndex<end;startIndex++)9==string.charCodeAt(startIndex)?startValue+=tabSize-startValue%tabSize:startValue++;return startValue}function fullParser(spec){return{name:spec.name||
"",token:spec.token,blankLine:spec.blankLine||(()=>{}),startState:spec.startState||(()=>!0),copyState:spec.copyState||defaultCopyState,indent:spec.indent||(()=>null),languageData:spec.languageData||{},tokenTable:spec.tokenTable||noTokens}}function defaultCopyState(state){if("object"!=typeof state)return state;let newState={};for(let prop in state){let val=state[prop];newState[prop]=val instanceof Array?val.slice():val}return newState}function findState(lang,tree,off,startPos,before){var state=off>=
startPos&&off+tree.length<=before&&tree.prop(lang.stateAfter);if(state)return{state:lang.streamParser.copyState(state),pos:off+tree.length};for(state=tree.children.length-1;0<=state;state--){var child=tree.children[state];let pos=off+tree.positions[state];if(child=child instanceof common.Tree&&pos<before&&findState(lang,child,pos,startPos,before))return child}return null}function cutTree(lang,tree,from,to,inside){if(inside&&0>=from&&to>=tree.length)return tree;inside||tree.type!=lang.topNode||(inside=
!0);for(let i=tree.children.length-1;0<=i;i--){let pos=tree.positions[i],child=tree.children[i];if(pos<to&&child instanceof common.Tree){if(!(lang=cutTree(lang,child,from-pos,to-pos,inside)))break;return inside?new common.Tree(tree.type,tree.children.slice(0,i).concat(lang),tree.positions.slice(0,i+1),pos+lang.length):lang}}return null}function readToken(token,stream,state){stream.start=stream.pos;for(let i=0;10>i;i++){let result=token(stream,state);if(stream.pos>stream.start)return result}throw Error("Stream parser failed to advance stream.");
}function warnForPart(part,msg){-1<warned.indexOf(part)||(warned.push(part),console.warn(msg))}function createTokenType(extra,tagStr){var tag=null;for(let part of tagStr.split(".")){let value=extra[part]||highlight.tags[part];value?"function"==typeof value?tag?tag=value(tag):warnForPart(part,`Modifier ${part} used at start of tag`):tag?warnForPart(part,`Tag ${part} used as modifier`):tag=value:warnForPart(part,`Unknown highlighting tag ${part}`)}if(!tag)return 0;extra=tagStr.replace(/ /g,"_");tag=
common.NodeType.define({id:typeArray.length,name:extra,props:[highlight.styleTags({[extra]:tag})]});typeArray.push(tag);return tag.id}function docID(data){let type=common.NodeType.define({id:typeArray.length,name:"Document",props:[languageDataProp.add(()=>data)]});typeArray.push(type);return type}Object.defineProperty(exports,"__esModule",{value:!0});var common=require("module$node_modules$$lezer$common$dist$index_cjs"),state$jscomp$0=require("module$node_modules$$codemirror$state$dist$index_cjs"),
view$jscomp$0=require("module$node_modules$$codemirror$view$dist$index_cjs"),highlight=require("module$node_modules$$lezer$highlight$dist$index_cjs"),styleMod=require("module$node_modules$style_mod$dist$style_mod_cjs"),_a$jscomp$0;const languageDataProp=new common.NodeProp;class Language{constructor(data,parser,extraExtensions=[],name=""){this.data=data;this.name=name;state$jscomp$0.EditorState.prototype.hasOwnProperty("tree")||Object.defineProperty(state$jscomp$0.EditorState.prototype,"tree",{get(){return syntaxTree(this)}});
this.parser=parser;this.extension=[language.of(this),state$jscomp$0.EditorState.languageData.of((state,pos,side)=>state.facet(languageDataFacetAt(state,pos,side)))].concat(extraExtensions)}isActiveAt(state,pos,side=-1){return languageDataFacetAt(state,pos,side)==this.data}findRegions(state){let lang=state.facet(language);if((null===lang||void 0===lang?void 0:lang.data)==this.data)return[{from:0,to:state.doc.length}];if(!lang||!lang.allowsNesting)return[];let result=[],explore=(tree,from)=>{if(tree.prop(languageDataProp)==
this.data)result.push({from,to:from+tree.length});else{var mount=tree.prop(common.NodeProp.mounted);if(mount){if(mount.tree.prop(languageDataProp)==this.data){if(mount.overlay)for(var r of mount.overlay)result.push({from:r.from+from,to:r.to+from});else result.push({from,to:from+tree.length});return}if(mount.overlay&&(r=result.length,explore(mount.tree,mount.overlay[0].from+from),result.length>r))return}for(mount=0;mount<tree.children.length;mount++)r=tree.children[mount],r instanceof common.Tree&&
explore(r,tree.positions[mount]+from)}};explore(syntaxTree(state),0);return result}get allowsNesting(){return!0}}Language.setState=state$jscomp$0.StateEffect.define();class LRLanguage extends Language{constructor(data,parser,name){super(data,parser,[],name);this.parser=parser}static define(spec){let data=defineLanguageFacet(spec.languageData);return new LRLanguage(data,spec.parser.configure({props:[languageDataProp.add(type=>type.isTop?data:void 0)]}),spec.name)}configure(options,name){return new LRLanguage(this.data,
this.parser.configure(options),name||this.name)}get allowsNesting(){return this.parser.hasWrappers()}}class DocInput{constructor(doc,length=doc.length){this.doc=doc;this.length=length;this.cursorPos=0;this.string="";this.cursor=doc.iter()}syncTo(pos){this.string=this.cursor.next(pos-this.cursorPos).value;this.cursorPos=pos+this.string.length;return this.cursorPos-this.string.length}chunk(pos){this.syncTo(pos);return this.string}get lineChunks(){return!0}read(from,to){let stringStart=this.cursorPos-
this.string.length;return from<stringStart||to>=this.cursorPos?this.doc.sliceString(from,to):this.string.slice(from-stringStart,to-stringStart)}}let currentContext=null;class ParseContext{constructor(parser,state,fragments=[],tree,treeLen,viewport,skipped,scheduleOn){this.parser=parser;this.state=state;this.fragments=fragments;this.tree=tree;this.treeLen=treeLen;this.viewport=viewport;this.skipped=skipped;this.scheduleOn=scheduleOn;this.parse=null;this.tempSkipped=[]}static create(parser,state,viewport){return new ParseContext(parser,
state,[],common.Tree.empty,0,viewport,[],null)}startParse(){return this.parser.startParse(new DocInput(this.state.doc),this.fragments)}work(until,upto){null!=upto&&upto>=this.state.doc.length&&(upto=void 0);return this.tree!=common.Tree.empty&&this.isDone(null!==upto&&void 0!==upto?upto:this.state.doc.length)?(this.takeTree(),!0):this.withContext(()=>{var _a;if("number"==typeof until){let endTime=Date.now()+until;until=()=>Date.now()>endTime}this.parse||(this.parse=this.startParse());for(null!=upto&&
(null==this.parse.stoppedAt||this.parse.stoppedAt>upto)&&upto<this.state.doc.length&&this.parse.stopAt(upto);;){let done=this.parse.advance();if(done)if(this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(done,this.fragments,null!=this.parse.stoppedAt)),this.treeLen=null!==(_a=this.parse.stoppedAt)&&void 0!==_a?_a:this.state.doc.length,this.tree=done,this.parse=null,this.treeLen<(null!==upto&&void 0!==upto?upto:this.state.doc.length))this.parse=this.startParse();else return!0;if(until())return!1}})}takeTree(){let pos,
tree;this.parse&&(pos=this.parse.parsedPos)>=this.treeLen&&((null==this.parse.stoppedAt||this.parse.stoppedAt>pos)&&this.parse.stopAt(pos),this.withContext(()=>{for(;!(tree=this.parse.advance()););}),this.treeLen=pos,this.tree=tree,this.fragments=this.withoutTempSkipped(common.TreeFragment.addTree(this.tree,this.fragments,!0)),this.parse=null)}withContext(f){let prev=currentContext;currentContext=this;try{return f()}finally{currentContext=prev}}withoutTempSkipped(fragments){for(let r;r=this.tempSkipped.pop();)fragments=
cutFragments(fragments,r.from,r.to);return fragments}changes(changes,newState){let {fragments,tree,treeLen,viewport,skipped}=this;this.takeTree();if(!changes.empty){let ranges=[];changes.iterChangedRanges((fromA,toA,fromB,toB)=>ranges.push({fromA,toA,fromB,toB}));fragments=common.TreeFragment.applyChanges(fragments,ranges);tree=common.Tree.empty;treeLen=0;viewport={from:changes.mapPos(viewport.from,-1),to:changes.mapPos(viewport.to,1)};if(this.skipped.length){skipped=[];for(let r of this.skipped){let from=
changes.mapPos(r.from,1),to=changes.mapPos(r.to,-1);from<to&&skipped.push({from,to})}}}return new ParseContext(this.parser,newState,fragments,tree,treeLen,viewport,skipped,this.scheduleOn)}updateViewport(viewport){if(this.viewport.from==viewport.from&&this.viewport.to==viewport.to)return!1;this.viewport=viewport;let startLen=this.skipped.length;for(let i=0;i<this.skipped.length;i++){let {from,to}=this.skipped[i];from<viewport.to&&to>viewport.from&&(this.fragments=cutFragments(this.fragments,from,
to),this.skipped.splice(i--,1))}if(this.skipped.length>=startLen)return!1;this.reset();return!0}reset(){this.parse&&(this.takeTree(),this.parse=null)}skipUntilInView(from,to){this.skipped.push({from,to})}static getSkippingParser(until){return new class extends common.Parser{createParse(input,fragments,ranges){let from=ranges[0].from,to=ranges[ranges.length-1].to;return{parsedPos:from,advance(){let cx=currentContext;if(cx){for(let r of ranges)cx.tempSkipped.push(r);until&&(cx.scheduleOn=cx.scheduleOn?
Promise.all([cx.scheduleOn,until]):until)}this.parsedPos=to;return new common.Tree(common.NodeType.none,[],[],to-from)},stoppedAt:null,stopAt(){}}}}}isDone(upto){upto=Math.min(upto,this.state.doc.length);let frags=this.fragments;return this.treeLen>=upto&&frags.length&&0==frags[0].from&&frags[0].to>=upto}static get(){return currentContext}}class LanguageState{constructor(context){this.context=context;this.tree=context.tree}apply(tr){if(!tr.docChanged&&this.tree==this.context.tree)return this;let newCx=
this.context.changes(tr.changes,tr.state);tr=this.context.treeLen==tr.startState.doc.length?void 0:Math.max(tr.changes.mapPos(this.context.treeLen),newCx.viewport.to);newCx.work(20,tr)||newCx.takeTree();return new LanguageState(newCx)}static init(state){let vpTo=Math.min(3E3,state.doc.length);state=ParseContext.create(state.facet(language).parser,state,{from:0,to:vpTo});state.work(20,vpTo)||state.takeTree();return new LanguageState(state)}}Language.state=state$jscomp$0.StateField.define({create:LanguageState.init,
update(value,tr){for(let e of tr.effects)if(e.is(Language.setState))return e.value;return tr.startState.facet(language)!=tr.state.facet(language)?LanguageState.init(tr.state):value.apply(tr)}});let requestIdle=callback=>{let timeout=setTimeout(()=>callback(),500);return()=>clearTimeout(timeout)};"undefined"!=typeof requestIdleCallback&&(requestIdle=callback=>{let idle=-1,timeout=setTimeout(()=>{idle=requestIdleCallback(callback,{timeout:400})},100);return()=>0>idle?clearTimeout(timeout):cancelIdleCallback(idle)});
const isInputPending="undefined"!=typeof navigator&&(null===(_a$jscomp$0=navigator.scheduling)||void 0===_a$jscomp$0?0:_a$jscomp$0.isInputPending)?()=>navigator.scheduling.isInputPending():null,parseWorker=view$jscomp$0.ViewPlugin.fromClass(class{constructor(view){this.view=view;this.working=null;this.workScheduled=0;this.chunkBudget=this.chunkEnd=-1;this.work=this.work.bind(this);this.scheduleWork()}update(update){let cx=this.view.state.field(Language.state).context;(cx.updateViewport(update.view.viewport)||
this.view.viewport.to>cx.treeLen)&&this.scheduleWork();update.docChanged&&(this.view.hasFocus&&(this.chunkBudget+=50),this.scheduleWork());this.checkAsyncSchedule(cx)}scheduleWork(){if(!this.working){var {state}=this.view,field=state.field(Language.state);field.tree==field.context.tree&&field.context.isDone(state.doc.length)||(this.working=requestIdle(this.work))}}work(deadline){this.working=null;let now=Date.now();this.chunkEnd<now&&(0>this.chunkEnd||this.view.hasFocus)&&(this.chunkEnd=now+3E4,this.chunkBudget=
3E3);if(!(0>=this.chunkBudget)){var {state,viewport:{to:vpTo}}=this.view,field=state.field(Language.state);if(field.tree!=field.context.tree||!field.context.isDone(vpTo+1E5)){var endTime=Date.now()+Math.min(this.chunkBudget,100,deadline&&!isInputPending?Math.max(25,deadline.timeRemaining()-5):1E9);deadline=field.context.treeLen<vpTo&&state.doc.length>vpTo+1E3;var done=field.context.work(()=>isInputPending&&isInputPending()||Date.now()>endTime,vpTo+(deadline?0:1E5));this.chunkBudget-=Date.now()-now;
if(done||0>=this.chunkBudget)field.context.takeTree(),this.view.dispatch({effects:Language.setState.of(new LanguageState(field.context))});0<this.chunkBudget&&(!done||deadline)&&this.scheduleWork();this.checkAsyncSchedule(field.context)}}}checkAsyncSchedule(cx){cx.scheduleOn&&(this.workScheduled++,cx.scheduleOn.then(()=>this.scheduleWork()).catch(err=>view$jscomp$0.logException(this.view.state,err)).then(()=>this.workScheduled--),cx.scheduleOn=null)}destroy(){this.working&&this.working()}isWorking(){return!!(this.working||
0<this.workScheduled)}},{eventHandlers:{focus(){this.scheduleWork()}}}),language=state$jscomp$0.Facet.define({combine(languages){return languages.length?languages[0]:null},enables:language=>[Language.state,parseWorker,view$jscomp$0.EditorView.contentAttributes.compute([language],state=>(state=state.facet(language))&&state.name?{"data-language":state.name}:{})]});class LanguageSupport{constructor(language,support=[]){this.language=language;this.support=support;this.extension=[language,support]}}class LanguageDescription{constructor(name,
alias,extensions,filename,loadFunc,support){this.name=name;this.alias=alias;this.extensions=extensions;this.filename=filename;this.loadFunc=loadFunc;this.support=support;this.loading=null}load(){return this.loading||(this.loading=this.loadFunc().then(support=>this.support=support,err=>{this.loading=null;throw err;}))}static of(spec){let {load,support}=spec;if(!load){if(!support)throw new RangeError("Must pass either 'load' or 'support' to LanguageDescription.of");load=()=>Promise.resolve(support)}return new LanguageDescription(spec.name,
(spec.alias||[]).concat(spec.name).map(s=>s.toLowerCase()),spec.extensions||[],spec.filename,load,support)}static matchFilename(descs,filename){for(let d of descs)if(d.filename&&d.filename.test(filename))return d;if(filename=/\.([^.]+)$/.exec(filename))for(let d of descs)if(-1<d.extensions.indexOf(filename[1]))return d;return null}static matchLanguageName(descs,name,fuzzy=!0){name=name.toLowerCase();for(let d of descs)if(d.alias.some(a=>a==name))return d;if(fuzzy)for(let d of descs)for(let a of d.alias)if(descs=
name.indexOf(a),-1<descs&&(2<a.length||!/\w/.test(name[descs-1])&&!/\w/.test(name[descs+a.length])))return d;return null}}const indentService=state$jscomp$0.Facet.define(),indentUnit=state$jscomp$0.Facet.define({combine:values=>{if(!values.length)return"  ";if(!/^(?: +|\t+)$/.test(values[0]))throw Error("Invalid indent unit: "+JSON.stringify(values[0]));return values[0]}});class IndentContext{constructor(state,options={}){this.state=state;this.options=options;this.unit=getIndentUnit(state)}lineAt(pos,
bias=1){let line=this.state.doc.lineAt(pos),{simulateBreak,simulateDoubleBreak}=this.options;return null!=simulateBreak&&simulateBreak>=line.from&&simulateBreak<=line.to?simulateDoubleBreak&&simulateBreak==pos?{text:"",from:pos}:(0>bias?simulateBreak<pos:simulateBreak<=pos)?{text:line.text.slice(simulateBreak-line.from),from:simulateBreak}:{text:line.text.slice(0,simulateBreak-line.from),from:line.from}:line}textAfterPos(pos,bias=1){if(this.options.simulateDoubleBreak&&pos==this.options.simulateBreak)return"";
let {text,from}=this.lineAt(pos,bias);return text.slice(pos-from,Math.min(text.length,pos+100-from))}column(pos,bias=1){let {text,from}=this.lineAt(pos,bias);pos=this.countColumn(text,pos-from);bias=this.options.overrideIndentation?this.options.overrideIndentation(from):-1;-1<bias&&(pos+=bias-this.countColumn(text,text.search(/\S|$/)));return pos}countColumn(line,pos=line.length){return state$jscomp$0.countColumn(line,this.state.tabSize,pos)}lineIndent(pos,bias=1){let {text,from}=this.lineAt(pos,
bias);if(pos=this.options.overrideIndentation)if(pos=pos(from),-1<pos)return pos;return this.countColumn(text,text.search(/\S|$/))}get simulatedBreak(){return this.options.simulateBreak||null}}const indentNodeProp=new common.NodeProp;class TreeIndentContext extends IndentContext{constructor(base,pos,node){super(base.state,base.options);this.base=base;this.pos=pos;this.node=node}static create(base,pos,node){return new TreeIndentContext(base,pos,node)}get textAfter(){return this.textAfterPos(this.pos)}get baseIndent(){let line=
this.state.doc.lineAt(this.node.from);for(;;){let atBreak=this.node.resolve(line.from);for(;atBreak.parent&&atBreak.parent.from==atBreak.from;)atBreak=atBreak.parent;var JSCompiler_inline_result;a:{for(JSCompiler_inline_result=this.node;JSCompiler_inline_result;JSCompiler_inline_result=JSCompiler_inline_result.parent)if(atBreak==JSCompiler_inline_result){JSCompiler_inline_result=!0;break a}JSCompiler_inline_result=!1}if(JSCompiler_inline_result)break;line=this.state.doc.lineAt(atBreak.from)}return this.lineIndent(line.from)}continue(){let parent=
this.node.parent;return parent?indentFrom(parent,this.pos,this.base):0}}const foldService=state$jscomp$0.Facet.define(),foldNodeProp=new common.NodeProp,foldEffect=state$jscomp$0.StateEffect.define({map:mapRange}),unfoldEffect=state$jscomp$0.StateEffect.define({map:mapRange}),foldState=state$jscomp$0.StateField.define({create(){return view$jscomp$0.Decoration.none},update(folded,tr){folded=folded.map(tr.changes);for(let e of tr.effects)e.is(foldEffect)&&!foldExists(folded,e.value.from,e.value.to)?
folded=folded.update({add:[foldWidget.range(e.value.from,e.value.to)]}):e.is(unfoldEffect)&&(folded=folded.update({filter:(from,to)=>e.value.from!=from||e.value.to!=to,filterFrom:e.value.from,filterTo:e.value.to}));if(tr.selection){let onSelection=!1,{head}=tr.selection.main;folded.between(head,head,(a,b)=>{a<head&&b>head&&(onSelection=!0)});onSelection&&(folded=folded.update({filterFrom:head,filterTo:head,filter:(a,b)=>b<=head||a>=head}))}return folded},provide:f=>view$jscomp$0.EditorView.decorations.from(f),
toJSON(folded,state){let ranges=[];folded.between(0,state.doc.length,(from,to)=>{ranges.push(from,to)});return ranges},fromJSON(value){if(!Array.isArray(value)||value.length%2)throw new RangeError("Invalid JSON for fold state");let ranges=[];for(let i=0;i<value.length;){let from=value[i++],to=value[i++];if("number"!=typeof from||"number"!=typeof to)throw new RangeError("Invalid JSON for fold state");ranges.push(foldWidget.range(from,to))}return view$jscomp$0.Decoration.set(ranges,!0)}}),foldCode=
view=>{for(let line of selectedLines(view)){let range=foldable(view.state,line.from,line.to);if(range)return view.dispatch({effects:maybeEnable(view.state,[foldEffect.of(range),announceFold(view,range)])}),!0}return!1},unfoldCode=view=>{if(!view.state.field(foldState,!1))return!1;let effects=[];for(let line of selectedLines(view)){let folded=findFold(view.state,line.from,line.to);folded&&effects.push(unfoldEffect.of(folded),announceFold(view,folded,!1))}effects.length&&view.dispatch({effects});return 0<
effects.length},foldAll=view=>{let {state}=view,effects=[];for(var pos=0;pos<state.doc.length;){pos=view.lineBlockAt(pos);let range=foldable(state,pos.from,pos.to);range&&effects.push(foldEffect.of(range));pos=(range?view.lineBlockAt(range.to):pos).to+1}effects.length&&view.dispatch({effects:maybeEnable(view.state,effects)});return!!effects.length},unfoldAll=view=>{let field=view.state.field(foldState,!1);if(!field||!field.size)return!1;let effects=[];field.between(0,view.state.doc.length,(from,to)=>
{effects.push(unfoldEffect.of({from,to}))});view.dispatch({effects});return!0},foldKeymap=[{key:"Ctrl-Shift-[",mac:"Cmd-Alt-[",run:foldCode},{key:"Ctrl-Shift-]",mac:"Cmd-Alt-]",run:unfoldCode},{key:"Ctrl-Alt-[",run:foldAll},{key:"Ctrl-Alt-]",run:unfoldAll}],defaultConfig={placeholderDOM:null,placeholderText:"…"},foldConfig=state$jscomp$0.Facet.define({combine(values){return state$jscomp$0.combineConfig(values,defaultConfig)}}),foldWidget=view$jscomp$0.Decoration.replace({widget:new class extends view$jscomp$0.WidgetType{toDOM(view){let {state}=
view,conf=state.facet(foldConfig),onclick=event=>{var line=view.lineBlockAt(view.posAtDOM(event.target));(line=findFold(view.state,line.from,line.to))&&view.dispatch({effects:unfoldEffect.of(line)});event.preventDefault()};if(conf.placeholderDOM)return conf.placeholderDOM(view,onclick);let element=document.createElement("span");element.textContent=conf.placeholderText;element.setAttribute("aria-label",state.phrase("folded code"));element.title=state.phrase("unfold");element.className="cm-foldPlaceholder";
element.onclick=onclick;return element}}}),foldGutterDefaults={openText:"⌄",closedText:"›",markerDOM:null,domEventHandlers:{},foldingChanged:()=>!1};class FoldMarker extends view$jscomp$0.GutterMarker{constructor(config,open){super();this.config=config;this.open=open}eq(other){return this.config==other.config&&this.open==other.open}toDOM(view){if(this.config.markerDOM)return this.config.markerDOM(this.open);let span=document.createElement("span");span.textContent=this.open?this.config.openText:this.config.closedText;
span.title=view.state.phrase(this.open?"Fold line":"Unfold line");return span}}const baseTheme$1=view$jscomp$0.EditorView.baseTheme({".cm-foldPlaceholder":{backgroundColor:"#eee",border:"1px solid #ddd",color:"#888",borderRadius:".2em",margin:"0 1px",padding:"0 1px",cursor:"pointer"},".cm-foldGutter span":{padding:"0 1px",cursor:"pointer"}});class HighlightStyle{constructor(specs,options){function def(spec){let cls=styleMod.StyleModule.newName();(modSpec||(modSpec=Object.create(null)))["."+cls]=spec;
return cls}this.specs=specs;let modSpec;const all="string"==typeof options.all?options.all:options.all?def(options.all):void 0,scopeOpt=options.scope;this.scope=scopeOpt instanceof Language?type=>type.prop(languageDataProp)==scopeOpt.data:scopeOpt?type=>type==scopeOpt:void 0;this.style=highlight.tagHighlighter(specs.map(style=>({tag:style.tag,class:style.class||def(Object.assign({},style,{tag:null}))})),{all}).style;this.module=modSpec?new styleMod.StyleModule(modSpec):null;this.themeType=options.themeType}static define(specs,
options){return new HighlightStyle(specs,options||{})}}const highlighterFacet=state$jscomp$0.Facet.define(),fallbackHighlighter=state$jscomp$0.Facet.define({combine(values){return values.length?[values[0]]:null}});class TreeHighlighter{constructor(view){this.markCache=Object.create(null);this.tree=syntaxTree(view.state);this.decorations=this.buildDeco(view,getHighlighters(view.state))}update(update){let tree=syntaxTree(update.state),highlighters=getHighlighters(update.state),styleChange=highlighters!=
getHighlighters(update.startState);if(tree.length<update.view.viewport.to&&!styleChange&&tree.type==this.tree.type)this.decorations=this.decorations.map(update.changes);else if(tree!=this.tree||update.viewportChanged||styleChange)this.tree=tree,this.decorations=this.buildDeco(update.view,highlighters)}buildDeco(view$1,highlighters){if(!highlighters||!this.tree.length)return view$jscomp$0.Decoration.none;let builder=new state$jscomp$0.RangeSetBuilder;for(let {from:from$jscomp$0,to:to$jscomp$0}of view$1.visibleRanges)highlight.highlightTree(this.tree,
highlighters,(from,to,style)=>{builder.add(from,to,this.markCache[style]||(this.markCache[style]=view$jscomp$0.Decoration.mark({class:style})))},from$jscomp$0,to$jscomp$0);return builder.finish()}}const treeHighlighter=state$jscomp$0.Prec.high(view$jscomp$0.ViewPlugin.fromClass(TreeHighlighter,{decorations:v=>v.decorations})),defaultHighlightStyle=HighlightStyle.define([{tag:highlight.tags.meta,color:"#7a757a"},{tag:highlight.tags.link,textDecoration:"underline"},{tag:highlight.tags.heading,textDecoration:"underline",
fontWeight:"bold"},{tag:highlight.tags.emphasis,fontStyle:"italic"},{tag:highlight.tags.strong,fontWeight:"bold"},{tag:highlight.tags.strikethrough,textDecoration:"line-through"},{tag:highlight.tags.keyword,color:"#708"},{tag:[highlight.tags.atom,highlight.tags.bool,highlight.tags.url,highlight.tags.contentSeparator,highlight.tags.labelName],color:"#219"},{tag:[highlight.tags.literal,highlight.tags.inserted],color:"#164"},{tag:[highlight.tags.string,highlight.tags.deleted],color:"#a11"},{tag:[highlight.tags.regexp,
highlight.tags.escape,highlight.tags.special(highlight.tags.string)],color:"#e40"},{tag:highlight.tags.definition(highlight.tags.variableName),color:"#00f"},{tag:highlight.tags.local(highlight.tags.variableName),color:"#30a"},{tag:[highlight.tags.typeName,highlight.tags.namespace],color:"#085"},{tag:highlight.tags.className,color:"#167"},{tag:[highlight.tags.special(highlight.tags.variableName),highlight.tags.macroName],color:"#256"},{tag:highlight.tags.definition(highlight.tags.propertyName),color:"#00c"},
{tag:highlight.tags.comment,color:"#940"},{tag:highlight.tags.invalid,color:"#f00"}]),baseTheme=view$jscomp$0.EditorView.baseTheme({"\x26.cm-focused .cm-matchingBracket":{backgroundColor:"#328c8252"},"\x26.cm-focused .cm-nonmatchingBracket":{backgroundColor:"#bb555544"}}),bracketMatchingConfig=state$jscomp$0.Facet.define({combine(configs){return state$jscomp$0.combineConfig(configs,{afterCursor:!0,brackets:"()[]{}",maxScanDistance:1E4,renderMatch:defaultRenderMatch})}}),matchingMark=view$jscomp$0.Decoration.mark({class:"cm-matchingBracket"}),
nonmatchingMark=view$jscomp$0.Decoration.mark({class:"cm-nonmatchingBracket"}),bracketMatchingUnique=[state$jscomp$0.StateField.define({create(){return view$jscomp$0.Decoration.none},update(deco,tr){if(!tr.docChanged&&!tr.selection)return deco;deco=[];let config=tr.state.facet(bracketMatchingConfig);for(let range of tr.state.selection.ranges){if(!range.empty)continue;let match=matchBrackets(tr.state,range.head,-1,config)||0<range.head&&matchBrackets(tr.state,range.head-1,1,config)||config.afterCursor&&
(matchBrackets(tr.state,range.head,1,config)||range.head<tr.state.doc.length&&matchBrackets(tr.state,range.head+1,-1,config));match&&(deco=deco.concat(config.renderMatch(match,tr.state)))}return view$jscomp$0.Decoration.set(deco,!0)},provide:f=>view$jscomp$0.EditorView.decorations.from(f)}),baseTheme];class StringStream{constructor(string,tabSize,indentUnit){this.string=string;this.tabSize=tabSize;this.indentUnit=indentUnit;this.lastColumnValue=this.lastColumnPos=this.start=this.pos=0}eol(){return this.pos>=
this.string.length}sol(){return 0==this.pos}peek(){return this.string.charAt(this.pos)||void 0}next(){if(this.pos<this.string.length)return this.string.charAt(this.pos++)}eat(match){let ch=this.string.charAt(this.pos);if("string"==typeof match?ch==match:ch&&(match instanceof RegExp?match.test(ch):match(ch)))return++this.pos,ch}eatWhile(match){let start=this.pos;for(;this.eat(match););return this.pos>start}eatSpace(){let start=this.pos;for(;/[\s\u00a0]/.test(this.string.charAt(this.pos));)++this.pos;
return this.pos>start}skipToEnd(){this.pos=this.string.length}skipTo(ch){ch=this.string.indexOf(ch,this.pos);if(-1<ch)return this.pos=ch,!0}backUp(n){this.pos-=n}column(){this.lastColumnPos<this.start&&(this.lastColumnValue=countCol(this.string,this.start,this.tabSize,this.lastColumnPos,this.lastColumnValue),this.lastColumnPos=this.start);return this.lastColumnValue}indentation(){return countCol(this.string,null,this.tabSize)}match(pattern,consume,caseInsensitive){if("string"==typeof pattern){var JSCompiler_inline_result=
this.string.substr(this.pos,pattern.length);JSCompiler_inline_result=caseInsensitive?JSCompiler_inline_result.toLowerCase():JSCompiler_inline_result;caseInsensitive=caseInsensitive?pattern.toLowerCase():pattern;return JSCompiler_inline_result==caseInsensitive?(!1!==consume&&(this.pos+=pattern.length),!0):null}if((pattern=this.string.slice(this.pos).match(pattern))&&0<pattern.index)return null;pattern&&!1!==consume&&(this.pos+=pattern[0].length);return pattern}current(){return this.string.slice(this.start,
this.pos)}}class StreamLanguage extends Language{constructor(parser){let data=defineLanguageFacet(parser.languageData),p=fullParser(parser),self,impl=new class extends common.Parser{createParse(input,fragments,ranges){return new Parse(self,input,fragments,ranges)}};super(data,impl,[indentService.of((cx,pos)=>this.getIndent(cx,pos))],parser.name);this.topNode=docID(data);self=this;this.streamParser=p;this.stateAfter=new common.NodeProp({perNode:!0});this.tokenTable=parser.tokenTable?new TokenTable(p.tokenTable):
defaultTokenTable}static define(spec){return new StreamLanguage(spec)}getIndent(cx,pos){for(var tree=syntaxTree(cx.state),at=tree.resolve(pos);at&&at.type!=this.topNode;)at=at.parent;if(!at)return null;(at=findState(this,tree,0,at.from,pos))?(tree=at.state,at=at.pos+1):(tree=this.streamParser.startState(cx.unit),at=0);if(1E4<pos-at)return null;for(;at<pos;){at=cx.state.doc.lineAt(at);let end=Math.min(pos,at.to);if(at.length){let stream=new StringStream(at.text,cx.state.tabSize,cx.unit);for(;stream.pos<
end-at.from;)readToken(this.streamParser.token,stream,tree)}else this.streamParser.blankLine(tree,cx.unit);if(end==pos)break;at=at.to+1}({text:pos}=cx.lineAt(pos));return this.streamParser.indent(tree,/^\s*(.*)/.exec(pos)[1],cx)}get allowsNesting(){return!1}}class Parse{constructor(lang,input,fragments,ranges){this.lang=lang;this.input=input;this.fragments=fragments;this.ranges=ranges;this.stoppedAt=null;this.chunks=[];this.chunkPos=[];this.chunk=[];this.chunkReused=void 0;this.rangeIndex=0;this.to=
ranges[ranges.length-1].to;input=ParseContext.get();ranges=ranges[0].from;a:{var editorState=null===input||void 0===input?void 0:input.state;for(let f of fragments){fragments=f.to-(f.openEnd?25:0);fragments=f.from+(f.openStart?25:0)<=ranges&&fragments>ranges&&findState(lang,f.tree,0-f.offset,ranges,fragments);let tree;if(fragments&&(tree=cutTree(lang,f.tree,ranges+f.offset,fragments.pos+f.offset,!1))){lang={state:fragments.state,tree};break a}}lang={state:lang.streamParser.startState(editorState?
getIndentUnit(editorState):4),tree:common.Tree.empty}}let {state,tree:tree$jscomp$0}=lang;this.state=state;this.parsedPos=this.chunkStart=ranges+tree$jscomp$0.length;for(lang=0;lang<tree$jscomp$0.children.length;lang++)this.chunks.push(tree$jscomp$0.children[lang]),this.chunkPos.push(tree$jscomp$0.positions[lang]);input&&this.parsedPos<input.viewport.from-1E5&&(this.state=this.lang.streamParser.startState(getIndentUnit(input.state)),input.skipUntilInView(this.parsedPos,input.viewport.from),this.parsedPos=
input.viewport.from);this.moveRangeIndex()}advance(){let context=ParseContext.get(),parseEnd=null==this.stoppedAt?this.to:Math.min(this.to,this.stoppedAt),end=Math.min(parseEnd,this.chunkStart+2048);for(context&&(end=Math.min(end,context.viewport.to));this.parsedPos<end;)this.parseLine(context);this.chunkStart<this.parsedPos&&this.finishChunk();return this.parsedPos>=parseEnd?this.finish():context&&this.parsedPos>=context.viewport.to?(context.skipUntilInView(this.parsedPos,parseEnd),this.finish()):
null}stopAt(pos){this.stoppedAt=pos}lineAfter(pos){let chunk=this.input.chunk(pos);if(this.input.lineChunks)"\n"==chunk&&(chunk="");else{let eol=chunk.indexOf("\n");-1<eol&&(chunk=chunk.slice(0,eol))}return pos+chunk.length<=this.to?chunk:chunk.slice(0,this.to-pos)}nextLine(){var from=this.parsedPos;let line=this.lineAfter(from);var end=from+line.length;for(from=this.rangeIndex;;){var rangeEnd=this.ranges[from].to;if(rangeEnd>=end)break;line=line.slice(0,rangeEnd-(end-line.length));from++;if(from==
this.ranges.length)break;end=this.ranges[from].from;rangeEnd=this.lineAfter(end);line+=rangeEnd;end+=rangeEnd.length}return{line,end}}skipGapsTo(pos,offset,side){for(;;){let end=this.ranges[this.rangeIndex].to;var offPos=pos+offset;if(0<side?end>offPos:end>=offPos)break;offPos=this.ranges[++this.rangeIndex].from;offset+=offPos-end}return offset}moveRangeIndex(){for(;this.ranges[this.rangeIndex].to<this.parsedPos;)this.rangeIndex++}emitToken(id,from,to,size,offset){if(1<this.ranges.length){offset=
this.skipGapsTo(from,offset,1);from+=offset;let len0=this.chunk.length;offset=this.skipGapsTo(to,offset,-1);to+=offset;size+=this.chunk.length-len0}this.chunk.push(id,from,to,size);return offset}parseLine(context){let {line,end}=this.nextLine(),offset=0,{streamParser}=this.lang;context=new StringStream(line,context?context.state.tabSize:4,context?getIndentUnit(context.state):2);if(context.eol())streamParser.blankLine(this.state,context.indentUnit);else for(;!context.eol();){let token=readToken(streamParser.token,
context,this.state);token&&(offset=this.emitToken(this.lang.tokenTable.resolve(token),this.parsedPos+context.start,this.parsedPos+context.pos,4,offset));if(1E4<context.start)break}this.parsedPos=end;this.moveRangeIndex();this.parsedPos<this.to&&this.parsedPos++}finishChunk(){let tree=common.Tree.build({buffer:this.chunk,start:this.chunkStart,length:this.parsedPos-this.chunkStart,nodeSet,topID:0,maxBufferLength:2048,reused:this.chunkReused});tree=new common.Tree(tree.type,tree.children,tree.positions,
tree.length,[[this.lang.stateAfter,this.lang.streamParser.copyState(this.state)]]);this.chunks.push(tree);this.chunkPos.push(this.chunkStart-this.ranges[0].from);this.chunk=[];this.chunkReused=void 0;this.chunkStart=this.parsedPos}finish(){return(new common.Tree(this.lang.topNode,this.chunks,this.chunkPos,this.parsedPos-this.ranges[0].from)).balance()}}const noTokens=Object.create(null),typeArray=[common.NodeType.none],nodeSet=new common.NodeSet(typeArray),warned=[],defaultTable=Object.create(null);
for(let [legacyName,name]of[["variable","variableName"],["variable-2","variableName.special"],["string-2","string.special"],["def","variableName.definition"],["tag","tagName"],["attribute","attributeName"],["type","typeName"],["builtin","variableName.standard"],["qualifier","modifier"],["error","invalid"],["header","heading"],["property","propertyName"]])defaultTable[legacyName]=createTokenType(noTokens,name);class TokenTable{constructor(extra){this.extra=extra;this.table=Object.assign(Object.create(null),
defaultTable)}resolve(tag){return tag?this.table[tag]||(this.table[tag]=createTokenType(this.extra,tag)):0}}const defaultTokenTable=new TokenTable(noTokens);exports.HighlightStyle=HighlightStyle;exports.IndentContext=IndentContext;exports.LRLanguage=LRLanguage;exports.Language=Language;exports.LanguageDescription=LanguageDescription;exports.LanguageSupport=LanguageSupport;exports.ParseContext=ParseContext;exports.StreamLanguage=StreamLanguage;exports.StringStream=StringStream;exports.TreeIndentContext=
TreeIndentContext;exports.bracketMatching=function(config={}){return[bracketMatchingConfig.of(config),bracketMatchingUnique]};exports.codeFolding=codeFolding;exports.continuedIndent=function({except,units=1}={}){return context=>{let matchExcept=except&&except.test(context.textAfter);return context.baseIndent+(matchExcept?0:units*context.unit)}};exports.defaultHighlightStyle=defaultHighlightStyle;exports.defineLanguageFacet=defineLanguageFacet;exports.delimitedIndent=function({closing,align=!0,units=
1}){return context=>delimitedStrategy(context,align,units,closing)};exports.ensureSyntaxTree=ensureSyntaxTree;exports.flatIndent=context=>context.baseIndent;exports.foldAll=foldAll;exports.foldCode=foldCode;exports.foldEffect=foldEffect;exports.foldGutter=function(config={}){let fullConfig=Object.assign(Object.assign({},foldGutterDefaults),config),canFold=new FoldMarker(fullConfig,!0),canUnfold=new FoldMarker(fullConfig,!1),markers=view$jscomp$0.ViewPlugin.fromClass(class{constructor(view){this.from=
view.viewport.from;this.markers=this.buildMarkers(view)}update(update){if(update.docChanged||update.viewportChanged||update.startState.facet(language)!=update.state.facet(language)||update.startState.field(foldState,!1)!=update.state.field(foldState,!1)||syntaxTree(update.startState)!=syntaxTree(update.state)||fullConfig.foldingChanged(update))this.markers=this.buildMarkers(update.view)}buildMarkers(view){let builder=new state$jscomp$0.RangeSetBuilder;for(let line of view.viewportLineBlocks){let mark=
findFold(view.state,line.from,line.to)?canUnfold:foldable(view.state,line.from,line.to)?canFold:null;mark&&builder.add(line.from,line.from,mark)}return builder.finish()}}),{domEventHandlers}=fullConfig;return[markers,view$jscomp$0.gutter({class:"cm-foldGutter",markers(view){var _a;return(null===(_a=view.plugin(markers))||void 0===_a?void 0:_a.markers)||state$jscomp$0.RangeSet.empty},initialSpacer(){return new FoldMarker(fullConfig,!1)},domEventHandlers:Object.assign(Object.assign({},domEventHandlers),
{click:(view,line,event)=>domEventHandlers.click&&domEventHandlers.click(view,line,event)?!0:(event=findFold(view.state,line.from,line.to))?(view.dispatch({effects:unfoldEffect.of(event)}),!0):(line=foldable(view.state,line.from,line.to))?(view.dispatch({effects:foldEffect.of(line)}),!0):!1})}),codeFolding()]};exports.foldInside=function(node){let first=node.firstChild,last=node.lastChild;return first&&first.to<last.from?{from:first.to,to:last.type.isError?node.to:last.from}:null};exports.foldKeymap=
foldKeymap;exports.foldNodeProp=foldNodeProp;exports.foldService=foldService;exports.foldState=foldState;exports.foldable=foldable;exports.foldedRanges=function(state$1){return state$1.field(foldState,!1)||state$jscomp$0.RangeSet.empty};exports.forceParsing=function(view,upto=view.viewport.to,timeout=100){upto=ensureSyntaxTree(view.state,upto,timeout);upto!=syntaxTree(view.state)&&view.dispatch({});return!!upto};exports.getIndentUnit=getIndentUnit;exports.getIndentation=getIndentation;exports.highlightingFor=
function(state,tags,scope){var highlighters=getHighlighters(state);state=null;if(highlighters)for(let highlighter of highlighters)(!highlighter.scope||scope&&highlighter.scope(scope))&&(highlighters=highlighter.style(tags))&&(state=state?state+" "+highlighters:highlighters);return state};exports.indentNodeProp=indentNodeProp;exports.indentOnInput=function(){return state$jscomp$0.EditorState.transactionFilter.of(tr=>{if(!tr.docChanged||!tr.isUserEvent("input.type")&&!tr.isUserEvent("input.complete"))return tr;
var rules=tr.startState.languageDataAt("indentOnInput",tr.startState.selection.main.head);if(!rules.length)return tr;var doc=tr.newDoc,{head:head$jscomp$0}=tr.newSelection.main,line=doc.lineAt(head$jscomp$0);if(head$jscomp$0>line.from+200)return tr;let lineStart=doc.sliceString(line.from,head$jscomp$0);if(!rules.some(r=>r.test(lineStart)))return tr;({state:rules}=tr);doc=-1;head$jscomp$0=[];for(let {head}of rules.selection.ranges){line=rules.doc.lineAt(head);if(line.from==doc)continue;doc=line.from;
var indent=getIndentation(rules,line.from);if(null==indent)continue;let cur=/^\s*/.exec(line.text)[0];indent=indentString(rules,indent);cur!=indent&&head$jscomp$0.push({from:line.from,to:line.from+cur.length,insert:indent})}return head$jscomp$0.length?[tr,{changes:head$jscomp$0,sequential:!0}]:tr})};exports.indentRange=function(state,from,to){let updated=Object.create(null),context=new IndentContext(state,{overrideIndentation:start=>{var _a;return null!==(_a=updated[start])&&void 0!==_a?_a:-1}}),
changes=[];for(;from<=to;){let line=state.doc.lineAt(from);from=line.to+1;let indent=getIndentation(context,line.from);if(null==indent)continue;/\S/.test(line.text)||(indent=0);let cur=/^\s*/.exec(line.text)[0],norm=indentString(state,indent);cur!=norm&&(updated[line.from]=indent,changes.push({from:line.from,to:line.from+cur.length,insert:norm}))}return state.changes(changes)};exports.indentService=indentService;exports.indentString=indentString;exports.indentUnit=indentUnit;exports.language=language;
exports.languageDataProp=languageDataProp;exports.matchBrackets=matchBrackets;exports.syntaxHighlighting=function(highlighter,options){let ext=[treeHighlighter],themeType;highlighter instanceof HighlightStyle&&(highlighter.module&&ext.push(view$jscomp$0.EditorView.styleModule.of(highlighter.module)),themeType=highlighter.themeType);(null===options||void 0===options?0:options.fallback)?ext.push(fallbackHighlighter.of(highlighter)):themeType?ext.push(highlighterFacet.computeN([view$jscomp$0.EditorView.darkTheme],
state=>state.facet(view$jscomp$0.EditorView.darkTheme)==("dark"==themeType)?[highlighter]:[])):ext.push(highlighterFacet.of(highlighter));return ext};exports.syntaxParserRunning=function(view){var _a;return(null===(_a=view.plugin(parseWorker))||void 0===_a?void 0:_a.isWorking())||!1};exports.syntaxTree=syntaxTree;exports.syntaxTreeAvailable=function(state,upto=state.doc.length){var _a;return(null===(_a=state.field(Language.state,!1))||void 0===_a?void 0:_a.context.isDone(upto))||!1};exports.unfoldAll=
unfoldAll;exports.unfoldCode=unfoldCode;exports.unfoldEffect=unfoldEffect}
//# sourceMappingURL=module$node_modules$$codemirror$language$dist$index_cjs.js.map
