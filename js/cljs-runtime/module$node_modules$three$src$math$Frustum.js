shadow$provide.module$node_modules$three$src$math$Frustum=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Frustum=void 0;global=require("module$node_modules$three$src$math$Vector3");module=require("module$node_modules$three$src$math$Sphere");var _Plane=require("module$node_modules$three$src$math$Plane");const _sphere=new module.Sphere,_vector=new global.Vector3;class Frustum{constructor(p0=new _Plane.Plane,p1=new _Plane.Plane,p2=new _Plane.Plane,
p3=new _Plane.Plane,p4=new _Plane.Plane,p5=new _Plane.Plane){this.planes=[p0,p1,p2,p3,p4,p5]}set(p0,p1,p2,p3,p4,p5){const planes=this.planes;planes[0].copy(p0);planes[1].copy(p1);planes[2].copy(p2);planes[3].copy(p3);planes[4].copy(p4);planes[5].copy(p5);return this}copy(frustum){const planes=this.planes;for(let i=0;6>i;i++)planes[i].copy(frustum.planes[i]);return this}setFromProjectionMatrix(m){const planes=this.planes;var me=m.elements;m=me[0];const me1=me[1],me2=me[2],me3=me[3],me4=me[4],me5=me[5],
me6=me[6],me7=me[7],me8=me[8],me9=me[9],me10=me[10],me11=me[11],me12=me[12],me13=me[13],me14=me[14];me=me[15];planes[0].setComponents(me3-m,me7-me4,me11-me8,me-me12).normalize();planes[1].setComponents(me3+m,me7+me4,me11+me8,me+me12).normalize();planes[2].setComponents(me3+me1,me7+me5,me11+me9,me+me13).normalize();planes[3].setComponents(me3-me1,me7-me5,me11-me9,me-me13).normalize();planes[4].setComponents(me3-me2,me7-me6,me11-me10,me-me14).normalize();planes[5].setComponents(me3+me2,me7+me6,me11+
me10,me+me14).normalize();return this}intersectsObject(object){const geometry=object.geometry;null===geometry.boundingSphere&&geometry.computeBoundingSphere();_sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);return this.intersectsSphere(_sphere)}intersectsSprite(sprite){_sphere.center.set(0,0,0);_sphere.radius=.7071067811865476;_sphere.applyMatrix4(sprite.matrixWorld);return this.intersectsSphere(_sphere)}intersectsSphere(sphere){const planes=this.planes,center=sphere.center;
sphere=-sphere.radius;for(let i=0;6>i;i++)if(planes[i].distanceToPoint(center)<sphere)return!1;return!0}intersectsBox(box){const planes=this.planes;for(let i=0;6>i;i++){const plane=planes[i];_vector.x=0<plane.normal.x?box.max.x:box.min.x;_vector.y=0<plane.normal.y?box.max.y:box.min.y;_vector.z=0<plane.normal.z?box.max.z:box.min.z;if(0>plane.distanceToPoint(_vector))return!1}return!0}containsPoint(point){const planes=this.planes;for(let i=0;6>i;i++)if(0>planes[i].distanceToPoint(point))return!1;return!0}clone(){return(new this.constructor).copy(this)}}
exports.Frustum=Frustum}
//# sourceMappingURL=module$node_modules$three$src$math$Frustum.js.map
