shadow$provide.module$node_modules$three$src$math$Ray=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Ray=void 0;var _Vector=require("module$node_modules$three$src$math$Vector3");const _vector=new _Vector.Vector3,_segCenter=new _Vector.Vector3,_segDir=new _Vector.Vector3,_diff=new _Vector.Vector3,_edge1=new _Vector.Vector3,_edge2=new _Vector.Vector3,_normal=new _Vector.Vector3;class Ray{constructor(origin=new _Vector.Vector3,direction=new _Vector.Vector3(0,
0,-1)){this.origin=origin;this.direction=direction}set(origin,direction){this.origin.copy(origin);this.direction.copy(direction);return this}copy(ray){this.origin.copy(ray.origin);this.direction.copy(ray.direction);return this}at(t,target){return target.copy(this.direction).multiplyScalar(t).add(this.origin)}lookAt(v){this.direction.copy(v).sub(this.origin).normalize();return this}recast(t){this.origin.copy(this.at(t,_vector));return this}closestPointToPoint(point,target){target.subVectors(point,
this.origin);point=target.dot(this.direction);return 0>point?target.copy(this.origin):target.copy(this.direction).multiplyScalar(point).add(this.origin)}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point))}distanceSqToPoint(point){const directionDistance=_vector.subVectors(point,this.origin).dot(this.direction);if(0>directionDistance)return this.origin.distanceToSquared(point);_vector.copy(this.direction).multiplyScalar(directionDistance).add(this.origin);return _vector.distanceToSquared(point)}distanceSqToSegment(v0,
v1,optionalPointOnRay,optionalPointOnSegment){_segCenter.copy(v0).add(v1).multiplyScalar(.5);_segDir.copy(v1).sub(v0).normalize();_diff.copy(this.origin).sub(_segCenter);var segExtent=.5*v0.distanceTo(v1),a01=-this.direction.dot(_segDir);const b0=_diff.dot(this.direction),b1=-_diff.dot(_segDir),c=_diff.lengthSq(),det=Math.abs(1-a01*a01);let extDet;0<det?(v0=a01*b1-b0,v1=a01*b0-b1,extDet=segExtent*det,0<=v0?v1>=-extDet?v1<=extDet?(segExtent=1/det,v0*=segExtent,v1*=segExtent,a01=v0*(v0+a01*v1+2*b0)+
v1*(a01*v0+v1+2*b1)+c):(v1=segExtent,v0=Math.max(0,-(a01*v1+b0)),a01=-v0*v0+v1*(v1+2*b1)+c):(v1=-segExtent,v0=Math.max(0,-(a01*v1+b0)),a01=-v0*v0+v1*(v1+2*b1)+c):v1<=-extDet?(v0=Math.max(0,-(-a01*segExtent+b0)),v1=0<v0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),a01=-v0*v0+v1*(v1+2*b1)+c):v1<=extDet?(v0=0,v1=Math.min(Math.max(-segExtent,-b1),segExtent),a01=v1*(v1+2*b1)+c):(v0=Math.max(0,-(a01*segExtent+b0)),v1=0<v0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),a01=-v0*v0+v1*(v1+
2*b1)+c)):(v1=0<a01?-segExtent:segExtent,v0=Math.max(0,-(a01*v1+b0)),a01=-v0*v0+v1*(v1+2*b1)+c);optionalPointOnRay&&optionalPointOnRay.copy(this.direction).multiplyScalar(v0).add(this.origin);optionalPointOnSegment&&optionalPointOnSegment.copy(_segDir).multiplyScalar(v1).add(_segCenter);return a01}intersectSphere(sphere,target){_vector.subVectors(sphere.center,this.origin);var tca=_vector.dot(this.direction),d2=_vector.dot(_vector)-tca*tca;sphere=sphere.radius*sphere.radius;if(d2>sphere)return null;
sphere=Math.sqrt(sphere-d2);d2=tca-sphere;tca+=sphere;return 0>d2&&0>tca?null:0>d2?this.at(tca,target):this.at(d2,target)}intersectsSphere(sphere){return this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius}distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(0===denominator)return 0===plane.distanceToPoint(this.origin)?0:null;plane=-(this.origin.dot(plane.normal)+plane.constant)/denominator;return 0<=plane?plane:null}intersectPlane(plane,target){plane=this.distanceToPlane(plane);
return null===plane?null:this.at(plane,target)}intersectsPlane(plane){const distToPoint=plane.distanceToPoint(this.origin);return 0===distToPoint||0>plane.normal.dot(this.direction)*distToPoint?!0:!1}intersectBox(box,target){let tmin;var tmax=1/this.direction.x;var tymax=1/this.direction.y;const invdirz=1/this.direction.z,origin=this.origin;0<=tmax?(tmin=(box.min.x-origin.x)*tmax,tmax*=box.max.x-origin.x):(tmin=(box.max.x-origin.x)*tmax,tmax*=box.min.x-origin.x);if(0<=tymax){var tymin=(box.min.y-
origin.y)*tymax;tymax*=box.max.y-origin.y}else tymin=(box.max.y-origin.y)*tymax,tymax*=box.min.y-origin.y;if(tmin>tymax||tymin>tmax)return null;if(tymin>tmin||tmin!==tmin)tmin=tymin;if(tymax<tmax||tmax!==tmax)tmax=tymax;0<=invdirz?(tymin=(box.min.z-origin.z)*invdirz,box=(box.max.z-origin.z)*invdirz):(tymin=(box.max.z-origin.z)*invdirz,box=(box.min.z-origin.z)*invdirz);if(tmin>box||tymin>tmax)return null;if(tymin>tmin||tmin!==tmin)tmin=tymin;if(box<tmax||tmax!==tmax)tmax=box;return 0>tmax?null:this.at(0<=
tmin?tmin:tmax,target)}intersectsBox(box){return null!==this.intersectBox(box,_vector)}intersectTriangle(a,b,c,backfaceCulling,target){_edge1.subVectors(b,a);_edge2.subVectors(c,a);_normal.crossVectors(_edge1,_edge2);b=this.direction.dot(_normal);if(0<b){if(backfaceCulling)return null;backfaceCulling=1}else if(0>b)backfaceCulling=-1,b=-b;else return null;_diff.subVectors(this.origin,a);a=backfaceCulling*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(0>a)return null;c=backfaceCulling*this.direction.dot(_edge1.cross(_diff));
if(0>c||a+c>b)return null;a=-backfaceCulling*_diff.dot(_normal);return 0>a?null:this.at(a/b,target)}applyMatrix4(matrix4){this.origin.applyMatrix4(matrix4);this.direction.transformDirection(matrix4);return this}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}exports.Ray=Ray}
//# sourceMappingURL=module$node_modules$three$src$math$Ray.js.map
