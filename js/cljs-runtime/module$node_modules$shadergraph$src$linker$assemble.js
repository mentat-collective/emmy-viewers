shadow$provide.module$node_modules$shadergraph$src$linker$assemble=function(global,require,module$jscomp$0,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}function _interopRequireWildcard(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;
if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,
desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}Object.defineProperty(exports,"__esModule",{value:!0});exports.assemble=void 0;var Graph=_interopRequireWildcard(require("module$node_modules$shadergraph$src$graph$index")),Priority=_interopRequireWildcard(require("module$node_modules$shadergraph$src$linker$priority"));exports.assemble=function(language,namespace$jscomp$0,calls$jscomp$0,requires){const externals={},symbols=[],uniforms={},varyings=
{},attributes={},library={},handle=calls=>{let c;calls=(()=>{const result=[];for(const ns in calls)c=calls[ns],result.push(c);return result})();calls.sort((a,b)=>b.priority-a.priority);const call=(node,module,priority)=>{include(node,module,priority);({main:priority}=module);({entry:module}=module);return language.call(name=>lookup(node,name),name=>isDangling(node,name),module,priority.signature,body)},body=language.body();for(c of Array.from(calls))call(c.node,c.module,c.priority);return[body,calls]},
adopt=function(namespace,code,priority){const record=library[namespace];return null!=record?record.priority=Priority.max(record.priority,priority):library[namespace]={code,priority}},include=function(node,module,priority){let key;priority=Priority.make(priority);for(const ns in module.library){const lib=module.library[ns];adopt(ns,lib.code,Priority.nest(priority,lib.priority))}adopt(module.namespace,module.body,priority);for(key in module.uniforms)priority=module.uniforms[key],uniforms[key]=priority;
for(key in module.varyings)priority=module.varyings[key],varyings[key]=priority;for(key in module.attributes)priority=module.attributes[key],attributes[key]=priority;return required(node,module)},required=(node,module)=>{const result=[];for(const key of Array.from(module.symbols)){const ext=module.externals[key];if(isDangling(node,ext.name)){const copy={};for(const k in ext)copy[k]=ext[k];copy.name=lookup(node,ext.name);externals[key]=copy;result.push(symbols.push(key))}else result.push(void 0)}return result},
isDangling=function(node,name){node=node.get(name);if(node.inout===Graph.IN)return null===node.input;if(node.inout===Graph.OUT)return 0===node.output.length},lookup=function(node,name){node=node.get(name);if(!node)return null;node.input&&(node=node.input);({name}=node);return node.id};return function(){let ns;for(ns in requires){var body=requires[ns];required(body.node,body.module)}[body,calls$jscomp$0]=Array.from(handle(calls$jscomp$0));null!=namespace$jscomp$0&&(body.entry=namespace$jscomp$0);body=
language.build(body,calls$jscomp$0);var includes=(()=>{const result=[];for(ns in library)result.push(library[ns]);return result})().sort((a,b)=>Priority.compare(a.priority,b.priority)).map(x=>x.code);includes.push(body.code);includes=language.lines(includes);return{namespace:body.name,library,body:body.code,code:includes,main:body,entry:body.name,symbols,externals,uniforms,varyings,attributes}}()}}
//# sourceMappingURL=module$node_modules$shadergraph$src$linker$assemble.js.map
