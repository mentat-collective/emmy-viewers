{"version":3,"sources":["sicmutils/calculus/indexed.cljc"],"mappings":";AAsBA,AAAA;;;;;oCAAA,4CAAAA,hFAAOE;AAAP,AAAA,IAAAD,YAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,gEAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,gEAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,kEAAA,lEAAOD,6EAIHE,EAAEC;AAJN,AAKG,2EAAA,pEAACC,gEAAOF,EAAEC;;;AALb,CAAA,kEAAA,lEAAOH,6EAMHE,EAAEC,EAAEE;AANR,AAOG,GAAI,AAACC,mCAAYJ;AACf,IAAAK,YAAG,AAACE,2BAAUP;IAAdM,YAAiBH;AAAjB,AAAA,0EAAAE,UAAAC,yBAAAD,UAAAC,/GAACL,kCAAAA,uDAAAA;;AACD,IAAAO,YAAG,AAACE,eAAKV;IAATS,YAAYN;AAAZ,AAAA,0EAAAK,UAAAC,yBAAAD,UAAAC,/GAACR,kCAAAA,uDAAAA;;;;AATN,CAAA,4DAAA,5DAAOH;;AAAP,AAWA,AAAA;;;;sCAAA,8CAAAF,pFAAOoB;AAAP,AAAA,IAAAL,qBAAA;AAAA,AAAA,IAAAC,2BAAA,AAAA;AAAA,AAAA,IAAAC,yBAAA;;AAAA,AAAA,GAAA,CAAAA,yBAAAD;AAAA,AAAA,AAAAD,wBAAA,CAAA,UAAAE;;AAAA,gBAAA,CAAAA,yBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,EAAA,CAAA,MAAA,AAAAH,4BAAA,AAAA,KAAAI,qBAAA,AAAAJ,yBAAA,KAAA,IAAA,OAAA;AAAA,AAAA,OAAAK,yEAAA,CAAA,UAAA,MAAAF;;;AAAA,AAAA,CAAA,2EAAA,3EAAOE,sFAGJhB,EAAIsB;AAHP,AAIE,GAAI,AAAClB,mCAAYJ;AACf,OAACuB,gCAAevB,EAAE,AAACwB,8CAAMC,gBAAM,AAAClB,2BAAUP,GAAGsB;;AAC7C,OAACE,8CAAME,oBAAU1B,EAAEyB,gBAAMH;;;;AAN7B,CAAA,8DAAA,9DAAON;;AAAP;AAAA,CAAA,wDAAA,WAAAC,nEAAOD;AAAP,AAAA,IAAAE,YAAA,AAAAC,gBAAAF;IAAAA,gBAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAI,qBAAA;AAAA,AAAA,OAAAA,wDAAAH,UAAAD;;;AAAA,AAQA;;;;;;;;;;;;4CAAA,5CAAMU,gGAWH3B;AAXH,AAYE,yEAAA,gEAAA,lIAACE,gEAAOF;;AAEV;;;uDAAA,vDAAe4B,sHAEZ5B;AAFH,AAGE,OAAC6B,mBACA,AAACC,cAAI,AAACH,0CAAe3B;;AAExB;;;;;;;iDAAA,jDAAM+B,0GAMH/B,EAAEgC;AANL,AAOE,IAAMC,OAAK,6CAAA,7CAACC,8EAAQF;AAApB,AACE,oIAAA,qEAAA,wDAAA,mFAAA,7UAACG,yEAASnC,oHACGiC,2MACM,AAACG,gBAAMH;;AAE9B;;;;;;;;;;;;yCAAA,zCAAMI,0FAWHrC;AAXH,AAYE,yEAAA,mEAAA,rIAACE,gEAAOF;;AAEV;;;oDAAA,pDAAesC,gHAEZtC;AAFH,AAGE,OAAC6B,mBACA,AAACC,cAAI,AAACO,uCAAYrC;;AAErB;;;;;;;8CAAA,9CAAMuC,oGAMHvC,EAAEgC;AANL,AAOE,IAAMQ,IAAE,6CAAA,7CAACN,8EAAQF;AAAjB,AACE,oIAAA,qEAAA,wDAAA,mFAAA,7UAACG,yEAASnC,uHACKwC,wMACI,AAACJ,gBAAMI;;AAY9B;;;;;;;;;;oDAAA,pDAAOC,gHASJC;AATH,AAUE,oBAAA,4EAAkBC;AAAlB,AACU,4DAAA,rDAACC,mDAAKD;;gBADhB,wEAEcA;AAFd,AAGU,4DAAA,rDAACC,mDAAKD;;AAHhB,AAIE,gCAAA,vBAAK,AAACb,cAAIY,WACL,AAACG,uBAAO,AAACC,gDAAQC,cAAQC,WAAKN,SAC9B,AAACG,uBAAOG,UAAI,AAACC,mDAAWF,cAAQL;;AAEzC,+CAAA,/CAAMQ,sGAAgBlD,EAAEmD;AAAxB,AACE,IAAMC,YAAU,AAACzB,0CAAe3B;AAAhC,AACE,oBAAQ,AAACyC,kDAAiBW;AAA1B;AAAA,AAAA,MAAA,KAAArD,MAAA,CAAA,0GAAA,KAAA,7FACQ,CAAA,kEAA2BqD;;;AACnC,IAAMC,eAAa,AAACC,gDAAsBH;IACpCI,gBAAc,AAACC,iDAAuBL;IACtCM,YAAU,AAACC,4CAAI,WAAKf;AAAL,AACE,GAAI,qDAAA,rDAACC,mDAAKD;AAAV,AAAA;;AAAA,AAAA;;GAGFS;AANrB,mDAOM,iEAAaO,pHAab,OAACpB;AAbD,AACE,GAAQ,AAACqB,6CAAE,AAACxB,gBAAMuB,SACP,AAACvB,gBAAMgB;AADlB;AAAA,AAAA,MAAA,KAAArD,MAAA,CAAA,6NAAA,KAAA,hNAEQ,CAAA,uDAAA,kEAAA,TACkB4D,qEACGP;;;AAC7B,IAAMnB,OAAK,AAAC4B,6CAAK,WAAKlB,EAAEmB;AAAP,AACE,GAAI,qDAAA,rDAAClB,mDAAKD;AACR,OAACoB,4CAAIV,aAAaS;;AAClB,OAACC,4CAAIR,cAAcO;;GACvBV,UACAO;AALjB,AAME,OAACnC,8CAAMxB,EAAEiC;GACKwB;;AAE5B;;;;;;;;;;;sDAAA,tDAAOO,oHAUJtB;AAVH,AAWE,OAACb,mBACA,yBAAA,vBAAK,AAACC,cAAIY,WACL,uBAAA,iFAAA,AAAA,0DAAA,AAAA,lKAACG,gPAAoBH,SACrB,uBAAA,iFAAA,AAAA,xGAACG,sLAAgB,mDAAA,iFAAA,AAAA,pIAACI,6MAAkBP;;AAE5C;;;;;;;;;;;;;uDAAA,vDAAOuB,sHAYJC,YAAYjC;AAZf,AAaE,GAAQ,AAAC2B,6CAAE,AAACxB,gBAAM8B,aACP,AAAC9B,gBAAMH;AADlB;AAAA,AAAA,MAAA,KAAAlC,MAAA,CAAA,qPAAA,KAAA,xOAEQ,CAAA,wFAAA,+GAAA,7IACK,AAACqC,gBAAM8B,sGACP,AAAC9B,gBAAMH;;;AACpB,GAAQ,AAACY,uBAAOsB,sBACA,AAACT,4CAAI,WAAKU,WAAWC;AAAhB,AACE,SAAI,EAAK,wDAAA,AAAA,xDAACT,6CAAEQ,sEACH,AAACE,mDAAkBD,YACxB,EAAK,wDAAA,AAAA,xDAACT,6CAAEQ,2EACH,AAACG,oDAAiBF;GAC7BH,YACAjC;AAPrB;;AAAA,AAAA,MAAA,KAAAlC,MAAA,CAAA,sYAAA,KAAA,zXAQQ,CAAA,qGAAA,4HAAA,nHACc,AAACyE,wGAAOvC,yBACH,AAACuC,wGAAON;;;AAErC,+CAAA,/CAAMO,sGAAgBC,QAAQvB;AAA9B,AACE,IAAMe,cAAY,AAAC7B,uCAAYqC;AAA/B,AACE,GAAQ,AAACV,oDAAmBE;AAA5B;AAAA,AAAA,MAAA,KAAAnE,MAAA,CAAA,8GAAA,KAAA,jGACQ,CAAA,oEAA6BmE;;;AACrC,IAAMb,eAAc,AAACC,gDAAsBH;IACrCI,gBAAc,AAACC,iDAAuBL;IACtCwB,IAAe,AAACC,6CAAmBzB;IACnCC,YAAU,6CAAA,2CAAA,AAAA,qDAAA,iIAAA,AAAA,0DAAA,xUAACS,kdAEKK;AALtB,sDAMM,tDAkBA,OAACnC;+EAlBYE;AAAb,AACE,AAACgC,qDAAqBC,YAAYjC;;AAClC,IAAM4C,QAAO,AAACC,kBAAQ,AAACC,8CAAMJ;IACvBK,SAAO,AAACC,yCACA,iBAAAC,qBAAA,8EAAAC;AAAA,AAAA,YAAAC,kBAAA,KAAA;AAAA,AAAA,IAAAD,gBAAAA;;AAAA,AAAA,IAAAE,qBAAA,AAAAvD,cAAAqD;AAAA,AAAA,GAAAE;AAAA,AAAA,IAAAF,gBAAAE;AAAA,AAAA,GAAA,AAAAC,6BAAAH;AAAA,IAAAI,kBAmuEyB,AAAAqG,sBAAAzG;IAnuEzBK,qBAAA,AAAApD,gBAAAmD;IAAAE,YAAA,AAAAC,uBAAAF;AAAA,AAAA,GAAA,AAAA,iBAAAG,YAAA;;AAAA,AAAA,GAAA,CAAAA,YAAAH;AAAA,QAAA,AAAAI,eAAAL,gBAAAI,nCAAMS;AAAN,AAAA,AAAA,AAAAP,uBAAAJ,UACE,AAAC/B,4CAAI;kBAAK2C,EAAEhC;AAAP,AAAA,0FACGgC,EAAE,EAAI,AAAC9B,oDAAiBF,MACpB,iBAAAiC,gBAAC,AAACvC,4CAAIR,cAAc8C;AAApB,AAAA,QAAAC,8CAAAA,mDAAAA,PAAuBjC,+BAAAA;KACvB,iBAAAmC,YAAK,AAACzC,4CAAIV,aAAagD;AAAvB,AAAA,8EAAAG,2BAAAA,jGAACnC,oCAAAA,+CAAAA;;;CACRQ,MACA,AAAC6B,+CAAON;;AANf,gBAAA,CAAAT,YAAA;;;;AAAA;;;;;AAAA,OAAAG,qBAAA,AAAAC,gBAAAN,WAAA,AAAAO,oEAAA,AAAAC,qBAAAd;;AAAA,OAAAW,qBAAA,AAAAC,gBAAAN,WAAA;;;AAAA,QAAA,AAAAtE,gBAAAgE,pBAAMiB;AAAN,AAAA,OAAAF,eACE,AAACxC,4CAAI;kBAAK2C,EAAEhC;AAAP,AAAA,0FACGgC,EAAE,EAAI,AAAC9B,oDAAiBF,MACpB,iBAAAkC,gBAAC,AAACxC,4CAAIR,cAAc8C;AAApB,AAAA,QAAAE,8CAAAA,mDAAAA,PAAuBlC,+BAAAA;KACvB,iBAAAoC,YAAK,AAAC1C,4CAAIV,aAAagD;AAAvB,AAAA,8EAAAI,2BAAAA,jGAACpC,oCAAAA,+CAAAA;;;0DAJf,AAAA2B,oEAAA,AAAAG,eAAAhB,5IAKON,MACA,AAAC6B,+CAAON;;;AANf;;;;GAAA,KAAA;;AAAA,AAAA,OAAAlB,mBAAQjD;;AAFtB,AASE,IAAA0E,YACC,iBAAAzB,qBAAA,8EAAA2B;AAAA,AAAA,YAAAzB,kBAAA,KAAA;AAAA,AAAA,IAAAyB,gBAAAA;;AAAA,AAAA,IAAAxB,qBAAA,AAAAvD,cAAA+E;AAAA,AAAA,GAAAxB;AAAA,AAAA,IAAAwB,gBAAAxB;AAAA,AAAA,GAAA,AAAAC,6BAAAuB;AAAA,IAAAtB,kBA2tEoC,AAAAqG,sBAAA/E;IA3tEpCrB,qBAAA,AAAApD,gBAAAmD;IAAAuB,YAAA,AAAApB,uBAAAF;AAAA,AAAA,GAAA,AAAA,iBAAAuB,YAAA;;AAAA,AAAA,GAAA,CAAAA,YAAAvB;AAAA,YAAA,AAAAI,eAAAL,gBAAAwB,vCAAME;AAAN,AAAA,IACYtD,UAAa,AAACD,4CAAIvC,gBAAM8F;IACxBC,eAAa,AAACxD,4CAAIyD,eAAKF;AAFnC,AAAA,AAAA,AAAApB,uBAAAiB,UAGE,AAACtF,8CAAM4F,yBACA,CAAC1C,wCAAAA,iDAAAA,XAAQf,6BAAAA,UACT,AAACmB,kBAAQoC;;AALlB,gBAAA,CAAAH,YAAA;;;;AAAA;;;;;AAAA,OAAAjB,qBAAA,AAAAC,gBAAAe,WAAA,AAAAE,oEAAA,AAAAf,qBAAAY;;AAAA,OAAAf,qBAAA,AAAAC,gBAAAe,WAAA;;;AAAA,YAAA,AAAA3F,gBAAA0F,xBAAMI;AAAN,AAAA,IACYtD,UAAa,AAACD,4CAAIvC,gBAAM8F;IACxBC,eAAa,AAACxD,4CAAIyD,eAAKF;AAFnC,AAAA,OAAAf,6OAAA,AAAAc,oEAAA,AAAAb,eAAAU,jTAGE,AAACrF,8CAAM4F,yBACA,CAAC1C,wCAAAA,iDAAAA,XAAQf,6BAAAA,UACT,AAACmB,kBAAQoC;;;AALlB;;;;GAAA,KAAA;;AAAA,AAAA,OAAAhC,mBAAYF;;AADb,AAAA,gJAAA2B,4DAAAA,pMAACC,qEAAAA,gFAAAA;;;IAXQ3E;;;;EAAAA;;gFAAAA;;;IAAAA;sEAAAA;;;;;CAkBQmB;;AAE/B,2CAAA,3CAAMiE,8FAAeC,GAAGC;AAAxB,AACE,IAAMC,KAAG,AAACnF,uCAAYiF;IAChBG,KAAG,AAACpF,uCAAYkF;AADtB,AAEE,GAAQ,AAACzF,cAAI0F;AAAb;AAAA,AAAA,MAAA,KAAAzH,MAAA,CAAA,kBAAA,oCAAA,KAAA;;;AACA,GAAQ,AAAC+B,cAAI2F;AAAb;AAAA,AAAA,MAAA,KAAA1H,MAAA,CAAA,kBAAA,oCAAA,KAAA;;;AACA,IAAA2H,cAA0B,AAACK,sBAAYP;IAAvCE,kBAAA,AAAAC,4BAAAD;UAAA,AAAA3D,4CAAA2D,gBAAA,AAAA,lEAAOG;UAAP,AAAA9D,4CAAA2D,gBAAA,AAAA,lEAAeI;IAAfF,cAC0B,AAACG,sBAAYN;IADvCG,kBAAA,AAAAD,4BAAAC;UAAA,AAAA7D,4CAAA6D,gBAAA,AAAA,lEACOI;UADP,AAAAjE,4CAAA6D,gBAAA,AAAA,lEACeK;IACTC,MAAI,AAACC,uDAAE,iBAAAC,mBAAIP;AAAJ,AAAA,oBAAAO;AAAAA;;AAAA;;KAAW,iBAAAA,mBAAIJ;AAAJ,AAAA,oBAAAI;AAAAA;;AAAA;;;IAClBC,MAAI,AAACF,uDAAE,iBAAAC,mBAAIN;AAAJ,AAAA,oBAAAM;AAAAA;;AAAA;;KAAW,iBAAAA,mBAAIH;AAAJ,AAAA,oBAAAG;AAAAA;;AAAA;;;IAClBE,KAAI,AAACH,uDAAED,IAAIG;IACXE,KAAI,AAACJ,uDAAED,IAAIJ;AALjB,AAME,cAAA,6DAAkB7F;AAAlB,AACU,GAAQ,AAAC2B,6CAAE,AAACxB,gBAAMH,MAAMqG;AAAxB;AAAA,AAAA,MAAA,KAAAvI,MAAA,CAAA,yMAAA,KAAA,5LACQ,CAAA,6GAAA,vBACK,AAACqC,gBAAMH,kEACQqG;;;AAC5B,IAAME,OAAK,6CAAA,7CAACtG,8EAAQD;AAApB,AACE,OAACwG,uDAAE,iBAAAC,YAAI,AAACxG,6CAAK,oDAAA,pDAACyG,+CAAOH,SAAOX,KACf,AAACc,+CAAOH,KAAKN,IAAIK;AAD3B,AAAA,4EAAAG,0BAAAA,9FAACpB,mCAAAA,8CAAAA;KAED,iBAAAsB,YAAI,AAAC1G,6CAAK,AAACyG,+CAAOH,KAAKX,IAAIK,KACjB,AAACS,+CAAOH,KAAKD,GAAGD;AAD1B,AAAA,4EAAAM,0BAAAA,9FAACrB,mCAAAA,8CAAAA;;;AARhB,AAUE,OAAChF,4CAAiBsG,QAChB,AAACC,+CAAO,mDAAA,AAAA,nDAACpC,+CAAOwB,0DACR,mDAAA,AAAA,nDAACxB,+CAAO2B;;AAE1B,cAAA,6CAAkBU,KAAK1C,EAAE7D;AAAzB,AACU,IAAMwG,IAAE,oDAAA,pDAACL,+CAAOI,SAAO1C;IACjB4C,IAAE,AAACN,+CAAOI,KAAK1C;AADrB,AAEE,OAAC7E,8CAAM0H,eAAKF,EAAExG,EAAEyG;;AAH5B,AAKE,sCAAA,tCAAME,oFAAUC,EAAEC,EAAEC,EAAE3E;AAAtB,AACE,IAAM4E,UAAQ,AAAClH,uCAAY+G;AAA3B,AACE,GAAQ,AAACtH,cAAIyH;AAAb;AAAA,AAAA,MAAA,KAAAxJ,MAAA,CAAA,kBAAA,mCAAA,KAAA;;;AACA,IAAAyJ,cAAwB,AAACzB,sBAAYwB;IAArCC,kBAAA,AAAA7B,4BAAA6B;SAAA,AAAAzF,4CAAAyF,gBAAA,AAAA,jEAAOC;SAAP,AAAA1F,4CAAAyF,gBAAA,AAAA,jEAAcE;AAAd,AACE,GAAQ,kBAAA,gBAAA,hCAAK,CAAA,OAAML,UAAG,CAAGA,IAAEI,WACd,CAAA,OAAMH,QAAG,CAAGA,IAAEI;AAD3B;AAAA,AAAA,MAAA,KAAA3J,MAAA,CAAA,qaAAA,KAAA,xZAEQ,CAAA,sEAAA,oDAAA,+BAAA,oDAAA,iEAAA,8DAAA,wDAAA,jUAA4BsJ,oDAAOC,iNAGhBG,wDAAWC;;;AACtC,IAAMC,MAAI,MAAA,LAAKF;IACTG,MAAI,MAAA,LAAKF;AADf,mDAEM,4DAAiBzH,/GAQjB,OAACM;AARD,AACE,IAAMiG,OAAK,6CAAA,7CAACtG,8EAAQD;AAApB,AACE,IAAA4H,YACC,WAAKxD;AAAL,AACE,IAAA2D,YAAG,AAAClB,+CACA,AAACmB,QAAQ,oDAAA,pDAACtB,+CAAOH,SAAOmB,KAAKN,EAAEhD,GAC/B,AAAC4D,QAAQ,AAACtB,+CAAOH,KAAKmB,KAAKL,EAAEjD;AAFjC,AAAA,0EAAA2D,yBAAAA,3FAACZ,kCAAAA,6CAAAA;;IAFJU,YAAA;IAAAC,YAKGpF;AALH,AAAA,gJAAAkF,UAAAC,UAAAC,4DAAAF,UAAAC,UAAAC,5OAACnD,qEAAAA,oGAAAA;GAOH,AAACkC,+CAAO,mDAAA,AAAA,nDAACpC,+CAAOiD,0DACR,mDAAA,AAAA,nDAACjD,+CAAOkD;;AAEhC,iDAAA,jDAAMM,0GAAkBd,EAAEjG;AAA1B,AACE,IAAME,eAAc,AAACC,gDAAsBH;IACrCI,gBAAc,AAACC,iDAAuBL;AAD5C,AAEE,SAAA,8DAAaC,UAAUoF;AAAvB,AACU,GAAI,AAAC2B,uBAAO/G;AACV,OAAC5B,8CAAM4H,EAAEZ;;AACT,IAAA4B,cAAehH;IAAfiH,cAAA,AAAAvI,cAAAsI;IAAAE,gBAAA,AAAAnJ,gBAAAkJ;IAAAA,kBAAA,AAAAjJ,eAAAiJ;QAAAC,JAAO3H;SAAP0H,LAAW3H;AAAX,AACE,OAAC6H,8DAAO,WAAKC;AAAL,AACE,OAACC,oDAAG/H,GAAG,AAACgI,6CAAKlC,KAAKgC;qDACpB,wMAAA,wMAAA,9YAAM,qDAAA,rDAAC5H,mDAAKD,sIACNU,eAEA,qDAAA,rDAACT,mDAAKD,qIACNY,cAEM,AAACoH,uBACA,CAAA,0IAAA,hHAA+B,AAACnG,wGAAO7B;;;;AAb1E,AAeE,uDAAA,hDAAC8H,GAAG,AAAC9I,0CAAeyH;;AAE1B,iDAAA,jDAAMwB,0GAAkBC,gBAAgB1H;AAAxC,AACE,IAAME,eAAc,AAACC,gDAAsBH;IACrCI,gBAAc,AAACC,iDAAuBL;IACtCC,YAAc,iBAAO0H,KAAID;UAAX,NACOE;;AADP,AAEE,GAAA,GAAQ,AAACC,qCAAaF;AACpBC;;AACA,IAAME,QAAM,iBAAAC,YACC,AAACE,gCAAcN;AADhB,AAAA,wJAAAI,gEAAAA,hNAACC,yEAAAA,oFAAAA;;IAEPxI,IAAE,iBAAA0I,YAAMJ;IAANI,gBAAA,EAAA,CAAAA,qBAAAC,oBAAA,AAAAD,cAAA;AAAA,AAAA,QAAAA;KAAA;AAAA;;;KAAA;AAAA;;;;AAAA,MAAA,KAAAtL,MAAA,CAAA,mEAAAsL;;;;AAFR,AAKE,gBAAO,+CAAA,/CAACE,4CAAIT;gBACL,AAACJ,6CAAKK,IAAIpI;;;;;;;;AAZ3C,sDAaM,tDA+BA,OAACZ;sFA/BiBE;AAAlB,AACE,GAAQ,AAAC2B,6CAAE,AAACxB,gBAAMH,MACP,AAACG,gBAAMgB;AADlB;AAAA,AAAA,MAAA,KAAArD,MAAA,CAAA,6VAAA,KAAA,hVAEQ,CAAA,yFAAA,6GAAA,KAAA,iHAAA,1PAA2B,AAACqC,gBAAMH,wFACQ,AAACG,gBAAMgB,uHACcA;;;AACvE,GAAQ,AAACP,uBAAOsB,sBAAM,AAACT,4CAAI,WAAKW,IAAImH;AAAT,AACE,OAAC5I,mDAAK,AAAC6I,qBAAOpH,KAAKmH;GACrBvJ,KAAKmB;AAFhC;AAAA,AAAA,MAAA,KAAArD,MAAA,CAAA,+NAAA,KAAA,lNAGQ,CAAA,wEAAA,KAAA,iHAAA,5HAA2BkC,iHACoCmB;;;AACvE,SAAA,2EAAanB,SAAKmB;AAAlB,AACU,GAAI,AAAC+G,uBAAOlI;AACVyJ;;AACA,IAAMrH,MAAI,AAAClD,gBAAMc;IACXuJ,WAAS,AAACrK,gBAAMiC;AADtB,AAEE,GAAM,4DAAA,5DAACR,mDAAK4I;AACN,OAACjB,8DAAO,WAAKoB;AAAL,AACE,OAAClD,uDAAE,CAACkD,uCAAAA,4CAAAA,PAAOtH,wBAAAA,MACR,AAACoG,iEAAG,AAACtE,eAAKlE,UACN,AAACkE,eAAK/C;qDACfG;;AALd,GAOM,4DAAA,5DAACX,mDAAK4I;AACN,OAACjB,8DAAO,WAAKC;AAAL,AACE,OAAC/B,uDAAE,CAACpE,oCAAAA,uCAAAA,LAAImG,mBAAAA,IACL,AAACC,iEAAG,AAACtE,eAAKlE,UACN,AAACkE,eAAK/C;qDACfC;;AAZd;;;;;AALd,AAkBE,OAACoF,uDAAE,AAACgC,GAAGxI,KAAKmB,WACTyH;;;IA9BW5I;;;;EAAAA;;uFAAAA;;;IAAAA;6EAAAA;;;;;CA+BGmB","names":["var_args","G__101566","sicmutils.calculus.indexed/meta-k","js/Error","f","k","sicmutils.calculus.indexed.meta_k","default","sicmutils.operator/operator?","G__101568","G__101569","sicmutils.operator/context","G__101570","G__101571","cljs.core/meta","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","sicmutils.calculus.indexed/with-kvs","seq101572","G__101573","cljs.core/first","cljs.core/next","self__4851__auto__","kvs","sicmutils.operator/with-context","cljs.core.apply","cljs.core/assoc","cljs.core/vary-meta","sicmutils.calculus.indexed/argument-types","sicmutils.calculus.indexed/has-argument-types?","cljs.core/boolean","cljs.core/seq","sicmutils.calculus.indexed/with-argument-types","types","args","cljs.core.into","sicmutils.calculus.indexed.with_kvs","cljs.core/count","sicmutils.calculus.indexed/index-types","sicmutils.calculus.indexed/has-index-types?","sicmutils.calculus.indexed/with-index-types","v","sicmutils.calculus.indexed/valid-arg-types?","ts","t","cljs.core.isa_QMARK_","cljs.core/every?","cljs.core.some_fn","one-ff?","vf?","cljs.core.drop_while","sicmutils.calculus.indexed/typed->indexed","basis","arg-types","vector-basis","sicmutils.calculus.basis/basis->vector-basis","oneform-basis","sicmutils.calculus.basis/basis->oneform-basis","idx-types","cljs.core.map","indices","cljs.core._EQ_","cljs.core.mapv","idx","cljs.core.get","sicmutils.calculus.indexed/valid-index-types?","sicmutils.calculus.indexed/validate-typed-args!","index-types","cljs.core/true?","index-type","arg","sicmutils.calculus.form-field/oneform-field?","sicmutils.calculus.vector-field/vector-field?","cljs.core.pr_str","sicmutils.calculus.indexed/indexed->typed","indexed","n","sicmutils.calculus.basis/basis->dimension","n-seq","cljs.core/reverse","cljs.core.range","combos","sicmutils.util.permute/cartesian-product","iter__4652__auto__","s__101589","cljs.core/LazySeq","temp__5753__auto__","cljs.core/chunked-seq?","c__4650__auto__","size__4651__auto__","b__101591","cljs.core/chunk-buffer","i__101590","cljs.core/-nth","cljs.core/chunk-append","cljs.core/chunk-cons","cljs.core/chunk","iter__101588","cljs.core/chunk-rest","cljs.core/cons","cljs.core/rest","x","i","fexpr__101592","fexpr__101594","G__101593","G__101595","cljs.core.repeat","G__101596","sicmutils.util.aggregate/generic-sum","s__101598","b__101600","i__101599","iter__101597","combo","product-args","cljs.core/peek","sicmutils.generic/*","sicmutils.calculus.indexed/outer-product","T1","T2","i1","i2","map__101601","cljs.core/--destructure-map","map__101602","nu1","nd1","cljs.core/frequencies","nu2","nd2","nup","sicmutils.generic._PLUS_","or__4253__auto__","ndp","np","n1","argv","sicmutils.generic._STAR_","G__101605","cljs.core.subvec","G__101606","product","cljs.core.concat","coll","l","r","cljs.core/conj","sicmutils.calculus.indexed/contract","T","u","d","i-types","map__101607","nu","nd","nuc","ndc","G__101608","G__101609","G__101610","G__101611","insertv","sicmutils.calculus.indexed/typed->structure","cljs.core/empty?","vec__101617","seq__101618","first__101619","sicmutils.structure.mapr","e","lp","cljs.core.conj","sicmutils.util/illegal","sicmutils.calculus.indexed/structure->typed","coeff-functions","cf","acc","sicmutils.structure/structure?","shape","G__101624","sicmutils.structure/opposite-orientation","sicmutils.structure/orientation","G__101628","cljs.core/Keyword","cljs.core.nth","arg-type","sicmutils.value/kind","sicmutils.calculus.manifold/one-manifold-function","etilde","cljs.core/chunk-first"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.calculus.indexed\n  \"This namespace implements minimal support for indexed objects and typed\n  functions.\"\n  (:refer-clojure :exclude [+ - * /])\n  (:require [sicmutils.calculus.basis :as b]\n            [sicmutils.calculus.form-field :as ff]\n            [sicmutils.calculus.manifold :as m]\n            [sicmutils.calculus.vector-field :as vf]\n            [sicmutils.generic :as g :refer [+ *]]\n            [sicmutils.operator :as o]\n            [sicmutils.structure :as s]\n            [sicmutils.util :as u]\n            [sicmutils.util.aggregate :as ua]\n            [sicmutils.util.permute :as permute]\n            [sicmutils.value :as v]))\n\n;; ## Minimal support for Indexed Objects\n;;\n;; Indices here are the components of tensors relative to a basis.\n\n(defn- meta-k\n  \"Takes a function or operator `f` and a metadata (or context) key `k` and\n  attempts to fetch it from the metadata (or context). Returns `default` if `k`\n  has no entry.\"\n  ([f k]\n   (meta-k f k nil))\n  ([f k default]\n   (if (o/operator? f)\n     (k (o/context f) default)\n     (k (meta f) default))))\n\n(defn- with-kvs\n  \"Returns a copy of `f` with the `k`, `v` pair added to its metadata (if a\n  function) or context (if an operator).\"\n  [f & kvs]\n  (if (o/operator? f)\n    (o/with-context f (apply assoc (o/context f) kvs))\n    (apply vary-meta f assoc kvs)))\n\n(defn argument-types\n  \"Given an operator or function `f`, returns its registered vector of argument\n  types, or `[]` if none exist.\n\n  argument types are, for example,\n\n  ```clojure\n  [::ff/oneform-field ::vf/vector-field ::vf/vector-field]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.\"\n  [f]\n  (meta-k f :arguments []))\n\n(defn ^:no-doc has-argument-types?\n  \"Returns true if `f` has any argument types registered, false otherwise.\"\n  [f]\n  (boolean\n   (seq (argument-types f))))\n\n(defn with-argument-types\n  \"Given some operator or function `f`, returns a copy of `f` with the supplied\n  argument types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[argument-types]].\"\n  [f types]\n  (let [args (into [] types)]\n    (with-kvs f\n      :arguments args\n      :arity [:exactly (count args)])))\n\n(defn index-types\n  \"Given an operator or function `f`, returns its registered vector of index\n  types, or `[]` if none exist.\n\n  index types are, for example,\n\n  ```clojure\n  ['up 'down 'down]\n  ```\n\n  for a `Christoffel-2`, which takes one oneform field and two vector fields.\"\n  [f]\n  (meta-k f :index-types []))\n\n(defn ^:no-doc has-index-types?\n  \"Returns true if `f` has any index types registered, false otherwise.\"\n  [f]\n  (boolean\n   (seq (index-types f))))\n\n(defn with-index-types\n  \"Given some operator or function `f`, returns a copy of `f` with the supplied\n  index types `types` registered in its metadata (if a function) or\n  context (if an operator).\n\n  Retrieve these types with [[index-types]].\"\n  [f types]\n  (let [v (into [] types)]\n    (with-kvs f\n      :index-types v\n      :arity [:exactly (count v)])))\n\n;; An argument-typed function of type (n . m) takes n oneform fields and m\n;; vector-fields, in that order, and produces a function on a manifold point.\n;;\n;; An indexed function of type (n . m) takes n+m indices and gives a function on\n;; a manifold point.\n;;\n;; For each argument-typed function and basis, there is an indexed function that\n;; gives the function resulting from applying the argument-typed function to the\n;; basis elements specified by the corresponding indices.\n\n(defn- valid-arg-types?\n  \"Returns true if `ts` is a well-formed-enough sequence of argument types to use\n  for generating an indexed function via [[typed->indexed]], false otherwise.\n\n  Validates that:\n\n  - The sequence of types `ts` is not empty\n  - every entry in `ts` derives from `::vf/vector-field` or `::ff/oneform-field`\n  - form fields come before vector fields.\"\n  [ts]\n  (letfn [(one-ff? [t]\n            (isa? t ::ff/oneform-field))\n          (vf? [t]\n            (isa? t ::vf/vector-field))]\n    (and (seq ts)\n         (every? (some-fn one-ff? vf?) ts)\n         (every? vf? (drop-while one-ff? ts)))))\n\n(defn typed->indexed [f basis]\n  (let [arg-types (argument-types f)]\n    (assert (valid-arg-types? arg-types)\n            (str \"Invalid arg types: \" arg-types))\n    (let [vector-basis (b/basis->vector-basis basis)\n          oneform-basis (b/basis->oneform-basis basis)\n          idx-types (map (fn [t]\n                           (if (isa? t ::vf/vector-field)\n                             'down\n                             'up))\n                         arg-types)]\n      (-> (fn indexed [indices]\n            (assert (= (count indices)\n                       (count arg-types))\n                    (str \"Indices count doesn't match expected argument types.\"\n                         \"  Indices:\" indices\n                         \", arg-types: \" arg-types))\n            (let [args (mapv (fn [t idx]\n                               (if (isa? t ::vf/vector-field)\n                                 (get vector-basis idx)\n                                 (get oneform-basis idx)))\n                             arg-types\n                             indices)]\n              (apply f args)))\n          (with-index-types idx-types)))))\n\n(defn- valid-index-types?\n  \"Returns true if `ts` is a well-formed-enough sequence of index types to use for\n  generating a typed function via [[indexed->typed]], false otherwise.\n\n  Validates that:\n\n  - The sequence of types `ts` is not empty\n  - every entry in `ts` is either the symbol `'up` or `'down`\n  - all `'up` entries (corresponding to oneform fields) come before `'down`\n    entries (corresponding to vector fields)\"\n  [ts]\n  (boolean\n   (and (seq ts)\n        (every? #{'up 'down} ts)\n        (every? #{'down} (drop-while #{'up} ts)))))\n\n(defn- validate-typed-args!\n  \"Returns true if:\n\n  - every argument in `args` has a corresponding index type in `index-types`\n  - every `'up` in `index-types` is aligned with a [[form-field/oneform-field?]]\n    argument in `args`\n  - every `'down` in `index-types` is aligned with a [[vector-field/vector-field?]]\n    argument in `args`\n\n  false otherwise.\n\n  `index-types` is assumed to have passed a [[valid-index-types?]] check.\"\n  [index-types args]\n  (assert (= (count index-types)\n             (count args))\n          (str \"The number \"\n               (count index-types) \" of index-types doesn't match the number \"\n               (count args) \" of arguments.\"))\n  (assert (every? true?\n                  (map (fn [index-type arg]\n                         (or (and (= index-type 'up)\n                                  (ff/oneform-field? arg))\n                             (and (= index-type 'down)\n                                  (vf/vector-field? arg))))\n                       index-types\n                       args))\n          (str \"Args do not match index-types 'up must be paired with oneform-fields and 'down with vector fields.\"\n               \" Args:\" (pr-str args)\n               \", indices: \" (pr-str index-types))))\n\n(defn indexed->typed [indexed basis]\n  (let [index-types (index-types indexed)]\n    (assert (valid-index-types? index-types)\n            (str \"Invalid index types: \" index-types))\n    (let [vector-basis  (b/basis->vector-basis basis)\n          oneform-basis (b/basis->oneform-basis basis)\n          n              (b/basis->dimension basis)\n          arg-types (mapv {'up ::ff/oneform-field\n                           'down ::vf/vector-field}\n                          index-types)]\n      (-> (fn typed [& args]\n            (validate-typed-args! index-types args)\n            (let [n-seq  (reverse (range n))\n                  combos (permute/cartesian-product\n                          (for [x args]\n                            (map (fn [i arg]\n                                   [i (if (vf/vector-field? arg)\n                                        ((get oneform-basis i) arg)\n                                        (arg (get vector-basis i)))])\n                                 n-seq\n                                 (repeat x))))]\n              (ua/generic-sum\n               (for [combo combos\n                     :let [indices      (map first combo)\n                           product-args (map peek combo)]]\n                 (apply *\n                        (indexed indices)\n                        (reverse product-args))))))\n          (with-argument-types arg-types)))))\n\n(defn outer-product [T1 T2]\n  (let [i1 (index-types T1)\n        i2 (index-types T2)]\n    (assert (seq i1) \"No index types registered for T1!\")\n    (assert (seq i2) \"No index types registered for T2!\")\n    (let [{nu1 'up nd1 'down} (frequencies i1)\n          {nu2 'up nd2 'down} (frequencies i2)\n          nup (+ (or nu1 0) (or nu2 0))\n          ndp (+ (or nd1 0) (or nd2 0))\n          np  (+ nup ndp)\n          n1  (+ nup nd1)]\n      (letfn [(product [args]\n                (assert (= (count args) np)\n                        (str \"Wrong number of args to outer-product: \"\n                             (count args)\n                             \", expected: \" np))\n                (let [argv (into [] args)]\n                  (* (T1 (into (subvec argv 0 nu1)\n                               (subvec argv nup n1)))\n                     (T2 (into (subvec argv nu1 nup)\n                               (subvec argv n1 np))))))]\n        (with-index-types product\n          (concat (repeat nup 'up)\n                  (repeat ndp 'down)))))))\n\n(letfn [(insertv [coll i v]\n          (let [l (subvec coll 0 i)\n                r (subvec coll i)]\n            (apply conj l v r)))]\n\n  (defn contract [T u d n]\n    (let [i-types (index-types T)]\n      (assert (seq i-types) \"No index types registered for T!\")\n      (let [{nu 'up nd 'down} (frequencies i-types)]\n        (assert (and (<= 0 u) (< u nu)\n                     (<= 0 d) (< d nd))\n                (str \"Contraction indices \" u \", \" d \"  not in the correct range. \"\n                     \"Each must be >= 0 and < the respective number of \"\n                     \"'up and 'down instances in the index types registered with T. \"\n                     \"These were \" nu \" and \" nd \".\"))\n        (let [nuc (dec nu)\n              ndc (dec nd)]\n          (-> (fn contraction [args]\n                (let [argv (into [] args)]\n                  (ua/generic-sum\n                   (fn [i]\n                     (T (concat\n                         (insertv (subvec argv 0 nuc) u i)\n                         (insertv (subvec argv nuc) d i))))\n                   0 n)))\n              (with-index-types\n                (concat (repeat nuc 'up)\n                        (repeat ndc 'down)))))))))\n\n(defn typed->structure [T basis]\n  (let [vector-basis  (b/basis->vector-basis basis)\n        oneform-basis (b/basis->oneform-basis basis)]\n    (letfn [(lp [arg-types argv]\n              (if (empty? arg-types)\n                (apply T argv)\n                (let [[t & ts] arg-types]\n                  (s/mapr (fn [e]\n                            (lp ts (conj argv e)))\n                          (cond (isa? t ::vf/vector-field)\n                                vector-basis\n\n                                (isa? t ::ff/oneform-field)\n                                oneform-basis\n\n                                :else (u/illegal\n                                       (str \"Invalid argument type: \" (pr-str t)\n                                            \". Every arg must be a vector field or oneform field.\")))))))]\n      (lp (argument-types T) []))))\n\n(defn structure->typed [coeff-functions basis]\n  (let [vector-basis  (b/basis->vector-basis basis)\n        oneform-basis (b/basis->oneform-basis basis)\n        arg-types     (loop [cf  coeff-functions\n                             acc []]\n                        (if-not (s/structure? cf)\n                          acc\n                          (let [shape (s/opposite-orientation\n                                       (s/orientation cf))\n                                t (case shape\n                                    ::s/up ::vf/vector-field\n                                    ::s/down ::ff/oneform-field)]\n                            (recur (nth cf 0)\n                                   (conj acc t)))))]\n    (-> (fn indexed-fn [& args]\n          (assert (= (count args)\n                     (count arg-types))\n                  (str \"The number of args \" (count args)\n                       \" did not match the expected arity \" (count arg-types) \". \"\n                       \"Please supply args corresponding to the expected types \" arg-types \".\"))\n          (assert (every? true? (map (fn [arg arg-type]\n                                       (isa? (v/kind arg) arg-type))\n                                     args arg-types))\n                  (str \"Invalid arguments: \" args \". \"\n                       \"Please supply args corresponding to the expected types \" arg-types \".\"))\n          (letfn [(lp [args arg-types]\n                    (if (empty? args)\n                      m/one-manifold-function\n                      (let [arg (first args)\n                            arg-type (first arg-types)]\n                        (cond (isa? arg-type ::vf/vector-field)\n                              (s/mapr (fn [etilde]\n                                        (* (etilde arg)\n                                           (lp (rest args)\n                                               (rest arg-types))))\n                                      oneform-basis)\n\n                              (isa? arg-type ::ff/oneform-field)\n                              (s/mapr (fn [e]\n                                        (* (arg e)\n                                           (lp (rest args)\n                                               (rest arg-types))))\n                                      vector-basis)))))]\n            (* (lp args arg-types)\n               coeff-functions)))\n        (with-argument-types arg-types))))\n"]}