{
"version":3,
"file":"module$node_modules$punycode$punycode.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/punycode/punycode.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$punycode$punycode\"] = function(global,require,module,exports) {\n'use strict';\n\n/** Highest positive signed 32-bit float value */\nconst maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nconst base = 36;\nconst tMin = 1;\nconst tMax = 26;\nconst skew = 38;\nconst damp = 700;\nconst initialBias = 72;\nconst initialN = 128; // 0x80\nconst delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nconst regexPunycode = /^xn--/;\nconst regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nconst regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nconst errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nconst baseMinusTMin = base - tMin;\nconst floor = Math.floor;\nconst stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tconst result = [];\n\tlet length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tconst parts = string.split('@');\n\tlet result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tconst labels = string.split('.');\n\tconst encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tconst output = [];\n\tlet counter = 0;\n\tconst length = string.length;\n\twhile (counter < length) {\n\t\tconst value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tconst extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) { // Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nconst ucs2encode = array => String.fromCodePoint(...array);\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nconst basicToDigit = function(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nconst digitToBasic = function(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nconst adapt = function(delta, numPoints, firstTime) {\n\tlet k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nconst decode = function(input) {\n\t// Don't use UCS-2.\n\tconst output = [];\n\tconst inputLength = input.length;\n\tlet i = 0;\n\tlet n = initialN;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tlet basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (let j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (let index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tlet oldi = i;\n\t\tfor (let w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror('invalid-input');\n\t\t\t}\n\n\t\t\tconst digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\n\t\t}\n\n\t\tconst out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\n\t}\n\n\treturn String.fromCodePoint(...output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nconst encode = function(input) {\n\tconst output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tlet inputLength = input.length;\n\n\t// Initialize the state.\n\tlet n = initialN;\n\tlet delta = 0;\n\tlet bias = initialBias;\n\n\t// Handle the basic code points.\n\tfor (const currentValue of input) {\n\t\tif (currentValue < 0x80) {\n\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t}\n\t}\n\n\tlet basicLength = output.length;\n\tlet handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tlet m = maxInt;\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\tm = currentValue;\n\t\t\t}\n\t\t}\n\n\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t// but guard against overflow.\n\t\tconst handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tfor (const currentValue of input) {\n\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\t\t\tif (currentValue == n) {\n\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\tlet q = delta;\n\t\t\t\tfor (let k = base; /* no condition */; k += base) {\n\t\t\t\t\tconst t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tconst qMinusT = q - t;\n\t\t\t\t\tconst baseMinusT = base - t;\n\t\t\t\t\toutput.push(\n\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t);\n\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t}\n\n\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\tdelta = 0;\n\t\t\t\t++handledCPCount;\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nconst toUnicode = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexPunycode.test(string)\n\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t: string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nconst toASCII = function(input) {\n\treturn mapDomain(input, function(string) {\n\t\treturn regexNonASCII.test(string)\n\t\t\t? 'xn--' + encode(string)\n\t\t\t: string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nconst punycode = {\n\t/**\n\t * A string representing the current Punycode.js version number.\n\t * @memberOf punycode\n\t * @type String\n\t */\n\t'version': '2.1.0',\n\t/**\n\t * An object of methods to convert from JavaScript's internal character\n\t * representation (UCS-2) to Unicode code points, and back.\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode\n\t * @type Object\n\t */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\nmodule.exports = punycode;\n\n};"],
"names":["shadow$provide","global","require","module","exports","error","type","RangeError","errors","mapDomain","string","fn","parts","split","result","length","replace","regexSeparators","labels","array","encoded","join","ucs2decode","output","counter","value","charCodeAt","extra","push","regexPunycode","regexNonASCII","floor","Math","stringFromCharCode","String","fromCharCode","adapt","delta","numPoints","firstTime","k","damp","base","baseMinusTMin","skew","decode","input","inputLength","i","n","initialN","bias","initialBias","basic","lastIndexOf","delimiter","j","index","oldi","w","digit","codePoint","maxInt","t","tMin","tMax","baseMinusT","out","splice","fromCodePoint","encode","currentValue","handledCPCount","basicLength","m","handledCPCountPlusOne","q","qMinusT","punycode","ucs2encode","toASCII","test","toUnicode","slice","toLowerCase"]
}
