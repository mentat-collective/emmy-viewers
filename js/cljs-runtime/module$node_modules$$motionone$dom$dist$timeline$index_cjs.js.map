{
"version":3,
"file":"module$node_modules$$motionone$dom$dist$timeline$index_cjs.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/@motionone/dom/dist/timeline/index.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$motionone$dom$dist$timeline$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar tslib = require('tslib');\nvar heyListen = require('hey-listen');\nvar utils = require('@motionone/utils');\nvar stagger = require('../utils/stagger.cjs.js');\nvar animateStyle = require('../animate/animate-style.cjs.js');\nvar controls = require('../animate/utils/controls.cjs.js');\nvar keyframes = require('../animate/utils/keyframes.cjs.js');\nvar options = require('../animate/utils/options.cjs.js');\nvar resolveElements = require('../utils/resolve-elements.cjs.js');\nvar transforms = require('../animate/utils/transforms.cjs.js');\nvar calcTime = require('./utils/calc-time.cjs.js');\nvar edit = require('./utils/edit.cjs.js');\nvar sort = require('./utils/sort.cjs.js');\n\nfunction timeline(definition, options = {}) {\n    var _a;\n    const animationDefinitions = createAnimationsFromTimeline(definition, options);\n    /**\n     * Create and start animations\n     */\n    const animationFactories = animationDefinitions\n        .map((definition) => animateStyle.animateStyle(...definition))\n        .filter(Boolean);\n    return controls.withControls(animationFactories, options, \n    // Get the duration from the first animation definition\n    (_a = animationDefinitions[0]) === null || _a === void 0 ? void 0 : _a[3].duration);\n}\nfunction createAnimationsFromTimeline(definition, _a = {}) {\n    var { defaultOptions = {} } = _a, timelineOptions = tslib.__rest(_a, [\"defaultOptions\"]);\n    const animationDefinitions = [];\n    const elementSequences = new Map();\n    const elementCache = {};\n    const timeLabels = new Map();\n    let prevTime = 0;\n    let currentTime = 0;\n    let totalDuration = 0;\n    /**\n     * Build the timeline by mapping over the definition array and converting\n     * the definitions into keyframes and offsets with absolute time values.\n     * These will later get converted into relative offsets in a second pass.\n     */\n    for (let i = 0; i < definition.length; i++) {\n        const segment = definition[i];\n        /**\n         * If this is a timeline label, mark it and skip the rest of this iteration.\n         */\n        if (utils.isString(segment)) {\n            timeLabels.set(segment, currentTime);\n            continue;\n        }\n        else if (!Array.isArray(segment)) {\n            timeLabels.set(segment.name, calcTime.calcNextTime(currentTime, segment.at, prevTime, timeLabels));\n            continue;\n        }\n        const [elementDefinition, keyframes$1, options$1 = {}] = segment;\n        /**\n         * If a relative or absolute time value has been specified we need to resolve\n         * it in relation to the currentTime.\n         */\n        if (options$1.at !== undefined) {\n            currentTime = calcTime.calcNextTime(currentTime, options$1.at, prevTime, timeLabels);\n        }\n        /**\n         * Keep track of the maximum duration in this definition. This will be\n         * applied to currentTime once the definition has been parsed.\n         */\n        let maxDuration = 0;\n        /**\n         * Find all the elements specified in the definition and parse value\n         * keyframes from their timeline definitions.\n         */\n        const elements = resolveElements.resolveElements(elementDefinition, elementCache);\n        const numElements = elements.length;\n        for (let elementIndex = 0; elementIndex < numElements; elementIndex++) {\n            const element = elements[elementIndex];\n            const elementSequence = getElementSequence(element, elementSequences);\n            for (const key in keyframes$1) {\n                const valueSequence = getValueSequence(key, elementSequence);\n                let valueKeyframes = keyframes.keyframesList(keyframes$1[key]);\n                const valueOptions = options.getOptions(options$1, key);\n                let { duration = defaultOptions.duration || utils.defaults.duration, easing = defaultOptions.easing || utils.defaults.easing, } = valueOptions;\n                if (utils.isEasingGenerator(easing)) {\n                    const valueIsTransform = transforms.isTransform(key);\n                    heyListen.invariant(valueKeyframes.length === 2 || !valueIsTransform, \"spring must be provided 2 keyframes within timeline\");\n                    const custom = easing.createAnimation(valueKeyframes, \n                    // TODO We currently only support explicit keyframes\n                    // so this doesn't currently read from the DOM\n                    () => \"0\", valueIsTransform);\n                    easing = custom.easing;\n                    if (custom.keyframes !== undefined)\n                        valueKeyframes = custom.keyframes;\n                    if (custom.duration !== undefined)\n                        duration = custom.duration;\n                }\n                const delay = stagger.resolveOption(options$1.delay, elementIndex, numElements) || 0;\n                const startTime = currentTime + delay;\n                const targetTime = startTime + duration;\n                /**\n                 *\n                 */\n                let { offset = utils.defaultOffset(valueKeyframes.length) } = valueOptions;\n                /**\n                 * If there's only one offset of 0, fill in a second with length 1\n                 *\n                 * TODO: Ensure there's a test that covers this removal\n                 */\n                if (offset.length === 1 && offset[0] === 0) {\n                    offset[1] = 1;\n                }\n                /**\n                 * Fill out if offset if fewer offsets than keyframes\n                 */\n                const remainder = length - valueKeyframes.length;\n                remainder > 0 && utils.fillOffset(offset, remainder);\n                /**\n                 * If only one value has been set, ie [1], push a null to the start of\n                 * the keyframe array. This will let us mark a keyframe at this point\n                 * that will later be hydrated with the previous value.\n                 */\n                valueKeyframes.length === 1 && valueKeyframes.unshift(null);\n                /**\n                 * Add keyframes, mapping offsets to absolute time.\n                 */\n                edit.addKeyframes(valueSequence, valueKeyframes, easing, offset, startTime, targetTime);\n                maxDuration = Math.max(delay + duration, maxDuration);\n                totalDuration = Math.max(targetTime, totalDuration);\n            }\n        }\n        prevTime = currentTime;\n        currentTime += maxDuration;\n    }\n    /**\n     * For every element and value combination create a new animation.\n     */\n    elementSequences.forEach((valueSequences, element) => {\n        for (const key in valueSequences) {\n            const valueSequence = valueSequences[key];\n            /**\n             * Arrange all the keyframes in ascending time order.\n             */\n            valueSequence.sort(sort.compareByTime);\n            const keyframes = [];\n            const valueOffset = [];\n            const valueEasing = [];\n            /**\n             * For each keyframe, translate absolute times into\n             * relative offsets based on the total duration of the timeline.\n             */\n            for (let i = 0; i < valueSequence.length; i++) {\n                const { at, value, easing } = valueSequence[i];\n                keyframes.push(value);\n                valueOffset.push(utils.progress(0, totalDuration, at));\n                valueEasing.push(easing || utils.defaults.easing);\n            }\n            /**\n             * If the first keyframe doesn't land on offset: 0\n             * provide one by duplicating the initial keyframe. This ensures\n             * it snaps to the first keyframe when the animation starts.\n             */\n            if (valueOffset[0] !== 0) {\n                valueOffset.unshift(0);\n                keyframes.unshift(keyframes[0]);\n                valueEasing.unshift(\"linear\");\n            }\n            /**\n             * If the last keyframe doesn't land on offset: 1\n             * provide one with a null wildcard value. This will ensure it\n             * stays static until the end of the animation.\n             */\n            if (valueOffset[valueOffset.length - 1] !== 1) {\n                valueOffset.push(1);\n                keyframes.push(null);\n            }\n            animationDefinitions.push([\n                element,\n                key,\n                keyframes,\n                Object.assign(Object.assign(Object.assign({}, defaultOptions), { duration: totalDuration, easing: valueEasing, offset: valueOffset }), timelineOptions),\n            ]);\n        }\n    });\n    return animationDefinitions;\n}\nfunction getElementSequence(element, sequences) {\n    !sequences.has(element) && sequences.set(element, {});\n    return sequences.get(element);\n}\nfunction getValueSequence(name, sequences) {\n    if (!sequences[name])\n        sequences[name] = [];\n    return sequences[name];\n}\n\nexports.createAnimationsFromTimeline = createAnimationsFromTimeline;\nexports.timeline = timeline;\n\n};"],
"names":["shadow$provide","global","require","module","exports","createAnimationsFromTimeline","definition","_a","defaultOptions","timelineOptions","tslib","__rest","animationDefinitions","elementSequences","Map","elementCache","timeLabels","prevTime","currentTime","totalDuration","i","length","segment","utils","isString","set","Array","isArray","name","calcTime","calcNextTime","at","elementDefinition","keyframes$1","options$1","undefined","maxDuration","elements","resolveElements","numElements","elementIndex","elementSequence","getElementSequence","element","key","valueSequence","getValueSequence","valueKeyframes","keyframes","keyframesList","valueOptions","options","getOptions","duration","defaults","easing","isEasingGenerator","valueIsTransform","transforms","isTransform","heyListen","invariant","custom","createAnimation","delay","stagger","resolveOption","startTime","targetTime","offset","defaultOffset","remainder","fillOffset","unshift","edit","addKeyframes","Math","max","forEach","valueSequences","sort","compareByTime","valueOffset","valueEasing","value","push","progress","Object","assign","sequences","has","get","defineProperty","animateStyle","controls","timeline","animationFactories","map","filter","Boolean","withControls"]
}
