shadow$provide.module$node_modules$mathbox$build$esm$util$data=function(global,require,module,exports){function __range__(left,right,inclusive){const range=[],ascending=left<right;for(right=inclusive?ascending?right+1:right-1:right;ascending?left<right:left>right;ascending?left++:left--)range.push(left);return range}Object.defineProperty(exports,"__esModule",{value:!0});exports.getLerpThunk=exports.getLerpEmitter=exports.getStreamer=exports.getThunk=exports.makeEmitter=exports.repeatCall=exports.getDimensions=
exports.getSizes=void 0;const getSizes=function(data){const sizes=[];for(;"string"!==typeof data&&null!=(null!=data?data.length:void 0);)sizes.push(data.length),data=data[0];return sizes};exports.getSizes=getSizes;exports.getDimensions=function(data,spec){let left;null==spec&&(spec={});const {items,channels,width,height,depth}=spec;spec={};if(!data||!data.length)return{items,channels,width:null!=width?width:0,height:null!=height?height:0,depth:null!=depth?depth:0};data=getSizes(data);var nesting=
data.length;spec.channels=1!==channels&&1<data.length?data.pop():channels;spec.items=1!==items&&1<data.length?data.pop():items;spec.width=1!==width&&1<data.length?data.pop():width;spec.height=1!==height&&1<data.length?data.pop():height;spec.depth=1!==depth&&1<data.length?data.pop():depth;1===channels&&nesting++;1===items&&1<nesting&&nesting++;1===width&&2<nesting&&nesting++;1===height&&3<nesting&&nesting++;data=null!=(left=data.pop())?left:1;1>=nesting&&(data/=null!=spec.channels?spec.channels:1);
2>=nesting&&(data/=null!=spec.items?spec.items:1);3>=nesting&&(data/=null!=spec.width?spec.width:1);4>=nesting&&(data/=null!=spec.height?spec.height:1);data=Math.floor(data);null==spec.width&&(spec.width=data,data=1);null==spec.height&&(spec.height=data,data=1);null==spec.depth&&(spec.depth=data);return spec};exports.repeatCall=function(call,times){switch(times){case 0:return()=>!0;case 1:return()=>call();case 2:return function(){call();return call()};case 3:return function(){call();call();call();
return call()};case 4:return function(){call();call();call();return call()};case 6:return function(){call();call();call();call();call();return call()};case 8:return function(){call();call();call();call();call();return call()}}};exports.makeEmitter=function(thunk,items,channels){let outer$jscomp$0;const inner=(()=>{switch(channels){case 0:return()=>!0;case 1:return emit=>emit(thunk());case 2:return emit=>emit(thunk(),thunk());case 3:return emit=>emit(thunk(),thunk(),thunk());case 4:return emit=>emit(thunk(),
thunk(),thunk(),thunk());case 6:return emit=>emit(thunk(),thunk(),thunk(),thunk(),thunk(),thunk());case 8:return emit=>emit(thunk(),thunk(),thunk(),thunk(),thunk(),thunk(),thunk(),thunk())}})();let next$jscomp$0=null;for(;0<items;){const n=Math.min(items,8);outer$jscomp$0=(()=>{switch(n){case 1:return emit=>inner(emit);case 2:return function(emit){inner(emit);return inner(emit)};case 3:return function(emit){inner(emit);inner(emit);return inner(emit)};case 4:return function(emit){inner(emit);inner(emit);
inner(emit);return inner(emit)};case 5:return function(emit){inner(emit);inner(emit);inner(emit);inner(emit);return inner(emit)};case 6:return function(emit){inner(emit);inner(emit);inner(emit);inner(emit);inner(emit);return inner(emit)};case 7:return function(emit){inner(emit);inner(emit);inner(emit);inner(emit);inner(emit);inner(emit);return inner(emit)};case 8:return function(emit){inner(emit);inner(emit);inner(emit);inner(emit);inner(emit);inner(emit);inner(emit);return inner(emit)}}})();next$jscomp$0=
null!=next$jscomp$0?((outer,next)=>function(emit){outer(emit);return next(emit)})(outer$jscomp$0,next$jscomp$0):outer$jscomp$0;items-=n}outer$jscomp$0=null!=next$jscomp$0?next$jscomp$0:()=>!0;outer$jscomp$0.reset=thunk.reset;outer$jscomp$0.rebind=thunk.rebind;return outer$jscomp$0};const getThunk=function(data){let thunk,j,k,l,m,sizes=getSizes(data);const nesting=sizes.length;let a=sizes.pop(),b=sizes.pop(),c=sizes.pop();const d$jscomp$0=sizes.pop();let i,first,second,third,fourth;switch(nesting){case 0:thunk=
()=>0;thunk.reset=function(){};break;case 1:i=0;thunk=()=>data[i++];thunk.reset=()=>i=0;break;case 2:i=j=0;first=null!=data[j]?data[j]:[];thunk=function(){const x=first[i++];i===a&&(i=0,j++,first=null!=data[j]?data[j]:[]);return x};thunk.reset=function(){i=j=0;first=null!=data[j]?data[j]:[]};break;case 3:i=j=k=0;second=null!=data[k]?data[k]:[];first=null!=second[j]?second[j]:[];thunk=function(){const x=first[i++];i===a&&(i=0,j++,j===b&&(j=0,k++,second=null!=data[k]?data[k]:[]),first=null!=second[j]?
second[j]:[]);return x};thunk.reset=function(){i=j=k=0;second=null!=data[k]?data[k]:[];first=null!=second[j]?second[j]:[]};break;case 4:i=j=k=l=0;third=null!=data[l]?data[l]:[];second=null!=third[k]?third[k]:[];first=null!=second[j]?second[j]:[];thunk=function(){const x=first[i++];i===a&&(i=0,j++,j===b&&(j=0,k++,k===c&&(k=0,l++,third=null!=data[l]?data[l]:[]),second=null!=third[k]?third[k]:[]),first=null!=second[j]?second[j]:[]);return x};thunk.reset=function(){i=j=k=l=0;third=null!=data[l]?data[l]:
[];second=null!=third[k]?third[k]:[];first=null!=second[j]?second[j]:[]};break;case 5:i=j=k=l=m=0,fourth=null!=data[m]?data[m]:[],third=null!=fourth[l]?fourth[l]:[],second=null!=third[k]?third[k]:[],first=null!=second[j]?second[j]:[],thunk=function(){const x=first[i++];i===a&&(i=0,j++,j===b&&(j=0,k++,k===c&&(k=0,l++,l===d$jscomp$0&&(l=0,m++,fourth=null!=data[m]?data[m]:[]),third=null!=fourth[l]?fourth[l]:[]),second=null!=third[k]?third[k]:[]),first=null!=second[j]?second[j]:[]);return x},thunk.reset=
function(){i=j=k=l=m=0;fourth=null!=data[m]?data[m]:[];third=null!=fourth[l]?fourth[l]:[];second=null!=third[k]?third[k]:[];first=null!=second[j]?second[j]:[]}}thunk.rebind=function(d){data=d;sizes=getSizes(data);sizes.length&&(a=sizes.pop());sizes.length&&(b=sizes.pop());sizes.length&&(c=sizes.pop());if(sizes.length)return sizes.pop()};return thunk};exports.getThunk=getThunk;exports.getStreamer=function(array,samples,channels,items){let i,j,limit=i=j=0;const reset=function(){limit=samples*channels*
items;return i=j=0},skip=(()=>{switch(channels){case 1:return function(n){i+=n;j+=n};case 2:return function(n){i+=2*n;j+=n};case 3:return function(n){i+=3*n;j+=n};case 4:return function(n){i+=4*n;j+=n}}})(),consume=(()=>{switch(channels){case 1:return function(emit){emit(array[i++]);++j};case 2:return function(emit){emit(array[i++],array[i++]);++j};case 3:return function(emit){emit(array[i++],array[i++],array[i++]);++j};case 4:return function(emit){emit(array[i++],array[i++],array[i++],array[i++]);
++j}}})(),emit$jscomp$0=(()=>{switch(channels){case 1:return function(x){array[i++]=x;++j};case 2:return function(x,y){array[i++]=x;array[i++]=y;++j};case 3:return function(x,y,z){array[i++]=x;array[i++]=y;array[i++]=z;++j};case 4:return function(x,y,z,w){array[i++]=x;array[i++]=y;array[i++]=z;array[i++]=w;++j}}})();consume.reset=reset;emit$jscomp$0.reset=reset;reset();return{emit:emit$jscomp$0,consume,skip,count:()=>j,done:()=>0>=limit-i,reset}};exports.getLerpEmitter=function(expr1,expr2){let lerp2,
q,r,s;const scratch=new Float32Array(4096);let lerp1=lerp2=.5,p=q=r=s=0;const emit1=function(x,y,z,w){r++;scratch[p++]=x*lerp1;scratch[p++]=y*lerp1;scratch[p++]=z*lerp1;return scratch[p++]=w*lerp1},emit2=function(x,y,z,w){s++;scratch[q++]+=x*lerp2;scratch[q++]+=y*lerp2;scratch[q++]+=z*lerp2;return scratch[q++]+=w*lerp2};var emitter=Math.max(expr1.length,expr2.length);emitter=3>=emitter?function(emit,x,i){p=q=r=s=0;expr1(emit1,x,i);expr2(emit2,x,i);let l=0;return __range__(0,Math.min(r,s),!1).map(_k=>
emit(scratch[l++],scratch[l++],scratch[l++],scratch[l++]))}:5>=emitter?function(emit,x,y,i,j){p=q=r=s=0;expr1(emit1,x,y,i,j);expr2(emit2,x,y,i,j);let l=0;return __range__(0,Math.min(r,s),!1).map(_k=>emit(scratch[l++],scratch[l++],scratch[l++],scratch[l++]))}:7>=emitter?function(emit,x,y,z,i,j,k){p=q=r=s=0;expr1(emit1,x,y,z,i,j,k);expr2(emit2,x,y,z,i,j,k);x=Math.min(r,s);y=0;i=[];k=0;for(z=0<=x;z?k<x:k>x;z?k++:k--)i.push(emit(scratch[y++],scratch[y++],scratch[y++],scratch[y++]));return i}:9>=emitter?
function(emit,x,y,z,w,i,j,k,l){p=q=r=s=0;expr1(emit1,x,y,z,w,i,j,k,l);expr2(emit2,x,y,z,w,i,j,k,l);x=Math.min(r,s);l=0;z=[];k=0;for(y=0<=x;y?k<x:k>x;y?k++:k--)z.push(emit(scratch[l++],scratch[l++],scratch[l++],scratch[l++]));return z}:function(emit,x,y,z,w,i,j,k,l,d,t){p=q=0;expr1(emit1,x,y,z,w,i,j,k,l,d,t);expr2(emit2,x,y,z,w,i,j,k,l,d,t);x=Math.min(r,s);l=0;z=[];k=0;for(y=0<=x;y?k<x:k>x;y?k++:k--)z.push(emit(scratch[l++],scratch[l++],scratch[l++],scratch[l++]));return z};emitter.lerp=function(f){let ref;
return[lerp1,lerp2]=Array.from(ref=[1-f,f]),ref};return emitter};exports.getLerpThunk=function(data1,data2){const n1=getSizes(data1).reduce((a,b)=>a*b),n2=getSizes(data2).reduce((a,b)=>a*b),n=Math.min(n1,n2),thunk1=getThunk(data1),thunk2=getThunk(data2),scratch=new Float32Array(n);scratch.lerp=function(f){thunk1.reset();thunk2.reset();let i=0;const result=[];for(;i<n;){const a=thunk1(),b=thunk2();result.push(scratch[i++]=a+(b-a)*f)}return result};return scratch}}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$util$data.js.map
