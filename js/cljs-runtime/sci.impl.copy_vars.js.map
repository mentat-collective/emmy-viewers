{"version":3,"sources":["sci/impl/copy_vars.cljc"],"mappings":"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","names":["sci.impl.copy-vars/inlined-vars","sci.impl.copy-vars/elide-vars","var_args","G__77628","sci.impl.copy-vars/macrofy*","js/Error","f","p1__77615#","cljs.core.vary_meta","cljs.core.assoc","sym","sci.impl.copy_vars.macrofy_STAR_","ns","ctx?","extra-meta","or__4253__auto__","sci.impl.utils/clojure-core-ns","sci.impl.utils.new_var","G__77657","and__4251__auto__","cljs.core.merge","G__77676","sci.impl.copy-vars/new-var","sci.impl.copy_vars.new_var","cljs.core/boolean?","sci.lang/Namespace","G__77722"],"sourcesContent":["(ns sci.impl.copy-vars\n  (:require\n   #?(:cljs [sci.impl.cljs])\n   [sci.impl.macros :as macros]\n   [sci.impl.utils :as utils :refer [clojure-core-ns]]\n   [sci.lang]\n   [sci.impl.cljs])\n  #?(:cljs (:require-macros [sci.impl.cljs :refer [require-cljs-analyzer-api]]\n                            [sci.impl.copy-vars :refer [copy-var copy-core-var macrofy]])))\n\n#?(:cljs (require-cljs-analyzer-api))\n\n#?(:clj (set! *warn-on-reflection* true))\n\n;; The following is produced with:\n;; (def inlined (filter (comp :inline meta) (vals (ns-publics 'clojure.core))))\n;; (map (comp :name meta) inlined)\n(def inlined-vars\n  '#{+' unchecked-remainder-int unchecked-subtract-int dec' short-array bit-shift-right aget = boolean bit-shift-left aclone dec < char unchecked-long unchecked-negate unchecked-inc-int floats pos? boolean-array alength bit-xor unsigned-bit-shift-right neg? unchecked-float num reduced? booleans int-array inc' <= -' * min get long double bit-and-not unchecked-add-int short quot unchecked-double longs unchecked-multiply-int int > unchecked-int unchecked-multiply unchecked-dec double-array float - byte-array zero? unchecked-dec-int rem nth nil? bit-and *' unchecked-add identical? unchecked-divide-int unchecked-subtract / bit-or >= long-array object-array doubles unchecked-byte unchecked-short float-array inc + aset chars ints bit-not byte max == count char-array compare shorts unchecked-negate-int unchecked-inc unchecked-char bytes})\n\n#?(:clj (def elide-vars (= \"true\" (System/getenv \"SCI_ELIDE_VARS\")))\n   ;; for self-hosted\n   :cljs (def elide-vars false))\n\n(macros/deftime\n\n  (defn ensure-quote [x]\n    (if (and (seq? x) (= 'quote (first x)))\n      x\n      (list 'quote x)))\n\n  (defn dequote [x]\n    (if (and (seq? x) (= 'quote (first x)))\n      (second x)\n      x))\n\n  (defn core-sym [sym]\n    (symbol \"clojure.core\" (name (dequote sym))))\n\n  (defn var-meta [&env sym opts & _a]\n    (let [sym (dequote sym)\n          macro (when opts (:macro opts))\n          nm (when opts (:name opts))\n          inline? (contains? inlined-vars sym)]\n      (merge (cond-> {:name (or nm (list 'quote (symbol (name sym))))}\n               macro (assoc :macro true)\n               inline? (assoc :sci.impl/inlined (:init opts sym)))\n             (let [#?@(:clj [the-var (macros/? :clj (resolve sym)\n                                               :cljs (atom nil))])]\n               (macros/? :clj #?(:clj  (let [m (meta the-var)\n                                             dyn (:dynamic m)\n                                             arglists (:arglists m)]\n                                         (cond-> {:doc (:doc m)}\n                                           dyn (assoc :dynamic dyn)\n                                           arglists (assoc :arglists (list 'quote (:arglists m)))))\n                                 :cljs nil)\n                         :cljs (let [r (sci.impl.cljs/cljs-resolve &env sym)\n                                     m (:meta r)\n                                     dyn (:dynamic m)\n                                     arglists (or (:arglists m) (:arglists r))]\n                                 (cond-> {:arglists (ensure-quote arglists)\n                                          :doc (or (:doc m) (:doc r))}\n                                   dyn (assoc :dynamic dyn)\n                                   arglists (assoc :arglists (ensure-quote arglists)))))))))\n\n  (defmacro macrofy [& args]\n    (let [[sym & args] args]\n      `(macrofy* ~sym ~@args ~@(repeat (- 3 (count args)) nil) ~(var-meta &env sym nil))))\n\n  (defmacro if-vars-elided [then else]\n    (if elide-vars\n      then else))\n  ;; Note: self hosted CLJS can't deal with multi-arity macros so this macro is split in 2\n  (if-vars-elided\n      (do\n        #?(:clj\n           (binding [*out* *err*]\n             (println \"SCI: eliding vars.\")))\n        (defmacro copy-var\n          [sym _ns & [_opts]] sym)\n        (defmacro copy-core-var [sym] sym))\n    (do\n      (defmacro copy-var\n        [sym ns & [opts]]\n        (let [macro (:macro opts)\n              #?@(:clj [the-var (macros/? :clj (resolve sym)\n                                          :cljs (atom nil))])\n              dyn (:dynamic opts)\n              varm (cond-> (assoc (var-meta &env (or (:name opts)\n                                                     (:copy-meta-from opts)\n                                                     sym)\n                                            opts)\n                                  :sci/built-in true\n                                  :ns ns)\n                     dyn (assoc :dynamic dyn))\n              nm (:name varm)\n              ctx (:ctx opts)\n              init (:init opts sym)]\n          ;; NOTE: emit as little code as possible, so our JS bundle is as small as possible\n          (if macro\n            (macros/? :clj\n                      #?(:clj  `(sci.lang.Var. ~(deref the-var) ~nm ~varm false ~ctx)\n                         :cljs `(sci.lang.Var. ~init ~nm ~varm false ~ctx))\n                      :cljs `(sci.lang.Var. ~init ~nm ~varm false ~ctx))\n            `(sci.lang.Var. ~init ~nm ~varm false ~ctx))))\n      (defmacro copy-core-var\n        [sym]\n        `(copy-var ~sym clojure-core-ns {:copy-meta-from ~(core-sym sym)})))))\n\n(defn macrofy*\n  ([f] (vary-meta f #(assoc % :sci/macro true)))\n  ([sym f] (macrofy* sym f nil false))\n  ([sym f ns] (macrofy* sym f ns false))\n  ([sym f ns ctx?] (macrofy* sym f ns ctx? nil))\n  ([sym f ns ctx? extra-meta]\n   (let [ns (or ns clojure-core-ns)]\n     (utils/new-var sym f (cond-> {:ns ns\n                                            :macro true\n                                            :sci/built-in true}\n                                     (and (not elide-vars)\n                                          extra-meta)\n                                     (merge extra-meta))\n                             ctx?))))\n\n(defn new-var\n  ([sym f] (new-var sym f nil false))\n  ([sym f ns] (new-var sym f ns false))\n  ([sym f ns ctx?] (new-var sym f ns ctx? nil))\n  ([sym f ns ctx? extra-meta]\n   (let [ctx? (or ctx? (true? ns))\n         ns (if (true? ns)\n              clojure-core-ns\n              (or ns clojure-core-ns))]\n     (assert (and (not (boolean? ns))\n                  (instance? sci.lang.Namespace ns)) sym)\n     (utils/new-var sym f (cond-> {:ns ns\n                                            :sci/built-in true}\n                                     (and (not elide-vars)\n                                          extra-meta)\n                                     (merge extra-meta))\n                             ctx?))))\n"]}