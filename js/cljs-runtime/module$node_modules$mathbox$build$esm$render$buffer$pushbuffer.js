shadow$provide.module$node_modules$mathbox$build$esm$render$buffer$pushbuffer=function(global,require,module,exports){function __range__(left,right,inclusive){const range=[],ascending=left<right;for(right=inclusive?ascending?right+1:right-1:right;ascending?left<right:left>right;ascending?left++:left--)range.push(left);return range}Object.defineProperty(exports,"__esModule",{value:!0});exports.PushBuffer=void 0;global=require("module$node_modules$mathbox$build$esm$render$buffer$buffer");class PushBuffer extends global.Buffer{constructor(renderer,
shaders,options){const width=options.width||1,height=options.height||1,depth=options.depth||1,samples=width*height*depth;options.samples||(options.samples=samples);super(renderer,shaders,options);this.width=width;this.height=height;this.depth=depth;null==this.samples&&(this.samples=samples);this.build(options)}build(_options){this.data=[];this.data.length=this.samples;this.filled=0;this.pad={x:0,y:0,z:0};return this.streamer=this.generate(this.data)}dispose(){this.data=null;return super.dispose()}getFilled(){return this.filled}setActive(i,
j,k){let ref;return[this.pad.x,this.pad.y,this.pad.z]=Array.from(ref=[this.width-i,this.height-j,this.depth-k]),ref}read(){return this.data}copy(data){const d=this.data;return __range__(0,Math.min(data.length,this.samples),!1).map(i=>d[i]=data[i])}fill(){let j,k,l,repeat;const {callback}=this;"function"===typeof callback.reset&&callback.reset();const {emit,skip,count,done,reset}=this.streamer;reset();const n=this.width,m=this.height,padX=this.pad.x,padY=this.pad.y,limit=this.samples-this.pad.z*n*
m;let i=j=k=l=0;if(0<padX||0<padY)for(;!done()&&l<limit&&(l++,repeat=callback(emit,i,j,k),++i===n-padX&&(skip(padX),i=0,++j===m-padY&&(skip(n*padY),j=0,k++)),!1!==repeat););else for(;!done()&&l<limit&&(l++,repeat=callback(emit,i,j,k),++i===n&&(i=0,++j===m&&(j=0,k++)),!1!==repeat););this.filled=1;return count()}}exports.PushBuffer=PushBuffer}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$render$buffer$pushbuffer.js.map
