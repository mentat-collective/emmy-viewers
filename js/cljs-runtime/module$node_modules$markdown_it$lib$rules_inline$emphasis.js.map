{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$emphasis.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_inline/emphasis.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$emphasis\"] = function(global,require,module,exports) {\n// Process *this* and _that_\n//\n'use strict';\n\n\n// Insert each marker as a separate text token, and add it to delimiter list\n//\nmodule.exports.tokenize = function emphasis(state, silent) {\n  var i, scanned, token,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (silent) { return false; }\n\n  if (marker !== 0x5F /* _ */ && marker !== 0x2A /* * */) { return false; }\n\n  scanned = state.scanDelims(state.pos, marker === 0x2A);\n\n  for (i = 0; i < scanned.length; i++) {\n    token         = state.push('text', '', 0);\n    token.content = String.fromCharCode(marker);\n\n    state.delimiters.push({\n      // Char code of the starting marker (number).\n      //\n      marker: marker,\n\n      // Total length of these series of delimiters.\n      //\n      length: scanned.length,\n\n      // A position of the token this delimiter corresponds to.\n      //\n      token:  state.tokens.length - 1,\n\n      // If this delimiter is matched as a valid opener, `end` will be\n      // equal to its position, otherwise it's `-1`.\n      //\n      end:    -1,\n\n      // Boolean flags that determine if this delimiter could open or close\n      // an emphasis.\n      //\n      open:   scanned.can_open,\n      close:  scanned.can_close\n    });\n  }\n\n  state.pos += scanned.length;\n\n  return true;\n};\n\n\nfunction postProcess(state, delimiters) {\n  var i,\n      startDelim,\n      endDelim,\n      token,\n      ch,\n      isStrong,\n      max = delimiters.length;\n\n  for (i = max - 1; i >= 0; i--) {\n    startDelim = delimiters[i];\n\n    if (startDelim.marker !== 0x5F/* _ */ && startDelim.marker !== 0x2A/* * */) {\n      continue;\n    }\n\n    // Process only opening markers\n    if (startDelim.end === -1) {\n      continue;\n    }\n\n    endDelim = delimiters[startDelim.end];\n\n    // If the previous delimiter has the same marker and is adjacent to this one,\n    // merge those into one strong delimiter.\n    //\n    // `<em><em>whatever</em></em>` -> `<strong>whatever</strong>`\n    //\n    isStrong = i > 0 &&\n               delimiters[i - 1].end === startDelim.end + 1 &&\n               // check that first two markers match and adjacent\n               delimiters[i - 1].marker === startDelim.marker &&\n               delimiters[i - 1].token === startDelim.token - 1 &&\n               // check that last two markers are adjacent (we can safely assume they match)\n               delimiters[startDelim.end + 1].token === endDelim.token + 1;\n\n    ch = String.fromCharCode(startDelim.marker);\n\n    token         = state.tokens[startDelim.token];\n    token.type    = isStrong ? 'strong_open' : 'em_open';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = 1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    token         = state.tokens[endDelim.token];\n    token.type    = isStrong ? 'strong_close' : 'em_close';\n    token.tag     = isStrong ? 'strong' : 'em';\n    token.nesting = -1;\n    token.markup  = isStrong ? ch + ch : ch;\n    token.content = '';\n\n    if (isStrong) {\n      state.tokens[delimiters[i - 1].token].content = '';\n      state.tokens[delimiters[startDelim.end + 1].token].content = '';\n      i--;\n    }\n  }\n}\n\n\n// Walk through delimiter list and replace text tokens with tags\n//\nmodule.exports.postProcess = function emphasis(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  postProcess(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      postProcess(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","postProcess","state","delimiters","i","length","startDelim","marker","end","endDelim","isStrong","token","ch","String","fromCharCode","tokens","type","tag","nesting","markup","content","tokenize","module.exports.tokenize","silent","src","charCodeAt","pos","scanned","scanDelims","push","open","can_open","close","can_close","module.exports.postProcess","curr","tokens_meta","max"]
}
