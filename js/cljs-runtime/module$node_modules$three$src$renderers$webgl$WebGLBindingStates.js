shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLBindingStates=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLBindingStates=function(gl,extensions,attributes,capabilities){function bindVertexArrayObject(vao){return capabilities.isWebGL2?gl.bindVertexArray(vao):extension.bindVertexArrayOES(vao)}function deleteVertexArrayObject(vao){return capabilities.isWebGL2?gl.deleteVertexArray(vao):extension.deleteVertexArrayOES(vao)}
function createBindingState(vao){const newAttributes=[],enabledAttributes=[],attributeDivisors=[];for(let i=0;i<maxVertexAttributes;i++)newAttributes[i]=0,enabledAttributes[i]=0,attributeDivisors[i]=0;return{geometry:null,program:null,wireframe:!1,newAttributes,enabledAttributes,attributeDivisors,object:vao,attributes:{},index:null}}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i=0,il=newAttributes.length;i<il;i++)newAttributes[i]=0}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,
0)}function enableAttributeAndDivisor(attribute,meshPerAttribute){const enabledAttributes=currentState.enabledAttributes,attributeDivisors=currentState.attributeDivisors;currentState.newAttributes[attribute]=1;0===enabledAttributes[attribute]&&(gl.enableVertexAttribArray(attribute),enabledAttributes[attribute]=1);attributeDivisors[attribute]!==meshPerAttribute&&((capabilities.isWebGL2?gl:extensions.get("ANGLE_instanced_arrays"))[capabilities.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](attribute,
meshPerAttribute),attributeDivisors[attribute]=meshPerAttribute)}function disableUnusedAttributes(){const newAttributes=currentState.newAttributes,enabledAttributes=currentState.enabledAttributes;for(let i=0,il=enabledAttributes.length;i<il;i++)enabledAttributes[i]!==newAttributes[i]&&(gl.disableVertexAttribArray(i),enabledAttributes[i]=0)}function vertexAttribPointer(index,size,type,normalized,stride,offset){!0!==capabilities.isWebGL2||type!==gl.INT&&type!==gl.UNSIGNED_INT?gl.vertexAttribPointer(index,
size,type,normalized,stride,offset):gl.vertexAttribIPointer(index,size,type,stride,offset)}function reset(){resetDefaultState();forceUpdate=!0;currentState!==defaultState&&(currentState=defaultState,bindVertexArrayObject(currentState.object))}function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=!1}const maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS),extension=capabilities.isWebGL2?null:extensions.get("OES_vertex_array_object"),vaoAvailable=
capabilities.isWebGL2||null!==extension,bindingStates={},defaultState=createBindingState(null);let currentState=defaultState,forceUpdate=!1;return{setup:function(object,material,program,geometry,index){var updateBuffers=!1;if(vaoAvailable){updateBuffers=!0===material.wireframe;var programMap=bindingStates[geometry.id];void 0===programMap&&(programMap={},bindingStates[geometry.id]=programMap);var stateMap=programMap[program.id];void 0===stateMap&&(stateMap={},programMap[program.id]=stateMap);programMap=
stateMap[updateBuffers];void 0===programMap&&(programMap=createBindingState(capabilities.isWebGL2?gl.createVertexArray():extension.createVertexArrayOES()),stateMap[updateBuffers]=programMap);updateBuffers=programMap;currentState!==updateBuffers&&(currentState=updateBuffers,bindVertexArrayObject(currentState.object));a:{updateBuffers=currentState.attributes;stateMap=geometry.attributes;programMap=0;var programAttributes=program.getAttributes();for(var name$jscomp$0 in programAttributes)if(0<=programAttributes[name$jscomp$0].location){var cachedAttribute=
updateBuffers[name$jscomp$0],geometryAttribute=stateMap[name$jscomp$0];void 0===geometryAttribute&&("instanceMatrix"===name$jscomp$0&&object.instanceMatrix&&(geometryAttribute=object.instanceMatrix),"instanceColor"===name$jscomp$0&&object.instanceColor&&(geometryAttribute=object.instanceColor));if(void 0===cachedAttribute||cachedAttribute.attribute!==geometryAttribute||geometryAttribute&&cachedAttribute.data!==geometryAttribute.data){updateBuffers=!0;break a}programMap++}updateBuffers=currentState.attributesNum!==
programMap||currentState.index!==index?!0:!1}if(updateBuffers){name$jscomp$0={};stateMap=geometry.attributes;programMap=0;programAttributes=program.getAttributes();for(var name$jscomp$1 in programAttributes)0<=programAttributes[name$jscomp$1].location&&(cachedAttribute=stateMap[name$jscomp$1],void 0===cachedAttribute&&("instanceMatrix"===name$jscomp$1&&object.instanceMatrix&&(cachedAttribute=object.instanceMatrix),"instanceColor"===name$jscomp$1&&object.instanceColor&&(cachedAttribute=object.instanceColor)),
geometryAttribute={},(geometryAttribute.attribute=cachedAttribute)&&cachedAttribute.data&&(geometryAttribute.data=cachedAttribute.data),name$jscomp$0[name$jscomp$1]=geometryAttribute,programMap++);currentState.attributes=name$jscomp$0;currentState.attributesNum=programMap;currentState.index=index}}else if(name$jscomp$1=!0===material.wireframe,currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==name$jscomp$1)currentState.geometry=geometry.id,currentState.program=
program.id,currentState.wireframe=name$jscomp$1,updateBuffers=!0;null!==index&&attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);if(updateBuffers||forceUpdate){forceUpdate=!1;if(!1!==capabilities.isWebGL2||!object.isInstancedMesh&&!geometry.isInstancedBufferGeometry||null!==extensions.get("ANGLE_instanced_arrays")){initAttributes();name$jscomp$1=geometry.attributes;program=program.getAttributes();material=material.defaultAttributeValues;for(const name in program)if(name$jscomp$0=program[name],0<=name$jscomp$0.location){var geometryAttribute$jscomp$0=
name$jscomp$1[name];void 0===geometryAttribute$jscomp$0&&("instanceMatrix"===name&&object.instanceMatrix&&(geometryAttribute$jscomp$0=object.instanceMatrix),"instanceColor"===name&&object.instanceColor&&(geometryAttribute$jscomp$0=object.instanceColor));if(void 0!==geometryAttribute$jscomp$0){if(updateBuffers=geometryAttribute$jscomp$0.normalized,stateMap=geometryAttribute$jscomp$0.itemSize,programAttributes=attributes.get(geometryAttribute$jscomp$0),void 0!==programAttributes)if(cachedAttribute=
programAttributes.buffer,programMap=programAttributes.type,programAttributes=programAttributes.bytesPerElement,geometryAttribute$jscomp$0.isInterleavedBufferAttribute){var data=geometryAttribute$jscomp$0.data;geometryAttribute=data.stride;geometryAttribute$jscomp$0=geometryAttribute$jscomp$0.offset;if(data.isInstancedInterleavedBuffer){for(let i=0;i<name$jscomp$0.locationSize;i++)enableAttributeAndDivisor(name$jscomp$0.location+i,data.meshPerAttribute);!0!==object.isInstancedMesh&&void 0===geometry._maxInstanceCount&&
(geometry._maxInstanceCount=data.meshPerAttribute*data.count)}else for(data=0;data<name$jscomp$0.locationSize;data++)enableAttribute(name$jscomp$0.location+data);gl.bindBuffer(gl.ARRAY_BUFFER,cachedAttribute);for(cachedAttribute=0;cachedAttribute<name$jscomp$0.locationSize;cachedAttribute++)vertexAttribPointer(name$jscomp$0.location+cachedAttribute,stateMap/name$jscomp$0.locationSize,programMap,updateBuffers,geometryAttribute*programAttributes,(geometryAttribute$jscomp$0+stateMap/name$jscomp$0.locationSize*
cachedAttribute)*programAttributes)}else{if(geometryAttribute$jscomp$0.isInstancedBufferAttribute){for(geometryAttribute=0;geometryAttribute<name$jscomp$0.locationSize;geometryAttribute++)enableAttributeAndDivisor(name$jscomp$0.location+geometryAttribute,geometryAttribute$jscomp$0.meshPerAttribute);!0!==object.isInstancedMesh&&void 0===geometry._maxInstanceCount&&(geometry._maxInstanceCount=geometryAttribute$jscomp$0.meshPerAttribute*geometryAttribute$jscomp$0.count)}else for(geometryAttribute=0;geometryAttribute<
name$jscomp$0.locationSize;geometryAttribute++)enableAttribute(name$jscomp$0.location+geometryAttribute);gl.bindBuffer(gl.ARRAY_BUFFER,cachedAttribute);for(cachedAttribute=0;cachedAttribute<name$jscomp$0.locationSize;cachedAttribute++)vertexAttribPointer(name$jscomp$0.location+cachedAttribute,stateMap/name$jscomp$0.locationSize,programMap,updateBuffers,stateMap*programAttributes,stateMap/name$jscomp$0.locationSize*cachedAttribute*programAttributes)}}else if(void 0!==material&&(updateBuffers=material[name],
void 0!==updateBuffers))switch(updateBuffers.length){case 2:gl.vertexAttrib2fv(name$jscomp$0.location,updateBuffers);break;case 3:gl.vertexAttrib3fv(name$jscomp$0.location,updateBuffers);break;case 4:gl.vertexAttrib4fv(name$jscomp$0.location,updateBuffers);break;default:gl.vertexAttrib1fv(name$jscomp$0.location,updateBuffers)}}disableUnusedAttributes()}null!==index&&gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer)}},reset,resetDefaultState,dispose:function(){reset();for(const geometryId in bindingStates){const programMap=
bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometryId]}},releaseStatesOfGeometry:function(geometry){if(void 0!==bindingStates[geometry.id]){var programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),
delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometry.id]}},releaseStatesOfProgram:function(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(void 0===programMap[program.id])continue;const stateMap=programMap[program.id];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[program.id]}},initAttributes,enableAttribute,disableUnusedAttributes}}}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLBindingStates.js.map
