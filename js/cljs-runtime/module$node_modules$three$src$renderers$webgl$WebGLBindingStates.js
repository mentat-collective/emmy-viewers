shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLBindingStates=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLBindingStates=function(gl,extensions,attributes,capabilities){function bindVertexArrayObject(vao){return capabilities.isWebGL2?gl.bindVertexArray(vao):extension.bindVertexArrayOES(vao)}function deleteVertexArrayObject(vao){return capabilities.isWebGL2?gl.deleteVertexArray(vao):extension.deleteVertexArrayOES(vao)}
function createBindingState(vao){const newAttributes=[],enabledAttributes=[],attributeDivisors=[];for(let i=0;i<maxVertexAttributes;i++)newAttributes[i]=0,enabledAttributes[i]=0,attributeDivisors[i]=0;return{geometry:null,program:null,wireframe:!1,newAttributes,enabledAttributes,attributeDivisors,object:vao,attributes:{},index:null}}function initAttributes(){const newAttributes=currentState.newAttributes;for(let i=0,il=newAttributes.length;i<il;i++)newAttributes[i]=0}function enableAttribute(attribute){enableAttributeAndDivisor(attribute,
0)}function enableAttributeAndDivisor(attribute,meshPerAttribute){const enabledAttributes=currentState.enabledAttributes,attributeDivisors=currentState.attributeDivisors;currentState.newAttributes[attribute]=1;0===enabledAttributes[attribute]&&(gl.enableVertexAttribArray(attribute),enabledAttributes[attribute]=1);attributeDivisors[attribute]!==meshPerAttribute&&((capabilities.isWebGL2?gl:extensions.get("ANGLE_instanced_arrays"))[capabilities.isWebGL2?"vertexAttribDivisor":"vertexAttribDivisorANGLE"](attribute,
meshPerAttribute),attributeDivisors[attribute]=meshPerAttribute)}function disableUnusedAttributes(){const newAttributes=currentState.newAttributes,enabledAttributes=currentState.enabledAttributes;for(let i=0,il=enabledAttributes.length;i<il;i++)enabledAttributes[i]!==newAttributes[i]&&(gl.disableVertexAttribArray(i),enabledAttributes[i]=0)}function vertexAttribPointer(index,size,type,normalized,stride,offset){!0!==capabilities.isWebGL2||type!==gl.INT&&type!==gl.UNSIGNED_INT?gl.vertexAttribPointer(index,
size,type,normalized,stride,offset):gl.vertexAttribIPointer(index,size,type,stride,offset)}function reset(){resetDefaultState();currentState!==defaultState&&(currentState=defaultState,bindVertexArrayObject(currentState.object))}function resetDefaultState(){defaultState.geometry=null;defaultState.program=null;defaultState.wireframe=!1}const maxVertexAttributes=gl.getParameter(gl.MAX_VERTEX_ATTRIBS),extension=capabilities.isWebGL2?null:extensions.get("OES_vertex_array_object"),vaoAvailable=capabilities.isWebGL2||
null!==extension,bindingStates={},defaultState=createBindingState(null);let currentState=defaultState;return{setup:function(object,material,program,geometry,index){var updateBuffers=!1;if(vaoAvailable){updateBuffers=!0===material.wireframe;var programMap=bindingStates[geometry.id];void 0===programMap&&(programMap={},bindingStates[geometry.id]=programMap);var stateMap=programMap[program.id];void 0===stateMap&&(stateMap={},programMap[program.id]=stateMap);programMap=stateMap[updateBuffers];void 0===
programMap&&(programMap=createBindingState(capabilities.isWebGL2?gl.createVertexArray():extension.createVertexArrayOES()),stateMap[updateBuffers]=programMap);updateBuffers=programMap;currentState!==updateBuffers&&(currentState=updateBuffers,bindVertexArrayObject(currentState.object));a:{updateBuffers=currentState.attributes;stateMap=geometry.attributes;programMap=0;for(var key in stateMap){var cachedAttribute=updateBuffers[key],geometryAttribute=stateMap[key];if(void 0===cachedAttribute||cachedAttribute.attribute!==
geometryAttribute||cachedAttribute.data!==geometryAttribute.data){updateBuffers=!0;break a}programMap++}updateBuffers=currentState.attributesNum!==programMap||currentState.index!==index?!0:!1}if(updateBuffers){key={};stateMap=geometry.attributes;programMap=0;for(var key$jscomp$0 in stateMap)cachedAttribute=stateMap[key$jscomp$0],geometryAttribute={},geometryAttribute.attribute=cachedAttribute,cachedAttribute.data&&(geometryAttribute.data=cachedAttribute.data),key[key$jscomp$0]=geometryAttribute,programMap++;
currentState.attributes=key;currentState.attributesNum=programMap;currentState.index=index}}else if(key$jscomp$0=!0===material.wireframe,currentState.geometry!==geometry.id||currentState.program!==program.id||currentState.wireframe!==key$jscomp$0)currentState.geometry=geometry.id,currentState.program=program.id,currentState.wireframe=key$jscomp$0,updateBuffers=!0;!0===object.isInstancedMesh&&(updateBuffers=!0);null!==index&&attributes.update(index,gl.ELEMENT_ARRAY_BUFFER);if(updateBuffers){if(!1!==
capabilities.isWebGL2||!object.isInstancedMesh&&!geometry.isInstancedBufferGeometry||null!==extensions.get("ANGLE_instanced_arrays")){initAttributes();key$jscomp$0=geometry.attributes;program=program.getAttributes();material=material.defaultAttributeValues;for(const name in program)if(key=program[name],0<=key.location){var geometryAttribute$jscomp$0=key$jscomp$0[name];void 0===geometryAttribute$jscomp$0&&("instanceMatrix"===name&&object.instanceMatrix&&(geometryAttribute$jscomp$0=object.instanceMatrix),
"instanceColor"===name&&object.instanceColor&&(geometryAttribute$jscomp$0=object.instanceColor));if(void 0!==geometryAttribute$jscomp$0){if(updateBuffers=geometryAttribute$jscomp$0.normalized,stateMap=geometryAttribute$jscomp$0.itemSize,cachedAttribute=attributes.get(geometryAttribute$jscomp$0),void 0!==cachedAttribute)if(geometryAttribute=cachedAttribute.buffer,programMap=cachedAttribute.type,cachedAttribute=cachedAttribute.bytesPerElement,geometryAttribute$jscomp$0.isInterleavedBufferAttribute){var data=
geometryAttribute$jscomp$0.data,stride=data.stride;geometryAttribute$jscomp$0=geometryAttribute$jscomp$0.offset;if(data&&data.isInstancedInterleavedBuffer){for(let i=0;i<key.locationSize;i++)enableAttributeAndDivisor(key.location+i,data.meshPerAttribute);!0!==object.isInstancedMesh&&void 0===geometry._maxInstanceCount&&(geometry._maxInstanceCount=data.meshPerAttribute*data.count)}else for(data=0;data<key.locationSize;data++)enableAttribute(key.location+data);gl.bindBuffer(gl.ARRAY_BUFFER,geometryAttribute);
for(geometryAttribute=0;geometryAttribute<key.locationSize;geometryAttribute++)vertexAttribPointer(key.location+geometryAttribute,stateMap/key.locationSize,programMap,updateBuffers,stride*cachedAttribute,(geometryAttribute$jscomp$0+stateMap/key.locationSize*geometryAttribute)*cachedAttribute)}else{if(geometryAttribute$jscomp$0.isInstancedBufferAttribute){for(stride=0;stride<key.locationSize;stride++)enableAttributeAndDivisor(key.location+stride,geometryAttribute$jscomp$0.meshPerAttribute);!0!==object.isInstancedMesh&&
void 0===geometry._maxInstanceCount&&(geometry._maxInstanceCount=geometryAttribute$jscomp$0.meshPerAttribute*geometryAttribute$jscomp$0.count)}else for(stride=0;stride<key.locationSize;stride++)enableAttribute(key.location+stride);gl.bindBuffer(gl.ARRAY_BUFFER,geometryAttribute);for(geometryAttribute=0;geometryAttribute<key.locationSize;geometryAttribute++)vertexAttribPointer(key.location+geometryAttribute,stateMap/key.locationSize,programMap,updateBuffers,stateMap*cachedAttribute,stateMap/key.locationSize*
geometryAttribute*cachedAttribute)}}else if(void 0!==material&&(updateBuffers=material[name],void 0!==updateBuffers))switch(updateBuffers.length){case 2:gl.vertexAttrib2fv(key.location,updateBuffers);break;case 3:gl.vertexAttrib3fv(key.location,updateBuffers);break;case 4:gl.vertexAttrib4fv(key.location,updateBuffers);break;default:gl.vertexAttrib1fv(key.location,updateBuffers)}}disableUnusedAttributes()}null!==index&&gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,attributes.get(index).buffer)}},reset,resetDefaultState,
dispose:function(){reset();for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];for(const programId in programMap){const stateMap=programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometryId]}},releaseStatesOfGeometry:function(geometry){if(void 0!==bindingStates[geometry.id]){var programMap=bindingStates[geometry.id];for(const programId in programMap){const stateMap=
programMap[programId];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];delete programMap[programId]}delete bindingStates[geometry.id]}},releaseStatesOfProgram:function(program){for(const geometryId in bindingStates){const programMap=bindingStates[geometryId];if(void 0===programMap[program.id])continue;const stateMap=programMap[program.id];for(const wireframe in stateMap)deleteVertexArrayObject(stateMap[wireframe].object),delete stateMap[wireframe];
delete programMap[program.id]}},initAttributes,enableAttribute,disableUnusedAttributes}}}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLBindingStates.js.map
