{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$text_collapse.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,8DAAA,CAAmF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAY3HD,MAAOC,CAAAA,OAAP,CAAiBC,QAAsB,CAACC,KAAD,CAAQ,CAAA,IACnCC,IADmC,CAEzCC,MAAQ,CAFiC,CAGzCC,OAASH,KAAMG,CAAAA,MAH0B,CAIzCC,IAAMJ,KAAMG,CAAAA,MAAOE,CAAAA,MAEvB,KAAKC,KAAL,CAAYL,IAAZ,CAAmB,CAAnB,CAAsBK,KAAtB,CAA6BF,GAA7B,CAAkCE,KAAA,EAAlC,CAG6B,CAI3B,CAJIH,MAAA,CAAOG,KAAP,CAAaC,CAAAA,OAIjB,EAJ8BL,KAAA,EAI9B,CAHAC,MAAA,CAAOG,KAAP,CAAaJ,CAAAA,KAGb,CAHqBA,KAGrB,CAF2B,CAE3B,CAFIC,MAAA,CAAOG,KAAP,CAAaC,CAAAA,OAEjB,EAF8BL,KAAA,EAE9B,CAA0B,MAA1B,GAAIC,MAAA,CAAOG,KAAP,CAAaE,CAAAA,IAAjB,EACIF,KADJ,CACW,CADX,CACeF,GADf,EAE8B,MAF9B,GAEID,MAAA,CAAOG,KAAP,CAAc,CAAd,CAAiBE,CAAAA,IAFrB,CAKEL,MAAA,CAAOG,KAAP,CAAc,CAAd,CAAiBG,CAAAA,OALnB,CAK6BN,MAAA,CAAOG,KAAP,CAAaG,CAAAA,OAL1C,CAKoDN,MAAA,CAAOG,KAAP,CAAc,CAAd,CAAiBG,CAAAA,OALrE,EAOMH,KAEJ,GAFaL,IAEb,GAFqBE,MAAA,CAAOF,IAAP,CAErB;AAFoCE,MAAA,CAAOG,KAAP,CAEpC,EAAAL,IAAA,EATF,CAaEK,MAAJ,GAAaL,IAAb,GACEE,MAAOE,CAAAA,MADT,CACkBJ,IADlB,CA1B6C,CAZ4E;",
"sources":["node_modules/markdown-it/lib/rules_inline/text_collapse.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$text_collapse\"] = function(global,require,module,exports) {\n// Clean up tokens after emphasis and strikethrough postprocessing:\n// merge adjacent text nodes into one and re-calculate all token levels\n//\n// This is necessary because initially emphasis delimiter markers (*, _, ~)\n// are treated as their own separate text tokens. Then emphasis rule either\n// leaves them as text (needed to merge with adjacent text) or turns them\n// into opening/closing tags (which messes up levels inside).\n//\n'use strict';\n\n\nmodule.exports = function text_collapse(state) {\n  var curr, last,\n      level = 0,\n      tokens = state.tokens,\n      max = state.tokens.length;\n\n  for (curr = last = 0; curr < max; curr++) {\n    // re-calculate levels after emphasis/strikethrough turns some text nodes\n    // into opening/closing tags\n    if (tokens[curr].nesting < 0) level--; // closing tag\n    tokens[curr].level = level;\n    if (tokens[curr].nesting > 0) level++; // opening tag\n\n    if (tokens[curr].type === 'text' &&\n        curr + 1 < max &&\n        tokens[curr + 1].type === 'text') {\n\n      // collapse two adjacent text nodes\n      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n    } else {\n      if (curr !== last) { tokens[last] = tokens[curr]; }\n\n      last++;\n    }\n  }\n\n  if (curr !== last) {\n    tokens.length = last;\n  }\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","module.exports","state","last","level","tokens","max","length","curr","nesting","type","content"]
}
