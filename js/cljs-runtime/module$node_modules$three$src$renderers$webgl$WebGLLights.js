shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLLights=function(global,require,module,exports){function UniformsCache(){const lights={};return{get:function(light){if(void 0!==lights[light.id])return lights[light.id];let uniforms;switch(light.type){case "DirectionalLight":uniforms={direction:new _Vector2.Vector3,color:new _Color.Color};break;case "SpotLight":uniforms={position:new _Vector2.Vector3,direction:new _Vector2.Vector3,color:new _Color.Color,distance:0,coneCos:0,penumbraCos:0,
decay:0};break;case "PointLight":uniforms={position:new _Vector2.Vector3,color:new _Color.Color,distance:0,decay:0};break;case "HemisphereLight":uniforms={direction:new _Vector2.Vector3,skyColor:new _Color.Color,groundColor:new _Color.Color};break;case "RectAreaLight":uniforms={color:new _Color.Color,position:new _Vector2.Vector3,halfWidth:new _Vector2.Vector3,halfHeight:new _Vector2.Vector3}}return lights[light.id]=uniforms}}}function ShadowUniformsCache(){const lights={};return{get:function(light){if(void 0!==
lights[light.id])return lights[light.id];let uniforms;switch(light.type){case "DirectionalLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new _Vector.Vector2};break;case "SpotLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new _Vector.Vector2};break;case "PointLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new _Vector.Vector2,shadowCameraNear:1,shadowCameraFar:1E3}}return lights[light.id]=uniforms}}}function shadowCastingAndTexturingLightsFirst(lightA,
lightB){return(lightB.castShadow?2:0)-(lightA.castShadow?2:0)+(lightB.map?1:0)-(lightA.map?1:0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLLights=function(extensions,capabilities){const cache=new UniformsCache,shadowCache=ShadowUniformsCache(),state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],
directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0};for(let i=0;9>i;i++)state.probe.push(new _Vector2.Vector3);const vector3=new _Vector2.Vector3,matrix4=new _Matrix.Matrix4,matrix42=new _Matrix.Matrix4;return{setup:function(lights,physicallyCorrectLights){let r=0,g=0,b=0;for(var i$jscomp$0=
0;9>i$jscomp$0;i$jscomp$0++)state.probe[i$jscomp$0].set(0,0,0);let pointLength=i$jscomp$0=0,spotLength=0,rectAreaLength=0,hemiLength=0,numDirectionalShadows=0,numPointShadows=0,numSpotShadows=0,numSpotMaps=0,numSpotShadowsWithMaps=0;lights.sort(shadowCastingAndTexturingLightsFirst);physicallyCorrectLights=!0!==physicallyCorrectLights?Math.PI:1;for(let i=0,l=lights.length;i<l;i++){var light=lights[i],color=light.color,intensity=light.intensity,distance=light.distance,shadowMap=light.shadow&&light.shadow.map?
light.shadow.map.texture:null;if(light.isAmbientLight)r+=color.r*intensity*physicallyCorrectLights,g+=color.g*intensity*physicallyCorrectLights,b+=color.b*intensity*physicallyCorrectLights;else if(light.isLightProbe)for(shadowMap=0;9>shadowMap;shadowMap++)state.probe[shadowMap].addScaledVector(light.sh.coefficients[shadowMap],intensity);else if(light.isDirectionalLight)intensity=cache.get(light),intensity.color.copy(light.color).multiplyScalar(light.intensity*physicallyCorrectLights),light.castShadow&&
(color=light.shadow,distance=shadowCache.get(light),distance.shadowBias=color.bias,distance.shadowNormalBias=color.normalBias,distance.shadowRadius=color.radius,distance.shadowMapSize=color.mapSize,state.directionalShadow[i$jscomp$0]=distance,state.directionalShadowMap[i$jscomp$0]=shadowMap,state.directionalShadowMatrix[i$jscomp$0]=light.shadow.matrix,numDirectionalShadows++),state.directional[i$jscomp$0]=intensity,i$jscomp$0++;else if(light.isSpotLight){const uniforms=cache.get(light);uniforms.position.setFromMatrixPosition(light.matrixWorld);
uniforms.color.copy(color).multiplyScalar(intensity*physicallyCorrectLights);uniforms.distance=distance;uniforms.coneCos=Math.cos(light.angle);uniforms.penumbraCos=Math.cos(light.angle*(1-light.penumbra));uniforms.decay=light.decay;state.spot[spotLength]=uniforms;intensity=light.shadow;light.map&&(state.spotLightMap[numSpotMaps]=light.map,numSpotMaps++,intensity.updateMatrices(light),light.castShadow&&numSpotShadowsWithMaps++);state.spotLightMatrix[spotLength]=intensity.matrix;light.castShadow&&(light=
shadowCache.get(light),light.shadowBias=intensity.bias,light.shadowNormalBias=intensity.normalBias,light.shadowRadius=intensity.radius,light.shadowMapSize=intensity.mapSize,state.spotShadow[spotLength]=light,state.spotShadowMap[spotLength]=shadowMap,numSpotShadows++);spotLength++}else light.isRectAreaLight?(shadowMap=cache.get(light),shadowMap.color.copy(color).multiplyScalar(intensity),shadowMap.halfWidth.set(.5*light.width,0,0),shadowMap.halfHeight.set(0,.5*light.height,0),state.rectArea[rectAreaLength]=
shadowMap,rectAreaLength++):light.isPointLight?(intensity=cache.get(light),intensity.color.copy(light.color).multiplyScalar(light.intensity*physicallyCorrectLights),intensity.distance=light.distance,intensity.decay=light.decay,light.castShadow&&(color=light.shadow,distance=shadowCache.get(light),distance.shadowBias=color.bias,distance.shadowNormalBias=color.normalBias,distance.shadowRadius=color.radius,distance.shadowMapSize=color.mapSize,distance.shadowCameraNear=color.camera.near,distance.shadowCameraFar=
color.camera.far,state.pointShadow[pointLength]=distance,state.pointShadowMap[pointLength]=shadowMap,state.pointShadowMatrix[pointLength]=light.shadow.matrix,numPointShadows++),state.point[pointLength]=intensity,pointLength++):light.isHemisphereLight&&(shadowMap=cache.get(light),shadowMap.skyColor.copy(light.color).multiplyScalar(intensity*physicallyCorrectLights),shadowMap.groundColor.copy(light.groundColor).multiplyScalar(intensity*physicallyCorrectLights),state.hemi[hemiLength]=shadowMap,hemiLength++)}0<
rectAreaLength&&(capabilities.isWebGL2?(state.rectAreaLTC1=_UniformsLib.UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=_UniformsLib.UniformsLib.LTC_FLOAT_2):!0===extensions.has("OES_texture_float_linear")?(state.rectAreaLTC1=_UniformsLib.UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=_UniformsLib.UniformsLib.LTC_FLOAT_2):!0===extensions.has("OES_texture_half_float_linear")?(state.rectAreaLTC1=_UniformsLib.UniformsLib.LTC_HALF_1,state.rectAreaLTC2=_UniformsLib.UniformsLib.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."));
state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;lights=state.hash;if(lights.directionalLength!==i$jscomp$0||lights.pointLength!==pointLength||lights.spotLength!==spotLength||lights.rectAreaLength!==rectAreaLength||lights.hemiLength!==hemiLength||lights.numDirectionalShadows!==numDirectionalShadows||lights.numPointShadows!==numPointShadows||lights.numSpotShadows!==numSpotShadows||lights.numSpotMaps!==numSpotMaps)state.directional.length=i$jscomp$0,state.spot.length=spotLength,state.rectArea.length=
rectAreaLength,state.point.length=pointLength,state.hemi.length=hemiLength,state.directionalShadow.length=numDirectionalShadows,state.directionalShadowMap.length=numDirectionalShadows,state.pointShadow.length=numPointShadows,state.pointShadowMap.length=numPointShadows,state.spotShadow.length=numSpotShadows,state.spotShadowMap.length=numSpotShadows,state.directionalShadowMatrix.length=numDirectionalShadows,state.pointShadowMatrix.length=numPointShadows,state.spotLightMatrix.length=numSpotShadows+numSpotMaps-
numSpotShadowsWithMaps,state.spotLightMap.length=numSpotMaps,state.numSpotLightShadowsWithMaps=numSpotShadowsWithMaps,lights.directionalLength=i$jscomp$0,lights.pointLength=pointLength,lights.spotLength=spotLength,lights.rectAreaLength=rectAreaLength,lights.hemiLength=hemiLength,lights.numDirectionalShadows=numDirectionalShadows,lights.numPointShadows=numPointShadows,lights.numSpotShadows=numSpotShadows,lights.numSpotMaps=numSpotMaps,state.version=nextVersion++},setupView:function(lights,camera){let directionalLength=
0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;camera=camera.matrixWorldInverse;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];if(light.isDirectionalLight){var uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(camera);directionalLength++}else light.isSpotLight?(uniforms=state.spot[spotLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),
uniforms.position.applyMatrix4(camera),uniforms.direction.setFromMatrixPosition(light.matrixWorld),vector3.setFromMatrixPosition(light.target.matrixWorld),uniforms.direction.sub(vector3),uniforms.direction.transformDirection(camera),spotLength++):light.isRectAreaLight?(uniforms=state.rectArea[rectAreaLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(camera),matrix42.identity(),matrix4.copy(light.matrixWorld),matrix4.premultiply(camera),matrix42.extractRotation(matrix4),
uniforms.halfWidth.set(.5*light.width,0,0),uniforms.halfHeight.set(0,.5*light.height,0),uniforms.halfWidth.applyMatrix4(matrix42),uniforms.halfHeight.applyMatrix4(matrix42),rectAreaLength++):light.isPointLight?(uniforms=state.point[pointLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(camera),pointLength++):light.isHemisphereLight&&(uniforms=state.hemi[hemiLength],uniforms.direction.setFromMatrixPosition(light.matrixWorld),uniforms.direction.transformDirection(camera),
hemiLength++)}},state}};var _Color=require("module$node_modules$three$src$math$Color"),_Matrix=require("module$node_modules$three$src$math$Matrix4"),_Vector=require("module$node_modules$three$src$math$Vector2"),_Vector2=require("module$node_modules$three$src$math$Vector3"),_UniformsLib=require("module$node_modules$three$src$renderers$shaders$UniformsLib");let nextVersion=0}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLLights.js.map
