shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLLights=function(global,require,module,exports){function UniformsCache(){const lights={};return{get:function(light){if(void 0!==lights[light.id])return lights[light.id];let uniforms;switch(light.type){case "DirectionalLight":uniforms={direction:new _Vector2.Vector3,color:new _Color.Color};break;case "SpotLight":uniforms={position:new _Vector2.Vector3,direction:new _Vector2.Vector3,color:new _Color.Color,distance:0,coneCos:0,penumbraCos:0,
decay:0};break;case "PointLight":uniforms={position:new _Vector2.Vector3,color:new _Color.Color,distance:0,decay:0};break;case "HemisphereLight":uniforms={direction:new _Vector2.Vector3,skyColor:new _Color.Color,groundColor:new _Color.Color};break;case "RectAreaLight":uniforms={color:new _Color.Color,position:new _Vector2.Vector3,halfWidth:new _Vector2.Vector3,halfHeight:new _Vector2.Vector3}}return lights[light.id]=uniforms}}}function ShadowUniformsCache(){const lights={};return{get:function(light){if(void 0!==
lights[light.id])return lights[light.id];let uniforms;switch(light.type){case "DirectionalLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new _Vector.Vector2};break;case "SpotLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new _Vector.Vector2};break;case "PointLight":uniforms={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new _Vector.Vector2,shadowCameraNear:1,shadowCameraFar:1E3}}return lights[light.id]=uniforms}}}function shadowCastingLightsFirst(lightA,
lightB){return(lightB.castShadow?1:0)-(lightA.castShadow?1:0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLLights=function(extensions,capabilities){const cache=new UniformsCache,shadowCache=ShadowUniformsCache(),state={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],
spot:[],spotShadow:[],spotShadowMap:[],spotShadowMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[]};for(let i=0;9>i;i++)state.probe.push(new _Vector2.Vector3);const vector3=new _Vector2.Vector3,matrix4=new _Matrix.Matrix4,matrix42=new _Matrix.Matrix4;return{setup:function(lights,physicallyCorrectLights){let r=0,g=0,b=0;for(var i$jscomp$0=0;9>i$jscomp$0;i$jscomp$0++)state.probe[i$jscomp$0].set(0,0,0);let pointLength=i$jscomp$0=
0,spotLength=0,rectAreaLength=0,hemiLength=0,numDirectionalShadows=0,numPointShadows=0,numSpotShadows=0;lights.sort(shadowCastingLightsFirst);physicallyCorrectLights=!0!==physicallyCorrectLights?Math.PI:1;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];var color=light.color,intensity=light.intensity;const distance=light.distance;var shadowMap=light.shadow&&light.shadow.map?light.shadow.map.texture:null;if(light.isAmbientLight)r+=color.r*intensity*physicallyCorrectLights,g+=color.g*intensity*
physicallyCorrectLights,b+=color.b*intensity*physicallyCorrectLights;else if(light.isLightProbe)for(shadowMap=0;9>shadowMap;shadowMap++)state.probe[shadowMap].addScaledVector(light.sh.coefficients[shadowMap],intensity);else if(light.isDirectionalLight){intensity=cache.get(light);intensity.color.copy(light.color).multiplyScalar(light.intensity*physicallyCorrectLights);if(light.castShadow){var shadow=light.shadow;color=shadowCache.get(light);color.shadowBias=shadow.bias;color.shadowNormalBias=shadow.normalBias;
color.shadowRadius=shadow.radius;color.shadowMapSize=shadow.mapSize;state.directionalShadow[i$jscomp$0]=color;state.directionalShadowMap[i$jscomp$0]=shadowMap;state.directionalShadowMatrix[i$jscomp$0]=light.shadow.matrix;numDirectionalShadows++}state.directional[i$jscomp$0]=intensity;i$jscomp$0++}else light.isSpotLight?(shadow=cache.get(light),shadow.position.setFromMatrixPosition(light.matrixWorld),shadow.color.copy(color).multiplyScalar(intensity*physicallyCorrectLights),shadow.distance=distance,
shadow.coneCos=Math.cos(light.angle),shadow.penumbraCos=Math.cos(light.angle*(1-light.penumbra)),shadow.decay=light.decay,light.castShadow&&(intensity=light.shadow,color=shadowCache.get(light),color.shadowBias=intensity.bias,color.shadowNormalBias=intensity.normalBias,color.shadowRadius=intensity.radius,color.shadowMapSize=intensity.mapSize,state.spotShadow[spotLength]=color,state.spotShadowMap[spotLength]=shadowMap,state.spotShadowMatrix[spotLength]=light.shadow.matrix,numSpotShadows++),state.spot[spotLength]=
shadow,spotLength++):light.isRectAreaLight?(shadowMap=cache.get(light),shadowMap.color.copy(color).multiplyScalar(intensity),shadowMap.halfWidth.set(.5*light.width,0,0),shadowMap.halfHeight.set(0,.5*light.height,0),state.rectArea[rectAreaLength]=shadowMap,rectAreaLength++):light.isPointLight?(intensity=cache.get(light),intensity.color.copy(light.color).multiplyScalar(light.intensity*physicallyCorrectLights),intensity.distance=light.distance,intensity.decay=light.decay,light.castShadow&&(shadow=light.shadow,
color=shadowCache.get(light),color.shadowBias=shadow.bias,color.shadowNormalBias=shadow.normalBias,color.shadowRadius=shadow.radius,color.shadowMapSize=shadow.mapSize,color.shadowCameraNear=shadow.camera.near,color.shadowCameraFar=shadow.camera.far,state.pointShadow[pointLength]=color,state.pointShadowMap[pointLength]=shadowMap,state.pointShadowMatrix[pointLength]=light.shadow.matrix,numPointShadows++),state.point[pointLength]=intensity,pointLength++):light.isHemisphereLight&&(shadowMap=cache.get(light),
shadowMap.skyColor.copy(light.color).multiplyScalar(intensity*physicallyCorrectLights),shadowMap.groundColor.copy(light.groundColor).multiplyScalar(intensity*physicallyCorrectLights),state.hemi[hemiLength]=shadowMap,hemiLength++)}0<rectAreaLength&&(capabilities.isWebGL2?(state.rectAreaLTC1=_UniformsLib.UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=_UniformsLib.UniformsLib.LTC_FLOAT_2):!0===extensions.has("OES_texture_float_linear")?(state.rectAreaLTC1=_UniformsLib.UniformsLib.LTC_FLOAT_1,state.rectAreaLTC2=
_UniformsLib.UniformsLib.LTC_FLOAT_2):!0===extensions.has("OES_texture_half_float_linear")?(state.rectAreaLTC1=_UniformsLib.UniformsLib.LTC_HALF_1,state.rectAreaLTC2=_UniformsLib.UniformsLib.LTC_HALF_2):console.error("THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."));state.ambient[0]=r;state.ambient[1]=g;state.ambient[2]=b;lights=state.hash;if(lights.directionalLength!==i$jscomp$0||lights.pointLength!==pointLength||lights.spotLength!==spotLength||lights.rectAreaLength!==
rectAreaLength||lights.hemiLength!==hemiLength||lights.numDirectionalShadows!==numDirectionalShadows||lights.numPointShadows!==numPointShadows||lights.numSpotShadows!==numSpotShadows)state.directional.length=i$jscomp$0,state.spot.length=spotLength,state.rectArea.length=rectAreaLength,state.point.length=pointLength,state.hemi.length=hemiLength,state.directionalShadow.length=numDirectionalShadows,state.directionalShadowMap.length=numDirectionalShadows,state.pointShadow.length=numPointShadows,state.pointShadowMap.length=
numPointShadows,state.spotShadow.length=numSpotShadows,state.spotShadowMap.length=numSpotShadows,state.directionalShadowMatrix.length=numDirectionalShadows,state.pointShadowMatrix.length=numPointShadows,state.spotShadowMatrix.length=numSpotShadows,lights.directionalLength=i$jscomp$0,lights.pointLength=pointLength,lights.spotLength=spotLength,lights.rectAreaLength=rectAreaLength,lights.hemiLength=hemiLength,lights.numDirectionalShadows=numDirectionalShadows,lights.numPointShadows=numPointShadows,lights.numSpotShadows=
numSpotShadows,state.version=nextVersion++},setupView:function(lights,camera){let directionalLength=0,pointLength=0,spotLength=0,rectAreaLength=0,hemiLength=0;camera=camera.matrixWorldInverse;for(let i=0,l=lights.length;i<l;i++){const light=lights[i];if(light.isDirectionalLight){var uniforms=state.directional[directionalLength];uniforms.direction.setFromMatrixPosition(light.matrixWorld);vector3.setFromMatrixPosition(light.target.matrixWorld);uniforms.direction.sub(vector3);uniforms.direction.transformDirection(camera);
directionalLength++}else light.isSpotLight?(uniforms=state.spot[spotLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(camera),uniforms.direction.setFromMatrixPosition(light.matrixWorld),vector3.setFromMatrixPosition(light.target.matrixWorld),uniforms.direction.sub(vector3),uniforms.direction.transformDirection(camera),spotLength++):light.isRectAreaLight?(uniforms=state.rectArea[rectAreaLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),
uniforms.position.applyMatrix4(camera),matrix42.identity(),matrix4.copy(light.matrixWorld),matrix4.premultiply(camera),matrix42.extractRotation(matrix4),uniforms.halfWidth.set(.5*light.width,0,0),uniforms.halfHeight.set(0,.5*light.height,0),uniforms.halfWidth.applyMatrix4(matrix42),uniforms.halfHeight.applyMatrix4(matrix42),rectAreaLength++):light.isPointLight?(uniforms=state.point[pointLength],uniforms.position.setFromMatrixPosition(light.matrixWorld),uniforms.position.applyMatrix4(camera),pointLength++):
light.isHemisphereLight&&(uniforms=state.hemi[hemiLength],uniforms.direction.setFromMatrixPosition(light.matrixWorld),uniforms.direction.transformDirection(camera),uniforms.direction.normalize(),hemiLength++)}},state}};var _Color=require("module$node_modules$three$src$math$Color"),_Matrix=require("module$node_modules$three$src$math$Matrix4"),_Vector=require("module$node_modules$three$src$math$Vector2"),_Vector2=require("module$node_modules$three$src$math$Vector3"),_UniformsLib=require("module$node_modules$three$src$renderers$shaders$UniformsLib");
let nextVersion=0}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLLights.js.map
