shadow$provide.module$node_modules$three$src$renderers$webgl$WebGLUniformsGroups=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.WebGLUniformsGroups=function(gl,info$jscomp$0,capabilities,state){function prepareUniformsGroup(uniformsGroup){const uniforms=uniformsGroup.uniforms;let offset=0;for(let i=0,l=uniforms.length;i<l;i++){const uniform=uniforms[i];var chunkOffset=uniform.value;var info={boundary:0,storage:0};"number"===typeof chunkOffset?
(info.boundary=4,info.storage=4):chunkOffset.isVector2?(info.boundary=8,info.storage=8):chunkOffset.isVector3||chunkOffset.isColor?(info.boundary=16,info.storage=12):chunkOffset.isVector4?(info.boundary=16,info.storage=16):chunkOffset.isMatrix3?(info.boundary=48,info.storage=48):chunkOffset.isMatrix4?(info.boundary=64,info.storage=64):chunkOffset.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",
chunkOffset);uniform.__data=new Float32Array(info.storage/Float32Array.BYTES_PER_ELEMENT);uniform.__offset=offset;if(0<i){chunkOffset=offset%16;const remainingSizeInChunk=16-chunkOffset;0!==chunkOffset&&0>remainingSizeInChunk-info.boundary&&(offset+=16-chunkOffset,uniform.__offset=offset)}offset+=info.storage}chunkOffset=offset%16;0<chunkOffset&&(offset+=16-chunkOffset);uniformsGroup.__size=offset;uniformsGroup.__cache={};return this}function onUniformsGroupsDispose(event){event=event.target;event.removeEventListener("dispose",
onUniformsGroupsDispose);const index=allocatedBindingPoints.indexOf(event.__bindingPointIndex);allocatedBindingPoints.splice(index,1);gl.deleteBuffer(buffers[event.id]);delete buffers[event.id];delete updateList[event.id]}let buffers={},updateList={},allocatedBindingPoints=[];const maxBindingPoints=capabilities.isWebGL2?gl.getParameter(gl.MAX_UNIFORM_BUFFER_BINDINGS):0;return{bind:function(uniformsGroup,program){state.uniformBlockBinding(uniformsGroup,program.program)},update:function(uniformsGroup,
program){var buffer=buffers[uniformsGroup.id];if(void 0===buffer){prepareUniformsGroup(uniformsGroup);a:{for(buffer=0;buffer<maxBindingPoints;buffer++)if(-1===allocatedBindingPoints.indexOf(buffer)){allocatedBindingPoints.push(buffer);break a}console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached.");buffer=0}uniformsGroup.__bindingPointIndex=buffer;var buffer$jscomp$0=gl.createBuffer(),size=uniformsGroup.__size,usage=uniformsGroup.usage;gl.bindBuffer(gl.UNIFORM_BUFFER,
buffer$jscomp$0);gl.bufferData(gl.UNIFORM_BUFFER,size,usage);gl.bindBuffer(gl.UNIFORM_BUFFER,null);gl.bindBufferBase(gl.UNIFORM_BUFFER,buffer,buffer$jscomp$0);buffer=buffer$jscomp$0;buffers[uniformsGroup.id]=buffer;uniformsGroup.addEventListener("dispose",onUniformsGroupsDispose)}state.updateUBOMapping(uniformsGroup,program.program);program=info$jscomp$0.render.frame;if(updateList[uniformsGroup.id]!==program){buffer=uniformsGroup.uniforms;buffer$jscomp$0=uniformsGroup.__cache;gl.bindBuffer(gl.UNIFORM_BUFFER,
buffers[uniformsGroup.id]);for(let i=0,il=buffer.length;i<il;i++){size=buffer[i];a:{var index=i,cache=buffer$jscomp$0;usage=size.value;if(void 0===cache[index])cache[index]="number"===typeof usage?usage:usage.clone(),usage=!0;else{if("number"===typeof usage){if(cache[index]!==usage){cache[index]=usage;usage=!0;break a}}else if(index=cache[index],!1===index.equals(usage)){index.copy(usage);usage=!0;break a}usage=!1}}!0===usage&&(usage=size.value,index=size.__offset,"number"===typeof usage?size.__data[0]=
usage:size.value.isMatrix3?(size.__data[0]=size.value.elements[0],size.__data[1]=size.value.elements[1],size.__data[2]=size.value.elements[2],size.__data[3]=size.value.elements[0],size.__data[4]=size.value.elements[3],size.__data[5]=size.value.elements[4],size.__data[6]=size.value.elements[5],size.__data[7]=size.value.elements[0],size.__data[8]=size.value.elements[6],size.__data[9]=size.value.elements[7],size.__data[10]=size.value.elements[8],size.__data[11]=size.value.elements[0]):usage.toArray(size.__data),
gl.bufferSubData(gl.UNIFORM_BUFFER,index,size.__data))}gl.bindBuffer(gl.UNIFORM_BUFFER,null);updateList[uniformsGroup.id]=program}},dispose:function(){for(const id in buffers)gl.deleteBuffer(buffers[id]);allocatedBindingPoints=[];buffers={};updateList={}}}}}
//# sourceMappingURL=module$node_modules$three$src$renderers$webgl$WebGLUniformsGroups.js.map
