{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$state_inline.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_inline/state_inline.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$state_inline\"] = function(global,require,module,exports) {\n// Inline parser state\n\n'use strict';\n\n\nvar Token          = require('../token');\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\n\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n\n  // backtick length => last seen position\n  this.backticks = {};\n  this.backticksScanned = false;\n}\n\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  var token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  var token = new Token(type, tag, nesting);\n  var token_meta = null;\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n\n  token.level = this.level;\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = { delimiters: this.delimiters };\n  }\n\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  var pos = start, lastChar, nextChar, count, can_open, can_close,\n      isLastWhiteSpace, isLastPunctChar,\n      isNextWhiteSpace, isNextPunctChar,\n      left_flanking = true,\n      right_flanking = true,\n      max = this.posMax,\n      marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++; }\n\n  count = pos - start;\n\n  // treat end of the line as a whitespace\n  nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n\n  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n  isLastWhiteSpace = isWhiteSpace(lastChar);\n  isNextWhiteSpace = isWhiteSpace(nextChar);\n\n  if (isNextWhiteSpace) {\n    left_flanking = false;\n  } else if (isNextPunctChar) {\n    if (!(isLastWhiteSpace || isLastPunctChar)) {\n      left_flanking = false;\n    }\n  }\n\n  if (isLastWhiteSpace) {\n    right_flanking = false;\n  } else if (isLastPunctChar) {\n    if (!(isNextWhiteSpace || isNextPunctChar)) {\n      right_flanking = false;\n    }\n  }\n\n  if (!canSplitWord) {\n    can_open  = left_flanking  && (!right_flanking || isLastPunctChar);\n    can_close = right_flanking && (!left_flanking  || isNextPunctChar);\n  } else {\n    can_open  = left_flanking;\n    can_close = right_flanking;\n  }\n\n  return {\n    can_open:  can_open,\n    can_close: can_close,\n    length:    count\n  };\n};\n\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\n\n\nmodule.exports = StateInline;\n\n};"],
"names":["shadow$provide","global","require","module","exports","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","backticks","backticksScanned","Token","isWhiteSpace","isPunctChar","isMdAsciiPunct","prototype","pushPending","StateInline.prototype.pushPending","token","content","push","StateInline.prototype.push","type","tag","nesting","token_meta","pop","scanDelims","StateInline.prototype.scanDelims","start","canSplitWord","lastChar","can_close","right_flanking","left_flanking","max","marker","charCodeAt","count","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","can_open"]
}
