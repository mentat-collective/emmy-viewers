shadow$provide.module$node_modules$three$src$renderers$shaders$ShaderChunk$iridescence_fragment_glsl=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="\n\n#ifdef USE_IRIDESCENCE\n\n\t// XYZ to linear-sRGB color space\n\tconst mat3 XYZ_TO_REC709 \x3d mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\n\t// Assume air interface for top\n\t// Note: We don't handle the case fresnel0 \x3d\x3d 1\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\n\t\tvec3 sqrtF0 \x3d sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\n\t}\n\n\t// Conversion FO/IOR\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\n\t}\n\n\t// ior is a value between 1.0 and 3.0. 1.0 is air interface\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\n\t}\n\n\t// Fresnel equations for dielectric/dielectric interfaces.\n\t// Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html\n\t// Evaluation XYZ sensitivity curves in Fourier space\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\n\t\tfloat phase \x3d 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val \x3d vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos \x3d vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var \x3d vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\n\t\tvec3 xyz \x3d val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x +\x3d 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /\x3d 1.0685e-7;\n\n\t\tvec3 rgb \x3d XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\n\t}\n\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\n\t\tvec3 I;\n\n\t\t// Force iridescenceIOR -\x3e outsideIOR when thinFilmThickness -\x3e 0.0\n\t\tfloat iridescenceIOR \x3d mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\t// Evaluate the cosTheta on the base layer (Snell law)\n\t\tfloat sinTheta2Sq \x3d pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\n\t\t// Handle TIR:\n\t\tfloat cosTheta2Sq \x3d 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq \x3c 0.0 ) {\n\n\t\t\t return vec3( 1.0 );\n\n\t\t}\n\n\t\tfloat cosTheta2 \x3d sqrt( cosTheta2Sq );\n\n\t\t// First interface\n\t\tfloat R0 \x3d IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 \x3d F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat R21 \x3d R12;\n\t\tfloat T121 \x3d 1.0 - R12;\n\t\tfloat phi12 \x3d 0.0;\n\t\tif ( iridescenceIOR \x3c outsideIOR ) phi12 \x3d PI;\n\t\tfloat phi21 \x3d PI - phi12;\n\n\t\t// Second interface\n\t\tvec3 baseIOR \x3d Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) ); // guard against 1.0\n\t\tvec3 R1 \x3d IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 \x3d F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 \x3d vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] \x3c iridescenceIOR ) phi23[ 0 ] \x3d PI;\n\t\tif ( baseIOR[ 1 ] \x3c iridescenceIOR ) phi23[ 1 ] \x3d PI;\n\t\tif ( baseIOR[ 2 ] \x3c iridescenceIOR ) phi23[ 2 ] \x3d PI;\n\n\t\t// Phase shift\n\t\tfloat OPD \x3d 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi \x3d vec3( phi21 ) + phi23;\n\n\t\t// Compound terms\n\t\tvec3 R123 \x3d clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 \x3d sqrt( R123 );\n\t\tvec3 Rs \x3d pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\n\t\t// Reflectance term for m \x3d 0 (DC term amplitude)\n\t\tvec3 C0 \x3d R12 + Rs;\n\t\tI \x3d C0;\n\n\t\t// Reflectance term for m \x3e 0 (pairs of diracs)\n\t\tvec3 Cm \x3d Rs - T121;\n\t\tfor ( int m \x3d 1; m \x3c\x3d 2; ++ m ) {\n\n\t\t\tCm *\x3d r123;\n\t\t\tvec3 Sm \x3d 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI +\x3d Cm * Sm;\n\n\t\t}\n\n\t\t// Since out of gamut colors might be produced, negative color values are clamped to 0.\n\t\treturn max( I, vec3( 0.0 ) );\n\n\t}\n\n#endif\n\n"}
//# sourceMappingURL=module$node_modules$three$src$renderers$shaders$ShaderChunk$iridescence_fragment_glsl.js.map
