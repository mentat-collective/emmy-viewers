shadow$provide.module$node_modules$three$src$extras$PMREMGenerator=function(global,require,module,exports){function _createRenderTarget(params){params=new _WebGLRenderTarget.WebGLRenderTarget(3*SIZE_MAX,3*SIZE_MAX,params);params.texture.mapping=_constants.CubeUVReflectionMapping;params.texture.name="PMREM.cubeUv";params.scissorTest=!0;return params}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height)}function _getEquirectShader(){const texelSize=
new _Vector.Vector2(1,1);return new _RawShaderMaterial.RawShaderMaterial({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null},texelSize:{value:texelSize}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform vec2 texelSize;\n\n\t\t\t#include \x3ccommon\x3e\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor \x3d vec4( 0.0, 0.0, 0.0, 1.0 );\n\n\t\t\t\tvec3 outputDirection \x3d normalize( vOutputDirection );\n\t\t\t\tvec2 uv \x3d equirectUv( outputDirection );\n\n\t\t\t\tvec2 f \x3d fract( uv / texelSize - 0.5 );\n\t\t\t\tuv -\x3d f * texelSize;\n\t\t\t\tvec3 tl \x3d texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x +\x3d texelSize.x;\n\t\t\t\tvec3 tr \x3d texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.y +\x3d texelSize.y;\n\t\t\t\tvec3 br \x3d texture2D ( envMap, uv ).rgb;\n\t\t\t\tuv.x -\x3d texelSize.x;\n\t\t\t\tvec3 bl \x3d texture2D ( envMap, uv ).rgb;\n\n\t\t\t\tvec3 tm \x3d mix( tl, tr, f.x );\n\t\t\t\tvec3 bm \x3d mix( bl, br, f.x );\n\t\t\t\tgl_FragColor.rgb \x3d mix( tm, bm, f.y );\n\n\t\t\t}\n\t\t",
blending:_constants.NoBlending,depthTest:!1,depthWrite:!1})}function _getCubemapShader(){return new _RawShaderMaterial.RawShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor \x3d textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
blending:_constants.NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv \x3d 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction \x3d vec3( uv, 1.0 );\n\n\t\t\tif ( face \x3d\x3d 0.0 ) {\n\n\t\t\t\tdirection \x3d direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face \x3d\x3d 1.0 ) {\n\n\t\t\t\tdirection \x3d direction.xzy;\n\t\t\t\tdirection.xz *\x3d -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face \x3d\x3d 2.0 ) {\n\n\t\t\t\tdirection.x *\x3d -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face \x3d\x3d 3.0 ) {\n\n\t\t\t\tdirection \x3d direction.zyx;\n\t\t\t\tdirection.xz *\x3d -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face \x3d\x3d 4.0 ) {\n\n\t\t\t\tdirection \x3d direction.xzy;\n\t\t\t\tdirection.xy *\x3d -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face \x3d\x3d 5.0 ) {\n\n\t\t\t\tdirection.z *\x3d -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection \x3d getDirection( uv, faceIndex );\n\t\t\tgl_Position \x3d vec4( position, 1.0 );\n\n\t\t}\n\t"}
Object.defineProperty(exports,"__esModule",{value:!0});exports.PMREMGenerator=void 0;var _constants=require("module$node_modules$three$src$constants"),_BufferAttribute=require("module$node_modules$three$src$core$BufferAttribute"),_BufferGeometry=require("module$node_modules$three$src$core$BufferGeometry"),_Mesh=require("module$node_modules$three$src$objects$Mesh");global=require("module$node_modules$three$src$cameras$OrthographicCamera");var _PerspectiveCamera=require("module$node_modules$three$src$cameras$PerspectiveCamera"),
_RawShaderMaterial=require("module$node_modules$three$src$materials$RawShaderMaterial"),_Vector=require("module$node_modules$three$src$math$Vector2"),_Vector2=require("module$node_modules$three$src$math$Vector3");module=require("module$node_modules$three$src$math$Color");var _WebGLRenderTarget=require("module$node_modules$three$src$renderers$WebGLRenderTarget"),_MeshBasicMaterial=require("module$node_modules$three$src$materials$MeshBasicMaterial"),_BoxGeometry=require("module$node_modules$three$src$geometries$BoxGeometry");
const SIZE_MAX=Math.pow(2,8),EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],TOTAL_LODS=5+EXTRA_LOD_SIGMA.length,_flatCamera=new global.OrthographicCamera,{_lodPlanes:_lodPlanes$jscomp$0,_sizeLods:_sizeLods$jscomp$0,_sigmas:_sigmas$jscomp$0}=function(){const _lodPlanes=[],_sizeLods=[],_sigmas=[];let lod=8;for(let i=0;i<TOTAL_LODS;i++){var sizeLod=Math.pow(2,lod);_sizeLods.push(sizeLod);var sigma=1/sizeLod;4<i?sigma=EXTRA_LOD_SIGMA[i-8+4-1]:0===i&&(sigma=0);_sigmas.push(sigma);sigma=1/(sizeLod-1);sizeLod=
-sigma/2;sigma=1+sigma/2;var uv1=[sizeLod,sizeLod,sigma,sizeLod,sigma,sigma,sizeLod,sizeLod,sigma,sigma,sizeLod,sigma];sizeLod=new Float32Array(108);sigma=new Float32Array(72);const faceIndex=new Float32Array(36);for(let face=0;6>face;face++){const x=face%3*2/3-1,y=2<face?0:-1;sizeLod.set([x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0],18*face);sigma.set(uv1,12*face);faceIndex.set([face,face,face,face,face,face],6*face)}uv1=new _BufferGeometry.BufferGeometry;uv1.setAttribute("position",new _BufferAttribute.BufferAttribute(sizeLod,
3));uv1.setAttribute("uv",new _BufferAttribute.BufferAttribute(sigma,2));uv1.setAttribute("faceIndex",new _BufferAttribute.BufferAttribute(faceIndex,1));_lodPlanes.push(uv1);4<lod&&lod--}return{_lodPlanes,_sizeLods,_sigmas}}(),_clearColor=new module.Color;let _oldTarget=null;require=(1+Math.sqrt(5))/2;global=1/require;const _axisDirections=[new _Vector2.Vector3(1,1,1),new _Vector2.Vector3(-1,1,1),new _Vector2.Vector3(1,1,-1),new _Vector2.Vector3(-1,1,-1),new _Vector2.Vector3(0,require,global),new _Vector2.Vector3(0,
require,-global),new _Vector2.Vector3(global,0,require),new _Vector2.Vector3(-global,0,require),new _Vector2.Vector3(require,global,0),new _Vector2.Vector3(-require,global,0)];class PMREMGenerator{constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;renderer=new Float32Array(20);const poleAxis=new _Vector2.Vector3(0,1,0);this._blurMaterial=new _RawShaderMaterial.RawShaderMaterial({name:"SphericalGaussianBlur",defines:{n:20},uniforms:{envMap:{value:null},samples:{value:1},
weights:{value:renderer},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:poleAxis}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include \x3ccube_uv_reflection_fragment\x3e\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta \x3d cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection \x3d vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis \x3d latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis \x3d vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis \x3d normalize( axis );\n\n\t\t\t\tgl_FragColor \x3d vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb +\x3d weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i \x3d 1; i \x3c n; i++ ) {\n\n\t\t\t\t\tif ( i \x3e\x3d samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta \x3d dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb +\x3d weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb +\x3d weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
blending:_constants.NoBlending,depthTest:!1,depthWrite:!1});this._cubemapShader=this._equirectShader=null;this._compileMaterial(this._blurMaterial)}fromScene(scene,sigma=0,near=.1,far=100){_oldTarget=this._renderer.getRenderTarget();const cubeUVRenderTarget=this._allocateTargets();this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget);0<sigma&&this._blur(cubeUVRenderTarget,0,0,sigma);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget}fromEquirectangular(equirectangular,
renderTarget=null){return this._fromTexture(equirectangular,renderTarget)}fromCubemap(cubemap,renderTarget=null){return this._fromTexture(cubemap,renderTarget)}compileCubemapShader(){null===this._cubemapShader&&(this._cubemapShader=_getCubemapShader(),this._compileMaterial(this._cubemapShader))}compileEquirectangularShader(){null===this._equirectShader&&(this._equirectShader=_getEquirectShader(),this._compileMaterial(this._equirectShader))}dispose(){this._blurMaterial.dispose();null!==this._pingPongRenderTarget&&
this._pingPongRenderTarget.dispose();null!==this._cubemapShader&&this._cubemapShader.dispose();null!==this._equirectShader&&this._equirectShader.dispose();for(let i=0;i<_lodPlanes$jscomp$0.length;i++)_lodPlanes$jscomp$0[i].dispose()}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=!1;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height)}_fromTexture(texture,renderTarget){_oldTarget=this._renderer.getRenderTarget();renderTarget=renderTarget||
this._allocateTargets(texture);this._textureToCubeUV(texture,renderTarget);this._applyPMREM(renderTarget);this._cleanup(renderTarget);return renderTarget}_allocateTargets(texture){const params={magFilter:_constants.LinearFilter,minFilter:_constants.LinearFilter,generateMipmaps:!1,type:_constants.HalfFloatType,format:_constants.RGBAFormat,encoding:_constants.LinearEncoding,depthBuffer:!1},cubeUVRenderTarget=_createRenderTarget(params);cubeUVRenderTarget.depthBuffer=texture?!1:!0;null===this._pingPongRenderTarget&&
(this._pingPongRenderTarget=_createRenderTarget(params));return cubeUVRenderTarget}_compileMaterial(material){material=new _Mesh.Mesh(_lodPlanes$jscomp$0[0],material);this._renderer.compile(material,_flatCamera)}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget){near=new _PerspectiveCamera.PerspectiveCamera(90,1,near,far);far=[1,-1,1,1,1,1];const forwardSign=[1,1,1,-1,-1,-1],renderer=this._renderer,originalAutoClear=renderer.autoClear,toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);
renderer.toneMapping=_constants.NoToneMapping;renderer.autoClear=!1;var backgroundMaterial=new _MeshBasicMaterial.MeshBasicMaterial({name:"PMREM.Background",side:_constants.BackSide,depthWrite:!1,depthTest:!1});const backgroundBox=new _Mesh.Mesh(new _BoxGeometry.BoxGeometry,backgroundMaterial);let useSolidColor=!1;const background=scene.background;background?background.isColor&&(backgroundMaterial.color.copy(background),scene.background=null,useSolidColor=!0):(backgroundMaterial.color.copy(_clearColor),
useSolidColor=!0);for(backgroundMaterial=0;6>backgroundMaterial;backgroundMaterial++){const col=backgroundMaterial%3;0===col?(near.up.set(0,far[backgroundMaterial],0),near.lookAt(forwardSign[backgroundMaterial],0,0)):1===col?(near.up.set(0,0,far[backgroundMaterial]),near.lookAt(0,forwardSign[backgroundMaterial],0)):(near.up.set(0,far[backgroundMaterial],0),near.lookAt(0,0,forwardSign[backgroundMaterial]));_setViewport(cubeUVRenderTarget,col*SIZE_MAX,2<backgroundMaterial?SIZE_MAX:0,SIZE_MAX,SIZE_MAX);
renderer.setRenderTarget(cubeUVRenderTarget);useSolidColor&&renderer.render(backgroundBox,near);renderer.render(scene,near)}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.autoClear=originalAutoClear;scene.background=background}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer,isCubeTexture=texture.mapping===_constants.CubeReflectionMapping||texture.mapping===_constants.CubeRefractionMapping;isCubeTexture?(null===
this._cubemapShader&&(this._cubemapShader=_getCubemapShader()),this._cubemapShader.uniforms.flipEnvMap.value=!1===texture.isRenderTargetTexture?-1:1):null===this._equirectShader&&(this._equirectShader=_getEquirectShader());var material=isCubeTexture?this._cubemapShader:this._equirectShader;const mesh=new _Mesh.Mesh(_lodPlanes$jscomp$0[0],material);material=material.uniforms;material.envMap.value=texture;isCubeTexture||material.texelSize.value.set(1/texture.image.width,1/texture.image.height);_setViewport(cubeUVRenderTarget,
0,0,3*SIZE_MAX,2*SIZE_MAX);renderer.setRenderTarget(cubeUVRenderTarget);renderer.render(mesh,_flatCamera)}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer,autoClear=renderer.autoClear;renderer.autoClear=!1;for(let i=1;i<TOTAL_LODS;i++)this._blur(cubeUVRenderTarget,i-1,i,Math.sqrt(_sigmas$jscomp$0[i]*_sigmas$jscomp$0[i]-_sigmas$jscomp$0[i-1]*_sigmas$jscomp$0[i-1]),_axisDirections[(i-1)%_axisDirections.length]);renderer.autoClear=autoClear}_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=
this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,"latitudinal",poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,"longitudinal",poleAxis)}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer;var blurMaterial=this._blurMaterial;"latitudinal"!==direction&&"longitudinal"!==direction&&console.error("blur direction must be either latitudinal or longitudinal!");const blurMesh=
new _Mesh.Mesh(_lodPlanes$jscomp$0[lodOut],blurMaterial);blurMaterial=blurMaterial.uniforms;var pixels=_sizeLods$jscomp$0[lodIn]-1;pixels=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/39;var sigmaPixels=sigmaRadians/pixels;const samples=isFinite(sigmaRadians)?1+Math.floor(3*sigmaPixels):20;20<samples&&console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${20}`);sigmaRadians=[];let sum=0;for(let i=0;20>i;++i){var x=
i/sigmaPixels;x=Math.exp(-x*x/2);sigmaRadians.push(x);0===i?sum+=x:i<samples&&(sum+=2*x)}for(sigmaPixels=0;sigmaPixels<sigmaRadians.length;sigmaPixels++)sigmaRadians[sigmaPixels]/=sum;blurMaterial.envMap.value=targetIn.texture;blurMaterial.samples.value=samples;blurMaterial.weights.value=sigmaRadians;blurMaterial.latitudinal.value="latitudinal"===direction;poleAxis&&(blurMaterial.poleAxis.value=poleAxis);blurMaterial.dTheta.value=pixels;blurMaterial.mipInt.value=8-lodIn;targetIn=_sizeLods$jscomp$0[lodOut];
_setViewport(targetOut,3*Math.max(0,SIZE_MAX-2*targetIn),(0===lodOut?0:2*SIZE_MAX)+2*targetIn*(4<lodOut?lodOut-8+4:0),3*targetIn,2*targetIn);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera)}}exports.PMREMGenerator=PMREMGenerator}
//# sourceMappingURL=module$node_modules$three$src$extras$PMREMGenerator.js.map
