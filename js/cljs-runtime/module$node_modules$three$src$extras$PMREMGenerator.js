shadow$provide.module$node_modules$three$src$extras$PMREMGenerator=function(global,require,module,exports){function _createRenderTarget(width,height,params){width=new _WebGLRenderTarget.WebGLRenderTarget(width,height,params);width.texture.mapping=_constants.CubeUVReflectionMapping;width.texture.name="PMREM.cubeUv";width.scissorTest=!0;return width}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height);target.scissor.set(x,y,width,height)}function _getEquirectMaterial(){return new _ShaderMaterial.ShaderMaterial({name:"EquirectangularToCubeUV",
uniforms:{envMap:{value:null}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include \x3ccommon\x3e\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection \x3d normalize( vOutputDirection );\n\t\t\t\tvec2 uv \x3d equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor \x3d vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",blending:_constants.NoBlending,
depthTest:!1,depthWrite:!1})}function _getCubemapMaterial(){return new _ShaderMaterial.ShaderMaterial({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor \x3d textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
blending:_constants.NoBlending,depthTest:!1,depthWrite:!1})}function _getCommonVertexShader(){return"\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv \x3d 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction \x3d vec3( uv, 1.0 );\n\n\t\t\tif ( face \x3d\x3d 0.0 ) {\n\n\t\t\t\tdirection \x3d direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face \x3d\x3d 1.0 ) {\n\n\t\t\t\tdirection \x3d direction.xzy;\n\t\t\t\tdirection.xz *\x3d -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face \x3d\x3d 2.0 ) {\n\n\t\t\t\tdirection.x *\x3d -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face \x3d\x3d 3.0 ) {\n\n\t\t\t\tdirection \x3d direction.zyx;\n\t\t\t\tdirection.xz *\x3d -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face \x3d\x3d 4.0 ) {\n\n\t\t\t\tdirection \x3d direction.xzy;\n\t\t\t\tdirection.xy *\x3d -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face \x3d\x3d 5.0 ) {\n\n\t\t\t\tdirection.z *\x3d -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection \x3d getDirection( uv, faceIndex );\n\t\t\tgl_Position \x3d vec4( position, 1.0 );\n\n\t\t}\n\t"}
Object.defineProperty(exports,"__esModule",{value:!0});exports.PMREMGenerator=void 0;var _constants=require("module$node_modules$three$src$constants"),_BufferAttribute=require("module$node_modules$three$src$core$BufferAttribute"),_BufferGeometry=require("module$node_modules$three$src$core$BufferGeometry"),_Mesh=require("module$node_modules$three$src$objects$Mesh");global=require("module$node_modules$three$src$cameras$OrthographicCamera");var _PerspectiveCamera=require("module$node_modules$three$src$cameras$PerspectiveCamera"),
_ShaderMaterial=require("module$node_modules$three$src$materials$ShaderMaterial"),_Vector=require("module$node_modules$three$src$math$Vector3");module=require("module$node_modules$three$src$math$Color");var _WebGLRenderTarget=require("module$node_modules$three$src$renderers$WebGLRenderTarget"),_MeshBasicMaterial=require("module$node_modules$three$src$materials$MeshBasicMaterial"),_BoxGeometry=require("module$node_modules$three$src$geometries$BoxGeometry");const EXTRA_LOD_SIGMA=[.125,.215,.35,.446,
.526,.582],_flatCamera=new global.OrthographicCamera,_clearColor=new module.Color;let _oldTarget=null;require=(1+Math.sqrt(5))/2;global=1/require;const _axisDirections=[new _Vector.Vector3(1,1,1),new _Vector.Vector3(-1,1,1),new _Vector.Vector3(1,1,-1),new _Vector.Vector3(-1,1,-1),new _Vector.Vector3(0,require,global),new _Vector.Vector3(0,require,-global),new _Vector.Vector3(global,0,require),new _Vector.Vector3(-global,0,require),new _Vector.Vector3(require,global,0),new _Vector.Vector3(-require,
global,0)];class PMREMGenerator{constructor(renderer){this._renderer=renderer;this._pingPongRenderTarget=null;this._cubeSize=this._lodMax=0;this._lodPlanes=[];this._sizeLods=[];this._sigmas=[];this._equirectMaterial=this._cubemapMaterial=this._blurMaterial=null;this._compileMaterial(this._blurMaterial)}fromScene(scene,sigma=0,near=.1,far=100){_oldTarget=this._renderer.getRenderTarget();this._setSize(256);const cubeUVRenderTarget=this._allocateTargets();cubeUVRenderTarget.depthBuffer=!0;this._sceneToCubeUV(scene,
near,far,cubeUVRenderTarget);0<sigma&&this._blur(cubeUVRenderTarget,0,0,sigma);this._applyPMREM(cubeUVRenderTarget);this._cleanup(cubeUVRenderTarget);return cubeUVRenderTarget}fromEquirectangular(equirectangular,renderTarget=null){return this._fromTexture(equirectangular,renderTarget)}fromCubemap(cubemap,renderTarget=null){return this._fromTexture(cubemap,renderTarget)}compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){null===
this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose();null!==this._cubemapMaterial&&this._cubemapMaterial.dispose();null!==this._equirectMaterial&&this._equirectMaterial.dispose()}_setSize(cubeSize){this._lodMax=Math.floor(Math.log2(cubeSize));this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose();null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();
for(let i=0;i<this._lodPlanes.length;i++)this._lodPlanes[i].dispose()}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget);outputTarget.scissorTest=!1;_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height)}_fromTexture(texture,renderTarget){texture.mapping===_constants.CubeReflectionMapping||texture.mapping===_constants.CubeRefractionMapping?this._setSize(0===texture.image.length?16:texture.image[0].width||texture.image[0].image.width):this._setSize(texture.image.width/
4);_oldTarget=this._renderer.getRenderTarget();renderTarget=renderTarget||this._allocateTargets();this._textureToCubeUV(texture,renderTarget);this._applyPMREM(renderTarget);this._cleanup(renderTarget);return renderTarget}_allocateTargets(){const width=3*Math.max(this._cubeSize,112),height=4*this._cubeSize;var params={magFilter:_constants.LinearFilter,minFilter:_constants.LinearFilter,generateMipmaps:!1,type:_constants.HalfFloatType,format:_constants.RGBAFormat,encoding:_constants.LinearEncoding,depthBuffer:!1};
const cubeUVRenderTarget=_createRenderTarget(width,height,params);if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==width){null!==this._pingPongRenderTarget&&this._dispose();this._pingPongRenderTarget=_createRenderTarget(width,height,params);var {_lodMax}=this;params=_lodMax;var lodPlanes=[];const sizeLods=[],sigmas=[];let lod=params;const totalLods=params-4+1+EXTRA_LOD_SIGMA.length;for(let i=0;i<totalLods;i++){var sizeLod=Math.pow(2,lod);sizeLods.push(sizeLod);var sigma=1/
sizeLod;i>params-4?sigma=EXTRA_LOD_SIGMA[i-params+4-1]:0===i&&(sigma=0);sigmas.push(sigma);sigma=1/(sizeLod-2);sizeLod=-sigma;sigma=1+sigma;var uv1=[sizeLod,sizeLod,sigma,sizeLod,sigma,sigma,sizeLod,sizeLod,sigma,sigma,sizeLod,sigma];sizeLod=new Float32Array(108);sigma=new Float32Array(72);const faceIndex=new Float32Array(36);for(let face=0;6>face;face++){const x=face%3*2/3-1,y=2<face?0:-1;sizeLod.set([x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0],18*face);sigma.set(uv1,12*face);faceIndex.set([face,
face,face,face,face,face],6*face)}uv1=new _BufferGeometry.BufferGeometry;uv1.setAttribute("position",new _BufferAttribute.BufferAttribute(sizeLod,3));uv1.setAttribute("uv",new _BufferAttribute.BufferAttribute(sigma,2));uv1.setAttribute("faceIndex",new _BufferAttribute.BufferAttribute(faceIndex,1));lodPlanes.push(uv1);4<lod&&lod--}({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}={lodPlanes,sizeLods,sigmas});params=_lodMax;_lodMax=new Float32Array(20);lodPlanes=new _Vector.Vector3(0,
1,0);this._blurMaterial=new _ShaderMaterial.ShaderMaterial({name:"SphericalGaussianBlur",defines:{n:20,CUBEUV_TEXEL_WIDTH:1/width,CUBEUV_TEXEL_HEIGHT:1/height,CUBEUV_MAX_MIP:`${params}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:_lodMax},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:lodPlanes}},vertexShader:_getCommonVertexShader(),fragmentShader:"\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include \x3ccube_uv_reflection_fragment\x3e\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta \x3d cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection \x3d vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis \x3d latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis \x3d vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis \x3d normalize( axis );\n\n\t\t\t\tgl_FragColor \x3d vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb +\x3d weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i \x3d 1; i \x3c n; i++ ) {\n\n\t\t\t\t\tif ( i \x3e\x3d samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta \x3d dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb +\x3d weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb +\x3d weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
blending:_constants.NoBlending,depthTest:!1,depthWrite:!1})}return cubeUVRenderTarget}_compileMaterial(material){material=new _Mesh.Mesh(this._lodPlanes[0],material);this._renderer.compile(material,_flatCamera)}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget){near=new _PerspectiveCamera.PerspectiveCamera(90,1,near,far);far=[1,-1,1,1,1,1];const forwardSign=[1,1,1,-1,-1,-1],renderer=this._renderer,originalAutoClear=renderer.autoClear,toneMapping=renderer.toneMapping;renderer.getClearColor(_clearColor);
renderer.toneMapping=_constants.NoToneMapping;renderer.autoClear=!1;var backgroundMaterial=new _MeshBasicMaterial.MeshBasicMaterial({name:"PMREM.Background",side:_constants.BackSide,depthWrite:!1,depthTest:!1});const backgroundBox=new _Mesh.Mesh(new _BoxGeometry.BoxGeometry,backgroundMaterial);let useSolidColor=!1;const background=scene.background;background?background.isColor&&(backgroundMaterial.color.copy(background),scene.background=null,useSolidColor=!0):(backgroundMaterial.color.copy(_clearColor),
useSolidColor=!0);for(backgroundMaterial=0;6>backgroundMaterial;backgroundMaterial++){const col=backgroundMaterial%3;0===col?(near.up.set(0,far[backgroundMaterial],0),near.lookAt(forwardSign[backgroundMaterial],0,0)):1===col?(near.up.set(0,0,far[backgroundMaterial]),near.lookAt(0,forwardSign[backgroundMaterial],0)):(near.up.set(0,far[backgroundMaterial],0),near.lookAt(0,0,forwardSign[backgroundMaterial]));const size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,2<backgroundMaterial?size:
0,size,size);renderer.setRenderTarget(cubeUVRenderTarget);useSolidColor&&renderer.render(backgroundBox,near);renderer.render(scene,near)}backgroundBox.geometry.dispose();backgroundBox.material.dispose();renderer.toneMapping=toneMapping;renderer.autoClear=originalAutoClear;scene.background=background}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer;var isCubeTexture=texture.mapping===_constants.CubeReflectionMapping||texture.mapping===_constants.CubeRefractionMapping;isCubeTexture?
(null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial()),this._cubemapMaterial.uniforms.flipEnvMap.value=!1===texture.isRenderTargetTexture?-1:1):null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial());const material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial;isCubeTexture=new _Mesh.Mesh(this._lodPlanes[0],material);material.uniforms.envMap.value=texture;texture=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*texture,2*texture);renderer.setRenderTarget(cubeUVRenderTarget);
renderer.render(isCubeTexture,_flatCamera)}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer,autoClear=renderer.autoClear;renderer.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++)this._blur(cubeUVRenderTarget,i-1,i,Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),_axisDirections[(i-1)%_axisDirections.length]);renderer.autoClear=autoClear}_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,
pingPongRenderTarget,lodIn,lodOut,sigma,"latitudinal",poleAxis);this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,"longitudinal",poleAxis)}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer;var blurMaterial=this._blurMaterial;"latitudinal"!==direction&&"longitudinal"!==direction&&console.error("blur direction must be either latitudinal or longitudinal!");const blurMesh=new _Mesh.Mesh(this._lodPlanes[lodOut],blurMaterial);
blurMaterial=blurMaterial.uniforms;var pixels=this._sizeLods[lodIn]-1;pixels=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/39;var sigmaPixels=sigmaRadians/pixels;const samples=isFinite(sigmaRadians)?1+Math.floor(3*sigmaPixels):20;20<samples&&console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${20}`);sigmaRadians=[];let sum=0;for(let i=0;20>i;++i){var x=i/sigmaPixels;x=Math.exp(-x*x/2);sigmaRadians.push(x);0===
i?sum+=x:i<samples&&(sum+=2*x)}for(sigmaPixels=0;sigmaPixels<sigmaRadians.length;sigmaPixels++)sigmaRadians[sigmaPixels]/=sum;blurMaterial.envMap.value=targetIn.texture;blurMaterial.samples.value=samples;blurMaterial.weights.value=sigmaRadians;blurMaterial.latitudinal.value="latitudinal"===direction;poleAxis&&(blurMaterial.poleAxis.value=poleAxis);({_lodMax:targetIn}=this);blurMaterial.dTheta.value=pixels;blurMaterial.mipInt.value=targetIn-lodIn;lodIn=this._sizeLods[lodOut];_setViewport(targetOut,
3*lodIn*(lodOut>targetIn-4?lodOut-targetIn+4:0),4*(this._cubeSize-lodIn),3*lodIn,2*lodIn);renderer.setRenderTarget(targetOut);renderer.render(blurMesh,_flatCamera)}}exports.PMREMGenerator=PMREMGenerator}
//# sourceMappingURL=module$node_modules$three$src$extras$PMREMGenerator.js.map
