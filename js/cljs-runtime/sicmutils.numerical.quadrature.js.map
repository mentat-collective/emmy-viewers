{"version":3,"sources":["sicmutils/numerical/quadrature.cljc"],"mappings":"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","names":["sicmutils.numerical.quadrature/quadrature-methods","sicmutils.numerical.quadrature.common/open","sicmutils.numerical.quadrature.common/closed","sicmutils.numerical.quadrature.common/closed-open","sicmutils.numerical.quadrature.common/open-closed","sicmutils.numerical.quadrature.bulirsch-stoer/open-integral","sicmutils.numerical.quadrature.bulirsch-stoer/closed-integral","sicmutils.numerical.quadrature.adaptive.adaptive","sicmutils.numerical.quadrature.riemann/left-integral","sicmutils.numerical.quadrature.riemann/right-integral","sicmutils.numerical.quadrature.riemann/lower-integral","sicmutils.numerical.quadrature.riemann/upper-integral","sicmutils.numerical.quadrature.midpoint/integral","sicmutils.numerical.quadrature.trapezoid/integral","sicmutils.numerical.quadrature.boole/integral","sicmutils.numerical.quadrature.milne/integral","sicmutils.numerical.quadrature.simpson/integral","sicmutils.numerical.quadrature.simpson38/integral","sicmutils.numerical.quadrature.romberg/closed-integral","sicmutils.numerical.quadrature.romberg/open-integral","sicmutils.numerical.quadrature/available-methods","cljs.core.into","cljs.core/keys","sicmutils.numerical.quadrature/extract-method","method","cljs.core/fn?","cljs.core/Keyword","G__102902","cljs.core/map?","vec__102903","cljs.core.nth","f","m","G__102906","cljs.core.merge","cljs.core.dissoc","var_args","G__102908","sicmutils.numerical.quadrature/get-integrator","js/Error","a","b","sicmutils.numerical.quadrature.get_integrator","temp__5753__auto__","vec__102909","integrate","opts","or__4253__auto__","sicmutils.generic/infinite?","sicmutils.numerical.quadrature.infinite/improper","G__102913","sicmutils.numerical.quadrature/definite-integral","p__102914","map__102915","cljs.core/--destructure-map","cljs.core.get","sicmutils.numerical.quadrature.definite_integral","compile?","info?","temp__5751__auto__","vec__102916","sicmutils.expression.compile.compile_fn","cljs.core.comp","sicmutils.util/double","result","sicmutils.util/illegal"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature\n  (:require [sicmutils.expression.compile :as c]\n            [sicmutils.generic :as g]\n            [sicmutils.numerical.quadrature.adaptive :as qa]\n            [sicmutils.numerical.quadrature.boole :as boole]\n            [sicmutils.numerical.quadrature.bulirsch-stoer :as bs]\n            [sicmutils.numerical.quadrature.common :as qc]\n            [sicmutils.numerical.quadrature.infinite :as qi]\n            [sicmutils.numerical.quadrature.midpoint :as mid]\n            [sicmutils.numerical.quadrature.milne :as milne]\n            [sicmutils.numerical.quadrature.riemann :as riemann]\n            [sicmutils.numerical.quadrature.romberg :as romberg]\n            [sicmutils.numerical.quadrature.simpson :as simp]\n            [sicmutils.numerical.quadrature.simpson38 :as simp38]\n            [sicmutils.numerical.quadrature.trapezoid :as trap]\n            [sicmutils.util :as u]))\n\n;; ## Numerical Quadrature\n;;\n;; This namespace unites all of the work inside `sicmutils.numerical.quadrature`\n;; behind a single interface, fronted by the all-powerful `definite-integral`\n;; function.\n;;\n;; The interface takes `f`, an integrand, along with bounds `a` and `b`:\n;;\n;; (definite-integral f a b)\n;;\n;; Optionally, you can provide a dictionary of customizing options. These are\n;; passed down to whatever method you supply via the `:method` key.\n;;\n;; (definite-integral f a b opts)\n;;\n;;\n;; ## Implementation\n;;\n;; The keys in `quad-methods` below define the full range of integration methods\n;; available in the package. Each entry in this dictionary is either:\n;;\n;; - An 'integrator' function that matches the interface above for\n;;   `definite-integral` (possibly created with `qc/defintegrator`)\n;;\n;; - a dictionary of extra options. This must contain a `:method` key.\n;;\n;; This latter style is used when the method itself is a specialization of a\n;; more general method.\n\n(def ^:private quadrature-methods\n  {:open                    {:method :adaptive-bulirsch-stoer\n                             :interval qc/open}\n   :closed                  {:method :adaptive-bulirsch-stoer\n                             :interval qc/closed}\n   :closed-open             {:method :adaptive-bulirsch-stoer\n                             :interval qc/closed-open}\n   :open-closed             {:method :adaptive-bulirsch-stoer\n                             :interval qc/open-closed}\n   :bulirsch-stoer-open     bs/open-integral\n   :bulirsch-stoer-closed   bs/closed-integral\n   :adaptive-bulirsch-stoer (qa/adaptive bs/open-integral bs/closed-integral)\n   :left-riemann            riemann/left-integral\n   :right-riemann           riemann/right-integral\n   :lower-riemann           riemann/lower-integral\n   :upper-riemann           riemann/upper-integral\n   :midpoint                mid/integral\n   :trapezoid               trap/integral\n   :boole                   boole/integral\n   :milne                   milne/integral\n   :simpson                 simp/integral\n   :simpson38               simp38/integral\n   :romberg                 romberg/closed-integral\n   :romberg-open            romberg/open-integral})\n\n(def available-methods\n  (into #{} (keys quadrature-methods)))\n\n;; The user can specify a method by providing the `:method` key in their options\n;; with:\n;;\n;; - a key in the above dictionary\n;; - another dict\n;; - a custom integration function\n;;\n;; The latter two are the allowed value types in `quadrature-methods`.\n\n(defn- extract-method\n  \"Attempts to turn the supplied argument into an integration method; returns nil\n  if method doesn't exist.\"\n  [method]\n  (cond (fn? method)\n        [method {}]\n\n        (keyword? method)\n        (extract-method\n         (quadrature-methods method))\n\n        (map? method)\n        (let [[f m] (extract-method\n                     (:method method))]\n          [f (merge (dissoc method :method) m)])))\n\n(defn get-integrator\n  \"Takes:\n\n  - An integration method, specified as either:\n    - a keyword naming one of the available methods in `available-methods`\n    - a function with the proper integrator signature\n    - a dictionary of integrator options with a `:method` key\n\n  - `a` and `b` integration endpoints\n  - an optional dictionary of options `m`\n\n  And returns a pair of an integrator function and a possibly-enhanced options\n  dictionary.\n\n  (Some integration functions require extra options, so the returned dictionary\n  may have more entries than the `m` you pass in.)\n\n  If either endpoint is infinite, the returned integrator is wrapped in\n  `qi/improper` and able to handle infinite endpoints (as well as non-infinite\n  endpoints by passing through directly to the underlying integrator).\"\n  ([method a b] (get-integrator method a b {}))\n  ([method a b m]\n   (when-let [[integrate opts] (extract-method method)]\n     (let [integrate (if (or (g/infinite? a)\n                             (g/infinite? b))\n                       (qi/improper integrate)\n                       integrate)]\n       [integrate (dissoc (merge opts m) :method)]))))\n\n;; ## Final API\n;;\n;; Here we are! The one function you need care about if you're interested in\n;; definite integrals. Learn to use this, and then dig in to the details of\n;; individual methods if you run into trouble or want to learn more. Enjoy!\n\n(defn definite-integral\n  \"Evaluates the definite integral of integrand `f` across the interval $a, b$.\n  Optionally accepts a dictionary `opts` of customizing options; All `opts` will\n  be passed through to the supplied `integrate` functions.\n\n  If you'd like more control, or to retrieve the integration function directly\n  without looking it up via `:method` each time, see `get-integrator`.\n\n  All supplied options are passed through to the underlying integrator; see the\n  specific integrator for information on what options are available.\n\n  ## Keyword arguments:\n\n  `:method`: Specifies the integration method used. Must be\n\n  - a keyword naming one of the available methods in `available-methods`\n  - a function with the proper integrator signature\n  - a dictionary of integrator options with a `:method` key\n\n  Defaults to `:open`, which specifies an adaptive bulirsch-stoer quadrature method.\n\n  `:compile?` If true, the generic function will be simplified and compiled\n  before execution.\n\n  `:info?` If true, `definite-integral` will return a map of integration\n  information returned by the underlying integrator. Else, returns an estimate\n  of the definite integral.\"\n  ([f a b] (definite-integral f a b {}))\n  ([f a b {:keys [method compile? info?]\n           :or {method :open\n                compile? false\n                info? false}\n           :as opts}]\n   (if-let [[integrate m] (get-integrator method a b opts)]\n     (let [f      (if compile?\n                    (c/compile-fn f 1)\n                    #?(:cljs (comp u/double f)\n                       :clj f))\n           result (integrate f a b m)]\n       (if info? result (:result result)))\n     (u/illegal (str \"Unknown method: \" method\n                     \". Try one of: \"\n                     available-methods)))))\n"]}