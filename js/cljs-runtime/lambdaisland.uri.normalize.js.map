{"version":3,"sources":["lambdaisland/uri/normalize.cljc"],"mappings":"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","names":["lambdaisland.uri.normalize/character-classes","alpha","digit","gen-delims","sub-delims","reserved","unreserved","pchar","scheme","host","authority","path","query","fragment","cljs.core/re-pattern","lambdaisland.uri.normalize/high-surrogate?","char-code","var_args","G__61618","lambdaisland.uri.normalize/char-seq","js/Error","str","lambdaisland.uri.normalize.char_seq","offset","res","lambdaisland.uri.platform/str-len","code","lambdaisland.uri.platform/char-code-at","width","next-offset","cur-char","cljs.core.subs","cljs.core.conj","G__61627","lambdaisland.uri.normalize/percent-encode","component","lambdaisland.uri.platform/string->byte-seq","p1__61621#","cljs.core.map","lambdaisland.uri.platform/byte->hex","cljs.core.apply","cljs.core/str","type","p1__61622#","char-class","cljs.core.get","encode-char","G__61649","cljs.core/re-find","lambdaisland.uri.normalize.percent_encode","lambdaisland.uri.normalize/percent-decode","s","clojure.string/replace","p__61674","vec__61675","cljs.core.nth","x","_","lambdaisland.uri.platform/byte-seq->string","clojure.string.split","cljs.core.drop","lambdaisland.uri.platform/hex->byte","lambdaisland.uri.normalize/normalize-path","lambdaisland.uri.normalize/normalize-fragment","lambdaisland.uri.normalize/hex-code-point?","cp","lambdaisland.uri.normalize/sub-delims","lambdaisland.uri.normalize/normalize-query","len","i","cljs.core._EQ_","cljs.core/contains?","increment","lambdaisland.uri.normalize/normalize","uri","cljs.core.update"],"sourcesContent":["(ns lambdaisland.uri.normalize\n  (:require [clojure.string :as str]\n            [lambdaisland.uri.platform :refer [byte-seq->string\n                                               string->byte-seq\n                                               byte->hex hex->byte\n                                               char-code-at\n                                               str-len]]))\n\n;; TODO we might be better off having these just be sets\n(def\n  ^{:doc\n    \"Which characters should be percent-encoded depends on which section\n    of the URI is being normalized. This map contains regexes that for each\n    case match the characters that need encoding.\"}\n  character-classes\n  (let [alpha       \"a-zA-Z\"\n        digit       \"0-9\"\n        gen-delims  \":\\\\/\\\\?#\\\\[\\\\]@\"\n        sub-delims  \"!\\\\$&'\\\\(\\\\)\\\\*\\\\+,;=\"\n        reserved    (str gen-delims sub-delims)\n        unreserved  (str alpha digit \"\\\\-\\\\._~\")\n        pchar       (str unreserved sub-delims \":@\")\n        scheme      (str alpha digit \"\\\\-\\\\+\\\\.\")\n        host        (str unreserved sub-delims \"\\\\[:\\\\]\")\n        authority   pchar\n        path        (str pchar \"\\\\/\")\n        query       (str unreserved \":@\\\\/\\\\?\")\n        fragment    (str pchar \"\\\\/\\\\?\")]\n    {:alpha      (re-pattern (str \"[^\" alpha \"]\"))\n     :digit      (re-pattern (str \"[^\" digit \"]\"))\n     :gen-delims (re-pattern (str \"[^\" gen-delims \"]\"))\n     :sub-delims (re-pattern (str \"[^\" sub-delims \"]\"))\n     :reserved   (re-pattern (str \"[^\" reserved \"]\"))\n     :unreserved (re-pattern (str \"[^\" unreserved \"]\"))\n     :pchar      (re-pattern (str \"[^\" pchar \"]\"))\n     :scheme     (re-pattern (str \"[^\" scheme \"]\"))\n     :host       (re-pattern (str \"[^\" host \"]\"))\n     :authority  (re-pattern (str \"[^\" authority \"]\"))\n     :path       (re-pattern (str \"[^\" path \"]\"))\n     :query      (re-pattern (str \"[^\" query \"]\"))\n     :fragment   (re-pattern (str \"[^\" fragment \"]\"))}))\n\n(defn high-surrogate? [char-code]\n  (<= 0xD800 char-code 0xDBFF))\n\n(defn char-seq\n  \"Return a seq of the characters in a string, making sure not to split up\n  UCS-2 (or is it UTF-16?) surrogate pairs. Because JavaScript. And Java.\"\n  ([str]\n   (char-seq str 0))\n  ([str offset]\n   (loop [offset offset\n          res []]\n     (if (>= offset (str-len str))\n       res\n       (let [code (char-code-at str offset)\n             width (if (high-surrogate? code) 2 1)\n             next-offset (+ offset width)\n             cur-char (subs str offset next-offset)]\n         (recur next-offset\n                (conj res cur-char)))))))\n\n(defn percent-encode\n  \"Convert characters in their percent encoded form. e.g.\n   `(percent_encode \\\"a\\\") #_=> \\\"%61\\\"`. When given a second argument, then\n   only characters of the given character class are encoded,\n   see `character-class`.\n\n   Characters are encoded as UTF-8. To use a different encoding. re-bind\n   `*character-encoding*`\"\n  ([component]\n   (->> (string->byte-seq component)\n        (map #(str \"%\" (byte->hex %)))\n        (apply str)))\n  ([component type]\n   (let [char-class (get character-classes type)\n         encode-char #(cond-> % (re-find char-class %) percent-encode)]\n     (->> (char-seq component)\n          (map encode-char)\n          (apply str)))))\n\n(defn percent-decode\n  \"The inverse of `percent-encode`, convert any %XX sequences in a string to\n   characters. Byte sequences are interpreted as UTF-8. To use a different\n   encoding. re-bind `*character-encoding*`\"\n  [s]\n  (when s\n    (str/replace s #\"(%[0-9A-Fa-f]{2})+\"\n                 (fn [[x _]]\n                   (byte-seq->string\n                    (->> (str/split x #\"%\")\n                         (drop 1)\n                         (map hex->byte)))))))\n\n(defn normalize-path [path]\n  (when-not (nil? path)\n    (percent-encode (percent-decode path) :path)))\n\n(defn normalize-fragment [fragment]\n  (when-not (nil? fragment)\n    (percent-encode (percent-decode fragment) :fragment)))\n\n(defn hex-code-point? [cp]\n  (or (<= #_(long \\0) 48 cp #_(long \\9) 57)\n      (<= #_(long \\A) 65 cp #_(long \\F) 70)\n      (<= #_(long \\a) 97 cp #_(long \\f) 102)))\n\n(def sub-delims\n  \"RFC3986 section 2.2\n\n  The purpose of reserved characters is to provide a set of delimiting\n  characters that are distinguishable from other data within a URI.\n  URIs that differ in the replacement of a reserved character with its\n  corresponding percent-encoded octet are not equivalent.  Percent-\n  encoding a reserved character, or decoding a percent-encoded octet\n  that corresponds to a reserved character, will change how the URI is\n  interpreted by most applications.  Thus, characters in the reserved\n  set are protected from normalization and are therefore safe to be\n  used by scheme-specific and producer-specific algorithms for\n  delimiting data subcomponents within a URI. \"\n  #{\"!\"  \"$\"  \"&\"  \"'\"  \"(\"  \")\" \"*\"  \"+\"  \",\"  \";\"  \"=\"})\n\n(defn normalize-query\n  \"Normalize the query section of a URI\n\n  - sub-delimiters that are not percent encoded are left unencoded\n  - sub-delimiters and other reserved characters are always percent encoded\n  - non-reserved characters that are percent-encoded are decoded\n  \"\n  [s]\n  (when s\n    (let [len (str-len s)]\n      (loop [i 0\n             res []]\n        (cond\n          (= i len)\n          (apply str res)\n\n          (and (< i (- len 2))\n               (= 37 (char-code-at s i))\n               (hex-code-point? (char-code-at s (inc i)))\n               (hex-code-point? (char-code-at s (+ i 2))))\n          (recur (+ i 3)\n                 (conj res (percent-encode (percent-decode (subs s i (+ i 3)))\n                                           :query)))\n\n          (contains? sub-delims (subs s i (inc i)))\n          (recur (inc i)\n                 (conj res (subs s i (inc i))))\n\n          :else\n          (let [increment (if (high-surrogate? (char-code-at s i)) 2 1)]\n            (recur (+ i increment)\n                   (conj res (percent-encode (subs s i (+ i increment)) :query)))))))))\n\n(defn normalize\n  \"Normalize a lambdaisland.uri.URI. Currently normalizes (percent-encodes) the\n  path, query, and fragment.\"\n  [uri]\n  (-> uri\n      (update :path normalize-path)\n      (update :query normalize-query)\n      (update :fragment normalize-fragment)))\n"]}