shadow$provide.module$node_modules$$sicmutils$glsl_parser$lib$index=function(global,require,module,exports){function mknode(mode,sourcetoken){return{mode,token:sourcetoken,children:[],type:stmt_type[mode],id:(4294967295*Math.random()).toString(16)}}module.exports=function(){function reader(data){if(null===data)return end(),program;nodes=[];write(data);return nodes}function write(input){if("whitespace"===input.type||"line-comment"===input.type||"block-comment"===input.type)whitespace.push(input);else for(tokens$jscomp$0.push(input),
(token=token||tokens$jscomp$0[0])&&whitespace.length&&(token.preceding=token.preceding||[],token.preceding=token.preceding.concat(whitespace),whitespace=[]);errored||!state.length?0:token=tokens$jscomp$0[0];)switch(state[0].mode){case STMT:parse_stmt();break;case STMTLIST:parse_stmtlist();break;case DECL:parse_decl();break;case DECLLIST:parse_decllist();break;case EXPR:parse_expr();break;case STRUCT:parse_struct(!0,!0);break;case PRECISION:parse_precision();break;case IDENT:"ident"!==token.type&&
"builtin"!==token.type?unexpected("expected user-defined name, got "+token.data):(state[0].data=token.data,state.shift(),tokens$jscomp$0.shift());break;case KEYWORD:"keyword"!==token.type?unexpected("expected keyword, got "+token.data):(state.shift(),tokens$jscomp$0.shift());break;case KEYWORD_OR_IDENT:"keyword"===token.type?(state[0].type="keyword",state[0].mode=KEYWORD):"ident"===token.type?(state[0].type="ident",state[0].mode=IDENT):unexpected("expected keyword or user-defined name, got "+token.data);
break;case FUNCTION:parse_function();break;case FUNCTIONARGS:parse_function_args();break;case FORLOOP:parse_forloop();break;case WHILELOOP:parse_whileloop();break;case DOWHILELOOP:parse_dowhileloop();break;case RETURN:parse_return();break;case IF:parse_if();break;case QUANTIFIER:parse_quantifier()}}function end(tokens){arguments.length&&write(tokens);1<state.length&&unexpected("unexpected EOF")}function parse_stmtlist(){return stative(function(){state.scope.enter();return Advance},function(){if(token.data===
state[0].expecting)return state.scope.exit(),state.shift();switch(token.type){case "preprocessor":state.fake(mknode(token_map[token.type],token,node));tokens$jscomp$0.shift();break;default:state.unshift(stmt())}})()}function parse_stmt(){if(state[0].brace){if("}"!==token.data)return unexpected("expected `}`, got "+token.data);state[0].brace=!1;return tokens$jscomp$0.shift(),state.shift()}switch(token.type){case "eof":return ended&&(errored=!0),ended=!0,state.shift();case "keyword":switch(token.data){case "for":return state.unshift(forstmt());
case "if":return state.unshift(ifstmt());case "while":return state.unshift(whilestmt());case "do":return state.unshift(dowhilestmt());case "break":return state.fake(mknode(BREAK,token)),tokens$jscomp$0.shift();case "continue":return state.fake(mknode(CONTINUE,token)),tokens$jscomp$0.shift();case "discard":return state.fake(mknode(DISCARD,token)),tokens$jscomp$0.shift();case "return":return state.unshift(returnstmt());case "precision":return state.unshift(precision())}return state.unshift(decl(255));
case "ident":var lookup;if(lookup=state.scope.find(token.data))return"struct"===lookup.parent.type?state.unshift(decl(255)):state.unshift(expr(";"));case "operator":if("{"===token.data)return state[0].brace=!0,lookup=stmtlist(),lookup.expecting="}",tokens$jscomp$0.shift(),state.unshift(lookup);if(";"===token.data)return tokens$jscomp$0.shift(),state.shift();default:return state.unshift(expr(";"))}}function parse_decl(){const stmt=state[0];return stative(function(){if("invariant"===token.data)return stmt.flags&
8?(state.unshift(keyword()),Advance):unexpected("`invariant` is not allowed here");state.fake(mknode(PLACEHOLDER,{data:"",position:token.position}));return Advance},function(){if("const"===token.data||"attribute"===token.data||"uniform"===token.data||"varying"===token.data)return stmt.flags&16?(state.unshift(keyword()),Advance):unexpected("storage is not allowed here");state.fake(mknode(PLACEHOLDER,{data:"",position:token.position}));return Advance},function(){if("in"===token.data||"inout"===token.data||
"out"===token.data){if(stmt.flags&32)return unexpected("parameter is not allowed here");state.unshift(keyword());return Advance}state.fake(mknode(PLACEHOLDER,{data:"",position:token.position}));return Advance},function(){"highp"===token.data||"mediump"===token.data||"lowp"===token.data?state.unshift(keyword()):state.fake(mknode(PLACEHOLDER,{data:"",position:token.position}));return Advance},function(){if("struct"===token.data){if(!(stmt.flags&64))return unexpected("cannot nest structs");state.unshift(struct());
return Advance}if("keyword"===token.type)return state.unshift(keyword()),Advance;const lookup=state.scope.find(token.data);return lookup?(state.fake(Object.create(lookup)),tokens$jscomp$0.shift(),Advance):unexpected("expected user defined type, struct or keyword, got "+token.data)},function(){if(","===token.data&&!(stmt.flags&2))return state.shift();if("["===token.data)state.unshift(quantifier());else{if(")"===token.data)return state.shift();if(";"===token.data)return stmt.stage+3;if("ident"!==token.type&&
"builtin"!==token.type)return unexpected("expected identifier, got "+token.data);stmt.collected_name=tokens$jscomp$0.shift();return Advance}},function(){return"("===token.data?(tokens$jscomp$0.unshift(stmt.collected_name),delete stmt.collected_name,state.unshift(fn()),stmt.stage+2):Advance},function(){tokens$jscomp$0.unshift(stmt.collected_name);delete stmt.collected_name;state.unshift(decllist());return Advance},function(){return state.shift()})()}function parse_decllist(){if("ident"===token.type||
"builtin"===token.type){const name=token.data;state.unshift(ident());state.scope.define(name)}else{if("operator"===token.type){if(","===token.data)return state[1].flags&2?tokens$jscomp$0.shift():state.shift();if("\x3d"===token.data){if(!(state[1].flags&1))return unexpected("`\x3d` is not allowed here.");tokens$jscomp$0.shift();state.unshift(expr(",",";"));return}if("["===token.data){state.unshift(quantifier());return}}return state.shift()}}function parse_expr(){const expecting=state[0].expecting;
state[0].tokens=state[0].tokens||[];void 0===state[0].parenlevel&&(state[0].parenlevel=0,state[0].bracelevel=0);if(1>state[0].parenlevel&&-1<expecting.indexOf(token.data)){try{full_parse_expr(state,state[0].tokens)}catch(err){throw errored=!0,err;}return state.shift()}"("===token.data?++state[0].parenlevel:")"===token.data&&--state[0].parenlevel;switch(token.data){case "{":++state[0].bracelevel;break;case "}":--state[0].bracelevel;break;case "(":++state[0].parenlevel;break;case ")":--state[0].parenlevel}if(0>
state[0].parenlevel)return unexpected("unexpected `)`");if(0>state[0].bracelevel)return unexpected("unexpected `}`");state[0].tokens.push(tokens$jscomp$0.shift())}function n$jscomp$0(type){return function(){return mknode(type,token)}}function decl(flags){const _=mknode(DECL,token,node);_.flags=flags;return _}function struct(allow_assign,allow_comma){const _=mknode(STRUCT,token,node);_.allow_assign=void 0===allow_assign?!0:allow_assign;_.allow_comma=void 0===allow_comma?!0:allow_comma;return _}function expr(){const n=
mknode(EXPR,token,node);n.expecting=[].slice.call(arguments);return n}function keyword(default_value){let t=token;default_value&&(t={type:"(implied)",data:"(default)",position:t.position});return mknode(KEYWORD,t,node)}function unexpected(str){errored=!0;throw Error((str||"unexpected "+state)+" at line "+state[0].token.line);}function assert(type,data){return 1,assert_null_string_or_array(type,token.type)&&assert_null_string_or_array(data,token.data)}function assert_null_string_or_array(x,y){switch(typeof x){case "string":return y!==
x&&unexpected("expected `"+x+"`, got "+y+"\n"+token.data),!errored;case "object":return x&&-1===x.indexOf(y)&&unexpected("expected one of `"+x.join("`, `")+"`, got "+y),!errored}return!0}function stative(){let steps=[].slice.call(arguments),step,result;return function(){const current=state[0];current.stage||(current.stage=0);step=steps[current.stage];if(!step)return unexpected("parser in undefined state!");result=step();if(result===Advance)return++current.stage;void 0!==result&&(current.stage=result)}}
function advance(op,t){t=t||"operator";return function(){if(assert(t,op)){var last=tokens$jscomp$0.shift(),children=state[0].children;(children=children[children.length-1])&&children.token&&last.preceding&&(children.token.succeeding=children.token.succeeding||[],children.token.succeeding=children.token.succeeding.concat(last.preceding));return Advance}}}function advance_expr(until){return function(){state.unshift(expr(until));return Advance}}function advance_ident(declare){return declare?function(){const name=
token.data;return assert("ident")&&(state.unshift(ident()),state.scope.define(name),Advance)}:function(){if(assert("ident"))return Object.create(state.scope.find(token.data)).token=token,tokens$jscomp$0.shift(),Advance}}function advance_stmtlist(){return function(){const n=stmtlist();n.expecting="}";return state.unshift(n),Advance}}function maybe_stmtlist(skip){return function(){const current=state[0].stage;return"{"!==token.data?(state.unshift(stmt()),current+skip):(tokens$jscomp$0.shift(),Advance)}}
function popstmt(){return function(){return state.shift(),state.shift()}}const stmtlist=n$jscomp$0(STMTLIST),stmt=n$jscomp$0(STMT),decllist=n$jscomp$0(DECLLIST),precision=n$jscomp$0(PRECISION),ident=n$jscomp$0(IDENT);n$jscomp$0(KEYWORD_OR_IDENT);const fn=n$jscomp$0(FUNCTION),fnargs=n$jscomp$0(FUNCTIONARGS),forstmt=n$jscomp$0(FORLOOP),ifstmt=n$jscomp$0(IF),whilestmt=n$jscomp$0(WHILELOOP),returnstmt=n$jscomp$0(RETURN),dowhilestmt=n$jscomp$0(DOWHILELOOP),quantifier=n$jscomp$0(QUANTIFIER);let parse_struct,
parse_precision,parse_quantifier,parse_forloop,parse_if,parse_return,parse_whileloop,parse_dowhileloop,parse_function,parse_function_args,check=arguments.length?[].slice.call(arguments):[],ended=!1,state=[],nodes=[],tokens$jscomp$0=[],whitespace=[],errored=!1,program,token,node;state.shift=function(){let _node=[].shift.call(this),okay=check[this.length],emit=!1;check.length?"function"===typeof check[0]?emit=check[0](_node):void 0!==okay&&(emit=okay.test?okay.test(_node.type):okay===_node.type):emit=
!0;emit&&!errored&&nodes.push(_node);node=_node.parent;return _node};state.unshift=function(_node,add_child){_node.parent=state[0];const ret=[].unshift.call(this,_node);(void 0===add_child||add_child)&&node!==_node&&node.children.push(_node);node=_node;return ret};state.fake=function(x){state.unshift(x);state.shift()};state.unexpected=unexpected;state.scope=new Scope(state);state.create_node=function(){const n=mknode(IDENT,token);n.parent=reader.program;return n};(function(){parse_struct=stative(advance("struct",
"keyword"),function(){return"{"===token.data?(state.fake(mknode(IDENT,{data:"",position:token.position,type:"ident"})),Advance):advance_ident(!0)()},function(){state.scope.enter();return Advance},advance("{"),function(){if("preprocessor"===token.type)state.fake(mknode(token_map[token.type],token,node)),tokens$jscomp$0.shift();else{if("}"===token.data)return state.scope.exit(),tokens$jscomp$0.shift(),state.shift();";"===token.data?tokens$jscomp$0.shift():state.unshift(decl(166))}});parse_precision=
stative(function(){return tokens$jscomp$0.shift(),Advance},function(){return assert("keyword",["lowp","mediump","highp"])&&(state.unshift(keyword()),Advance)},function(){return state.unshift(keyword()),Advance},function(){return state.shift()});parse_quantifier=stative(advance("["),advance_expr("]"),advance("]"),function(){return state.shift()});parse_forloop=stative(advance("for","keyword"),advance("("),function(){let lookup;if("ident"===token.type){if((lookup=state.scope.find(token.data))||(lookup=
state.create_node()),"struct"===lookup.parent.type)return state.unshift(decl(255)),Advance}else if("builtin"===token.type||"keyword"===token.type)return state.unshift(decl(255)),Advance;return advance_expr(";")()},advance(";"),advance_expr(";"),advance(";"),advance_expr(")"),advance(")"),maybe_stmtlist(3),advance_stmtlist(),advance("}"),popstmt());parse_if=stative(advance("if","keyword"),advance("("),advance_expr(")"),advance(")"),maybe_stmtlist(3),advance_stmtlist(),advance("}"),function(){return"else"===
token.data?(tokens$jscomp$0.shift(),state.unshift(stmt()),Advance):popstmt()()},popstmt());parse_return=stative(advance("return","keyword"),function(){return";"===token.data?Advance:(state.unshift(expr(";")),Advance)},function(){tokens$jscomp$0.shift();popstmt()()});parse_whileloop=stative(advance("while","keyword"),advance("("),advance_expr(")"),advance(")"),maybe_stmtlist(3),advance_stmtlist(),advance("}"),popstmt());parse_dowhileloop=stative(advance("do","keyword"),maybe_stmtlist(3),advance_stmtlist(),
advance("}"),advance("while","keyword"),advance("("),advance_expr(")"),advance(")"),popstmt());parse_function=stative(function(){for(let i=1,len=state.length;i<len;++i)if(state[i].mode===FUNCTION)return unexpected("function definition is not allowed within another function");return Advance},function(){if(assert("ident")){var name=token.data,lookup=state.scope.find(name);state.unshift(ident());state.scope.define(name);state.scope.enter(lookup?lookup.scope:null);return Advance}},advance("("),function(){return state.unshift(fnargs()),
Advance},advance(")"),function(){return";"===token.data?(state.scope.exit(),state.shift(),state.shift()):Advance},advance("{"),advance_stmtlist(),advance("}"),function(){state.scope.exit();return Advance},function(){return state.shift(),state.shift(),state.shift()});parse_function_args=stative(function(){if("void"===token.data)return state.fake(keyword()),tokens$jscomp$0.shift(),Advance;if(")"===token.data)state.shift();else{if("struct"===token.data)return state.unshift(struct(!1,!1)),Advance;state.unshift(decl(208));
return Advance}},function(){if(","===token.data)return tokens$jscomp$0.shift(),0;")"===token.data?state.shift():unexpected("expected one of `,` or `)`, got "+token.data)})})();node=stmtlist();node.expecting="(eof)";node.mode=STMTLIST;node.token={type:"(program)",data:"(program)"};program=node;reader.program=program;reader.scope=function(scope){1===arguments.length&&(state.scope=scope);return state.scope};state.unshift(node);return reader};const full_parse_expr=require("module$node_modules$$sicmutils$glsl_parser$lib$expr"),
Scope=require("module$node_modules$$sicmutils$glsl_parser$lib$scope"),Advance={};global=0;let IDENT=global++,STMT=global++,STMTLIST=global++,STRUCT=global++,FUNCTION=global++,FUNCTIONARGS=global++,DECL=global++,DECLLIST=global++,FORLOOP=global++,WHILELOOP=global++,IF=global++,EXPR=global++,PRECISION=global++;require=global++;module=global++;let KEYWORD=global++,KEYWORD_OR_IDENT=global++,RETURN=global++,BREAK=global++,CONTINUE=global++,DISCARD=global++,DOWHILELOOP=global++,PLACEHOLDER=global++,QUANTIFIER=
global++;const token_map={"block-comment":require,"line-comment":require,preprocessor:module},stmt_type=global="ident stmt stmtlist struct function functionargs decl decllist forloop whileloop if expr precision comment preprocessor keyword keyword_or_ident return break continue discard do-while placeholder quantifier".split(" ")}
//# sourceMappingURL=module$node_modules$$sicmutils$glsl_parser$lib$index.js.map
