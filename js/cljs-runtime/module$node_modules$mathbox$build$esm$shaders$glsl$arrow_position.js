shadow$provide.module$node_modules$mathbox$build$esm$shaders$glsl$arrow_position=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.default=void 0;exports.default="uniform float worldUnit;\nuniform float lineDepth;\nuniform float lineWidth;\nuniform float focusDepth;\n\nuniform vec4 geometryClip;\nuniform float arrowSize;\nuniform float arrowSpace;\n\nattribute vec4 position4;\nattribute vec3 arrow;\nattribute vec2 attach;\n\n// External\nvec3 getPosition(vec4 xyzw, float canonical);\n\nvoid getArrowGeometry(vec4 xyzw, float near, float mid, float far, out vec3 left, out vec3 right, out vec3 middle, out vec3 start) {\n  right  \x3d getPosition(xyzw, 1.0);\n  left   \x3d getPosition(vec4(near, xyzw.yzw), 0.0);\n  middle \x3d getPosition(vec4(mid,  xyzw.yzw), 0.0);\n  start  \x3d getPosition(vec4(far,  xyzw.yzw), 0.0);\n}\n\nmat4 getArrowMatrix(vec3 left, vec3 right, vec3 middle, vec3 start) {\n\n  float depth \x3d focusDepth;\n  if (lineDepth \x3c 1.0) {\n    // Depth blending\n    float z \x3d max(0.00001, -right.z);\n    depth \x3d mix(z, focusDepth, lineDepth);\n  }\n\n  vec3 diff \x3d left - right;\n  float l \x3d length(diff);\n  if (l \x3d\x3d 0.0) {\n    return mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n  }\n\n  // Construct TBN matrix around shaft\n  vec3 t \x3d normalize(diff);\n  vec3 n \x3d normalize(cross(t, t.yzx + vec3(.1, .2, .3)));\n  vec3 b \x3d cross(n, t);\n\n  // Shrink arrows when vector gets too small\n  // Approach linear scaling with cubic ease the smaller we get\n  float size \x3d arrowSize * lineWidth * worldUnit * depth * 1.25;\n  l \x3d max(length(right - middle), length(middle - start)) * 2.0 * arrowSpace;\n  float mini \x3d clamp(1.0 - l / size * .333, 0.0, 1.0);\n  float scale \x3d 1.0 - mini * mini * mini;\n  float range \x3d size * scale;\n\n  // Size to 2.5:1 ratio\n  float rangeNB \x3d range / 2.5;\n\n  // Anchor at end position\n  return mat4(vec4(n * rangeNB,  0),\n              vec4(b * rangeNB,  0),\n              vec4(t * range, 0),\n              vec4(right,  1.0));\n}\n\nvec3 getArrowPosition() {\n  vec3 left, right, middle, start;\n\n  // Clip arrow position and attachment anchors to data\n  vec4 p \x3d min(geometryClip, position4);\n  vec3 a \x3d vec3(min(geometryClip.x, p.x + attach.x), geometryClip.x / 2.0, min(geometryClip.x, attach.y));\n\n  getArrowGeometry(p, a.x, a.y, a.z, left, right, middle, start);\n  mat4 matrix \x3d getArrowMatrix(left, right, middle, start);\n\n  return (matrix * vec4(arrow.xyz, 1.0)).xyz;\n\n}\n"}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$shaders$glsl$arrow_position.js.map
