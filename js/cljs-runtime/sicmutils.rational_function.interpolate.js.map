{"version":3,"sources":["sicmutils/rational_function/interpolate.cljc"],"mappings":"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","names":["sicmutils.rational-function.interpolate/bulirsch-stoer-recursive","points","x","cljs.core/empty?","cljs.core._EQ_","cljs.core/count","vec__86638","vec__86641","cljs.core.nth","_","y","vec__86644","vec__86647","l-branch","cljs.core/pop","r-branch","cljs.core.subvec","center","xl","cljs.core/first","xr","cljs.core/peek","rl","evaluate","rr","rc","p","sicmutils.generic._","q","sicmutils.generic._SLASH_","sicmutils.generic._STAR_","sicmutils.generic._PLUS_","point-array","cljs.core/vec","p__86653","vec__86654","sicmutils.rational-function.interpolate/bs-prepare","fx","sicmutils.rational-function.interpolate/bs-merge","p__86657","p__86658","vec__86659","vec__86662","sicmutils.rational-function.interpolate/bs-present","row","cljs.core.map","var_args","G__86669","sicmutils.rational-function.interpolate/bulirsch-stoer","js/Error","sicmutils.rational_function.interpolate.bulirsch_stoer","column","merge","tableau","sicmutils.polynomial.interpolate/tableau-fn","sicmutils.polynomial.interpolate/first-terms","p__86677","vec__86678","sicmutils.rational-function.interpolate/mbs-prepare","sicmutils.rational-function.interpolate/mbs-merge","p__86683","p__86684","vec__86686","vec__86689","dl","cr","c-d","d*ratio","den","taoensso.timbre._log_BANG_","taoensso.timbre/*config*","cljs.core/Delay","cnum","dnum","sicmutils.rational-function.interpolate/modified-bulirsch-stoer","sicmutils.polynomial.interpolate/mn-present","sicmutils.rational-function.interpolate/bulirsch-stoer-fold","sicmutils.polynomial.interpolate/tableau-fold-fn","cljs.core/last","sicmutils.rational-function.interpolate/modified-bulirsch-stoer-fold","sicmutils.polynomial.interpolate/mn-present-final","sicmutils.rational-function.interpolate/bulirsch-stoer-sum","sicmutils.algebra.fold.fold__GT_sum_fn","sicmutils.rational-function.interpolate/bulirsch-stoer-scan","sicmutils.algebra.fold.fold__GT_scan_fn","sicmutils.rational-function.interpolate/modified-bulirsch-stoer-sum","sicmutils.rational-function.interpolate/modified-bulirsch-stoer-scan"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.rational-function.interpolate\n  \"This namespace contains a discussion of rational function interpolation, and\n  different methods for fitting rational functions to `N` points and evaluating\n  them at some value `x`.\"\n  (:require [sicmutils.algebra.fold :as af]\n            [sicmutils.generic :as g]\n            [sicmutils.polynomial.interpolate :as pi]\n            [taoensso.timbre :as log]))\n\n;; ## Rational Function Interpolation\n;;\n;; This namespace contains implementations of rational function interpolation\n;; methods. The [ALGLib](https://www.alglib.net/interpolation/rational.php) user\n;; guide has a nice page on [rational function\n;; interpolation](https://www.alglib.net/interpolation/rational.php), which\n;; suggests that the Bulirsch-Stoer method, included here, is NOT great, and\n;; that there are better methods. We'd love implementations of the others if you\n;; agree!\n;;\n;; The main method in this package is an incremental version of the\n;; Bulirsch-Stoer algorithm.\n;;\n;; Just like with polynomial interpolation, let's start with a straightforward\n;; implementation of the non-incremental recursive algorithm.\n\n(defn bulirsch-stoer-recursive\n  \"Returns the value of `P(x)`, where `P` is rational function fit (using the\n  Bulirsch-Stoer algorithm, of similar style to Neville's algorithm described in\n  [[sicmutils.numerical.interpolate.polynomial]]) to every point in the supplied\n  sequence `points`.\n\n  `points`: is a sequence of pairs of the form `[x (f x)]`.\n\n  \\\"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\\\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  References:\n\n    - Stoer & Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)\"\n  [points x]\n  (letfn [(evaluate [points x]\n            (cond (empty? points) 0\n\n                  (= 1 (count points))\n                  (let [[[_ y]] points]\n                    y)\n\n                  :else\n                  (let [l-branch (pop points)\n                        r-branch (subvec points 1)\n                        center   (pop r-branch)\n                        [xl]     (first points)\n                        [xr]     (peek points)\n                        rl (evaluate l-branch x)\n                        rr (evaluate r-branch x)\n                        rc (evaluate center x)\n                        p  (g/- rr rl)\n                        q  (-> (g// (g/- x xl)\n                                    (g/- x xr))\n                               (g/* (g/- 1 (g// p (g/- rr rc))))\n                               (g/- 1))]\n                    (g/+ rr (g// p q)))))]\n    (let [point-array (vec points)]\n      (evaluate point-array x))))\n\n;; We can be a bit more clever, if we reuse the idea of the \"tableau\" described\n;; in the polynomial namespace.\n\n(defn bs-prepare [[x fx]]\n  [x x 0 fx])\n\n(defn bs-merge [x]\n  (fn [[xl _ _ rl] [_ xr rc rr]]\n    (let [p  (- rr rl)\n          q  (-> (/ (- x xl)\n                    (- x xr))\n                 (* (- 1 (/ p (- rr rc))))\n                 (- 1))]\n      [xl xr rl (+ rr (/ p q))])))\n\n(defn- bs-present [row]\n  (map peek row))\n\n(defn bulirsch-stoer\n  \"Takes\n\n  - a (potentially lazy) sequence of `points` of the form `[x (f x)]` and\n  - a point `x` to interpolate\n\n  and generates a lazy sequence of approximations of `P(x)`. Each entry in the\n  return sequence incorporates one more point from `points` into the `P(x)`\n  estimate.\n\n  `P(x)` is rational function fit (using the Bulirsch-Stoer algorithm, of\n  similar style to Neville's algorithm described\n  in [[sicmutils.numerical.interpolate.polynomial]]) to every point in the\n  supplied sequence `points`.\n\n  \\\"The Bulirsch-Stoer algorithm produces the so-called diagonal rational\n  function, with the degrees of numerator and denominator equal (if m is even)\n  or with the degree of the denominator larger by one if m is odd.\\\" ~ Press,\n  Numerical Recipes, p105\n\n  The implementation follows [Equation 3.2.3 on on page 105 of\n  Press](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf).\n\n  ### Column\n\n  If you supply an integer for the third (optional) `column` argument,\n  `bulirsch-stoer` will return that /column/ offset the interpolation tableau\n  instead of the first row. This will give you a sequence of nth-order\n  polynomial approximations taken between point `i` and the next `n` points.\n\n  As a reminder, this is the shape of the tableau:\n\n  ```\n  p0 p01 p012 p0123 p01234\n  p1 p12 p123 p1234 .\n  p2 p23 p234 .     .\n  p3 p34 .    .     .\n  p4 .   .    .     .\n  ```\n\n  So supplying a `column` of `1` gives a sequence of 2-point approximations\n  between pairs of points; `2` gives 3-point approximations between successive\n  triplets, etc.\n\n  References:\n\n    - Stoer & Bulirsch, ['Introduction to Numerical Analysis'](https://www.amazon.com/Introduction-Numerical-Analysis-Applied-Mathematics/dp/144193006X)\n    - [PDF of the same reference](http://www.math.uni.wroc.pl/~olech/metnum2/Podreczniki/(eBook)%20Introduction%20to%20Numerical%20Analysis%20-%20J.Stoer,R.Bulirsch.pdf)\n    - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)\"\n  ([points x] (bulirsch-stoer points x nil))\n  ([points x column]\n   (let [merge   (bs-merge x)\n         tableau (pi/tableau-fn bs-prepare merge points)]\n     (bs-present\n      (if column\n        (nth tableau column)\n        (pi/first-terms tableau))))))\n\n;; ## Incremental Bulirsch-Stoer\n;;\n;; Press, in [Numerical Recipes section\n;; 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf), describes a\n;; modification to the Bulirsch-Stoer that lets you track the differences from\n;; the left and left-up entries in the tableau, just like the modified Neville\n;; method in `polynomial.cljc`. the algorithm is implemented below.\n\n(defn- mbs-prepare\n  \"Processes an initial point `[x (f x)]` into the required state:\n\n  ```\n  [x_l, x_r, C, D]\n  ```\n\n  The recursion starts with $C = D = f(x)$.\"\n  [[x fx]] [x x fx fx])\n\n(defn- mbs-merge\n  \"Implements the recursion rules described in Press's Numerical Recipes, [section\n  3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf) to generate x_l, x_r,\n  C and D for a tableau node, given the usual left and left-up tableau entries.\n\n  This merge function ALSO includes a 'zero denominator fix used by Bulirsch and\n  Stoer and Henon', in the words of Sussman from `rational.scm` in the scmutils\n  package.\n\n  If the denominator is 0, we pass along `C` from the up-left node and `d` from\n  the previous entry in the row. Otherwise, we use the algorithm to calculate.\n\n  TODO understand why this works, or where it helps!\"\n  [x]\n  (fn [[xl _ _ dl] [_ xr cr _]]\n    (let [c-d     (- cr dl)\n          d*ratio (-> (/ (- x xl)\n                         (- x xr))\n                      (* dl))\n          den  (- d*ratio cr)]\n      (if (zero? den)\n        (do (log/info \"zero denominator!\")\n            [xl xr cr dl])\n        (let [cnum (* d*ratio c-d)\n              dnum (* cr c-d)]\n          [xl xr (/ cnum den) (/ dnum den)])))))\n\n(defn modified-bulirsch-stoer\n  \"Similar to [[bulirsch-stoer]] (the interface is identical) but slightly more\n  efficient. Internally this builds up its estimates by tracking the delta from\n  the previous estimate.\n\n  This non-obvious change lets us swap an addition in for a division,\n  making the algorithm slightly more efficient.\n\n  See [[bulirsch-stoer]] for usage information, and info about the required\n  structure of the arguments.\n\n  References:\n\n   - Press's Numerical Recipes (p105), [Section 3.2](http://phys.uri.edu/nigh/NumRec/bookfpdf/f3-2.pdf)\"\n  [points x]\n  (pi/mn-present\n   (pi/first-terms\n    (pi/tableau-fn mbs-prepare\n                   (mbs-merge x)\n                   points))))\n\n;; ## Rational Interpolation as a Fold\n;;\n;; Just like in `polynomial.cljc`, we can write rational interpolation in the\n;; style of a functional fold:\n\n(defn bulirsch-stoer-fold\n  \"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[bulirsch-stoer]].\"\n  [x]\n  (pi/tableau-fold-fn bs-prepare\n                      (bs-merge x)\n                      (fn [row]\n                        (peek (last row)))))\n\n(defn modified-bulirsch-stoer-fold\n  \"Given some point `x`, returns a fold that accumulates rows of a rational\n  function interpolation tableau providing successively better estimates (at the\n  value `x`) of a rational function interpolated to all seen points.\n\n  The 2-arity aggregation step takes:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x_new (f x_new)]`\n\n  Returns a function that accepts:\n\n  - `previous-row`: previous row of an interpolation tableau\n  - a new point of the form `[x (f x)]`\n\n  and returns the next row of the tableau using the algorithm described in\n  [[modified-bulirsch-stoer]].\"\n  [x]\n  (pi/tableau-fold-fn mbs-prepare\n                      (mbs-merge x)\n                      pi/mn-present-final))\n\n(defn bulirsch-stoer-sum\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[bulirsch-stoer]] xs x))`\"\n  [x]\n  (af/fold->sum-fn\n   (bulirsch-stoer-fold x)))\n\n(defn bulirsch-stoer-scan\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[bulirsch-stoer]] xs x)`.\"\n  [x]\n  (af/fold->scan-fn\n   (bulirsch-stoer-fold x)))\n\n(defn modified-bulirsch-stoer-sum\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns the best approximation of `x` using a rational\n  function fitted to all points in `xs` using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Faster than, but equivalent to, `(last ([[modified-bulirsch-stoer]] xs x))`\"\n  [x]\n  (af/fold->sum-fn\n   (modified-bulirsch-stoer-fold x)))\n\n(defn modified-bulirsch-stoer-scan\n  \"Returns a function that consumes an entire sequence `xs` of points of the form\n  `[x_i, f(x_i)]` and returns a lazy sequence of successive approximations of\n  `x` using rational functions fitted to the first point, then the first and\n  second points, etc. using the algorithm described\n  in [[modified-bulirsch-stoer]].\n\n  Equivalent to `([[modified-bulirsch-stoer]] xs x)`.\"\n  [x]\n  (af/fold->scan-fn\n   (modified-bulirsch-stoer-fold x)))\n"]}