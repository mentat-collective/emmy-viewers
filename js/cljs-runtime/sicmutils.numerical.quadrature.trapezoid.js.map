{"version":3,"sources":["sicmutils/numerical/quadrature/trapezoid.cljc"],"mappings":";AAuDA,4DAAA,5DAAMA,gIAAkBC,EAAEC,GAAGC;AAA7B,AACE,4ZAAA,rZAACC,wDAAI,AAACC,uDAAI,AAACC,kDAAIH,GAAGD,IACR,AAACK,uDAAI,CAACN,kCAAAA,sCAAAA,NAAEC,kBAAAA,KAAI,CAACD,kCAAAA,sCAAAA,NAAEE,kBAAAA;;AAM3B,AAgBA,+DAAA,/DAAOK,sIAAgBP,EAAEQ,EAAEC;AAA3B,AACE,OAACC,oDAAgB,AAACC,gDAAQZ,0DAAiBC,GAC1BQ,EAAEC;;AAIrB,AAMA,AAAeG,8DACb,iBAAMZ,IAAE,WAAKa;AAAL,AAAQ,QAAA,MAAK,CAAA,MAAK,CAAGA,IAAEA;;AAA/B,AACE,sEAAA,IAAA,nEAACN,6DAAeP;;AAIpB,AAIA,AAMA,AAOA,sEAAA,tEAAOc,oJAAsBC,MAAMC;AAAnC,AACE,8BAAA,WAAAC,lCAACC;AAAD,AAAS,QAAAD,mBAAA;GACD,AAACE,4CAAIC,YAAEL,MAAMC;;AAEvB,AA6BA;;;;;yDAAA,zDAAMK,0HAIHrB,EAAEQ,EAAEC;AAJP,AAKE,IAAMa,QAAM,CAAGb,IAAED;AAAjB,AACE,kBAAKe;AAAL,AACE,IAAMC,IAAG,CAAGF,QAAMC;IACZE,KAAG,WAAKC;AAAL,AAAQ,IAAAC,WAAG,CAAGnB,IAAE,CAAGkB,IAAEF;AAAb,AAAA,0EAAAG,wBAAAA,1FAAC3B,kCAAAA,4CAAAA;;AADlB,AAEE,QAAGwB,IAAE,CAAG,uLAAA,tLAAG,CAAG,CAACxB,kCAAAA,qCAAAA,LAAEQ,iBAAAA,MAAG,CAACR,kCAAAA,qCAAAA,LAAES,iBAAAA,cACf,8DAAA,9DAACmB,2DAAOH,OAAKF;;;AAK7B,AAAeM,wDACb,iBAAM7B,IAAE,WAAKa;AAAL,AAAQ,QAAA,MAAK,CAAA,MAAK,CAAGA,IAAEA;;AAA/B,AACE,sEAAA,IAAA,nEAACN,6DAAeP;;AAEpB,AA2BA,AAAA;;;;;;;;;;;;;;;;8DAAA,sEAAA8B,pIAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,0FAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,0FAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,4FAAA,5FAAMD,uGAeFhC,EAAEQ,EAAEC;AAfR,AAeW,uGAAA,2CAAA,8CAAA,zLAAC6B,0FAAmBtC,EAAEQ,EAAEC;;;AAfnC,CAAA,4FAAA,iBAAAyB,7GAAMF,uGAgBFhC,EAAEQ,EAAEC;AAhBR,AAAA,IAAA0B,aAAAD;IAAAC,iBAAA,AAAAC,4BAAAD;QAAA,AAAAE,4CAAAF,eAAA,8CAAA,7GAgBkBZ;wBAhBlB,AAAAc,4CAAAF,eAAA,/EAgBoBI;AAhBpB,AAiBG,IAAMC,IAAO,AAACnB,uDAAcrB,EAAEQ,EAAEC;IAC1BgC,SAAO,AAACC,kDAAW1C,EAAEQ,EAAEC;IACvBkC,KAAO,+DAAA,/DAACC,sDAAkBJ,EAAEC,WAASlB;AAF3C,AAGE,oBAAI,iBAAAsB,oBAAKN;AAAL,AAAA,oBAAAM;AAAiB,cAAStB;;AAA1BsB;;;AACF,4FAAA,IAAA,IAAA,7FAACC,kFAAuBH;;AACxBA;;;;AAtBP,CAAA,sFAAA,tFAAMX;;AAAN,AAsCA,AAoCA,AAmCA;;;;;;;;;;;AAAAe,oDAAA,AAAAC,yDAUWjD,0DACDiC","names":["sicmutils.numerical.quadrature.trapezoid/single-trapezoid","f","xl","xr","sicmutils.generic._SLASH_","sicmutils.generic._STAR_","sicmutils.generic._","sicmutils.generic._PLUS_","sicmutils.numerical.quadrature.trapezoid/trapezoid-sum*","a","b","sicmutils.numerical.quadrature.riemann/windowed-sum","cljs.core.partial","sicmutils.numerical.quadrature.trapezoid/pi-estimator*","x","sicmutils.numerical.quadrature.trapezoid/basically-identical?","l-seq","r-seq","p1__90419#","cljs.core/every?","cljs.core.map","cljs.core/-","sicmutils.numerical.quadrature.trapezoid/trapezoid-sum","width","n","h","fx","i","G__90420","sicmutils.util.aggregate.sum","sicmutils.numerical.quadrature.trapezoid/pi-estimator","var_args","G__90423","sicmutils.numerical.quadrature.trapezoid/trapezoid-sequence","js/Error","p__90424","map__90425","cljs.core/--destructure-map","cljs.core.get","sicmutils.numerical.quadrature.trapezoid.trapezoid_sequence","accelerate?","S","next-S","sicmutils.numerical.quadrature.riemann/Sn->S2n","xs","sicmutils.numerical.quadrature.riemann/incrementalize","and__4251__auto__","sicmutils.polynomial.richardson.richardson_sequence","sicmutils.numerical.quadrature.trapezoid/integral","sicmutils.numerical.quadrature.common/make-integrator-fn"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.numerical.quadrature.trapezoid\n  \"Trapezoid method.\"\n  (:require [sicmutils.abstract.function :as f]\n            [sicmutils.generic :as g]\n            [sicmutils.numerical.quadrature.common :as qc :include-macros true]\n            [sicmutils.numerical.quadrature.riemann :as qr]\n            [sicmutils.polynomial.richardson :as pr]\n            [sicmutils.util :as u]\n            [sicmutils.util.aggregate :as ua]))\n\n;; ## The Trapezoid Method\n;;\n;; This namespace builds on the ideas introduced in `riemann.cljc` and\n;; `midpoint.cljc`, and follows the pattern of those namespaces:\n;;\n;; - implement a simple, easy-to-understand version of the Trapezoid method\n;; - make the computation more efficient\n;; - write an incremental version that can reuse prior results\n;; - wrap everything up behind a nice, exposed API\n;;\n;; Let's begin.\n;;\n;; ## Simple Implementation\n;;\n;; A nice integration scheme related to the Midpoint method is the \"Trapezoid\"\n;; method. The idea here is to estimate the area of each slice by fitting a\n;; trapezoid between the function values at the left and right sides of the\n;; slice.\n;;\n;; Alternatively, you can think of drawing a line between $f(x_l)$ and $f(x_r)$\n;; and taking the area under the line.\n;;\n;; What's the area of a trapezoid? The two slice endpoints are\n;;\n;; - $(x_l, f(x_l))$ and\n;; - $(x_r, f(x_r))$\n;;\n;; The trapezoid consists of a lower rectangle and a capping triangle. The lower\n;; rectangle's area is:\n;;\n;; $$(b - a) f(a)$$.\n;;\n;; Just like in the left Riemann sum. The upper triangle's area is one half base\n;; times height:\n;;\n;; $$ {1 \\over 2} (x_r - x_l) (f(x_r) - f(x_l))$$\n;;\n;; The sum of these simplifies to:\n;;\n;; $${1 \\over 2} {(x_r - x_l) (f(x_l) + f(x_r))}$$\n;;\n;; Or, in Clojure:\n\n(defn single-trapezoid [f xl xr]\n  (g// (g/* (g/- xr xl)\n            (g/+ (f xl) (f xr)))\n       2))\n\n;; We can use the symbolic algebra facilities in the library to show that this\n;; simplification is valid:\n\n(comment\n  (let [f (f/literal-function 'f)\n        square    (g/* (f 'x_l)\n                       (g/- 'x_r 'x_l))\n        triangle  (g/* (g// 1 2)\n                       (g/- 'x_r 'x_l)\n                       (g/- (f 'x_r) (f 'x_l)))]\n    (zero?\n     (g/simplify\n      (g/- (single-trapezoid f 'x_l 'x_r)\n           (g/+ square triangle))))))\n;; => true\n\n;; We can use `qr/windowed-sum` to turn this function into an (inefficient)\n;; integrator:\n\n(defn- trapezoid-sum* [f a b]\n  (qr/windowed-sum (partial single-trapezoid f)\n                   a b))\n\n;; Fitting triangles is easy:\n\n(comment\n  (= (* 0.5 10 10)\n     ((trapezoid-sum* identity 0.0 10.0) 10)))\n\n;; In fact, we can even use our estimator to estimate $\\pi$:\n\n(def ^:private pi-estimator*\n  (let [f (fn [x] (/ 4 (+ 1 (* x x))))]\n    (trapezoid-sum* f 0.0 1.0)))\n\n;; The accuracy is not bad, for 10 slices:\n\n(comment\n  (= 3.1399259889071587\n     (pi-estimator* 10)))\n\n(comment\n  (- Math/PI (pi-estimator* 10)))\n;; => 0.0016666646826344333\n\n;; 10000 slices gets us closer:\n\n(comment\n  (< (- Math/PI (pi-estimator* 10000))\n     1e-8))\n\n;; Fun fact: the trapezoid method is equal to the /average/ of the left and\n;; right Riemann sums. You can see that in the equation, but lets verify:\n\n(defn- basically-identical? [l-seq r-seq]\n  (every? #(< % 1e-15)\n          (map - l-seq r-seq)))\n\n(comment\n  (let [points  (take 5 (iterate inc 1))\n        average (fn [l r]\n                  (/ (+ l r) 2))\n        f       (fn [x] (/ 4 (+ 1 (* x x))))\n        [a b]   [0 1]\n        left-estimates  (qr/left-sequence f a b {:n points})\n        right-estimates (qr/right-sequence f a b {:n points})]\n    (basically-identical?\n     (map (trapezoid-sum* f a b) points)\n     (map average\n          left-estimates\n          right-estimates))))\n\n;; ## Efficient Trapezoid Method\n;;\n;; Next let's attempt a more efficient implementation. Looking at\n;; `single-trapezoid`, it's clear that each slice evaluates both of its\n;; endpoints. This means that each point on a border between two slices earns a\n;; contribution of $f(x) \\over 2$ from each slice.\n;;\n;; A more efficient implementation would evaluate both endpoints once and then\n;; sum (without halving) each interior point.\n;;\n;; This interior sum is identical to a left Riemann sum (without the $f(a)$\n;; evaluation), or a right Riemann sum (without $f(b)$).\n;;\n;; Here is this idea implemented in Clojure:\n\n(defn trapezoid-sum\n  \"Returns a function of `n`, some number of slices of the total integration\n  range, that returns an estimate for the definite integral of $f$ over the\n  range $(a, b)$ using the trapezoid method.\"\n  [f a b]\n  (let [width (- b a)]\n    (fn [n]\n      (let [h  (/ width n)\n            fx (fn [i] (f (+ a (* i h))))]\n        (* h (+ (/ (+ (f a) (f b)) 2)\n                (ua/sum fx 1 n)))))))\n\n;; We can define a new `pi-estimator` and check it against our less efficient\n;; version:\n\n(def ^:private pi-estimator\n  (let [f (fn [x] (/ 4 (+ 1 (* x x))))]\n    (trapezoid-sum* f 0.0 1.0)))\n\n(comment\n  (basically-identical?\n   (map pi-estimator (range 1 100))\n   (map pi-estimator* (range 1 100))))\n;; => true\n\n;; ## Incremental Trapezoid Rule\n;;\n;; Next let's develop an incremental updater for the Trapezoid rule that lets us\n;; reuse evaluation points as we increase the number of slices.\n;;\n;; Because interior points of the Trapezoid method mirror the interior points of\n;; the left and right Riemann sums, we can piggyback on the incremental\n;; implementations for those two methods in developing an incremental Trapezoid\n;; implementation.\n;;\n;; Consider the evaluation points of the trapezoid method with 2 slices, next to\n;; the points of a 4 slice pass:\n;;\n;; x-------x-------x\n;; x---x---x---x---x\n;;\n;; The new points are simply the /midpoints/ of the existing slices, just like\n;; we had for the left (and right) Riemann sums. This means that we can reuse\n;; `qr/Sn->S2n` in our definition of the incrementally-enabled\n;; `trapezoid-sequence`:\n\n(defn trapezoid-sequence\n  \"Returns a (lazy) sequence of successively refined estimates of the integral of\n  `f` over the open interval $(a, b)$ using the Trapezoid method.\n\n  ### Optional arguments:\n\n  `:n`: If `:n` is a number, returns estimates with $n, 2n, 4n, ...$ slices,\n  geometrically increasing by a factor of 2 with each estimate.\n\n  If `:n` is a sequence, the resulting sequence will hold an estimate for each\n  integer number of slices in that sequence.\n\n  `:accelerate?`: if supplied (and `n` is a number), attempts to accelerate\n  convergence using Richardson extrapolation. If `n` is a sequence this option\n  is ignored.\"\n  ([f a b] (trapezoid-sequence f a b {:n 1}))\n  ([f a b {:keys [n accelerate?] :or {n 1}}]\n   (let [S      (trapezoid-sum f a b)\n         next-S (qr/Sn->S2n f a b)\n         xs     (qr/incrementalize S next-S 2 n)]\n     (if (and accelerate? (number? n))\n       (pr/richardson-sequence xs 2 2 2)\n       xs))))\n\n;; The following example shows that for the sequence $1, 2, 4, 8, ..., 2^n$, the\n;; incrementally-augmented `trapezoid-sequence` only performs $2^n + 1$ function\n;; evaluations; ie, the same number of evaluations as the\n;; non-incremental `(trapezoid-sum f2 0 1)` would perform for $2^n$ slices. (why\n;; $2^n + 1$? each interior point is shared, so each trapezoid contributes one\n;; evaluation, plus a final evaluation for the right side.)\n;;\n;; The example also shows that evaluating /every/ $n$ in the sequence costs\n;; $\\sum_{i=0}^n{2^i + 1} = 2^{n+1} + n$ evaluations. As $n$ gets large, this is\n;; roughly twice what the incremental implementation costs.\n;;\n;; When $n=11$, the incremental implementation uses 2049 evaluations, while the\n;; non-incremental takes 4017.\n\n(comment\n  (let [n-elements 11\n        f (fn [x] (/ 4 (+ 1 (* x x))))\n        [counter1 f1] (u/counted f)\n        [counter2 f2] (u/counted f)\n        [counter3 f3] (u/counted f)\n        n-seq (take (inc n-elements)\n                    (iterate (fn [x] (* 2 x)) 1))]\n    ;; Incremental version evaluating every `n` in the sequence $1, 2, 4, ...$:\n    (dorun (trapezoid-sequence f1 0 1 {:n n-seq}))\n\n    ;; Non-incremental version evaluating every `n` in the sequence $1, 2, 4, ...$:\n    (run! (trapezoid-sum f2 0 1) n-seq)\n\n    ;; A single evaluation of the final `n`\n    ((trapezoid-sum f3 0 1) (last n-seq))\n\n    (let [two**n+1 (inc (g/expt 2 n-elements))\n          n+2**n (+ n-elements (g/expt 2 (inc n-elements)))]\n      (= [2049 4107 2049]\n         [two**n+1 n+2**n two**n+1]\n         [@counter1 @counter2 @counter3]))))\n;; => true\n\n;; Another short example that hints of work to come. The incremental\n;; implementation is useful in cases where the sequence includes doublings\n;; nested in among other values.\n;;\n;; For the sequence $2, 3, 4, 6, ...$ (used in the Bulirsch-Stoer method!), the\n;; incrementally-augmented `trapezoid-sequence` only performs 162 function\n;; evaluations, vs the 327 of the non-incremental\n;; `(trapezoid-sum f2 0 1)` mapped across the points.\n;;\n;; This is a good bit more efficient than the Midpoint method's incremental\n;; savings, since factors of 2 come up more often than factors of 3.\n\n(comment\n  (let [f (fn [x] (/ 4 (+ 1 (* x x))))\n        [counter1 f1] (u/counted f)\n        [counter2 f2] (u/counted f)\n        n-seq (take 12 (interleave\n                        (iterate (fn [x] (* 2 x)) 2)\n                        (iterate (fn [x] (* 2 x)) 3)))]\n    (dorun (trapezoid-sequence f1 0 1 {:n n-seq}))\n    (run! (trapezoid-sum f2 0 1) n-seq)\n    (= [162 327]\n       [@counter1 @counter2])))\n\n;; Final Trapezoid API:\n;;\n;; The final version is analogous the `qr/left-integral` and friends, including\n;; an option to `:accelerate?` the final sequence with Richardson\n;; extrapolation. (Accelerating the trapezoid method in this way is\n;; called \"Romberg integration\".)\n;;\n;; ### Note on Richardson Extrapolation\n;;\n;; The terms of the error series for the Trapezoid method increase as $h^2, h^4,\n;; h^6$... (see https://en.wikipedia.org/wiki/Trapezoidal_rule#Error_analysis).\n;; Because of this, we pass $p = q = 2$ into `pr/richardson-sequence` below.\n;; Additionally, `integral` hardcodes the factor of `2` and doesn't currently\n;; allow for a custom sequence of $n$. This is configured by passing $t = 2$\n;; into `pr/richardson-sequence`.\n;;\n;; If you want to accelerate some other geometric sequence, call\n;; `pr/richardson-sequence` with some other value of `t.`\n;;\n;; To accelerate an arbitrary sequence of trapezoid evaluations, investigate\n;; `polynomial.cljc` or `rational.cljc`. The \"Bulirsch-Stoer\" method uses either\n;; of these to extrapolate the Trapezoid method using a non-geometric sequence.\n\n(qc/defintegrator integral\n  \"Returns an estimate of the integral of `f` over the closed interval $[a, b]$\n  using the Trapezoid method with $1, 2, 4 ... 2^n$ windows for each estimate.\n\n  Optionally accepts `opts`, a dict of optional arguments. All of these get\n  passed on to [[sicmutils.util.stream/seq-limit]] to configure convergence\n  checking.\n\n  See [[trapezoid-sequence]] for information on the optional args in `opts` that\n  customize this function's behavior.\"\n  :area-fn single-trapezoid\n  :seq-fn trapezoid-sequence)\n\n;; ## Next Steps\n;;\n;; If you start with the trapezoid method, one single step of Richardson\n;; extrapolation (taking the second column of the Richardson tableau) is\n;; equivalent to \"Simpson's rule\". One step using `t=3`, ie, when you /triple/\n;; the number of integration slices per step, gets you \"Simpson's 3/8 Rule\". Two\n;; steps of Richardson extrapolation gives you \"Boole's rule\".\n;;\n;; The full Richardson-accelerated Trapezoid method is also known as \"Romberg\n;; integration\" (see `romberg.cljc`).\n;;\n;; These methods will appear in their respective namespaces in the `quadrature`\n;; package.\n;;\n;; See the wikipedia entry on [Closed Newton-Cotes\n;; Formulas](https://en.wikipedia.org/wiki/Newton%E2%80%93Cotes_formulas#Closed_Newton%E2%80%93Cotes_formulas)\n;; for more details.\n"]}