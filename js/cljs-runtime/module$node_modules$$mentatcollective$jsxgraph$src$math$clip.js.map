{
"version":3,
"file":"module$node_modules$$mentatcollective$jsxgraph$src$math$clip.js",
"lineCount":37,
"mappings":"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",
"sources":["node_modules/@mentatcollective/jsxgraph/src/math/clip.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$mentatcollective$jsxgraph$src$math$clip\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _jxg = _interopRequireDefault(require(\"../jxg\"));\n\nvar _constants = _interopRequireDefault(require(\"../base/constants\"));\n\nvar _coords = _interopRequireDefault(require(\"../base/coords\"));\n\nvar _math = _interopRequireDefault(require(\"./math\"));\n\nvar _geometry = _interopRequireDefault(require(\"./geometry\"));\n\nvar _type = _interopRequireDefault(require(\"../utils/type\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\nconsole.log(\"P:\", P.coords.usrCoords, P.data.type)\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * @fileoverview This file contains the Math.Clip namespace for clipping and computing boolean operations\n * on polygons and curves\n *\n * // TODO:\n * * Check if input polygons are closed. If not, handle this case.\n */\n\n/**\n * Math.Clip namespace definition. This namespace contains algorithms for Boolean operations on paths, i.e.\n * intersection, union and difference of paths. Base is the Greiner-Hormann algorithm.\n * @name JXG.Math.Clip\n * @exports Mat.Clip as JXG.Math.Clip\n * @namespace\n */\n// Mat.Clip = function () {\n// };\n// JXG.extend(Mat.Clip.prototype, /** @lends JXG.Curve.prototype */ {\n_math.default.Clip = {\n  _isSeparator: function (node) {\n    return isNaN(node.coords.usrCoords[1]) && isNaN(node.coords.usrCoords[2]);\n  },\n\n  /**\n   * Add pointers to an array S such that it is a circular doubly-linked list.\n   *\n   * @private\n   * @param  {Array} S Array\n   * @return {Array} return containing the starter indices of each component.\n   */\n  makeDoublyLinkedList: function (S) {\n    var i,\n        first = null,\n        components = [],\n        le = S.length;\n\n    if (le > 0) {\n      for (i = 0; i < le; i++) {\n        // S[i]._next = S[(i + 1) % le];\n        // S[i]._prev = S[(le + i - 1) % le];\n        // If S[i] is component separator we proceed with the next node.\n        if (this._isSeparator(S[i])) {\n          S[i]._next = S[(i + 1) % le];\n          S[i]._prev = S[(le + i - 1) % le];\n          continue;\n        } // Now we know that S[i] is a path component\n\n\n        if (first === null) {\n          // Start the component if it is not yet started.\n          first = i;\n          components.push(first);\n        }\n\n        if (this._isSeparator(S[(i + 1) % le]) || i === le - 1) {\n          // If the next node is a component separator or if the node is the last node,\n          // then we close the loop\n          S[i]._next = S[first];\n          S[first]._prev = S[i];\n          S[i]._end = true;\n          first = null;\n        } else {\n          // Here, we are not at the end of component\n          S[i]._next = S[(i + 1) % le];\n          S[first]._prev = S[i];\n        }\n\n        if (!this._isSeparator(S[(le + i - 1) % le])) {\n          S[i]._prev = S[(le + i - 1) % le];\n        }\n      }\n    }\n\n    return components;\n  },\n\n  /**\n   * JavaScript object containing the intersection of two paths. Every intersection point is on one path, but\n   * comes with a neighbour point having the same coordinates and being on the other path.\n   *\n   * The intersection point is inserted into the doubly linked list of the path.\n   *\n   * @private\n   * @param  {JXG.Coords} coords JSXGraph Coords object conatining the coordinates of the intersection\n   * @param  {Number} i        Number of the segment of the subject path (first path) containing the intersection.\n   * @param  {Number} alpha    The intersection is a p_1 + alpha*(p_2 - p_1), where p_1 and p_2 are the end points\n   *      of the i-th segment.\n   * @param  {Array} path      Pointer to the path containing the intersection point\n   * @param  {String} pathname Name of the path: 'S' or 'C'.\n   */\n  Vertex: function (coords, i, alpha, path, pathname, type) {\n    this.pos = i;\n    this.intersection = true;\n    this.coords = coords;\n    this.elementClass = _constants.default.OBJECT_CLASS_POINT;\n    this.data = {\n      alpha: alpha,\n      path: path,\n      pathname: pathname,\n      done: false,\n      type: type,\n      idx: 0\n    }; // Set after initialisation\n\n    this.neighbour = null;\n    this.entry_exit = false;\n  },\n  _addToList: function (list, coords, pos) {\n    var len = list.length,\n        eps = _math.default.eps * _math.default.eps;\n\n    if (len > 0 && Math.abs(list[len - 1].coords.usrCoords[0] - coords.usrCoords[0]) < eps && Math.abs(list[len - 1].coords.usrCoords[1] - coords.usrCoords[1]) < eps && Math.abs(list[len - 1].coords.usrCoords[2] - coords.usrCoords[2]) < eps) {\n      // Skip point\n      return;\n    }\n\n    list.push({\n      pos: pos,\n      intersection: false,\n      coords: coords,\n      elementClass: _constants.default.OBJECT_CLASS_POINT\n    });\n  },\n\n  /**\n   * Sort the intersection points into their path.\n   * @private\n   * @param  {Array} P_crossings Array of arrays. Each array contains the intersections of the path\n   *      with one segment of the other path.\n   * @return {Array}  Array of intersection points ordered by first occurrence in the path.\n   */\n  sortIntersections: function (P_crossings) {\n    var i,\n        j,\n        P,\n        Q,\n        last,\n        next_node,\n        P_intersect = [],\n        P_le = P_crossings.length;\n\n    for (i = 0; i < P_le; i++) {\n      P_crossings[i].sort(function (a, b) {\n        return a.data.alpha > b.data.alpha ? 1 : -1;\n      });\n\n      if (P_crossings[i].length > 0) {\n        // console.log(\"Crossings\", P_crossings[i])\n        last = P_crossings[i].length - 1;\n        P = P_crossings[i][0]; //console.log(\"SORT\", P.coords.usrCoords)\n\n        Q = P.data.path[P.pos];\n        next_node = Q._next; // Store the next \"normal\" node\n\n        if (i === P_le - 1) {\n          Q._end = false;\n        }\n\n        if (P.data.alpha === 0.0 && P.data.type === \"T\") {\n          // console.log(\"SKIP\", P.coords.usrCoords, P.data.type, P.neighbour.data.type);\n          Q.intersection = true;\n          Q.data = P.data;\n          Q.neighbour = P.neighbour;\n          Q.neighbour.neighbour = Q;\n          Q.entry_exit = false;\n          P_crossings[i][0] = Q;\n        } else {\n          // Insert the first intersection point\n          P._prev = Q;\n          P._prev._next = P;\n        } // Insert the other intersection points, but the last\n\n\n        for (j = 1; j <= last; j++) {\n          P = P_crossings[i][j];\n          P._prev = P_crossings[i][j - 1];\n          P._prev._next = P;\n        } // Link last intersection point to the next node\n\n\n        P = P_crossings[i][last];\n        P._next = next_node;\n        P._next._prev = P;\n\n        if (i === P_le - 1) {\n          P._end = true; //console.log(\"END\", P._end, P.coords.usrCoords, P._prev.coords.usrCoords, P._next.coords.usrCoords);\n        }\n\n        P_intersect = P_intersect.concat(P_crossings[i]);\n      }\n    }\n\n    return P_intersect;\n  },\n  _inbetween: function (q, p1, p2) {\n    var alpha,\n        eps = _math.default.eps * _math.default.eps,\n        px = p2[1] - p1[1],\n        py = p2[2] - p1[2],\n        qx = q[1] - p1[1],\n        qy = q[2] - p1[2];\n\n    if (px === 0 && py === 0 && qx === 0 && qy === 0) {\n      // All three points are equal\n      return true;\n    }\n\n    if (Math.abs(qx) < eps && Math.abs(px) < eps) {\n      alpha = qy / py;\n    } else {\n      alpha = qx / px;\n    }\n\n    if (Math.abs(alpha) < eps) {\n      alpha = 0.0;\n    }\n\n    return alpha;\n  },\n  _print_array: function (arr) {\n    var i, end;\n\n    for (i = 0; i < arr.length; i++) {\n      //console.log(i, arr[i].coords.usrCoords,  arr[i].data.type);\n      try {\n        end = \"\";\n\n        if (arr[i]._end) {\n          end = \" end\";\n        }\n\n        console.log(i, arr[i].coords.usrCoords, arr[i].data.type, \"\\t\", \"prev\", arr[i]._prev.coords.usrCoords, \"next\", arr[i]._next.coords.usrCoords + end);\n      } catch (e) {\n        console.log(i, arr[i].coords.usrCoords);\n      }\n    }\n  },\n  _print_list: function (P) {\n    var cnt = 0,\n        alpha;\n\n    while (cnt < 100) {\n      if (P.data) {\n        alpha = P.data.alpha;\n      } else {\n        alpha = \"-\";\n      }\n\n      console.log(\"\\t\", P.coords.usrCoords, \"\\n\\t\\tis:\", P.intersection, \"end:\", P._end, alpha, \"\\n\\t\\t-:\", P._prev.coords.usrCoords, \"\\n\\t\\t+:\", P._next.coords.usrCoords, \"\\n\\t\\tn:\", P.intersection ? P.neighbour.coords.usrCoords : \"-\");\n\n      if (P._end) {\n        break;\n      }\n\n      P = P._next;\n      cnt++;\n    }\n  },\n  _noOverlap: function (p1, p2, q1, q2) {\n    var k,\n        eps = Math.sqrt(_math.default.eps),\n        minp,\n        maxp,\n        minq,\n        maxq,\n        no_overlap = false;\n\n    for (k = 0; k < 3; k++) {\n      minp = Math.min(p1[k], p2[k]);\n      maxp = Math.max(p1[k], p2[k]);\n      minq = Math.min(q1[k], q2[k]);\n      maxq = Math.max(q1[k], q2[k]);\n\n      if (maxp < minq - eps || minp > maxq + eps) {\n        no_overlap = true;\n        break;\n      }\n    }\n\n    return no_overlap;\n  },\n\n  /**\n   * Find all intersections between two paths.\n   * @private\n   * @param  {Array} S     Subject path\n   * @param  {Array} C     Clip path\n   * @param  {JXG.Board} board JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}  Array containing two arrays. The first array contains the intersection vertices\n   * of the subject path and the second array contains the intersection vertices of the clip path.\n   * @see JXG.Clip#Vertex\n   */\n  findIntersections: function (S, C, board) {\n    var res = [],\n        eps = _math.default.eps,\n        i,\n        j,\n        crds,\n        S_le = S.length,\n        C_le = C.length,\n        Si,\n        Si1,\n        Cj,\n        Cj1,\n        d1,\n        d2,\n        alpha,\n        type,\n        IS,\n        IC,\n        S_intersect = [],\n        C_intersect = [],\n        S_crossings = [],\n        C_crossings = [],\n        hasMultCompsS = false,\n        hasMultCompsC = false,\n        DEBUG = false;\n\n    for (j = 0; j < C_le; j++) {\n      C_crossings.push([]);\n    } // Run through the subject path.\n\n\n    for (i = 0; i < S_le; i++) {\n      S_crossings.push([]); // Test if S[i] or its successor is a path separator.\n      // If yes, we know that the path consists of multiple components.\n      // We immediately jump to the next segment.\n\n      if (this._isSeparator(S[i]) || this._isSeparator(S[(i + 1) % S_le])) {\n        hasMultCompsS = true;\n        continue;\n      } // If the path consists of multiple components then there is\n      // no path-closing segment between the last node and the first\n      // node. In this case we can leave the loop now.\n\n\n      if (hasMultCompsS && i === S_le - 1) {\n        break;\n      }\n\n      Si = S[i].coords.usrCoords;\n      Si1 = S[(i + 1) % S_le].coords.usrCoords; // Run through the clip path.\n\n      for (j = 0; j < C_le; j++) {\n        // Test if C[j] or its successor is a path separator.\n        // If yes, we know that the path consists of multiple components.\n        // We immediately jump to the next segment.\n        if (this._isSeparator(C[j]) || this._isSeparator(C[(j + 1) % C_le])) {\n          hasMultCompsC = true;\n          continue;\n        } // If the path consists of multiple components then there is\n        // no path-closing segment between the last node and the first\n        // node. In this case we can leave the loop now.\n\n\n        if (hasMultCompsC && j === C_le - 1) {\n          break;\n        } // Test if bounding boxes of the two curve segments overlap\n        // If not, the expensive intersection test can be skipped.\n\n\n        Cj = C[j].coords.usrCoords;\n        Cj1 = C[(j + 1) % C_le].coords.usrCoords;\n\n        if (this._noOverlap(Si, Si1, Cj, Cj1)) {\n          continue;\n        } // Intersection test\n\n\n        res = _geometry.default.meetSegmentSegment(Si, Si1, Cj, Cj1);\n        d1 = _geometry.default.distance(Si, Si1, 3);\n        d2 = _geometry.default.distance(Cj, Cj1, 3); // Found an intersection point\n\n        if ( // \"Regular\" intersection\n        res[1] * d1 > -eps && res[1] < 1 - eps / d1 && res[2] * d2 > -eps && res[2] < 1 - eps / d2 || res[1] === Infinity && res[2] === Infinity && _math.default.norm(res[0], 3) < eps) {\n          crds = new _coords.default(_constants.default.COORDS_BY_USER, res[0], board);\n          type = \"X\"; // Handle degenerated cases\n\n          if (Math.abs(res[1]) * d1 < eps || Math.abs(res[2]) * d2 < eps) {\n            // Crossing / bouncing at vertex or\n            // end of delayed crossing / bouncing\n            type = \"T\";\n\n            if (Math.abs(res[1]) * d1 < eps) {\n              res[1] = 0;\n            }\n\n            if (Math.abs(res[2]) * d2 < eps) {\n              res[2] = 0;\n            }\n\n            if (res[1] === 0) {\n              crds = new _coords.default(_constants.default.COORDS_BY_USER, Si, board);\n            } else {\n              crds = new _coords.default(_constants.default.COORDS_BY_USER, Cj, board);\n            }\n\n            if (DEBUG) {\n              console.log(\"Degenerate case I\", res[1], res[2], crds.usrCoords, \"type\", type);\n            }\n          } else if (res[1] === Infinity && res[2] === Infinity && _math.default.norm(res[0], 3) < eps) {\n            // console.log(C_intersect);\n            // Collinear segments\n            // Here, there might be two intersection points to be added\n            alpha = this._inbetween(Si, Cj, Cj1);\n\n            if (DEBUG) {// console.log(\"alpha Si\", alpha, Si);\n              // console.log(j, Cj)\n              // console.log((j + 1) % C_le, Cj1)\n            }\n\n            if (alpha >= 0 && alpha < 1) {\n              type = \"T\";\n              crds = new _coords.default(_constants.default.COORDS_BY_USER, Si, board);\n              res[1] = 0;\n              res[2] = alpha;\n              IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n              IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n              IS.neighbour = IC;\n              IC.neighbour = IS;\n              S_crossings[i].push(IS);\n              C_crossings[j].push(IC);\n\n              if (DEBUG) {\n                console.log(\"Degenerate case II\", res[1], res[2], crds.usrCoords, \"type T\");\n              }\n            }\n\n            alpha = this._inbetween(Cj, Si, Si1);\n\n            if (DEBUG) {// console.log(\"alpha Cj\", alpha, Si, Geometry.distance(Si, Cj, 3));\n            }\n\n            if (_geometry.default.distance(Si, Cj, 3) > eps && alpha >= 0 && alpha < 1) {\n              type = \"T\";\n              crds = new _coords.default(_constants.default.COORDS_BY_USER, Cj, board);\n              res[1] = alpha;\n              res[2] = 0;\n              IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n              IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n              IS.neighbour = IC;\n              IC.neighbour = IS;\n              S_crossings[i].push(IS);\n              C_crossings[j].push(IC);\n\n              if (DEBUG) {\n                console.log(\"Degenerate case III\", res[1], res[2], crds.usrCoords, \"type T\");\n              }\n            }\n\n            continue;\n          }\n\n          if (DEBUG) {\n            console.log(\"IS\", i, j, crds.usrCoords, type);\n          }\n\n          IS = new this.Vertex(crds, i, res[1], S, \"S\", type);\n          IC = new this.Vertex(crds, j, res[2], C, \"C\", type);\n          IS.neighbour = IC;\n          IC.neighbour = IS;\n          S_crossings[i].push(IS);\n          C_crossings[j].push(IC);\n        }\n      }\n    } // For both paths, sort their intersection points\n\n\n    S_intersect = this.sortIntersections(S_crossings);\n\n    if (DEBUG) {\n      console.log(\">>>>>> Intersections \");\n      console.log(\"S_intersect\");\n\n      this._print_array(S_intersect);\n\n      console.log(\"----------\");\n    }\n\n    for (i = 0; i < S_intersect.length; i++) {\n      S_intersect[i].data.idx = i;\n      S_intersect[i].neighbour.data.idx = i;\n    }\n\n    C_intersect = this.sortIntersections(C_crossings);\n\n    if (DEBUG) {\n      console.log(\"C_intersect\");\n\n      this._print_array(C_intersect);\n\n      console.log(\"<<<<<< Phase 1 done\");\n    }\n\n    return [S_intersect, C_intersect];\n  },\n\n  /**\n   * It is testedd if the point q lies to the left or right\n   * of the poylgonal chain [p1, p2, p3].\n   * @param {Array} q User coords array\n   * @param {Array} p1 User coords array\n   * @param {Array} p2 User coords array\n   * @param {Array} p3 User coords array\n   * @returns string 'left' or 'right'\n   * @private\n   */\n  _getPosition: function (q, p1, p2, p3) {\n    var s1 = _geometry.default.det3p(q, p1, p2),\n        s2 = _geometry.default.det3p(q, p2, p3),\n        s3 = _geometry.default.det3p(p1, p2, p3); // Left turn\n\n\n    if (s3 >= 0) {\n      if (s1 >= 0 && s2 >= 0) {\n        return \"left\";\n      }\n\n      return \"right\";\n    } // Right turn\n\n\n    if (s1 >= 0 || s2 >= 0) {\n      return \"left\";\n    }\n\n    return \"right\";\n  },\n\n  /**\n   * Determine the delayed status of degenerated intersection points.\n   * It is of the form\n   *   ['on|left|right', 'on|left|right']\n   * <p>\n   * If all four determinants are zero, we add random noise to the point.\n   *\n   * @param {JXG.Math.Clip.Vertex} P Start of path\n   * @private\n   * @see JXG.Math.Clip#markEntryExit\n   * @see JXG.Math.Clip#_handleIntersectionChains\n   */\n  _classifyDegenerateIntersections: function (P) {\n    var Pp,\n        Pm,\n        Qp,\n        Qm,\n        Q,\n        side,\n        cnt,\n        tmp,\n        det,\n        oppositeDir,\n        s1,\n        s2,\n        s3,\n        s4,\n        DEBUG = false;\n\n    if (DEBUG) {\n      console.log(\"\\n-------------- _classifyDegenerateIntersections()\", _type.default.exists(P.data) ? P.data.pathname : \" \");\n    }\n\n    det = _geometry.default.det3p;\n    cnt = 0;\n    P._tours = 0;\n\n    while (true) {\n      if (DEBUG) {\n        console.log(\"Inspect P:\", P.coords.usrCoords, P.data ? P.data.type : \" \");\n      }\n\n      if (P.intersection && P.data.type === \"T\") {\n        // Handle the degenerate cases\n        // Decide if they are (delayed) bouncing or crossing intersections\n        Pp = P._next.coords.usrCoords; // P+\n\n        Pm = P._prev.coords.usrCoords; // P-\n        // If the intersection point is degenerated and\n        // equal to the start and end of one component,\n        // then there will be two adjacent points with\n        // the same coordinate.\n        // In that case, we proceed to the next node.\n\n        if (_geometry.default.distance(P.coords.usrCoords, Pp, 3) < _math.default.eps) {\n          Pp = P._next._next.coords.usrCoords;\n        }\n\n        if (_geometry.default.distance(P.coords.usrCoords, Pm, 3) < _math.default.eps) {\n          Pm = P._prev._prev.coords.usrCoords;\n        }\n\n        Q = P.neighbour;\n        Qm = Q._prev.coords.usrCoords; // Q-\n\n        Qp = Q._next.coords.usrCoords; // Q+\n\n        if (_geometry.default.distance(Q.coords.usrCoords, Qp, 3) < _math.default.eps) {\n          Qp = Q._next._next.coords.usrCoords;\n        }\n\n        if (_geometry.default.distance(Q.coords.usrCoords, Qm, 3) < _math.default.eps) {\n          Qm = Q._prev._prev.coords.usrCoords;\n        }\n\n        if (DEBUG) {\n          console.log(\"P chain:\", Pm, P.coords.usrCoords, Pp);\n          console.log(\"Q chain:\", Qm, P.neighbour.coords.usrCoords, Qp);\n          console.log(\"Pm\", this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp));\n          console.log(\"Pp\", this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));\n        }\n\n        s1 = det(P.coords.usrCoords, Pm, Qm);\n        s2 = det(P.coords.usrCoords, Pp, Qp);\n        s3 = det(P.coords.usrCoords, Pm, Qp);\n        s4 = det(P.coords.usrCoords, Pp, Qm);\n\n        if (s1 === 0 && s2 === 0 && s3 === 0 && s4 === 0) {\n          P.coords.usrCoords[1] *= 1 + Math.random() * _math.default.eps;\n          P.coords.usrCoords[2] *= 1 + Math.random() * _math.default.eps;\n          Q.coords.usrCoords[1] = P.coords.usrCoords[1];\n          Q.coords.usrCoords[2] = P.coords.usrCoords[2];\n          s1 = det(P.coords.usrCoords, Pm, Qm);\n          s2 = det(P.coords.usrCoords, Pp, Qp);\n          s3 = det(P.coords.usrCoords, Pm, Qp);\n          s4 = det(P.coords.usrCoords, Pp, Qm);\n\n          if (DEBUG) {\n            console.log(\"Random shift\", P.coords.usrCoords);\n            console.log(s1, s2, s3, s4, s2 === 0);\n            console.log(this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp), this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp));\n          }\n        }\n\n        oppositeDir = false;\n\n        if (s1 === 0) {\n          // Q-, Q=P, P- on straight line\n          if (_geometry.default.affineRatio(P.coords.usrCoords, Pm, Qm) < 0) {\n            oppositeDir = true;\n          }\n        } else if (s2 === 0) {\n          if (_geometry.default.affineRatio(P.coords.usrCoords, Pp, Qp) < 0) {\n            oppositeDir = true;\n          }\n        } else if (s3 === 0) {\n          if (_geometry.default.affineRatio(P.coords.usrCoords, Pm, Qp) > 0) {\n            oppositeDir = true;\n          }\n        } else if (s4 === 0) {\n          if (_geometry.default.affineRatio(P.coords.usrCoords, Pp, Qm) > 0) {\n            oppositeDir = true;\n          }\n        }\n\n        if (oppositeDir) {\n          // Swap Qm and Qp\n          // Then Qm Q Qp has the same direction as Pm P Pp\n          tmp = Qm;\n          Qm = Qp;\n          Qp = tmp;\n          tmp = s1;\n          s1 = s3;\n          s3 = tmp;\n          tmp = s2;\n          s2 = s4;\n          s4 = tmp;\n        }\n\n        if (DEBUG) {\n          console.log(s1, s2, s3, s4, oppositeDir);\n        }\n\n        if (!_type.default.exists(P.delayedStatus)) {\n          P.delayedStatus = [];\n        }\n\n        if (s1 === 0 && s2 === 0) {\n          // Line [P-,P] equals [Q-,Q] and line [P,P+] equals [Q,Q+]\n          // Interior of delayed crossing / bouncing\n          P.delayedStatus = [\"on\", \"on\"];\n        } else if (s1 === 0) {\n          // P- on line [Q-,Q], P+ not on line [Q,Q+]\n          // Begin / end of delayed crossing / bouncing\n          side = this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp);\n          P.delayedStatus = [\"on\", side];\n        } else if (s2 === 0) {\n          // P+ on line [Q,Q+], P- not on line [Q-,Q]\n          // Begin / end of delayed crossing / bouncing\n          side = this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp);\n          P.delayedStatus = [side, \"on\"];\n        } else {\n          // Neither P+ on line [Q,Q+], nor P- on line [Q-,Q]\n          // No delayed crossing / bouncing\n          if (P.delayedStatus.length === 0) {\n            if (this._getPosition(Pm, Qm, Q.coords.usrCoords, Qp) !== this._getPosition(Pp, Qm, Q.coords.usrCoords, Qp)) {\n              P.data.type = \"X\";\n            } else {\n              P.data.type = \"B\";\n            }\n          }\n        }\n\n        if (DEBUG) {\n          console.log(\">>>> P:\", P.coords.usrCoords, \"delayedStatus:\", P.delayedStatus.toString(), P.data ? P.data.type : \" \", \"\\n---\");\n        }\n      }\n\n      if (_type.default.exists(P._tours)) {\n        P._tours++;\n      }\n\n      if (P._tours > 3 || P._end || cnt > 1000) {\n        // Jump out if either\n        // - we reached the end\n        // - there are more than 1000 intersection points\n        // - P._tours > 3: We went already 4 times through this path.\n        if (cnt > 1000) {\n          console.log(\"Clipping: _classifyDegenerateIntersections exit\");\n        }\n\n        if (_type.default.exists(P._tours)) {\n          delete P._tours;\n        }\n\n        break;\n      }\n\n      if (P.intersection) {\n        cnt++;\n      }\n\n      P = P._next;\n    }\n\n    if (DEBUG) {\n      console.log(\"------------------------\");\n    }\n  },\n\n  /**\n   * At this point the degenerated intersections have been classified.\n   * Now we decide if the intersection chains of the given path\n   * ultimatively cross the other path or bounce.\n   *\n   * @param {JXG.Math.Clip.Vertex} P Start of path\n   *\n   * @see JXG.Math.Clip#markEntryExit\n   * @see JXG.Math.Clip#_classifyDegenerateIntersections\n   * @private\n   */\n  _handleIntersectionChains: function (P) {\n    var cnt = 0,\n        start_status = \"Null\",\n        P_start,\n        intersection_chain = false,\n        wait_for_exit = false,\n        DEBUG = false;\n\n    if (DEBUG) {\n      console.log(\"\\n-------------- _handleIntersectionChains()\", _type.default.exists(P.data) ? P.data.pathname : \" \");\n    }\n\n    while (true) {\n      if (P.intersection === true) {\n        if (DEBUG) {\n          if (P.data.type === \"T\") {\n            console.log(\"Degenerate point\", P.coords.usrCoords, P.data.type, P.data.type === \"T\" ? P.delayedStatus : \" \");\n          } else {\n            console.log(\"Intersection point\", P.coords.usrCoords, P.data.type);\n          }\n        }\n\n        if (P.data.type === \"T\") {\n          if (P.delayedStatus[0] !== \"on\" && P.delayedStatus[1] === \"on\") {\n            // First point of intersection chain\n            intersection_chain = true;\n            P_start = P;\n            start_status = P.delayedStatus[0];\n          } else if (intersection_chain && P.delayedStatus[0] === \"on\" && P.delayedStatus[1] === \"on\") {\n            // Interior of intersection chain\n            P.data.type = \"B\";\n\n            if (DEBUG) {\n              console.log(\"Interior\", P.coords.usrCoords);\n            }\n          } else if (intersection_chain && P.delayedStatus[0] === \"on\" && P.delayedStatus[1] !== \"on\") {\n            // Last point of intersection chain\n            intersection_chain = false;\n\n            if (start_status === P.delayedStatus[1]) {\n              // Intersection chain is delayed bouncing\n              P_start.data.type = \"DB\";\n              P.data.type = \"DB\";\n\n              if (DEBUG) {\n                console.log(\"Chain: delayed bouncing\", P_start.coords.usrCoords, \"...\", P.coords.usrCoords);\n              }\n            } else {\n              // Intersection chain is delayed crossing\n              P_start.data.type = \"DX\";\n              P.data.type = \"DX\";\n\n              if (DEBUG) {\n                console.log(\"Chain: delayed crossing\", P_start.coords.usrCoords, \"...\", P.coords.usrCoords);\n              }\n            }\n          }\n        }\n\n        cnt++;\n      }\n\n      if (P._end) {\n        wait_for_exit = true;\n      }\n\n      if (wait_for_exit && !intersection_chain) {\n        break;\n      }\n\n      if (cnt > 1000) {\n        console.log(\"Warning: _handleIntersectionChains: intersection chain reached maximum numbers of iterations\");\n        break;\n      }\n\n      P = P._next;\n    }\n  },\n\n  /**\n   * Handle the case that all vertices of one path are contained\n   * in the other path. In this case we search for a midpoint of an edge\n   * which is not contained in the other path and add it to the path.\n   * It will be used as starting point for the entry/exit algorithm.\n   *\n   * @private\n   * @param {Array} S Subject path\n   * @param {Array} C Clip path\n   * @param {JXG.board} board JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   */\n  _handleFullyDegenerateCase: function (S, C, board) {\n    var P,\n        Q,\n        l,\n        M,\n        crds,\n        q1,\n        q2,\n        node,\n        i,\n        j,\n        leP,\n        leQ,\n        is_on_Q,\n        tmp,\n        is_fully_degenerated,\n        arr = [S, C];\n\n    for (l = 0; l < 2; l++) {\n      P = arr[l];\n      leP = P.length;\n\n      for (i = 0, is_fully_degenerated = true; i < leP; i++) {\n        if (!P[i].intersection) {\n          is_fully_degenerated = false;\n          break;\n        }\n      }\n\n      if (is_fully_degenerated) {\n        // All nodes of P are also on the other path.\n        Q = arr[(l + 1) % 2];\n        leQ = Q.length; // We search for a midpoint of one edge of P which is not the other path and\n        // we add that midpoint to P.\n\n        for (i = 0; i < leP; i++) {\n          q1 = P[i].coords.usrCoords;\n          q2 = P[i]._next.coords.usrCoords; // M is the midpoint\n\n          M = [(q1[0] + q2[0]) * 0.5, (q1[1] + q2[1]) * 0.5, (q1[2] + q2[2]) * 0.5]; // Test if M is on path Q. If this is not the case,\n          // we take M as additional point of P.\n\n          for (j = 0, is_on_Q = false; j < leQ; j++) {\n            if (Math.abs(_geometry.default.det3p(Q[j].coords.usrCoords, Q[(j + 1) % leQ].coords.usrCoords, M)) < _math.default.eps) {\n              is_on_Q = true;\n              break;\n            }\n          }\n\n          if (!is_on_Q) {\n            // The midpoint is added to the doubly-linked list.\n            crds = new _coords.default(_constants.default.COORDS_BY_USER, M, board);\n            node = {\n              pos: i,\n              intersection: false,\n              coords: crds,\n              elementClass: _constants.default.OBJECT_CLASS_POINT\n            };\n            tmp = P[i]._next;\n            P[i]._next = node;\n            node._prev = P[i];\n            node._next = tmp;\n            tmp._prev = node;\n\n            if (P[i]._end) {\n              P[i]._end = false;\n              node._end = true;\n            }\n\n            break;\n          }\n        }\n      }\n    }\n  },\n  _getStatus: function (P, path) {\n    var status;\n\n    while (P.intersection) {\n      if (P._end) {\n        break;\n      }\n\n      P = P._next;\n    }\n\n    if (_geometry.default.windingNumber(P.coords.usrCoords, path) === 0) {\n      // Outside\n      status = \"entry\"; // console.log(P.coords.usrCoords, ' is outside')\n    } else {\n      // Inside\n      status = \"exit\"; // console.log(P.coords.usrCoords, ' is inside')\n    }\n\n    return [P, status];\n  },\n\n  /**\n   * Mark the intersection vertices of path1 as entry points or as exit points\n   * in respect to path2.\n   * <p>\n   * This is the simple algorithm as in\n   * Greiner, G\u00fcnther; Kai Hormann (1998). \"Efficient clipping of arbitrary polygons\".\n   * ACM Transactions on Graphics. 17 (2): 71\u201383\n   * <p>\n   * The algorithm handles also \"delayed crossings\" from\n   * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n   * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n   * and - as an additional improvement -\n   * handles self intersections of delayed crossings (A.W. 2021).\n   *\n   * @private\n   * @param  {Array} path1 First path\n   * @param  {Array} path2 Second path\n   */\n  markEntryExit: function (path1, path2, starters) {\n    var status,\n        P,\n        cnt,\n        res,\n        i,\n        len,\n        start,\n        chain_start = null,\n        intersection_chain = 0,\n        DEBUG = false;\n    len = starters.length;\n\n    for (i = 0; i < len; i++) {\n      start = starters[i];\n\n      if (DEBUG) {\n        console.log(\"\\n;;;;;;;;;; Labelling phase\", _type.default.exists(path1[start].data) ? path1[start].data.pathname : \" \", path1[start].coords.usrCoords);\n      }\n\n      this._classifyDegenerateIntersections(path1[start]);\n\n      this._handleIntersectionChains(path1[start]);\n\n      if (DEBUG) {\n        console.log(\"\\n---- back to markEntryExit\");\n      } // Decide if the first point of the component is inside or outside\n      // of the other path.\n\n\n      res = this._getStatus(path1[start], path2);\n      P = res[0];\n      status = res[1];\n\n      if (DEBUG) {\n        console.log(\"Start node:\", P.coords.usrCoords, status);\n      }\n\n      P._starter = true; // Greiner-Hormann entry/exit algorithm\n      // with additional handling of delayed crossing / bouncing\n\n      cnt = 0;\n      chain_start = null;\n      intersection_chain = 0;\n\n      while (true) {\n        if (P.intersection === true) {\n          if (P.data.type === \"X\" && intersection_chain === 1) {\n            // While we are in an intersection chain, i.e. a delayed crossing,\n            // we stumble on a crossing intersection.\n            // Probably, the other path is self intersecting.\n            // We end the intersection chain here and\n            // mark this event by setting intersection_chain = 2.\n            chain_start.entry_exit = status;\n\n            if (status === \"exit\") {\n              chain_start.data.type = \"X\";\n            }\n\n            intersection_chain = 2;\n          }\n\n          if (P.data.type === \"X\" || P.data.type === \"DB\") {\n            P.entry_exit = status;\n            status = status === \"entry\" ? \"exit\" : \"entry\";\n\n            if (DEBUG) {\n              console.log(\"mark:\", P.coords.usrCoords, P.data.type, P.entry_exit);\n            }\n          }\n\n          if (P.data.type === \"DX\") {\n            if (intersection_chain === 0) {\n              // Start of intersection chain.\n              // No active intersection chain yet,\n              // i.e. we did not pass a the first node of a delayed crossing.\n              chain_start = P;\n              intersection_chain = 1;\n\n              if (DEBUG) {\n                console.log(\"Start intersection chain:\", P.coords.usrCoords, P.data.type, status);\n              }\n            } else if (intersection_chain === 1) {\n              // Active intersection chain (intersection_chain===1)!\n              // End of delayed crossing chain reached\n              P.entry_exit = status;\n              chain_start.entry_exit = status;\n\n              if (status === \"exit\") {\n                chain_start.data.type = \"X\";\n              } else {\n                P.data.type = \"X\";\n              }\n\n              status = status === \"entry\" ? \"exit\" : \"entry\";\n\n              if (DEBUG) {\n                console.log(\"mark':\", chain_start.coords.usrCoords, chain_start.data.type, chain_start.entry_exit);\n                console.log(\"mark:\", P.coords.usrCoords, P.data.type, P.entry_exit);\n              }\n\n              chain_start = null;\n              intersection_chain = 0;\n            } else if (intersection_chain === 2) {\n              // The delayed crossing had been interrupted by a crossing intersection.\n              // Now we treat the end of the delayed crossing as regular crossing.\n              P.entry_exit = status;\n              P.data.type = \"X\";\n              status = status === \"entry\" ? \"exit\" : \"entry\";\n              chain_start = null;\n              intersection_chain = 0;\n            }\n          }\n        }\n\n        P = P._next;\n\n        if (_type.default.exists(P._starter) || cnt > 10000) {\n          break;\n        }\n\n        cnt++;\n      }\n    }\n  },\n\n  /**\n   *\n   * @private\n   * @param {Array} P\n   * @param {Boolean} isBackward\n   * @returns {Boolean} True, if the node is an intersection and is of type 'X'\n   */\n  _stayOnPath: function (P, status) {\n    var stay = true;\n\n    if (P.intersection && P.data.type !== \"B\") {\n      stay = status === P.entry_exit;\n    }\n\n    return stay;\n  },\n\n  /**\n   * Add a point to the clipping path and returns if the algorithms\n   * arrived at an intersection point which has already been visited.\n   * In this case, true is returned.\n   *\n   * @param {Array} path Resulting path\n   * @param {JXG.Math.Clip.Vertex} vertex Point to be added\n   * @param {Boolean} DEBUG debug output to console.log\n   * @returns {Boolean} true: point has been visited before, false otherwise\n   * @private\n   */\n  _addVertex: function (path, vertex, DEBUG) {\n    if (!isNaN(vertex.coords.usrCoords[1]) && !isNaN(vertex.coords.usrCoords[2])) {\n      path.push(vertex);\n    }\n\n    if (vertex.intersection && vertex.data.done) {\n      if (DEBUG) {\n        console.log(\"Add last intersection point\", vertex.coords.usrCoords, \"on\", vertex.data.pathname, vertex.entry_exit, vertex.data.type);\n      }\n\n      return true;\n    }\n\n    if (vertex.intersection) {\n      vertex.data.done = true;\n\n      if (DEBUG) {\n        console.log(\"Add intersection point\", vertex.coords.usrCoords, \"on\", vertex.data.pathname, vertex.entry_exit, vertex.data.type);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * Tracing phase of the Greiner-Hormann algorithm, see\n   * Greiner, G\u00fcnther; Kai Hormann (1998).\n   * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71\u201383\n   *\n   * Boolean operations on polygons are distinguished: 'intersection', 'union', 'difference'.\n   *\n   * @private\n   * @param  {Array} S           Subject path\n   * @param  {Array} S_intersect Array containing the intersection vertices of the subject path\n   * @param  {String} clip_type  contains the Boolean operation: 'intersection', 'union', or 'difference'\n   * @return {Array}             Array consisting of two arrays containing the x-coordinates and the y-coordintaes of\n   *      the resulting path.\n   */\n  tracing: function (S, S_intersect, clip_type) {\n    var P,\n        current,\n        start,\n        cnt = 0,\n        status,\n        maxCnt = 10000,\n        S_idx = 0,\n        path = [],\n        done = false,\n        DEBUG = false;\n\n    if (DEBUG) {\n      console.log(\"\\n------ Start Phase 3\");\n    } // reverse = (clip_type === 'difference' || clip_type === 'union') ? true : false;\n\n\n    while (S_idx < S_intersect.length && cnt < maxCnt) {\n      // Take the first intersection node of the subject path\n      // which is not yet included as start point.\n      current = S_intersect[S_idx];\n\n      if (current.data.done || current.data.type !== \"X\"\n      /*|| !this._isCrossing(current, reverse)*/\n      ) {\n        S_idx++;\n        continue;\n      }\n\n      if (DEBUG) {\n        console.log(\"\\nStart\", current.data.pathname, current.coords.usrCoords, current.data.type, current.entry_exit, S_idx);\n      }\n\n      if (path.length > 0) {\n        // Add a new path\n        path.push([NaN, NaN]);\n      } // Start now the tracing with that node of the subject path\n\n\n      start = current.data.idx;\n      P = S;\n      done = this._addVertex(path, current, DEBUG);\n      status = current.entry_exit;\n\n      do {\n        if (done) {\n          break;\n        } //\n        // Decide if we follow the current path forward or backward.\n        // for example, in case the clipping is of type \"intersection\"\n        // and the current intersection node is of type entry, we go forward.\n        //\n\n\n        if (clip_type === \"intersection\" && current.entry_exit === \"entry\" || clip_type === \"union\" && current.entry_exit === \"exit\" || clip_type === \"difference\" && P === S === (current.entry_exit === \"exit\")) {\n          if (DEBUG) {\n            console.log(\"Go forward on\", current.data.pathname, current.entry_exit);\n          } //\n          // Take the next nodes and add them to the path\n          // as long as they are not intersection nodes of type 'X'.\n          //\n\n\n          do {\n            current = current._next;\n            done = this._addVertex(path, current, DEBUG);\n\n            if (done) {\n              break;\n            }\n          } while (this._stayOnPath(current, status));\n\n          cnt++;\n        } else {\n          if (DEBUG) {\n            console.log(\"Go backward on\", current.data.pathname);\n          } //\n          // Here, we go backward:\n          // Take the previous nodes and add them to the path\n          // as long as they are not intersection nodes of type 'X'.\n          //\n\n\n          do {\n            current = current._prev;\n            done = this._addVertex(path, current, DEBUG);\n\n            if (done) {\n              break;\n            }\n          } while (this._stayOnPath(current, status));\n\n          cnt++;\n        }\n\n        if (done) {\n          break;\n        }\n\n        if (!current.neighbour) {\n          console.log(\"Tracing: emergency break - no neighbour!!!!!!!!!!!!!!!!!\", cnt);\n          return [[0], [0]];\n        } //\n        // We stopped the forward or backward loop, because we've\n        // arrived at a crossing intersection node, i.e. we have to\n        // switch to the other path now.\n\n\n        if (DEBUG) {\n          console.log(\"Switch from\", current.coords.usrCoords, current.data.pathname, \"to\", current.neighbour.coords.usrCoords, \"on\", current.neighbour.data.pathname);\n        }\n\n        current = current.neighbour;\n\n        if (current.data.done) {\n          break;\n        }\n\n        current.data.done = true;\n        status = current.entry_exit; // if (current.data.done) {\n        //     // We arrived at an intersection node which is already\n        //     // added to the clipping path.\n        //     // We add it again to close the clipping path and jump out of the\n        //     // loop.\n        //     path.push(current);\n        //     if (DEBUG) {\n        //         console.log(\"Push last\", current.coords.usrCoords);\n        //     }\n        //     break;\n        // }\n\n        P = current.data.path; // Polygon closed:\n        // if (DEBUG) {\n        //     console.log(\"End of loop:\", \"start=\", start, \"idx=\", current.data.idx);\n        // }\n        // } while (!(current.data.pathname === 'S' && current.data.idx === start) && cnt < maxCnt);\n      } while (current.data.idx !== start && cnt < maxCnt);\n\n      if (cnt >= maxCnt) {\n        console.log(\"Tracing: stopping an infinite loop!\", cnt);\n      }\n\n      S_idx++;\n    }\n\n    return this._getCoordsArrays(path, false);\n  },\n\n  /**\n   * Handle path clipping if one of the two paths is empty.\n   * @private\n   * @param  {Array} S        First path, array of JXG.Coords\n   * @param  {Array} C        Second path, array of JXG.Coords\n   * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n   * @return {Boolean}        true, if one of the input paths is empty, false otherwise.\n   */\n  isEmptyCase: function (S, C, clip_type) {\n    if (clip_type === \"intersection\" && (S.length === 0 || C.length === 0)) {\n      return true;\n    }\n\n    if (clip_type === \"union\" && S.length === 0 && C.length === 0) {\n      return true;\n    }\n\n    if (clip_type === \"difference\" && S.length === 0) {\n      return true;\n    }\n\n    return false;\n  },\n  _getCoordsArrays: function (path, doClose) {\n    var pathX = [],\n        pathY = [],\n        i,\n        le = path.length;\n\n    for (i = 0; i < le; i++) {\n      if (path[i].coords) {\n        pathX.push(path[i].coords.usrCoords[1]);\n        pathY.push(path[i].coords.usrCoords[2]);\n      } else {\n        pathX.push(path[i][0]);\n        pathY.push(path[i][1]);\n      }\n    }\n\n    if (doClose && le > 0) {\n      if (path[0].coords) {\n        pathX.push(path[0].coords.usrCoords[1]);\n        pathY.push(path[0].coords.usrCoords[2]);\n      } else {\n        pathX.push(path[0][0]);\n        pathY.push(path[0][1]);\n      }\n    }\n\n    return [pathX, pathY];\n  },\n\n  /**\n   * Handle cases when there are no intersection points of the two paths. This is the case if the\n   * paths are disjoint or one is contained in the other.\n   * @private\n   * @param  {Array} S        First path, array of JXG.Coords\n   * @param  {Array} C        Second path, array of JXG.Coords\n   * @param  {String} clip_type Type of Boolean operation: 'intersection', 'union', 'differrence'.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   */\n  handleEmptyIntersection: function (S, C, clip_type) {\n    var P,\n        Q,\n        doClose = false,\n        path = []; // Handle trivial cases\n\n    if (S.length === 0) {\n      if (clip_type === \"union\") {\n        // S cup C = C\n        path = C;\n      } else {\n        // S cap C = S \\ C = {}\n        path = [];\n      }\n\n      return this._getCoordsArrays(path, true);\n    }\n\n    if (C.length === 0) {\n      if (clip_type === \"intersection\") {\n        // S cap C = {}\n        path = [];\n      } else {\n        // S cup C = S \\ C = S\n        path = S;\n      }\n\n      return this._getCoordsArrays(path, true);\n    } // From now on, both paths have non-zero length.\n    // The two paths have no crossing intersections,\n    // but there might be bouncing intersections.\n    // First, we find -- if possible -- on each path a point which is not an intersection point.\n\n\n    if (S.length > 0) {\n      P = S[0];\n\n      while (P.intersection) {\n        P = P._next;\n\n        if (P._end) {\n          break;\n        }\n      }\n    }\n\n    if (C.length > 0) {\n      Q = C[0];\n\n      while (Q.intersection) {\n        Q = Q._next;\n\n        if (Q._end) {\n          break;\n        }\n      }\n    } // Test if one curve is contained by the other\n\n\n    if (_geometry.default.windingNumber(P.coords.usrCoords, C) === 0) {\n      // P is outside of C:\n      // Either S is disjoint from C or C is inside of S\n      if (_geometry.default.windingNumber(Q.coords.usrCoords, S) !== 0) {\n        // C is inside of S, i.e. C subset of S\n        if (clip_type === \"union\") {\n          path = path.concat(S);\n          path.push(S[0]);\n        } else if (clip_type === \"difference\") {\n          path = path.concat(S);\n          path.push(S[0]);\n\n          if (_geometry.default.signedPolygon(S) * _geometry.default.signedPolygon(C) > 0) {\n            // Pathes have same orientation, we have to revert one.\n            path.reverse();\n          }\n\n          path.push([NaN, NaN]);\n        }\n\n        if (clip_type === \"difference\" || clip_type === \"intersection\") {\n          path = path.concat(C);\n          path.push(C[0]);\n          doClose = false;\n        }\n      } else {\n        // The curves are disjoint\n        if (clip_type === \"difference\") {\n          path = path.concat(S);\n          doClose = true;\n        } else if (clip_type === \"union\") {\n          path = path.concat(S);\n          path.push(S[0]);\n          path.push([NaN, NaN]);\n          path = path.concat(C);\n          path.push(C[0]);\n        }\n      }\n    } else {\n      // S inside of C, i.e. S subset of C\n      if (clip_type === \"intersection\") {\n        path = path.concat(S);\n        doClose = true;\n      } else if (clip_type === \"union\") {\n        path = path.concat(C);\n        path.push(C[0]);\n      } // 'difference': path is empty\n\n    }\n\n    return this._getCoordsArrays(path, doClose);\n  },\n\n  /**\n   * Count intersection points of type 'X'.\n   * @param {JXG.Mat.Clip.Vertex} intersections\n   * @returns Number\n   * @private\n   */\n  _countCrossingIntersections: function (intersections) {\n    var i,\n        le = intersections.length,\n        sum = 0;\n\n    for (i = 0; i < le; i++) {\n      if (intersections[i].data.type === \"X\") {\n        sum++;\n      }\n    }\n\n    return sum;\n  },\n\n  /**\n   * Create path from all sorts of input elements and convert it\n   * to a suitable input path for greinerHormann().\n   *\n   * @private\n   * @param {Object} obj Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n   * array of coordinate pairs.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @returns {Array} Array of JXG.Coords elements containing a path.\n   * @see JXG.Math.Clip#greinerHormann\n   */\n  _getPath: function (obj, board) {\n    var i,\n        len,\n        r,\n        rad,\n        angle,\n        alpha,\n        steps,\n        S = []; // Collect all points into path array S\n\n    if (obj.elementClass === _constants.default.OBJECT_CLASS_CURVE && (obj.type === _constants.default.OBJECT_TYPE_ARC || obj.type === _constants.default.OBJECT_TYPE_SECTOR)) {\n      angle = _geometry.default.rad(obj.radiuspoint, obj.center, obj.anglepoint);\n      steps = Math.floor(angle * 180 / Math.PI);\n      r = obj.Radius();\n      rad = angle / steps;\n      alpha = Math.atan2(obj.radiuspoint.coords.usrCoords[2] - obj.center.coords.usrCoords[2], obj.radiuspoint.coords.usrCoords[1] - obj.center.coords.usrCoords[1]);\n\n      if (obj.type === _constants.default.OBJECT_TYPE_SECTOR) {\n        this._addToList(S, obj.center.coords, 0);\n      }\n\n      for (i = 0; i <= steps; i++) {\n        this._addToList(S, new _coords.default(_constants.default.COORDS_BY_USER, [obj.center.coords.usrCoords[0], obj.center.coords.usrCoords[1] + Math.cos(i * rad + alpha) * r, obj.center.coords.usrCoords[2] + Math.sin(i * rad + alpha) * r], board), i + 1);\n      }\n\n      if (obj.type === _constants.default.OBJECT_TYPE_SECTOR) {\n        this._addToList(S, obj.center.coords, steps + 2);\n      }\n    } else if (obj.elementClass === _constants.default.OBJECT_CLASS_CURVE && _type.default.exists(obj.points)) {\n      len = obj.numberPoints;\n\n      for (i = 0; i < len; i++) {\n        this._addToList(S, obj.points[i], i);\n      }\n    } else if (obj.type === _constants.default.OBJECT_TYPE_POLYGON) {\n      for (i = 0; i < obj.vertices.length; i++) {\n        this._addToList(S, obj.vertices[i].coords, i);\n      }\n    } else if (obj.elementClass === _constants.default.OBJECT_CLASS_CIRCLE) {\n      steps = 359;\n      r = obj.Radius();\n      rad = 2 * Math.PI / steps;\n\n      for (i = 0; i <= steps; i++) {\n        this._addToList(S, new _coords.default(_constants.default.COORDS_BY_USER, [obj.center.coords.usrCoords[0], obj.center.coords.usrCoords[1] + Math.cos(i * rad) * r, obj.center.coords.usrCoords[2] + Math.sin(i * rad) * r], board), i);\n      }\n    } else if (_type.default.isArray(obj)) {\n      len = obj.length;\n\n      for (i = 0; i < len; i++) {\n        if (_type.default.exists(obj[i].coords)) {\n          // Point type\n          this._addToList(S, obj[i].coords, i);\n        } else if (_type.default.isArray(obj[i])) {\n          // Coordinate pair\n          this._addToList(S, new _coords.default(_constants.default.COORDS_BY_USER, obj[i], board), i);\n        } else if (_type.default.exists(obj[i].usrCoords)) {\n          // JXG.Coordinates\n          this._addToList(S, obj[i], i);\n        }\n      }\n    }\n\n    return S;\n  },\n\n  /**\n   * Determine the intersection, union or difference of two closed paths.\n   * <p>\n   * This is an implementation of the Greiner-Hormann algorithm, see\n   * G\u00fcnther Greiner and Kai Hormann (1998).\n   * \"Efficient clipping of arbitrary polygons\". ACM Transactions on Graphics. 17 (2): 71\u201383.\n   * and\n   * Erich, L. Foster, and Kai Hormann, Kai, and Romeo Traaian Popa (2019),\n   * \"Clipping simple polygons with degenerate intersections\", Computers & Graphics:X, 2.\n   * <p>\n   * It is assumed that the pathes are closed, whereby it does not matter if the last point indeed\n   * equals the first point. In contrast to the original Greiner-Hormann algorithm,\n   * this algorithm can cope with many degenerate cases. A degenerate case is a vertext of one path\n   * which is contained in the other path.\n   * <p>\n   *\n   * <p>Problematic are:\n   * <ul>\n   *   <li>degenerate cases where one path additionally has self-intersections\n   *   <li>differences with one path having self-intersections.\n   * </ul>\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path, usually called 'subject'.\n   * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n   * array of coordinate pairs.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path, usually called 'clip'.\n   * Maybe curve, arc, sector, circle, polygon, array of points, array of JXG.Coords,\n   * array of coordinate pairs.\n   * @param  {String} clip_type Determines the type of boolean operation on the two paths.\n   *  Possible values are 'intersection', 'union', or 'difference'.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#intersection\n   * @see JXG.Math.Clip#union\n   * @see JXG.Math.Clip#difference\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-3, 3, 0, -3],\n   *             [3, 3, 0, 3]\n   *         ],\n   *         {strokeColor: 'black'});\n   *\n   *     var curve2 = board.create('curve', [\n   *             [-4, 4, 0, -4],\n   *             [2, 2, 4, 2]\n   *         ],\n   *         {strokeColor: 'blue'});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n   *\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG9d2a6acf-a43b-4035-8f8a-9b1bee580210',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *\n   *         var curve1 = board.create('curve', [\n   *                 [-3, 3, 0, -3],\n   *                 [3, 3, 0, 3]\n   *             ],\n   *             {strokeColor: 'black'});\n   *\n   *         var curve2 = board.create('curve', [\n   *                 [-4, 4, 0, -4],\n   *                 [2, 2, 4, 2]\n   *             ],\n   *             {strokeColor: 'blue'});\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.greinerHormann(curve2, curve1, 'intersection', this.board);\n   *\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-3, 3, 0, -3],\n   *             [3, 3, 0, 3]\n   *         ],\n   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *             {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG6075c918-4d57-4b72-b600-6597a6a4f44e\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG6075c918-4d57-4b72-b600-6597a6a4f44e',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('curve', [\n   *                 [-3, 3, 0, -3],\n   *                 [3, 3, 0, 3]\n   *             ],\n   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *                 {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'union', this.board);\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-4, 4, 0, -4],\n   *             [4, 4, -2, 4]\n   *         ],\n   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *     var curve2 = board.create('circle', [[0, 0], [0, -2]],\n   *             {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n   *             center: {visible: true, size: 5}, point2: {size: 5}});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n   *\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG46b3316b-5ab9-4928-9473-ccb476ca4185\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG46b3316b-5ab9-4928-9473-ccb476ca4185',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('curve', [\n   *                 [-4, 4, 0, -4],\n   *                 [4, 4, -2, 4]\n   *             ],\n   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *         var curve2 = board.create('circle', [[0, 0], [0, -2]],\n   *                 {strokeColor: 'blue', strokeWidth: 1, fillColor: 'red', fixed: true, fillOpacity: 0.3,\n   *                 center: {visible: true, size: 5}, point2: {size: 5}});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.6});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.greinerHormann(curve1, curve2, 'difference', this.board);\n   *\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   * @example\n   * var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n   * clip_path.updateDataArray = function() {\n   *     var bbox = this.board.getBoundingBox(),\n   *         canvas, triangle;\n   *\n   *     canvas = [[bbox[0], bbox[1]], // ul\n   *          [bbox[0], bbox[3]], // ll\n   *          [bbox[2], bbox[3]], // lr\n   *          [bbox[2], bbox[1]], // ur\n   *          [bbox[0], bbox[1]]] // ul\n   *     triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n   *\n   *     var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n   *     this.dataX = a[0];\n   *     this.dataY = a[1];\n   * };\n   *\n   * </pre><div id=\"JXGe94da07a-2a01-4498-ad62-f71a327f8e25\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXGe94da07a-2a01-4498-ad62-f71a327f8e25',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 1, fillColor: 'yellow', fillOpacity: 0.6});\n   *     clip_path.updateDataArray = function() {\n   *         var bbox = this.board.getBoundingBox(),\n   *             canvas, triangle;\n   *\n   *         canvas = [[bbox[0], bbox[1]], // ul\n   *              [bbox[0], bbox[3]], // ll\n   *              [bbox[2], bbox[3]], // lr\n   *              [bbox[2], bbox[1]], // ur\n   *              [bbox[0], bbox[1]]] // ul\n   *         triangle = [[-1,1], [1,1], [0,-1], [-1,1]];\n   *\n   *         var a = JXG.Math.Clip.greinerHormann(canvas, triangle, 'difference', this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   */\n  greinerHormann: function (subject, clip, clip_type, board) {\n    //},\n    // subject_first_point_type, clip_first_point_type) {\n    var len,\n        S = [],\n        C = [],\n        S_intersect = [],\n        // C_intersect = [],\n    S_starters,\n        C_starters,\n        res = [],\n        DEBUG = false;\n\n    if (DEBUG) {\n      console.log(\"\\n------------ GREINER-HORMANN --------------\");\n    } // Collect all subject points into subject array S\n\n\n    S = this._getPath(subject, board);\n    len = S.length;\n\n    if (len > 0 && _geometry.default.distance(S[0].coords.usrCoords, S[len - 1].coords.usrCoords, 3) < _math.default.eps) {\n      S.pop();\n    } // Collect all points into clip array C\n\n\n    C = this._getPath(clip, board);\n    len = C.length;\n\n    if (len > 0 && _geometry.default.distance(C[0].coords.usrCoords, C[len - 1].coords.usrCoords, 3) < _math.default.eps * _math.default.eps) {\n      C.pop();\n    } // Handle cases where at least one of the paths is empty\n\n\n    if (this.isEmptyCase(S, C, clip_type)) {\n      return [[], []];\n    } // Add pointers for doubly linked lists\n\n\n    S_starters = this.makeDoublyLinkedList(S);\n    C_starters = this.makeDoublyLinkedList(C);\n\n    if (DEBUG) {\n      this._print_array(S);\n\n      console.log(\"Components:\", S_starters);\n\n      this._print_array(C);\n\n      console.log(\"Components:\", C_starters);\n    }\n\n    res = this.findIntersections(S, C, board);\n    S_intersect = res[0];\n\n    this._handleFullyDegenerateCase(S, C, board); // Phase 2: mark intersection points as entry or exit points\n\n\n    this.markEntryExit(S, C, S_starters); // if (S[0].coords.distance(Const.COORDS_BY_USER, C[0].coords) === 0) {\n    //     // Randomly disturb the first point of the second path\n    //     // if both paths start at the same point.\n    //     C[0].usrCoords[1] *= 1 + Math.random() * 0.0001 - 0.00005;\n    //     C[0].usrCoords[2] *= 1 + Math.random() * 0.0001 - 0.00005;\n    // }\n\n    this.markEntryExit(C, S, C_starters); // Handle cases without intersections\n\n    if (this._countCrossingIntersections(S_intersect) === 0) {\n      return this.handleEmptyIntersection(S, C, clip_type);\n    } // Phase 3: tracing\n\n\n    return this.tracing(S, S_intersect, clip_type);\n  },\n\n  /**\n   * Union of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n   * Computed by the Greiner-Hormann algorithm.\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#greinerHormann\n   * @see JXG.Math.Clip#intersection\n   * @see JXG.Math.Clip#difference\n   *\n   * @example\n   *     var curve1 = board.create('curve', [\n   *             [-3, 3, 0, -3],\n   *             [3, 3, 0, 3]\n   *         ],\n   *         {strokeColor: 'black'});\n   *\n   *     var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *             {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXG7c5204aa-3824-4464-819c-80df7bf1d917\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG7c5204aa-3824-4464-819c-80df7bf1d917',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('curve', [\n   *                 [-3, 3, 0, -3],\n   *                 [3, 3, 0, 3]\n   *             ],\n   *             {strokeColor: 'black'});\n   *\n   *         var curve2 = board.create('polygon', [[3, 4], [-4, 0], [-4, 4]],\n   *                 {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.union(curve1, curve2, this.board);\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   */\n  union: function (path1, path2, board) {\n    return this.greinerHormann(path1, path2, \"union\", board);\n  },\n\n  /**\n   * Intersection of two closed paths. The paths could be JSXGraph elements circle, curve, or polygon.\n   * Computed by the Greiner-Hormann algorithm.\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#greinerHormann\n   * @see JXG.Math.Clip#union\n   * @see JXG.Math.Clip#difference\n   *\n   * @example\n   * var p = [];\n   * p.push(board.create('point', [0, -5]));\n   * p.push(board.create('point', [-5, 0]));\n   * p.push(board.create('point', [-3, 3]));\n   *\n   * var curve1 = board.create('ellipse', p,\n   *                 {strokeColor: 'black'});\n   *\n   * var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n   *                                     [0, 0],\n   *                                     0, 2 * Math.PI],\n   *                       {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n   *\n   * var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   * clip_path.updateDataArray = function() {\n   *     var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n   *\n   *     this.dataX = a[0];\n   *     this.dataY = a[1];\n   * };\n   *\n   * board.update();\n   *\n   * </pre><div id=\"JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG7ad547eb-7b6c-4a1a-a4d4-4ed298fc7998',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *     var p = [];\n   *     p.push(board.create('point', [0, -5]));\n   *     p.push(board.create('point', [-5, 0]));\n   *     p.push(board.create('point', [-3, 3]));\n   *\n   *     var curve1 = board.create('ellipse', p,\n   *                     {strokeColor: 'black'});\n   *\n   *     var curve2 = board.create('curve', [function(phi){return 4 * Math.cos(2*phi); },\n   *                                         [0, 0],\n   *                                         0, 2 * Math.PI],\n   *                           {curveType:'polar', strokeColor: 'blue', strokewidth:1});\n   *\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.intersection(curve2, curve1, this.board);\n   *\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   *\n   */\n  intersection: function (path1, path2, board) {\n    return this.greinerHormann(path1, path2, \"intersection\", board);\n  },\n\n  /**\n   * Difference of two closed paths, i.e. path1 minus path2.\n   * The paths could be JSXGraph elements circle, curve, or polygon.\n   * Computed by the Greiner-Hormann algorithm.\n   *\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} subject   First closed path.\n   * @param  {JXG.Circle|JXG.Curve|JXG.Polygon} clip      Second closed path.\n   * @param  {JXG.Board} board   JSXGraph board object. It is needed to convert between\n   * user coordinates and screen coordinates.\n   * @return {Array}          Array consisting of two arrays containing the x-coordinates and the y-coordinates of\n   *      the resulting path.\n   *\n   * @see JXG.Math.Clip#greinerHormann\n   * @see JXG.Math.Clip#intersection\n   * @see JXG.Math.Clip#union\n   *\n   * @example\n   *     var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n   *             {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *     var curve2 = board.create('curve', [\n   *             [-1, 1, 0, -1],\n   *             [1, 1, 3, 1]\n   *         ],\n   *         {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *     var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *     clip_path.updateDataArray = function() {\n   *         var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n   *         this.dataX = a[0];\n   *         this.dataY = a[1];\n   *     };\n   *\n   *     board.update();\n   *\n   * </pre><div id=\"JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXGc5ce6bb3-146c-457f-a48b-6b9081fb68a3',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *         var curve1 = board.create('polygon', [[-4, 4], [4, 4], [0, -1]],\n   *                 {strokeColor: 'blue', fillColor: 'none'});\n   *\n   *         var curve2 = board.create('curve', [\n   *                 [-1, 1, 0, -1],\n   *                 [1, 1, 3, 1]\n   *             ],\n   *             {strokeColor: 'black', fillColor: 'none', fillOpacity: 0.8});\n   *\n   *\n   *         var clip_path = board.create('curve', [[], []], {strokeWidth: 3, fillColor: 'yellow', fillOpacity: 0.3});\n   *         clip_path.updateDataArray = function() {\n   *             var a = JXG.Math.Clip.difference(curve1, curve2, this.board);\n   *             this.dataX = a[0];\n   *             this.dataY = a[1];\n   *         };\n   *\n   *         board.update();\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   */\n  difference: function (path1, path2, board) {\n    return this.greinerHormann(path1, path2, \"difference\", board);\n  }\n}; //);\n\n_jxg.default.extend(_math.default.Clip,\n/** @lends JXG.Math.Clip */\n{});\n\nvar _default = _math.default.Clip;\nexports.default = _default;\n};"],
"names":["shadow$provide","global","require","module","exports","_interopRequireDefault","obj","__esModule","default","Object","defineProperty","value","_jxg","_constants","_coords","_math","_geometry","_type","Clip","_isSeparator","node","isNaN","coords","usrCoords","makeDoublyLinkedList","S","i","first","components","le","length","_next","_prev","push","_end","Vertex","alpha","path","pathname","type","pos","intersection","elementClass","OBJECT_CLASS_POINT","data","done","idx","neighbour","entry_exit","_addToList","list","len","eps","Math","abs","sortIntersections","P_crossings","P_intersect","P_le","sort","a","b","last","P","Q","next_node","j","concat","_inbetween","q","p1","p2","px","py","qx","qy","_print_array","arr","end","console","log","e","_print_list","cnt","_noOverlap","q1","q2","k","sqrt","no_overlap","minp","min","maxp","max","minq","maxq","findIntersections","C","board","S_le","C_le","S_crossings","C_crossings","hasMultCompsS","hasMultCompsC","Si","Si1","Cj","Cj1","res","meetSegmentSegment","d1","distance","d2","Infinity","norm","crds","COORDS_BY_USER","IS","IC","S_intersect","C_intersect","_getPosition","p3","s1","det3p","s2","s3","_classifyDegenerateIntersections","det","_tours","Pp","Pm","Qm","Qp","s4","random","oppositeDir","affineRatio","tmp","exists","delayedStatus","side","_handleIntersectionChains","start_status","P_start","intersection_chain","wait_for_exit","_handleFullyDegenerateCase","is_on_Q","l","leP","is_fully_degenerated","leQ","M","_getStatus","status","windingNumber","markEntryExit","path1","path2","starters","start","_starter","chain_start","_stayOnPath","stay","_addVertex","vertex","DEBUG","tracing","clip_type","current","S_idx","maxCnt","NaN","_getCoordsArrays","isEmptyCase","doClose","pathX","pathY","handleEmptyIntersection","signedPolygon","reverse","_countCrossingIntersections","intersections","sum","_getPath","OBJECT_CLASS_CURVE","OBJECT_TYPE_ARC","OBJECT_TYPE_SECTOR","angle","rad","radiuspoint","center","anglepoint","steps","floor","PI","r","Radius","atan2","cos","sin","points","numberPoints","OBJECT_TYPE_POLYGON","vertices","OBJECT_CLASS_CIRCLE","isArray","greinerHormann","subject","clip","pop","S_starters","C_starters","union","difference","extend"]
}
