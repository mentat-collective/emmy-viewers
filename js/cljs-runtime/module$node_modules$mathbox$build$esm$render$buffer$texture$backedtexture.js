shadow$provide.module$node_modules$mathbox$build$esm$render$buffer$texture$backedtexture=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.BackedTexture=void 0;global=require("module$node_modules$mathbox$build$esm$render$buffer$texture$datatexture");class BackedTexture extends global.DataTexture{constructor(renderer,width,height,channels,options){super(renderer,width,height,channels,options);this.data=new this.ctor(this.n)}resize(width,height){const old=
this.data,oldWidth=this.width,oldHeight=this.height;this.width=width;this.height=height;this.n=width*height*this.channels;this.data=new this.ctor(this.n);const {gl}=this;this.renderer.state.bindTexture(gl.TEXTURE_2D,this.texture);gl.pixelStorei(gl.UNPACK_ALIGNMENT,1);gl.texImage2D(gl.TEXTURE_2D,0,this.format,width,height,0,this.format,this.type,this.data);this.uniforms.dataResolution.value.set(1/width,1/height);return this.write(old,0,0,oldWidth,oldHeight)}write(src,x,y,w,h){({width:j}=this);const dst=
this.data;var {channels}=this;let i=0;if(j===w&&0===x){var j=y*w*channels;for(var n=w*h*channels;i<n;)dst[j++]=src[i++]}else{n=j*channels;const ww=w*channels;channels*=x;let yy=y;const yh=y+h;for(;yy<yh;){let k=0;for(j=channels+yy*n;k++<ww;)dst[j++]=src[i++];yy++}}return super.write(src,x,y,w,h)}dispose(){this.data=null;return super.dispose()}}exports.BackedTexture=BackedTexture}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$render$buffer$texture$backedtexture.js.map
