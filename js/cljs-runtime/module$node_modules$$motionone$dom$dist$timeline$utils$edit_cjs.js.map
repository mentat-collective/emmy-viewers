{
"version":3,
"file":"module$node_modules$$motionone$dom$dist$timeline$utils$edit_cjs.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,+DAAA,CAAoF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAO5HC,QAASA,eAAc,CAACC,QAAD,CAAWC,SAAX,CAAsBC,OAAtB,CAA+B,CAClD,IAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBH,QAASI,CAAAA,MAA7B,CAAqCD,CAAA,EAArC,CAA0C,CACtC,MAAME,SAAWL,QAAA,CAASG,CAAT,CACbE,SAASC,CAAAA,EAAb,CAAkBL,SAAlB,EAA+BI,QAASC,CAAAA,EAAxC,CAA6CJ,OAA7C,GACIK,KAAMC,CAAAA,UAAN,CAAiBR,QAAjB,CAA2BK,QAA3B,CAEA,CAAAF,CAAA,EAHJ,CAFsC,CADQ,CAJtDM,MAAOC,CAAAA,cAAP,CAAsBZ,OAAtB,CAA+B,YAA/B,CAA6C,CAAEa,MAAO,CAAA,CAAT,CAA7C,CAEA,KAAIJ,MAAQX,OAAA,CAAQ,qDAAR,CA4BZE,QAAQc,CAAAA,YAAR,CAhBAA,QAAqB,CAACZ,QAAD,CAAWa,SAAX,CAAsBC,MAAtB;AAA8BC,MAA9B,CAAsCd,SAAtC,CAAiDC,OAAjD,CAA0D,CAM3EH,cAAA,CAAeC,QAAf,CAAyBC,SAAzB,CAAoCC,OAApC,CACA,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAAoBU,SAAUT,CAAAA,MAA9B,CAAsCD,CAAA,EAAtC,CACIH,QAASgB,CAAAA,IAAT,CAAc,CACVL,MAAOE,SAAA,CAAUV,CAAV,CADG,CAEVG,GAAIC,KAAMU,CAAAA,GAAN,CAAUhB,SAAV,CAAqBC,OAArB,CAA8Ba,MAAA,CAAOZ,CAAP,CAA9B,CAFM,CAGVW,OAAQP,KAAMW,CAAAA,mBAAN,CAA0BJ,MAA1B,CAAkCX,CAAlC,CAHE,CAAd,CARuE,CAiB/EL,QAAQC,CAAAA,cAAR,CAAyBA,cAlCmG;",
"sources":["node_modules/@motionone/dom/dist/timeline/utils/edit.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$motionone$dom$dist$timeline$utils$edit_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\n\nfunction eraseKeyframes(sequence, startTime, endTime) {\n    for (let i = 0; i < sequence.length; i++) {\n        const keyframe = sequence[i];\n        if (keyframe.at > startTime && keyframe.at < endTime) {\n            utils.removeItem(sequence, keyframe);\n            // If we remove this item we have to push the pointer back one\n            i--;\n        }\n    }\n}\nfunction addKeyframes(sequence, keyframes, easing, offset, startTime, endTime) {\n    /**\n     * Erase every existing value between currentTime and targetTime,\n     * this will essentially splice this timeline into any currently\n     * defined ones.\n     */\n    eraseKeyframes(sequence, startTime, endTime);\n    for (let i = 0; i < keyframes.length; i++) {\n        sequence.push({\n            value: keyframes[i],\n            at: utils.mix(startTime, endTime, offset[i]),\n            easing: utils.getEasingForSegment(easing, i),\n        });\n    }\n}\n\nexports.addKeyframes = addKeyframes;\nexports.eraseKeyframes = eraseKeyframes;\n\n};"],
"names":["shadow$provide","global","require","module","exports","eraseKeyframes","sequence","startTime","endTime","i","length","keyframe","at","utils","removeItem","Object","defineProperty","value","addKeyframes","keyframes","easing","offset","push","mix","getEasingForSegment"]
}
