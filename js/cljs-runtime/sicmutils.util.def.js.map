{"version":3,"sources":["sicmutils/util/def.cljc"],"mappings":";AAiBA,AAAcA,uCACZ,AAACC,4CAAI,AAACC,6CAAKC,iBAAOC,cAAIC,iBACjB,8CAAA,KAAA,nDAACC;AAER;;;;8BAAA,9BAAeC,oEAGZC,EAAEC;AAHL,AAIE,IAAMC,UAAQ,gFAAA,9DAAID,GACF,AAACH,8CAAME,EAAE,KAAA,JAAKC,6FACbD;AAFjB,AAGE,mDAAA,WAAAG,vDAACV;AAAD,AAAM,oDAAA,7CAACW,8EAAQ,6CAAAD,7CAACE,+DAAQb;GACnBU;;AAsFT;;;;;;;;;;;;;;;;;iCAAA,jCAAMI,0EAgBcC;AAhBpB,AAkBK,kBAAKK,IAAIC;AAAT,AAAA,OAAAL,iDAAA,AAAAC,cAAA,AAAAC,sDAAA,KAAAC,eAAA,KAAA,AAAA,sDAAA,KAAA,IAAA,OAAA,KAAAA,eAAA,SAAA,KAAA,IAAA,yDAAA,KAAAA,eAAA,UAAA,KAAA,IAAA,7GACSC,+FAAKC","names":["sicmutils.util.def/lowercase-symbols","cljs.core.map","cljs.core.comp","cljs.core/symbol","cljs.core/str","cljs.core/char","cljs.core.range","sicmutils.util.def/arglists","a","b","arities","p1__77474#","cljs.core.into","cljs.core.take","sicmutils.util.def/careful-def","_","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","sym","form"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.util.def\n  #?(:clj\n     (:import (clojure.lang Keyword RT))))\n\n(defmacro ^:no-doc fork\n  \"I borrowed this lovely, mysterious macro from `macrovich`:\n  https://github.com/cgrand/macrovich. This allows us to fork behavior inside of\n  a macro at macroexpansion time, not at read time.\"\n  [& {:keys [cljs clj]}]\n  (if (contains? &env '&env)\n    `(if (:ns ~'&env) ~cljs ~clj)\n    (if #?(:clj (:ns &env) :cljs true)\n      cljs\n      clj)))\n\n(def ^:no-doc lowercase-symbols\n  (map (comp symbol str char)\n       (range 97 123)))\n\n(defn ^:no-doc arglists\n  \"returns a list of `:arglists` entries appropriate for a generic function with\n  arities between `a` and `b` inclusive.\"\n  [a b]\n  (let [arities (if b\n                  (range a (inc b))\n                  [a])]\n    (map #(into [] (take %) lowercase-symbols)\n         arities)))\n\n(defmacro defgeneric\n  \"Defines a multifn using the provided symbol. Arranges for the multifn\n  to answer the :arity message, reporting either `[:exactly a]` or\n  `[:between a b]` according to the arguments given.\n\n  - `arities` can be either a single or a vector of 2 numbers.\n\n  The `options` allowed differs slightly from `defmulti`:\n\n  - the first optional argument is a docstring.\n\n  - the second optional argument is a dict of metadata. When you query the\n  defined multimethod with a keyword, it will pass that keyword along as a query\n  to this metadata map. (`:arity` is always overridden if supplied, and `:name`\n  defaults to the symbol `f`.)\n\n  Any remaining options are passed along to `defmulti`.\"\n  {:arglists '([name arities docstring? attr-map? & options])}\n  [f arities & options]\n  (let [[a b]     (if (vector? arities) arities [arities])\n        arity     (if b [:between a b] [:exactly a])\n        docstring (if (string? (first options))\n                    (str \"generic \" f \".\\n\\n\" (first options))\n                    (str \"generic \" f ))\n        options   (if (string? (first options))\n                    (next options)\n                    options)\n        [attr options] (if (map? (first options))\n                         [(first options) (next options)]\n                         [{} options])\n        kwd-klass (fork :clj Keyword :cljs 'cljs.core/Keyword)\n        attr (assoc attr\n                    :arity arity\n                    :name (:name attr `'~f))]\n    `(do\n       (defmulti ~f\n         ~docstring\n         {:arglists '~(arglists a b)}\n         v/argument-kind ~@options)\n       (defmethod ~f [~kwd-klass] [k#]\n         (~attr k#)))))\n\n(defmacro import-def\n  \"Given a regular def'd var from another namespace, defined a new var with the\n   same name in the current namespace.\n\n  This macro is modeled after `potemkin.namespaces/import-def` but meant to be\n  usable from Clojurescript. In Clojurescript, it's not possible to:\n\n  - alter the metadata of a var after definition\n  - call `resolve` at macro-time\n\n  And therefore not possible to mirror the metadata from one var to another.\n  This simplified version therefore suffices in the cljs case.\"\n  ([sym]\n   `(import-def ~sym nil))\n  ([sym var-name]\n   (let [n (or var-name (symbol (name sym)))]\n     `(def ~n ~sym))))\n\n(defmacro import-vars\n  \"import multiple defs from multiple namespaces. works for vars and fns. not\n  macros.\n\n  [[import-vars]] has the same syntax as `potemkin.namespaces/import-vars`:\n\n   ```clojure\n  (import-vars\n     [m.n.ns1 a b]\n     [x.y.ns2 d e f]) =>\n   (def a m.n.ns1/a)\n   (def b m.n.ns1/b)\n    ...\n   (def d m.n.ns2/d)\n    ... etc\n  ```\"\n  [& imports]\n  (let [expanded-imports (for [[from-ns & defs] imports\n                               d defs\n                               :let [sym (symbol (str from-ns)\n                                                 (str d))]]\n                           `(def ~d ~sym))]\n    `(do ~@expanded-imports)))\n\n(defn careful-def\n  \"Given some namespace `ns`, returns a function of some binding symbol and a form\n  to bind. The function returns either\n\n  - A form like `(def ~sym ~form)`, if `sym` is not currently bound into `ns`\n\n  - If `sym` is bound already, returns a form that emits a warning and then\n    uses `ns-unmap` and `intern` to reassign the binding.\n\n  In Clojure, this behavior matches redefinitions of symbols bound in\n  `clojure.core`. Symbols bound with `def` that are already imported from other\n  namespaces cause an exception, hence this more careful workaround.\n\n  (In Clojurescript, only forms like `(def ~sym ~form)` are emitted, since the\n  compiler does not currently error in case 2 and already handles emitting the\n  warning for us.)\"\n  [#?(:clj ns :cljs _)]\n  #?(:cljs\n     (fn [sym form]\n       `(def ~sym ~form))\n\n     :clj\n     (let [ns-sym (ns-name ns)\n           nsm (ns-map ns)\n           remote? (fn [sym]\n                     (when-let [v (nsm sym)]\n                       (not= ns (:ns (meta v)))))\n           warn (fn [sym]\n                  `(.println\n                    (RT/errPrintWriter)\n                    (str \"WARNING: \"\n                         '~sym\n                         \" already refers to: \"\n                         ~(nsm sym)\n                         \" in namespace: \"\n                         '~ns-sym\n                         \", being replaced by: \"\n                         ~(str \"#'\" ns-sym \"/\" sym))))]\n       (fn [sym form]\n         (if (remote? sym)\n           `(do\n              ~(warn sym)\n              (ns-unmap '~ns-sym '~sym)\n              (intern '~ns-sym '~sym ~form))\n           `(def ~sym ~form))))))\n"]}