{
"version":3,
"file":"module$node_modules$$sicmutils$glsl_parser$lib$index.js",
"lineCount":30,
"mappings":"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",
"sources":["node_modules/@sicmutils/glsl-parser/lib/index.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$sicmutils$glsl_parser$lib$index\"] = function(global,require,module,exports) {\nmodule.exports = parser;\n\nconst full_parse_expr = require(\"./expr\"),\n  Scope = require(\"./scope\");\n\n// singleton!\nconst Advance = new Object();\n\nconst DEBUG = false;\n\nlet _ = 0,\n  IDENT = _++,\n  STMT = _++,\n  STMTLIST = _++,\n  STRUCT = _++,\n  FUNCTION = _++,\n  FUNCTIONARGS = _++,\n  DECL = _++,\n  DECLLIST = _++,\n  FORLOOP = _++,\n  WHILELOOP = _++,\n  IF = _++,\n  EXPR = _++,\n  PRECISION = _++,\n  COMMENT = _++,\n  PREPROCESSOR = _++,\n  KEYWORD = _++,\n  KEYWORD_OR_IDENT = _++,\n  RETURN = _++,\n  BREAK = _++,\n  CONTINUE = _++,\n  DISCARD = _++,\n  DOWHILELOOP = _++,\n  PLACEHOLDER = _++,\n  QUANTIFIER = _++;\n\nconst DECL_ALLOW_ASSIGN = 0x1,\n  DECL_ALLOW_COMMA = 0x2,\n  DECL_REQUIRE_NAME = 0x4,\n  DECL_ALLOW_INVARIANT = 0x8,\n  DECL_ALLOW_STORAGE = 0x10,\n  DECL_NO_INOUT = 0x20,\n  DECL_ALLOW_STRUCT = 0x40,\n  DECL_STATEMENT = 0xff,\n  DECL_FUNCTION =\n    DECL_STATEMENT &\n    ~(\n      DECL_ALLOW_ASSIGN |\n      DECL_ALLOW_COMMA |\n      DECL_NO_INOUT |\n      DECL_ALLOW_INVARIANT |\n      DECL_REQUIRE_NAME\n    ),\n  DECL_STRUCT =\n    DECL_STATEMENT &\n    ~(\n      DECL_ALLOW_ASSIGN |\n      DECL_ALLOW_INVARIANT |\n      DECL_ALLOW_STORAGE |\n      DECL_ALLOW_STRUCT\n    );\n\nconst QUALIFIERS = [\"const\", \"attribute\", \"uniform\", \"varying\"];\n\nconst NO_ASSIGN_ALLOWED = false,\n  NO_COMMA_ALLOWED = false;\n\n// map of tokens to stmt types\nconst token_map = {\n  \"block-comment\": COMMENT,\n  \"line-comment\": COMMENT,\n  preprocessor: PREPROCESSOR,\n};\n\n// map of stmt types to human\nconst stmt_type = (_ = [\n  \"ident\",\n  \"stmt\",\n  \"stmtlist\",\n  \"struct\",\n  \"function\",\n  \"functionargs\",\n  \"decl\",\n  \"decllist\",\n  \"forloop\",\n  \"whileloop\",\n  \"if\",\n  \"expr\",\n  \"precision\",\n  \"comment\",\n  \"preprocessor\",\n  \"keyword\",\n  \"keyword_or_ident\",\n  \"return\",\n  \"break\",\n  \"continue\",\n  \"discard\",\n  \"do-while\",\n  \"placeholder\",\n  \"quantifier\",\n]);\n\nfunction parser() {\n  const stmtlist = n(STMTLIST),\n    stmt = n(STMT),\n    decllist = n(DECLLIST),\n    precision = n(PRECISION),\n    ident = n(IDENT),\n    keyword_or_ident = n(KEYWORD_OR_IDENT),\n    fn = n(FUNCTION),\n    fnargs = n(FUNCTIONARGS),\n    forstmt = n(FORLOOP),\n    ifstmt = n(IF),\n    whilestmt = n(WHILELOOP),\n    returnstmt = n(RETURN),\n    dowhilestmt = n(DOWHILELOOP),\n    quantifier = n(QUANTIFIER);\n\n  let parse_struct,\n    parse_precision,\n    parse_quantifier,\n    parse_forloop,\n    parse_if,\n    parse_return,\n    parse_whileloop,\n    parse_dowhileloop,\n    parse_function,\n    parse_function_args;\n\n  let check = arguments.length ? [].slice.call(arguments) : [],\n    complete = false,\n    ended = false,\n    depth = 0,\n    state = [],\n    nodes = [],\n    tokens = [],\n    whitespace = [],\n    errored = false,\n    program,\n    token,\n    node;\n\n  // setup state\n  state.shift = special_shift;\n  state.unshift = special_unshift;\n  state.fake = special_fake;\n  state.unexpected = unexpected;\n  state.scope = new Scope(state);\n  state.create_node = function () {\n    const n = mknode(IDENT, token);\n    n.parent = reader.program;\n    return n;\n  };\n\n  setup_stative_parsers();\n\n  // setup root node\n  node = stmtlist();\n  node.expecting = \"(eof)\";\n  node.mode = STMTLIST;\n  node.token = { type: \"(program)\", data: \"(program)\" };\n  program = node;\n\n  reader.program = program;\n  reader.scope = function (scope) {\n    if (arguments.length === 1) {\n      state.scope = scope;\n    }\n    return state.scope;\n  };\n\n  state.unshift(node);\n  return reader;\n\n  function reader(data) {\n    if (data === null) {\n      return end(), program;\n    }\n\n    nodes = [];\n    write(data);\n    return nodes;\n  }\n\n  // stream functions ---------------------------------------------\n\n  function write(input) {\n    if (\n      input.type === \"whitespace\" ||\n      input.type === \"line-comment\" ||\n      input.type === \"block-comment\"\n    ) {\n      whitespace.push(input);\n      return;\n    }\n    tokens.push(input);\n    token = token || tokens[0];\n\n    if (token && whitespace.length) {\n      token.preceding = token.preceding || [];\n      token.preceding = token.preceding.concat(whitespace);\n      whitespace = [];\n    }\n\n    while (take())\n      switch (state[0].mode) {\n        case STMT:\n          parse_stmt();\n          break;\n        case STMTLIST:\n          parse_stmtlist();\n          break;\n        case DECL:\n          parse_decl();\n          break;\n        case DECLLIST:\n          parse_decllist();\n          break;\n        case EXPR:\n          parse_expr();\n          break;\n        case STRUCT:\n          parse_struct(true, true);\n          break;\n        case PRECISION:\n          parse_precision();\n          break;\n        case IDENT:\n          parse_ident();\n          break;\n        case KEYWORD:\n          parse_keyword();\n          break;\n        case KEYWORD_OR_IDENT:\n          parse_keyword_or_ident();\n          break;\n        case FUNCTION:\n          parse_function();\n          break;\n        case FUNCTIONARGS:\n          parse_function_args();\n          break;\n        case FORLOOP:\n          parse_forloop();\n          break;\n        case WHILELOOP:\n          parse_whileloop();\n          break;\n        case DOWHILELOOP:\n          parse_dowhileloop();\n          break;\n        case RETURN:\n          parse_return();\n          break;\n        case IF:\n          parse_if();\n          break;\n        case QUANTIFIER:\n          parse_quantifier();\n          break;\n      }\n  }\n\n  function end(tokens) {\n    if (arguments.length) {\n      write(tokens);\n    }\n\n    if (state.length > 1) {\n      unexpected(\"unexpected EOF\");\n      return;\n    }\n\n    complete = true;\n  }\n\n  function take() {\n    if (errored || !state.length) return false;\n\n    return (token = tokens[0]);\n  }\n\n  // ----- state manipulation --------\n\n  function special_fake(x) {\n    state.unshift(x);\n    state.shift();\n  }\n\n  function special_unshift(_node, add_child) {\n    _node.parent = state[0];\n\n    const ret = [].unshift.call(this, _node);\n\n    add_child = add_child === undefined ? true : add_child;\n\n    if (DEBUG) {\n      let pad = \"\";\n      for (let i = 0, len = this.length - 1; i < len; ++i) {\n        pad += \" |\";\n      }\n      console.log(pad, \"\\\\\" + _node.type, _node.token.data);\n    }\n\n    if (add_child && node !== _node) node.children.push(_node);\n    node = _node;\n\n    return ret;\n  }\n\n  function special_shift() {\n    let _node = [].shift.call(this),\n      okay = check[this.length],\n      emit = false;\n\n    if (DEBUG) {\n      let pad = \"\";\n      for (let i = 0, len = this.length; i < len; ++i) {\n        pad += \" |\";\n      }\n      console.log(pad, \"/\" + _node.type);\n    }\n\n    if (check.length) {\n      if (typeof check[0] === \"function\") {\n        emit = check[0](_node);\n      } else if (okay !== undefined) {\n        emit = okay.test ? okay.test(_node.type) : okay === _node.type;\n      }\n    } else {\n      emit = true;\n    }\n\n    if (emit && !errored) nodes.push(_node);\n\n    node = _node.parent;\n    return _node;\n  }\n\n  // parse states ---------------\n\n  function parse_stmtlist() {\n    // determine the type of the statement\n    // and then start parsing\n    return stative(function () {\n      state.scope.enter();\n      return Advance;\n    }, normal_mode)();\n\n    function normal_mode() {\n      if (token.data === state[0].expecting) {\n        return state.scope.exit(), state.shift();\n      }\n      switch (token.type) {\n        case \"preprocessor\":\n          state.fake(adhoc());\n          tokens.shift();\n          return;\n        default:\n          state.unshift(stmt());\n          return;\n      }\n    }\n  }\n\n  function parse_stmt() {\n    if (state[0].brace) {\n      if (token.data !== \"}\") {\n        return unexpected(\"expected `}`, got \" + token.data);\n      }\n      state[0].brace = false;\n      return tokens.shift(), state.shift();\n    }\n    switch (token.type) {\n      case \"eof\":\n        return got_eof();\n      case \"keyword\":\n        switch (token.data) {\n          case \"for\":\n            return state.unshift(forstmt());\n          case \"if\":\n            return state.unshift(ifstmt());\n          case \"while\":\n            return state.unshift(whilestmt());\n          case \"do\":\n            return state.unshift(dowhilestmt());\n          case \"break\":\n            return state.fake(mknode(BREAK, token)), tokens.shift();\n          case \"continue\":\n            return state.fake(mknode(CONTINUE, token)), tokens.shift();\n          case \"discard\":\n            return state.fake(mknode(DISCARD, token)), tokens.shift();\n          case \"return\":\n            return state.unshift(returnstmt());\n          case \"precision\":\n            return state.unshift(precision());\n        }\n        return state.unshift(decl(DECL_STATEMENT));\n      case \"ident\":\n        var lookup;\n        if ((lookup = state.scope.find(token.data))) {\n          if (lookup.parent.type === \"struct\") {\n            // this is strictly untrue, you could have an\n            // expr that starts with a struct constructor.\n            //      ... sigh\n            return state.unshift(decl(DECL_STATEMENT));\n          }\n          return state.unshift(expr(\";\"));\n        }\n      case \"operator\":\n        if (token.data === \"{\") {\n          state[0].brace = true;\n          const n = stmtlist();\n          n.expecting = \"}\";\n          return tokens.shift(), state.unshift(n);\n        }\n        if (token.data === \";\") {\n          return tokens.shift(), state.shift();\n        }\n      default:\n        return state.unshift(expr(\";\"));\n    }\n  }\n\n  function got_eof() {\n    if (ended) errored = true;\n    ended = true;\n    return state.shift();\n  }\n\n  function parse_decl() {\n    const stmt = state[0];\n\n    return stative(\n      invariant_or_not,\n      storage_or_not,\n      parameter_or_not,\n      precision_or_not,\n      struct_or_type,\n      maybe_name,\n      maybe_lparen, // lparen means we're a function\n      is_decllist,\n      done\n    )();\n\n    function invariant_or_not() {\n      if (token.data === \"invariant\") {\n        if (stmt.flags & DECL_ALLOW_INVARIANT) {\n          state.unshift(keyword());\n          return Advance;\n        } else {\n          return unexpected(\"`invariant` is not allowed here\");\n        }\n      } else {\n        state.fake(mknode(PLACEHOLDER, { data: \"\", position: token.position }));\n        return Advance;\n      }\n    }\n\n    function storage_or_not() {\n      if (is_storage(token)) {\n        if (stmt.flags & DECL_ALLOW_STORAGE) {\n          state.unshift(keyword());\n          return Advance;\n        } else {\n          return unexpected(\"storage is not allowed here\");\n        }\n      } else {\n        state.fake(mknode(PLACEHOLDER, { data: \"\", position: token.position }));\n        return Advance;\n      }\n    }\n\n    function parameter_or_not() {\n      if (is_parameter(token)) {\n        if (!(stmt.flags & DECL_NO_INOUT)) {\n          state.unshift(keyword());\n          return Advance;\n        } else {\n          return unexpected(\"parameter is not allowed here\");\n        }\n      } else {\n        state.fake(mknode(PLACEHOLDER, { data: \"\", position: token.position }));\n        return Advance;\n      }\n    }\n\n    function precision_or_not() {\n      if (is_precision(token)) {\n        state.unshift(keyword());\n        return Advance;\n      } else {\n        state.fake(mknode(PLACEHOLDER, { data: \"\", position: token.position }));\n        return Advance;\n      }\n    }\n\n    function struct_or_type() {\n      if (token.data === \"struct\") {\n        if (!(stmt.flags & DECL_ALLOW_STRUCT)) {\n          return unexpected(\"cannot nest structs\");\n        }\n        state.unshift(struct());\n        return Advance;\n      }\n\n      if (token.type === \"keyword\") {\n        state.unshift(keyword());\n        return Advance;\n      }\n\n      const lookup = state.scope.find(token.data);\n\n      if (lookup) {\n        state.fake(Object.create(lookup));\n        tokens.shift();\n        return Advance;\n      }\n      return unexpected(\n        \"expected user defined type, struct or keyword, got \" + token.data\n      );\n    }\n\n    function maybe_name() {\n      if (token.data === \",\" && !(stmt.flags & DECL_ALLOW_COMMA)) {\n        return state.shift();\n      }\n\n      if (token.data === \"[\") {\n        // oh lord.\n        state.unshift(quantifier());\n        return;\n      }\n\n      if (token.data === \")\") return state.shift();\n\n      if (token.data === \";\") {\n        return stmt.stage + 3;\n      }\n\n      if (token.type !== \"ident\" && token.type !== \"builtin\") {\n        return unexpected(\"expected identifier, got \" + token.data);\n      }\n\n      stmt.collected_name = tokens.shift();\n      return Advance;\n    }\n\n    function maybe_lparen() {\n      if (token.data === \"(\") {\n        tokens.unshift(stmt.collected_name);\n        delete stmt.collected_name;\n        state.unshift(fn());\n        return stmt.stage + 2;\n      }\n      return Advance;\n    }\n\n    function is_decllist() {\n      tokens.unshift(stmt.collected_name);\n      delete stmt.collected_name;\n      state.unshift(decllist());\n      return Advance;\n    }\n\n    function done() {\n      return state.shift();\n    }\n  }\n\n  function parse_decllist() {\n    // grab ident\n\n    if (token.type === \"ident\" || token.type === \"builtin\") {\n      const name = token.data;\n      state.unshift(ident());\n      state.scope.define(name);\n      return;\n    }\n\n    if (token.type === \"operator\") {\n      if (token.data === \",\") {\n        // multi-decl!\n        if (!(state[1].flags & DECL_ALLOW_COMMA)) {\n          return state.shift();\n        }\n\n        return tokens.shift();\n      } else if (token.data === \"=\") {\n        if (!(state[1].flags & DECL_ALLOW_ASSIGN))\n          return unexpected(\"`=` is not allowed here.\");\n\n        tokens.shift();\n\n        state.unshift(expr(\",\", \";\"));\n        return;\n      } else if (token.data === \"[\") {\n        state.unshift(quantifier());\n        return;\n      }\n    }\n    return state.shift();\n  }\n\n  function parse_keyword_or_ident() {\n    if (token.type === \"keyword\") {\n      state[0].type = \"keyword\";\n      state[0].mode = KEYWORD;\n      return;\n    }\n\n    if (token.type === \"ident\") {\n      state[0].type = \"ident\";\n      state[0].mode = IDENT;\n      return;\n    }\n\n    return unexpected(\n      \"expected keyword or user-defined name, got \" + token.data\n    );\n  }\n\n  function parse_keyword() {\n    if (token.type !== \"keyword\") {\n      return unexpected(\"expected keyword, got \" + token.data);\n    }\n\n    return state.shift(), tokens.shift();\n  }\n\n  function parse_ident() {\n    if (token.type !== \"ident\" && token.type !== \"builtin\") {\n      return unexpected(\"expected user-defined name, got \" + token.data);\n    }\n\n    state[0].data = token.data;\n    return state.shift(), tokens.shift();\n  }\n\n  function parse_expr() {\n    const expecting = state[0].expecting;\n\n    state[0].tokens = state[0].tokens || [];\n\n    if (state[0].parenlevel === undefined) {\n      state[0].parenlevel = 0;\n      state[0].bracelevel = 0;\n    }\n    if (state[0].parenlevel < 1 && expecting.indexOf(token.data) > -1) {\n      return parseexpr(state[0].tokens);\n    }\n    if (token.data === \"(\") {\n      ++state[0].parenlevel;\n    } else if (token.data === \")\") {\n      --state[0].parenlevel;\n    }\n\n    switch (token.data) {\n      case \"{\":\n        ++state[0].bracelevel;\n        break;\n      case \"}\":\n        --state[0].bracelevel;\n        break;\n      case \"(\":\n        ++state[0].parenlevel;\n        break;\n      case \")\":\n        --state[0].parenlevel;\n        break;\n    }\n\n    if (state[0].parenlevel < 0) return unexpected(\"unexpected `)`\");\n    if (state[0].bracelevel < 0) return unexpected(\"unexpected `}`\");\n\n    state[0].tokens.push(tokens.shift());\n    return;\n\n    function parseexpr(tokens) {\n      try {\n        full_parse_expr(state, tokens);\n      } catch (err) {\n        errored = true;\n        throw err;\n      }\n\n      return state.shift();\n    }\n  }\n\n  // node types ---------------\n\n  function n(type) {\n    // this is a function factory that suffices for most kinds of expressions and statements\n    return function () {\n      return mknode(type, token);\n    };\n  }\n\n  function adhoc() {\n    return mknode(token_map[token.type], token, node);\n  }\n\n  function decl(flags) {\n    const _ = mknode(DECL, token, node);\n    _.flags = flags;\n\n    return _;\n  }\n\n  function struct(allow_assign, allow_comma) {\n    const _ = mknode(STRUCT, token, node);\n    _.allow_assign = allow_assign === undefined ? true : allow_assign;\n    _.allow_comma = allow_comma === undefined ? true : allow_comma;\n    return _;\n  }\n\n  function expr() {\n    const n = mknode(EXPR, token, node);\n\n    n.expecting = [].slice.call(arguments);\n    return n;\n  }\n\n  function keyword(default_value) {\n    let t = token;\n    if (default_value) {\n      t = { type: \"(implied)\", data: \"(default)\", position: t.position };\n    }\n    return mknode(KEYWORD, t, node);\n  }\n\n  // utils ----------------------------\n\n  function unexpected(str) {\n    errored = true;\n    throw new Error(\n      (str || \"unexpected \" + state) + \" at line \" + state[0].token.line\n    );\n  }\n\n  function assert(type, data) {\n    return (\n      1,\n      assert_null_string_or_array(type, token.type) &&\n        assert_null_string_or_array(data, token.data)\n    );\n  }\n\n  function assert_null_string_or_array(x, y) {\n    switch (typeof x) {\n      case \"string\":\n        if (y !== x) {\n          unexpected(\"expected `\" + x + \"`, got \" + y + \"\\n\" + token.data);\n        }\n        return !errored;\n\n      case \"object\":\n        if (x && x.indexOf(y) === -1) {\n          unexpected(\"expected one of `\" + x.join(\"`, `\") + \"`, got \" + y);\n        }\n        return !errored;\n    }\n    return true;\n  }\n\n  // stative ----------------------------\n\n  function stative() {\n    let steps = [].slice.call(arguments),\n      step,\n      result;\n\n    return function () {\n      const current = state[0];\n\n      current.stage || (current.stage = 0);\n\n      step = steps[current.stage];\n      if (!step) return unexpected(\"parser in undefined state!\");\n\n      result = step();\n\n      if (result === Advance) return ++current.stage;\n      if (result === undefined) return;\n      current.stage = result;\n    };\n  }\n\n  function advance(op, t) {\n    t = t || \"operator\";\n    return function () {\n      if (!assert(t, op)) return;\n\n      const last = tokens.shift(),\n        children = state[0].children,\n        last_node = children[children.length - 1];\n\n      if (last_node && last_node.token && last.preceding) {\n        last_node.token.succeeding = last_node.token.succeeding || [];\n        last_node.token.succeeding = last_node.token.succeeding.concat(\n          last.preceding\n        );\n      }\n      return Advance;\n    };\n  }\n\n  function advance_expr(until) {\n    return function () {\n      state.unshift(expr(until));\n      return Advance;\n    };\n  }\n\n  function advance_ident(declare) {\n    return declare\n      ? function () {\n          const name = token.data;\n          return (\n            assert(\"ident\") &&\n            (state.unshift(ident()), state.scope.define(name), Advance)\n          );\n        }\n      : function () {\n          if (!assert(\"ident\")) return;\n\n          const s = Object.create(state.scope.find(token.data));\n          s.token = token;\n\n          return tokens.shift(), Advance;\n        };\n  }\n\n  function advance_stmtlist() {\n    return function () {\n      const n = stmtlist();\n      n.expecting = \"}\";\n      return state.unshift(n), Advance;\n    };\n  }\n\n  function maybe_stmtlist(skip) {\n    return function () {\n      const current = state[0].stage;\n      if (token.data !== \"{\") {\n        return state.unshift(stmt()), current + skip;\n      }\n      return tokens.shift(), Advance;\n    };\n  }\n\n  function popstmt() {\n    return function () {\n      return state.shift(), state.shift();\n    };\n  }\n\n  function setup_stative_parsers() {\n    // could also be\n    // struct { } decllist\n    parse_struct = stative(\n      advance(\"struct\", \"keyword\"),\n      function () {\n        if (token.data === \"{\") {\n          state.fake(\n            mknode(IDENT, { data: \"\", position: token.position, type: \"ident\" })\n          );\n          return Advance;\n        }\n\n        return advance_ident(true)();\n      },\n      function () {\n        state.scope.enter();\n        return Advance;\n      },\n      advance(\"{\"),\n      function () {\n        if (token.type === \"preprocessor\") {\n          state.fake(adhoc());\n          tokens.shift();\n          return;\n        }\n        if (token.data === \"}\") {\n          state.scope.exit();\n          tokens.shift();\n          return state.shift();\n        }\n        if (token.data === \";\") {\n          tokens.shift();\n          return;\n        }\n        state.unshift(decl(DECL_STRUCT));\n      }\n    );\n\n    parse_precision = stative(\n      function () {\n        return tokens.shift(), Advance;\n      },\n      function () {\n        return (\n          assert(\"keyword\", [\"lowp\", \"mediump\", \"highp\"]) &&\n          (state.unshift(keyword()), Advance)\n        );\n      },\n      function () {\n        return state.unshift(keyword()), Advance;\n      },\n      function () {\n        return state.shift();\n      }\n    );\n\n    parse_quantifier = stative(\n      advance(\"[\"),\n      advance_expr(\"]\"),\n      advance(\"]\"),\n      function () {\n        return state.shift();\n      }\n    );\n\n    parse_forloop = stative(\n      advance(\"for\", \"keyword\"),\n      advance(\"(\"),\n      function () {\n        let lookup;\n        if (token.type === \"ident\") {\n          if (!(lookup = state.scope.find(token.data))) {\n            lookup = state.create_node();\n          }\n\n          if (lookup.parent.type === \"struct\") {\n            return state.unshift(decl(DECL_STATEMENT)), Advance;\n          }\n        } else if (token.type === \"builtin\" || token.type === \"keyword\") {\n          return state.unshift(decl(DECL_STATEMENT)), Advance;\n        }\n        return advance_expr(\";\")();\n      },\n      advance(\";\"),\n      advance_expr(\";\"),\n      advance(\";\"),\n      advance_expr(\")\"),\n      advance(\")\"),\n      maybe_stmtlist(3),\n      advance_stmtlist(),\n      advance(\"}\"),\n      popstmt()\n    );\n\n    parse_if = stative(\n      advance(\"if\", \"keyword\"),\n      advance(\"(\"),\n      advance_expr(\")\"),\n      advance(\")\"),\n      maybe_stmtlist(3),\n      advance_stmtlist(),\n      advance(\"}\"),\n      function () {\n        if (token.data === \"else\") {\n          return tokens.shift(), state.unshift(stmt()), Advance;\n        }\n        return popstmt()();\n      },\n      popstmt()\n    );\n\n    parse_return = stative(\n      advance(\"return\", \"keyword\"),\n      function () {\n        if (token.data === \";\") return Advance;\n        return state.unshift(expr(\";\")), Advance;\n      },\n      function () {\n        tokens.shift(), popstmt()();\n      }\n    );\n\n    parse_whileloop = stative(\n      advance(\"while\", \"keyword\"),\n      advance(\"(\"),\n      advance_expr(\")\"),\n      advance(\")\"),\n      maybe_stmtlist(3),\n      advance_stmtlist(),\n      advance(\"}\"),\n      popstmt()\n    );\n\n    parse_dowhileloop = stative(\n      advance(\"do\", \"keyword\"),\n      maybe_stmtlist(3),\n      advance_stmtlist(),\n      advance(\"}\"),\n      advance(\"while\", \"keyword\"),\n      advance(\"(\"),\n      advance_expr(\")\"),\n      advance(\")\"),\n      popstmt()\n    );\n\n    parse_function = stative(\n      function () {\n        for (let i = 1, len = state.length; i < len; ++i)\n          if (state[i].mode === FUNCTION) {\n            return unexpected(\n              \"function definition is not allowed within another function\"\n            );\n          }\n\n        return Advance;\n      },\n      function () {\n        if (!assert(\"ident\")) return;\n\n        const name = token.data,\n          lookup = state.scope.find(name);\n\n        state.unshift(ident());\n        state.scope.define(name);\n\n        state.scope.enter(lookup ? lookup.scope : null);\n        return Advance;\n      },\n      advance(\"(\"),\n      function () {\n        return state.unshift(fnargs()), Advance;\n      },\n      advance(\")\"),\n      function () {\n        // forward decl\n        if (token.data === \";\") {\n          return state.scope.exit(), state.shift(), state.shift();\n        }\n        return Advance;\n      },\n      advance(\"{\"),\n      advance_stmtlist(),\n      advance(\"}\"),\n      function () {\n        state.scope.exit();\n        return Advance;\n      },\n      function () {\n        return state.shift(), state.shift(), state.shift();\n      }\n    );\n\n    parse_function_args = stative(\n      function () {\n        if (token.data === \"void\") {\n          state.fake(keyword());\n          tokens.shift();\n          return Advance;\n        }\n        if (token.data === \")\") {\n          state.shift();\n          return;\n        }\n        if (token.data === \"struct\") {\n          state.unshift(struct(NO_ASSIGN_ALLOWED, NO_COMMA_ALLOWED));\n          return Advance;\n        }\n        state.unshift(decl(DECL_FUNCTION));\n        return Advance;\n      },\n      function () {\n        if (token.data === \",\") {\n          tokens.shift();\n          return 0;\n        }\n        if (token.data === \")\") {\n          state.shift();\n          return;\n        }\n        unexpected(\"expected one of `,` or `)`, got \" + token.data);\n      }\n    );\n  }\n}\n\nfunction mknode(mode, sourcetoken) {\n  return {\n    mode: mode,\n    token: sourcetoken,\n    children: [],\n    type: stmt_type[mode],\n    id: (Math.random() * 0xffffffff).toString(16),\n  };\n}\n\nfunction is_storage(token) {\n  return (\n    token.data === \"const\" ||\n    token.data === \"attribute\" ||\n    token.data === \"uniform\" ||\n    token.data === \"varying\"\n  );\n}\n\nfunction is_parameter(token) {\n  return token.data === \"in\" || token.data === \"inout\" || token.data === \"out\";\n}\n\nfunction is_precision(token) {\n  return (\n    token.data === \"highp\" || token.data === \"mediump\" || token.data === \"lowp\"\n  );\n}\n\n};"],
"names":["shadow$provide","global","require","module","exports","mknode","mode","sourcetoken","token","children","type","stmt_type","id","toString","Math","random","parser","reader","data","end","program","nodes","write","input","whitespace","push","tokens","length","preceding","concat","errored","state","STMT","parse_stmt","STMTLIST","parse_stmtlist","DECL","parse_decl","DECLLIST","parse_decllist","EXPR","parse_expr","STRUCT","parse_struct","PRECISION","parse_precision","IDENT","unexpected","shift","KEYWORD","KEYWORD_OR_IDENT","FUNCTION","parse_function","FUNCTIONARGS","parse_function_args","FORLOOP","parse_forloop","WHILELOOP","parse_whileloop","DOWHILELOOP","parse_dowhileloop","RETURN","parse_return","IF","parse_if","QUANTIFIER","parse_quantifier","arguments","stative","scope","enter","Advance","normal_mode","expecting","exit","fake","token_map","node","unshift","stmt","brace","ended","forstmt","ifstmt","whilestmt","dowhilestmt","BREAK","CONTINUE","DISCARD","returnstmt","precision","decl","DECL_STATEMENT","lookup","find","parent","expr","n","stmtlist","invariant_or_not","flags","DECL_ALLOW_INVARIANT","keyword","PLACEHOLDER","position","storage_or_not","DECL_ALLOW_STORAGE","parameter_or_not","DECL_NO_INOUT","precision_or_not","struct_or_type","DECL_ALLOW_STRUCT","struct","Object","create","maybe_name","DECL_ALLOW_COMMA","quantifier","stage","collected_name","maybe_lparen","fn","is_decllist","decllist","done","name","ident","define","DECL_ALLOW_ASSIGN","undefined","parenlevel","bracelevel","indexOf","full_parse_expr","err","_","allow_assign","allow_comma","slice","call","default_value","t","str","Error","line","assert","assert_null_string_or_array","x","y","join","steps","step","result","current","advance","op","last","last_node","succeeding","advance_expr","until","advance_ident","declare","s","advance_stmtlist","maybe_stmtlist","skip","popstmt","fnargs","check","special_shift","_node","okay","emit","test","special_unshift","add_child","ret","special_fake","Scope","create_node","state.create_node","setup_stative_parsers","DECL_STRUCT","i","len","NO_ASSIGN_ALLOWED","NO_COMMA_ALLOWED","DECL_FUNCTION","reader.scope","COMMENT","PREPROCESSOR","preprocessor"]
}
