shadow$provide.module$node_modules$three$src$core$BufferGeometry=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.BufferGeometry=void 0;var _Vector=require("module$node_modules$three$src$math$Vector3"),
_Vector2=require("module$node_modules$three$src$math$Vector2"),_Box=require("module$node_modules$three$src$math$Box3");global=require("module$node_modules$three$src$core$EventDispatcher");var _BufferAttribute=require("module$node_modules$three$src$core$BufferAttribute"),_Sphere=require("module$node_modules$three$src$math$Sphere");module=require("module$node_modules$three$src$core$Object3D");var _Matrix=require("module$node_modules$three$src$math$Matrix4"),_Matrix2=require("module$node_modules$three$src$math$Matrix3"),
MathUtils=function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,
key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$three$src$math$MathUtils")),_utils=require("module$node_modules$three$src$utils");let _id=0;const _m1=new _Matrix.Matrix4,_obj=new module.Object3D,_offset=new _Vector.Vector3,_box=new _Box.Box3,_boxMorphTargets=new _Box.Box3,_vector=new _Vector.Vector3;class BufferGeometry extends global.EventDispatcher{constructor(){super();
Object.defineProperty(this,"id",{value:_id++});this.uuid=MathUtils.generateUUID();this.name="";this.type="BufferGeometry";this.index=null;this.attributes={};this.morphAttributes={};this.morphTargetsRelative=!1;this.groups=[];this.boundingSphere=this.boundingBox=null;this.drawRange={start:0,count:Infinity};this.userData={}}getIndex(){return this.index}setIndex(index){Array.isArray(index)?this.index=new ((0,_utils.arrayNeedsUint32)(index)?_BufferAttribute.Uint32BufferAttribute:_BufferAttribute.Uint16BufferAttribute)(index,
1):this.index=index;return this}getAttribute(name){return this.attributes[name]}setAttribute(name,attribute){this.attributes[name]=attribute;return this}deleteAttribute(name){delete this.attributes[name];return this}hasAttribute(name){return void 0!==this.attributes[name]}addGroup(start,count,materialIndex=0){this.groups.push({start,count,materialIndex})}clearGroups(){this.groups=[]}setDrawRange(start,count){this.drawRange.start=start;this.drawRange.count=count}applyMatrix4(matrix){var position=this.attributes.position;
void 0!==position&&(position.applyMatrix4(matrix),position.needsUpdate=!0);position=this.attributes.normal;if(void 0!==position){const normalMatrix=(new _Matrix2.Matrix3).getNormalMatrix(matrix);position.applyNormalMatrix(normalMatrix);position.needsUpdate=!0}position=this.attributes.tangent;void 0!==position&&(position.transformDirection(matrix),position.needsUpdate=!0);null!==this.boundingBox&&this.computeBoundingBox();null!==this.boundingSphere&&this.computeBoundingSphere();return this}applyQuaternion(q){_m1.makeRotationFromQuaternion(q);
this.applyMatrix4(_m1);return this}rotateX(angle){_m1.makeRotationX(angle);this.applyMatrix4(_m1);return this}rotateY(angle){_m1.makeRotationY(angle);this.applyMatrix4(_m1);return this}rotateZ(angle){_m1.makeRotationZ(angle);this.applyMatrix4(_m1);return this}translate(x,y,z){_m1.makeTranslation(x,y,z);this.applyMatrix4(_m1);return this}scale(x,y,z){_m1.makeScale(x,y,z);this.applyMatrix4(_m1);return this}lookAt(vector){_obj.lookAt(vector);_obj.updateMatrix();this.applyMatrix4(_obj.matrix);return this}center(){this.computeBoundingBox();
this.boundingBox.getCenter(_offset).negate();this.translate(_offset.x,_offset.y,_offset.z);return this}setFromPoints(points){const position=[];for(let i=0,l=points.length;i<l;i++){const point=points[i];position.push(point.x,point.y,point.z||0)}this.setAttribute("position",new _BufferAttribute.Float32BufferAttribute(position,3));return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new _Box.Box3);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;
if(position&&position.isGLBufferAttribute)console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingBox.set(new _Vector.Vector3(-Infinity,-Infinity,-Infinity),new _Vector.Vector3(Infinity,Infinity,Infinity));else{if(void 0!==position){if(this.boundingBox.setFromBufferAttribute(position),morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++)_box.setFromBufferAttribute(morphAttributesPosition[i]),
this.morphTargetsRelative?(_vector.addVectors(this.boundingBox.min,_box.min),this.boundingBox.expandByPoint(_vector),_vector.addVectors(this.boundingBox.max,_box.max),this.boundingBox.expandByPoint(_vector)):(this.boundingBox.expandByPoint(_box.min),this.boundingBox.expandByPoint(_box.max))}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
this)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new _Sphere.Sphere);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute)console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',this),this.boundingSphere.set(new _Vector.Vector3,Infinity);else if(position){const center=this.boundingSphere.center;
_box.setFromBufferAttribute(position);if(morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++)_boxMorphTargets.setFromBufferAttribute(morphAttributesPosition[i]),this.morphTargetsRelative?(_vector.addVectors(_box.min,_boxMorphTargets.min),_box.expandByPoint(_vector),_vector.addVectors(_box.max,_boxMorphTargets.max),_box.expandByPoint(_vector)):(_box.expandByPoint(_boxMorphTargets.min),_box.expandByPoint(_boxMorphTargets.max));_box.getCenter(center);let maxRadiusSq=0;for(let i=
0,il=position.count;i<il;i++)_vector.fromBufferAttribute(position,i),maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector));if(morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i],morphTargetsRelative=this.morphTargetsRelative;for(let j=0,jl=morphAttribute.count;j<jl;j++)_vector.fromBufferAttribute(morphAttribute,j),morphTargetsRelative&&(_offset.fromBufferAttribute(position,j),_vector.add(_offset)),maxRadiusSq=
Math.max(maxRadiusSq,center.distanceToSquared(_vector))}this.boundingSphere.radius=Math.sqrt(maxRadiusSq);isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){function handleTriangle(a,b,c){vA.fromArray(positions,3*a);vB.fromArray(positions,3*b);vC.fromArray(positions,3*c);uvA.fromArray(uvs,2*a);uvB.fromArray(uvs,2*b);uvC.fromArray(uvs,2*c);vB.sub(vA);
vC.sub(vA);uvB.sub(uvA);uvC.sub(uvA);const r=1/(uvB.x*uvC.y-uvC.x*uvB.y);isFinite(r)&&(sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r),tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r),tan1[a].add(sdir),tan1[b].add(sdir),tan1[c].add(sdir),tan2[a].add(tdir),tan2[b].add(tdir),tan2[c].add(tdir))}function handleVertex(v){n.fromArray(normals,3*v);n2.copy(n);var t=tan1[v];tmp.copy(t);tmp.sub(n.multiplyScalar(n.dot(t))).normalize();tmp2.crossVectors(n2,
t);t=tmp2.dot(tan2[v]);tangents[4*v]=tmp.x;tangents[4*v+1]=tmp.y;tangents[4*v+2]=tmp.z;tangents[4*v+3]=0>t?-1:1}var index=this.index,attributes=this.attributes;if(null===index||void 0===attributes.position||void 0===attributes.normal||void 0===attributes.uv)console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");else{index=index.array;var positions=attributes.position.array,normals=attributes.normal.array,uvs=attributes.uv.array,
nVertices=positions.length/3;void 0===attributes.tangent&&this.setAttribute("tangent",new _BufferAttribute.BufferAttribute(new Float32Array(4*nVertices),4));var tangents=attributes.tangent.array,tan1=[],tan2=[];for(attributes=0;attributes<nVertices;attributes++)tan1[attributes]=new _Vector.Vector3,tan2[attributes]=new _Vector.Vector3;var vA=new _Vector.Vector3,vB=new _Vector.Vector3,vC=new _Vector.Vector3,uvA=new _Vector2.Vector2,uvB=new _Vector2.Vector2,uvC=new _Vector2.Vector2,sdir=new _Vector.Vector3,
tdir=new _Vector.Vector3;attributes=this.groups;0===attributes.length&&(attributes=[{start:0,count:index.length}]);for(let i=0,il=attributes.length;i<il;++i){var group=attributes[i];nVertices=group.start;group=group.count;for(let j=nVertices,jl=nVertices+group;j<jl;j+=3)handleTriangle(index[j+0],index[j+1],index[j+2])}var tmp=new _Vector.Vector3,tmp2=new _Vector.Vector3,n=new _Vector.Vector3,n2=new _Vector.Vector3;for(let i=0,il=attributes.length;i<il;++i){group=attributes[i];nVertices=group.start;
group=group.count;for(let j=nVertices,jl=nVertices+group;j<jl;j+=3)handleVertex(index[j+0]),handleVertex(index[j+1]),handleVertex(index[j+2])}}}computeVertexNormals(){const index=this.index,positionAttribute=this.getAttribute("position");if(void 0!==positionAttribute){let normalAttribute=this.getAttribute("normal");if(void 0===normalAttribute)normalAttribute=new _BufferAttribute.BufferAttribute(new Float32Array(3*positionAttribute.count),3),this.setAttribute("normal",normalAttribute);else for(let i=
0,il=normalAttribute.count;i<il;i++)normalAttribute.setXYZ(i,0,0,0);const pA=new _Vector.Vector3,pB=new _Vector.Vector3,pC=new _Vector.Vector3,nA=new _Vector.Vector3,nB=new _Vector.Vector3,nC=new _Vector.Vector3,cb=new _Vector.Vector3,ab=new _Vector.Vector3;if(index)for(let i=0,il=index.count;i<il;i+=3){const vA=index.getX(i+0),vB=index.getX(i+1),vC=index.getX(i+2);pA.fromBufferAttribute(positionAttribute,vA);pB.fromBufferAttribute(positionAttribute,vB);pC.fromBufferAttribute(positionAttribute,vC);
cb.subVectors(pC,pB);ab.subVectors(pA,pB);cb.cross(ab);nA.fromBufferAttribute(normalAttribute,vA);nB.fromBufferAttribute(normalAttribute,vB);nC.fromBufferAttribute(normalAttribute,vC);nA.add(cb);nB.add(cb);nC.add(cb);normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z);normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z);normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z)}else for(let i=0,il=positionAttribute.count;i<il;i+=3)pA.fromBufferAttribute(positionAttribute,i+0),pB.fromBufferAttribute(positionAttribute,i+1),pC.fromBufferAttribute(positionAttribute,
i+2),cb.subVectors(pC,pB),ab.subVectors(pA,pB),cb.cross(ab),normalAttribute.setXYZ(i+0,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i+1,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i+2,cb.x,cb.y,cb.z);this.normalizeNormals();normalAttribute.needsUpdate=!0}}merge(geometry,offset){if(geometry&&geometry.isBufferGeometry){void 0===offset&&(offset=0,console.warn("THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset\x3d0. Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge."));
var attributes=this.attributes;for(const key in attributes){if(void 0===geometry.attributes[key])continue;const attributeArray1=attributes[key].array;var attribute2=geometry.attributes[key];const attributeArray2=attribute2.array;attribute2=attribute2.itemSize*offset;const length=Math.min(attributeArray2.length,attributeArray1.length-attribute2);for(let i=0,j=attribute2;i<length;i++,j++)attributeArray1[j]=attributeArray2[i]}return this}console.error("THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.",
geometry)}normalizeNormals(){const normals=this.attributes.normal;for(let i=0,il=normals.count;i<il;i++)_vector.fromBufferAttribute(normals,i),_vector.normalize(),normals.setXYZ(i,_vector.x,_vector.y,_vector.z)}toNonIndexed(){function convertBufferAttribute(attribute,indices){const array=attribute.array,itemSize=attribute.itemSize,normalized=attribute.normalized,array2=new array.constructor(indices.length*itemSize);let index,index2=0;for(let i=0,l=indices.length;i<l;i++){index=attribute.isInterleavedBufferAttribute?
indices[i]*attribute.data.stride+attribute.offset:indices[i]*itemSize;for(let j=0;j<itemSize;j++)array2[index2++]=array[index++]}return new _BufferAttribute.BufferAttribute(array2,itemSize,normalized)}if(null===this.index)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const geometry2=new BufferGeometry;var indices$jscomp$0=this.index.array,attributes=this.attributes;for(var name in attributes){var newAttribute$jscomp$0=convertBufferAttribute(attributes[name],
indices$jscomp$0);geometry2.setAttribute(name,newAttribute$jscomp$0)}attributes=this.morphAttributes;for(var name$jscomp$0 in attributes){name=[];newAttribute$jscomp$0=attributes[name$jscomp$0];for(let i=0,il=newAttribute$jscomp$0.length;i<il;i++){const newAttribute=convertBufferAttribute(newAttribute$jscomp$0[i],indices$jscomp$0);name.push(newAttribute)}geometry2.morphAttributes[name$jscomp$0]=name}geometry2.morphTargetsRelative=this.morphTargetsRelative;indices$jscomp$0=this.groups;for(let i=0,
l=indices$jscomp$0.length;i<l;i++)name$jscomp$0=indices$jscomp$0[i],geometry2.addGroup(name$jscomp$0.start,name$jscomp$0.count,name$jscomp$0.materialIndex);return geometry2}toJSON(){const data={metadata:{version:4.5,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};data.uuid=this.uuid;data.type=this.type;""!==this.name&&(data.name=this.name);0<Object.keys(this.userData).length&&(data.userData=this.userData);if(void 0!==this.parameters){var parameters=this.parameters;for(var key in parameters)void 0!==
parameters[key]&&(data[key]=parameters[key]);return data}data.data={attributes:{}};key=this.index;null!==key&&(data.data.index={type:key.array.constructor.name,array:Array.prototype.slice.call(key.array)});key=this.attributes;for(var key$jscomp$0 in key)data.data.attributes[key$jscomp$0]=key[key$jscomp$0].toJSON(data.data);key$jscomp$0={};key=!1;for(parameters in this.morphAttributes){const attributeArray=this.morphAttributes[parameters],array=[];for(let i=0,il=attributeArray.length;i<il;i++)array.push(attributeArray[i].toJSON(data.data));
0<array.length&&(key$jscomp$0[parameters]=array,key=!0)}key&&(data.data.morphAttributes=key$jscomp$0,data.data.morphTargetsRelative=this.morphTargetsRelative);parameters=this.groups;0<parameters.length&&(data.data.groups=JSON.parse(JSON.stringify(parameters)));parameters=this.boundingSphere;null!==parameters&&(data.data.boundingSphere={center:parameters.center.toArray(),radius:parameters.radius});return data}clone(){return(new this.constructor).copy(this)}copy(source){this.index=null;this.attributes=
{};this.morphAttributes={};this.groups=[];this.boundingSphere=this.boundingBox=null;var data={};this.name=source.name;var index=source.index;null!==index&&this.setIndex(index.clone(data));index=source.attributes;for(var name in index)this.setAttribute(name,index[name].clone(data));name=source.morphAttributes;for(var name$jscomp$0 in name){index=[];const morphAttribute=name[name$jscomp$0];for(let i=0,l=morphAttribute.length;i<l;i++)index.push(morphAttribute[i].clone(data));this.morphAttributes[name$jscomp$0]=
index}this.morphTargetsRelative=source.morphTargetsRelative;data=source.groups;for(let i=0,l=data.length;i<l;i++)name$jscomp$0=data[i],this.addGroup(name$jscomp$0.start,name$jscomp$0.count,name$jscomp$0.materialIndex);data=source.boundingBox;null!==data&&(this.boundingBox=data.clone());data=source.boundingSphere;null!==data&&(this.boundingSphere=data.clone());this.drawRange.start=source.drawRange.start;this.drawRange.count=source.drawRange.count;this.userData=source.userData;void 0!==source.parameters&&
(this.parameters=Object.assign({},source.parameters));return this}dispose(){this.dispatchEvent({type:"dispose"})}}exports.BufferGeometry=BufferGeometry;BufferGeometry.prototype.isBufferGeometry=!0}
//# sourceMappingURL=module$node_modules$three$src$core$BufferGeometry.js.map
