shadow$provide.module$node_modules$three$src$math$Sphere=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Sphere=void 0;global=require("module$node_modules$three$src$math$Box3");var _Vector=require("module$node_modules$three$src$math$Vector3");const _box=new global.Box3,_v1=new _Vector.Vector3,_toFarthestPoint=new _Vector.Vector3,_toPoint=new _Vector.Vector3;class Sphere{constructor(center=new _Vector.Vector3,radius=-1){this.center=center;this.radius=
radius}set(center,radius){this.center.copy(center);this.radius=radius;return this}setFromPoints(points,optionalCenter){const center=this.center;void 0!==optionalCenter?center.copy(optionalCenter):_box.setFromPoints(points).getCenter(center);optionalCenter=0;for(let i=0,il=points.length;i<il;i++)optionalCenter=Math.max(optionalCenter,center.distanceToSquared(points[i]));this.radius=Math.sqrt(optionalCenter);return this}copy(sphere){this.center.copy(sphere.center);this.radius=sphere.radius;return this}isEmpty(){return 0>
this.radius}makeEmpty(){this.center.set(0,0,0);this.radius=-1;return this}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(point){return point.distanceTo(this.center)-this.radius}intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum}intersectsBox(box){return box.intersectsSphere(this)}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=
this.radius}clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);target.copy(point);deltaLengthSq>this.radius*this.radius&&(target.sub(this.center).normalize(),target.multiplyScalar(this.radius).add(this.center));return target}getBoundingBox(target){if(this.isEmpty())return target.makeEmpty(),target;target.set(this.center,this.center);target.expandByScalar(this.radius);return target}applyMatrix4(matrix){this.center.applyMatrix4(matrix);this.radius*=matrix.getMaxScaleOnAxis();
return this}translate(offset){this.center.add(offset);return this}expandByPoint(point){_toPoint.subVectors(point,this.center);point=_toPoint.lengthSq();if(point>this.radius*this.radius){point=Math.sqrt(point);const missingRadiusHalf=.5*(point-this.radius);this.center.add(_toPoint.multiplyScalar(missingRadiusHalf/point));this.radius+=missingRadiusHalf}return this}union(sphere){!0===this.center.equals(sphere.center)?_toFarthestPoint.set(0,0,1).multiplyScalar(sphere.radius):_toFarthestPoint.subVectors(sphere.center,
this.center).normalize().multiplyScalar(sphere.radius);this.expandByPoint(_v1.copy(sphere.center).add(_toFarthestPoint));this.expandByPoint(_v1.copy(sphere.center).sub(_toFarthestPoint));return this}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius}clone(){return(new this.constructor).copy(this)}}exports.Sphere=Sphere}
//# sourceMappingURL=module$node_modules$three$src$math$Sphere.js.map
