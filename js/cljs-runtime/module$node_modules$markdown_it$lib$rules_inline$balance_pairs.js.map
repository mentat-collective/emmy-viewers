{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_inline$balance_pairs.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_inline/balance_pairs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_inline$balance_pairs\"] = function(global,require,module,exports) {\n// For each opening emphasis-like marker find a matching closing one\n//\n'use strict';\n\n\nfunction processDelimiters(state, delimiters) {\n  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx,\n      isOddMatch, lastJump,\n      openersBottom = {},\n      max = delimiters.length;\n\n  if (!max) return;\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  var headerIdx = 0;\n  var lastTokenIdx = -2; // needs any value lower than -1\n  var jumps = [];\n\n  for (closerIdx = 0; closerIdx < max; closerIdx++) {\n    closer = delimiters[closerIdx];\n\n    jumps.push(0);\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n\n    lastTokenIdx = closer.token;\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [ -1, -1, -1, -1, -1, -1 ];\n    }\n\n    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)];\n\n    openerIdx = headerIdx - jumps[headerIdx] - 1;\n\n    newMinOpenerIdx = openerIdx;\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      opener = delimiters[openerIdx];\n\n      if (opener.marker !== closer.marker) continue;\n\n      if (opener.open && opener.end < 0) {\n\n        isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ?\n            jumps[openerIdx - 1] + 1 :\n            0;\n\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n\n          closer.open  = false;\n          opener.end   = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx;\n    }\n  }\n}\n\n\nmodule.exports = function link_pairs(state) {\n  var curr,\n      tokens_meta = state.tokens_meta,\n      max = state.tokens_meta.length;\n\n  processDelimiters(state, state.delimiters);\n\n  for (curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(state, tokens_meta[curr].delimiters);\n    }\n  }\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","processDelimiters","state","delimiters","openerIdx","newMinOpenerIdx","openersBottom","max","length","headerIdx","lastTokenIdx","jumps","closerIdx","closer","push","marker","token","close","hasOwnProperty","minOpenerIdx","open","opener","end","isOddMatch","lastJump","module.exports","curr","tokens_meta"]
}
