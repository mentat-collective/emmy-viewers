{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_block$blockquote.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_block/blockquote.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_block$blockquote\"] = function(global,require,module,exports) {\n// Block quotes\n\n'use strict';\n\nvar isSpace = require('../common/utils').isSpace;\n\n\nmodule.exports = function blockquote(state, startLine, endLine, silent) {\n  var adjustTab,\n      ch,\n      i,\n      initial,\n      l,\n      lastLineEmpty,\n      lines,\n      nextLine,\n      offset,\n      oldBMarks,\n      oldBSCount,\n      oldIndent,\n      oldParentType,\n      oldSCount,\n      oldTShift,\n      spaceAfterMarker,\n      terminate,\n      terminatorRules,\n      token,\n      isOutdented,\n      oldLineMax = state.lineMax,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false; }\n\n  // check the block quote marker\n  if (state.src.charCodeAt(pos++) !== 0x3E/* > */) { return false; }\n\n  // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n  if (silent) { return true; }\n\n  // set offset past spaces and \">\"\n  initial = offset = state.sCount[startLine] + 1;\n\n  // skip one optional space after '>'\n  if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n    // ' >   test '\n    //     ^ -- position start of line here:\n    pos++;\n    initial++;\n    offset++;\n    adjustTab = false;\n    spaceAfterMarker = true;\n  } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n    spaceAfterMarker = true;\n\n    if ((state.bsCount[startLine] + offset) % 4 === 3) {\n      // '  >\\t  test '\n      //       ^ -- position start of line here (tab has width===1)\n      pos++;\n      initial++;\n      offset++;\n      adjustTab = false;\n    } else {\n      // ' >\\t  test '\n      //    ^ -- position start of line here + shift bsCount slightly\n      //         to make extra space appear\n      adjustTab = true;\n    }\n  } else {\n    spaceAfterMarker = false;\n  }\n\n  oldBMarks = [ state.bMarks[startLine] ];\n  state.bMarks[startLine] = pos;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (isSpace(ch)) {\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;\n      } else {\n        offset++;\n      }\n    } else {\n      break;\n    }\n\n    pos++;\n  }\n\n  oldBSCount = [ state.bsCount[startLine] ];\n  state.bsCount[startLine] = state.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n  lastLineEmpty = pos >= max;\n\n  oldSCount = [ state.sCount[startLine] ];\n  state.sCount[startLine] = offset - initial;\n\n  oldTShift = [ state.tShift[startLine] ];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n\n  terminatorRules = state.md.block.ruler.getRules('blockquote');\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n\n  // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag:\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    // check if it's outdented, i.e. it's inside list item and indented\n    // less than said list item:\n    //\n    // ```\n    // 1. anything\n    //    > current blockquote\n    // 2. checking this line\n    // ```\n    isOutdented = state.sCount[nextLine] < state.blkIndent;\n\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E/* > */ && !isOutdented) {\n      // This line is inside the blockquote.\n\n      // set offset past spaces and \">\"\n      initial = offset = state.sCount[nextLine] + 1;\n\n      // skip one optional space after '>'\n      if (state.src.charCodeAt(pos) === 0x20 /* space */) {\n        // ' >   test '\n        //     ^ -- position start of line here:\n        pos++;\n        initial++;\n        offset++;\n        adjustTab = false;\n        spaceAfterMarker = true;\n      } else if (state.src.charCodeAt(pos) === 0x09 /* tab */) {\n        spaceAfterMarker = true;\n\n        if ((state.bsCount[nextLine] + offset) % 4 === 3) {\n          // '  >\\t  test '\n          //       ^ -- position start of line here (tab has width===1)\n          pos++;\n          initial++;\n          offset++;\n          adjustTab = false;\n        } else {\n          // ' >\\t  test '\n          //    ^ -- position start of line here + shift bsCount slightly\n          //         to make extra space appear\n          adjustTab = true;\n        }\n      } else {\n        spaceAfterMarker = false;\n      }\n\n      oldBMarks.push(state.bMarks[nextLine]);\n      state.bMarks[nextLine] = pos;\n\n      while (pos < max) {\n        ch = state.src.charCodeAt(pos);\n\n        if (isSpace(ch)) {\n          if (ch === 0x09) {\n            offset += 4 - (offset + state.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;\n          } else {\n            offset++;\n          }\n        } else {\n          break;\n        }\n\n        pos++;\n      }\n\n      lastLineEmpty = pos >= max;\n\n      oldBSCount.push(state.bsCount[nextLine]);\n      state.bsCount[nextLine] = state.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);\n\n      oldSCount.push(state.sCount[nextLine]);\n      state.sCount[nextLine] = offset - initial;\n\n      oldTShift.push(state.tShift[nextLine]);\n      state.tShift[nextLine] = pos - state.bMarks[nextLine];\n      continue;\n    }\n\n    // Case 2: line is not inside the blockquote, and the last line was empty.\n    if (lastLineEmpty) { break; }\n\n    // Case 3: another tag found.\n    terminate = false;\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      // Quirk to enforce \"hard termination mode\" for paragraphs;\n      // normally if you call `tokenize(state, startLine, nextLine)`,\n      // paragraphs will look below nextLine for paragraph continuation,\n      // but if blockquote is terminated by another tag, they shouldn't\n      state.lineMax = nextLine;\n\n      if (state.blkIndent !== 0) {\n        // state.blkIndent was non-zero, we now set it to zero,\n        // so we need to re-calculate all offsets to appear as\n        // if indent wasn't changed\n        oldBMarks.push(state.bMarks[nextLine]);\n        oldBSCount.push(state.bsCount[nextLine]);\n        oldTShift.push(state.tShift[nextLine]);\n        oldSCount.push(state.sCount[nextLine]);\n        state.sCount[nextLine] -= state.blkIndent;\n      }\n\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldBSCount.push(state.bsCount[nextLine]);\n    oldTShift.push(state.tShift[nextLine]);\n    oldSCount.push(state.sCount[nextLine]);\n\n    // A negative indentation means that this is a paragraph continuation\n    //\n    state.sCount[nextLine] = -1;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n\n  token        = state.push('blockquote_open', 'blockquote', 1);\n  token.markup = '>';\n  token.map    = lines = [ startLine, 0 ];\n\n  state.md.block.tokenize(state, startLine, nextLine);\n\n  token        = state.push('blockquote_close', 'blockquote', -1);\n  token.markup = '>';\n\n  state.lineMax = oldLineMax;\n  state.parentType = oldParentType;\n  lines[1] = state.line;\n\n  // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n    state.sCount[i + startLine] = oldSCount[i];\n    state.bsCount[i + startLine] = oldBSCount[i];\n  }\n  state.blkIndent = oldIndent;\n\n  return true;\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","isSpace","module.exports","state","startLine","endLine","silent","offset","oldLineMax","lineMax","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","src","charCodeAt","initial","adjustTab","spaceAfterMarker","bsCount","oldBMarks","ch","oldBSCount","lastLineEmpty","oldSCount","oldTShift","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","nextLine","isOutdented","terminate","i","l","length","push","oldIndent","token","markup","map","lines","tokenize","line"]
}
