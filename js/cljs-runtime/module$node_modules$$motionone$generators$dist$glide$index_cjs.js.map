{
"version":3,
"file":"module$node_modules$$motionone$generators$dist$glide$index_cjs.js",
"lineCount":4,
"mappings":"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",
"sources":["node_modules/@motionone/generators/dist/glide/index.cjs.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$motionone$generators$dist$glide$index_cjs\"] = function(global,require,module,exports) {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar utils = require('@motionone/utils');\nvar velocity = require('../utils/velocity.cjs.js');\nvar index = require('../spring/index.cjs.js');\n\nconst glide = ({ from = 0, velocity: velocity$1 = 0.0, power = 0.8, decay = 0.325, bounceDamping, bounceStiffness, changeTarget, min, max, restDistance = 0.5, restSpeed, }) => {\n    decay = utils.time.ms(decay);\n    const state = {\n        hasReachedTarget: false,\n        done: false,\n        current: from,\n        target: from,\n    };\n    const isOutOfBounds = (v) => (min !== undefined && v < min) || (max !== undefined && v > max);\n    const nearestBoundary = (v) => {\n        if (min === undefined)\n            return max;\n        if (max === undefined)\n            return min;\n        return Math.abs(min - v) < Math.abs(max - v) ? min : max;\n    };\n    let amplitude = power * velocity$1;\n    const ideal = from + amplitude;\n    const target = changeTarget === undefined ? ideal : changeTarget(ideal);\n    state.target = target;\n    /**\n     * If the target has changed we need to re-calculate the amplitude, otherwise\n     * the animation will start from the wrong position.\n     */\n    if (target !== ideal)\n        amplitude = target - from;\n    const calcDelta = (t) => -amplitude * Math.exp(-t / decay);\n    const calcLatest = (t) => target + calcDelta(t);\n    const applyFriction = (t) => {\n        const delta = calcDelta(t);\n        const latest = calcLatest(t);\n        state.done = Math.abs(delta) <= restDistance;\n        state.current = state.done ? target : latest;\n    };\n    /**\n     * Ideally this would resolve for t in a stateless way, we could\n     * do that by always precalculating the animation but as we know\n     * this will be done anyway we can assume that spring will\n     * be discovered during that.\n     */\n    let timeReachedBoundary;\n    let spring;\n    const checkCatchBoundary = (t) => {\n        if (!isOutOfBounds(state.current))\n            return;\n        timeReachedBoundary = t;\n        spring = index.spring({\n            from: state.current,\n            to: nearestBoundary(state.current),\n            velocity: velocity.calcGeneratorVelocity(calcLatest, t, state.current),\n            damping: bounceDamping,\n            stiffness: bounceStiffness,\n            restDistance,\n            restSpeed,\n        });\n    };\n    checkCatchBoundary(0);\n    return (t) => {\n        /**\n         * We need to resolve the friction to figure out if we need a\n         * spring but we don't want to do this twice per frame. So here\n         * we flag if we updated for this frame and later if we did\n         * we can skip doing it again.\n         */\n        let hasUpdatedFrame = false;\n        if (!spring && timeReachedBoundary === undefined) {\n            hasUpdatedFrame = true;\n            applyFriction(t);\n            checkCatchBoundary(t);\n        }\n        /**\n         * If we have a spring and the provided t is beyond the moment the friction\n         * animation crossed the min/max boundary, use the spring.\n         */\n        if (timeReachedBoundary !== undefined && t > timeReachedBoundary) {\n            state.hasReachedTarget = true;\n            return spring(t - timeReachedBoundary);\n        }\n        else {\n            state.hasReachedTarget = false;\n            !hasUpdatedFrame && applyFriction(t);\n            return state;\n        }\n    };\n};\n\nexports.glide = glide;\n\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","utils","velocity","index","glide","from","velocity$1","power","decay","bounceDamping","bounceStiffness","changeTarget","min","max","restDistance","restSpeed","time","ms","state","hasReachedTarget","done","current","target","amplitude","ideal","undefined","calcLatest","t","Math","exp","applyFriction","latest","abs","timeReachedBoundary","spring","checkCatchBoundary","v","to","calcGeneratorVelocity","damping","stiffness","hasUpdatedFrame"]
}
