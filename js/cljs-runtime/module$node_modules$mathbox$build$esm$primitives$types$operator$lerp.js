shadow$provide.module$node_modules$mathbox$build$esm$primitives$types$operator$lerp=function(global,require,module,exports){function _getRequireWildcardCache(nodeInterop$jscomp$0){if("function"!==typeof WeakMap)return null;var cacheBabelInterop=new WeakMap,cacheNodeInterop=new WeakMap;return(_getRequireWildcardCache=function(nodeInterop){return nodeInterop?cacheNodeInterop:cacheBabelInterop})(nodeInterop$jscomp$0)}Object.defineProperty(exports,"__esModule",{value:!0});exports.Lerp=void 0;var UGLSL=
function(obj,nodeInterop){if(!nodeInterop&&obj&&obj.__esModule)return obj;if(null===obj||"object"!==typeof obj&&"function"!==typeof obj)return{default:obj};if((nodeInterop=_getRequireWildcardCache(nodeInterop))&&nodeInterop.has(obj))return nodeInterop.get(obj);var newObj={},hasPropertyDescriptor=Object.defineProperty&&Object.getOwnPropertyDescriptor,key;for(key in obj)if("default"!==key&&Object.prototype.hasOwnProperty.call(obj,key)){var desc=hasPropertyDescriptor?Object.getOwnPropertyDescriptor(obj,
key):null;desc&&(desc.get||desc.set)?Object.defineProperty(newObj,key,desc):newObj[key]=obj[key]}newObj.default=obj;nodeInterop&&nodeInterop.set(obj,newObj);return newObj}(require("module$node_modules$mathbox$build$esm$util$glsl"));global=require("module$node_modules$mathbox$build$esm$primitives$types$operator$operator");class Lerp extends global.Operator{static initClass(){this.traits="node bind operator source index lerp sampler:x sampler:y sampler:z sampler:w".split(" ")}indexShader(shader){shader.pipe(this.indexer);
return super.indexShader(shader)}sourceShader(shader){return shader.pipe(this.operator)}getDimensions(){return this._resample(this.bind.source.getDimensions())}getActiveDimensions(){return this._resample(this.bind.source.getActiveDimensions())}getFutureDimensions(){return this._resample(this.bind.source.getFutureDimensions())}getIndexDimensions(){return this._resample(this.bind.source.getIndexDimensions())}_resample(dims){const r=this.resampled,c=this.centered,p=this.padding;this.relativeSize?(c.items||
dims.items--,c.width||dims.width--,c.height||dims.height--,c.depth||dims.depth--,null!=r.items&&(dims.items*=r.items),null!=r.width&&(dims.width*=r.width),null!=r.height&&(dims.height*=r.height),null!=r.depth&&(dims.depth*=r.depth),c.items||dims.items++,c.width||dims.width++,c.height||dims.height++,c.depth||dims.depth++,dims.items-=2*p.items,dims.width-=2*p.width,dims.height-=2*p.height,dims.depth-=2*p.depth):(null!=r.items&&(dims.items=r.items),null!=r.width&&(dims.width=r.width),null!=r.height&&
(dims.height=r.height),null!=r.depth&&(dims.depth=r.depth));dims.items=Math.max(0,Math.floor(dims.items));dims.width=Math.max(0,Math.floor(dims.width));dims.height=Math.max(0,Math.floor(dims.height));dims.depth=Math.max(0,Math.floor(dims.depth));return dims}make(){let i;super.make();if(null!=this.bind.source){var {size,items,width,height,depth}=this.props,relativeSize=size===this.node.attributes["lerp.size"].enum.relative;this.resampled={};null!=items&&(this.resampled.items=items);null!=width&&(this.resampled.width=
width);null!=height&&(this.resampled.height=height);null!=depth&&(this.resampled.depth=depth);this.centered={};this.centered.items=this.props.centeredW;this.centered.width=this.props.centeredX;this.centered.height=this.props.centeredY;this.centered.depth=this.props.centeredZ;this.padding={};this.padding.items=this.props.paddingW;this.padding.width=this.props.paddingX;this.padding.height=this.props.paddingY;this.padding.depth=this.props.paddingZ;var operator=this._shaders.shader(),indexer=this._shaders.shader(),
uniforms={resampleFactor:this._attributes.make(this._types.vec4(0,0,0,0)),resampleBias:this._attributes.make(this._types.vec4(0,0,0,0))};this.resampleFactor=uniforms.resampleFactor;this.resampleBias=uniforms.resampleBias;var resize=null!=items||null!=width||null!=height||null!=depth;operator.pipe("resample.padding",uniforms);var vec=[],any=!1,iterable=["width","height","depth","items"];for(i=0;i<iterable.length;i++){var key=iterable[i];key=this.centered[key];any||(any=key);vec[i]=key?"0.5":"0.0"}if(any&&
resize){var vec4=`vec4(${vec})`;operator.pipe(UGLSL.binaryOperator(4,"+",vec4));indexer.pipe(UGLSL.binaryOperator(4,"+",vec4))}resize?(operator.pipe("resample.relative",uniforms),indexer.pipe("resample.relative",uniforms)):(operator.pipe(UGLSL.identity("vec4")),indexer.pipe(UGLSL.identity("vec4")));any&&resize&&(operator.pipe(UGLSL.binaryOperator(4,"-",vec4)),indexer.pipe(UGLSL.binaryOperator(4,"-",vec4)));resize=this.bind.source.sourceShader(this._shaders.shader());vec=["width","height","depth",
"items"];for(i=0;i<vec.length;i++)key=vec[i],any=`lerp.${key}`,null!=this.props[key]&&(resize=this._shaders.shader().require(resize),resize.pipe(any,uniforms));operator.pipe(resize);this.operator=operator;this.indexer=indexer;return this.relativeSize=relativeSize}}unmake(){super.unmake();return this.operator=null}resize(){if(null!=this.bind.source){var dims=this.bind.source.getActiveDimensions(),target=this.getActiveDimensions(),axis=key=>{const centered=this.centered[key],pad=this.padding[key];target[key]+=
2*pad;return[centered?dims[key]/Math.max(1,target[key]):Math.max(1,dims[key]-1)/Math.max(1,target[key]-1),pad]},[rw,bw]=Array.from(axis("width")),[rh,bh]=Array.from(axis("height")),[rd,bd]=Array.from(axis("depth")),[ri,bi]=Array.from(axis("items"));this.resampleFactor.value.set(rw,rh,rd,ri);this.resampleBias.value.set(bw,bh,bd,bi);return super.resize()}}change(changed,touched,_init){if(touched.operator||touched.lerp||touched.sampler)return this.rebuild()}}exports.Lerp=Lerp;Lerp.initClass()}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$primitives$types$operator$lerp.js.map
