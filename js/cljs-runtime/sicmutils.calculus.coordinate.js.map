{"version":3,"sources":["sicmutils/calculus/coordinate.cljc"],"mappings":";AAUA;;;;;;qDAAA,rDAAMA,kHAKHC;AALH,AAME,IAAMC,YAAU,AAACC,iDAAuBF;AAAxC,AACE,OAACG,8BAAY,WAAKC,MAAMC,MAAMC;AAAjB,2BACM,WAAKC,tCAGL,OAACG;AAHD,sDACM,AAACF,6CAAgBR,kBAAkBO,rHACnC,OAACE,qHAAOJ;GACd,2CAAA,qDAAkBD;GACxBH;;AAEjB;;;;;;;;;;;;;;;;;6DAAA,7DAAMU,kIAgBHC;AAhBH,AAiBE,QAAA,yEAAYA;AAAZ,AACU,oBAAM,iBAAAC,oBAAK,AAACC,4BAAYF;AAAlB,AAAA,GAAAC;AAAqB,IAAAE,WAAa,AAACE,gBAAML;IAApBI,eAAA,AAAA;AAAA,AAAA,QAAAA,6CAAAA,2CAAAD,YAAAC,uBAAAD;;AAArBF;;;AACA,IAAMS,IAAE,AAACL,gBAAML;IACTW,SAAO,wGAAA,AAAA,0FAAA,AAAA,hMAAI,+CAAA,AAAA,/CAACC,6CAAEF;AADpB,AAAA,OAAAJ,iDAAA,AAAAC,cAAA,AAAAC,+CAAA,KAAAC,eAAA,YAAA,KAAA,IAAA,hBAIKE,uBAAS,AAACE,4CAAIC,+DAAE,AAACC,eAAKf;;AALjC,GAOM,AAACgB,wBAAQhB;AAAG,OAACiB,6CAAKH,+DAAEd;;AAP1B,GAQM,kBAAAkB,jBAASlB;AAAG,YAAAS,eAAA,KAAA,AAAA,2DAAA,KAAAA,eAAA,WAAA,KAAA,IAAA,OAAA,IAAA,1BAAaT;;AAR/B,AASY,8BAAA,vBAACmB;;;;;;AAVvB,AAWE,OAACL,EAAEd;;AAEP;;;;;;;uDAAA,vDAAeoB,sHAMZpB;AANH,AAOE,oBAAM,iBAAAC,oBAAK,AAACC,4BAAYF;AAAlB,AAAA,GAAAC;AACK,IAAAoB,WAAa,AAAChB,gBAAML;IAApBsB,eAAA,AAAA;AAAA,AAAA,QAAAA,6CAAAA,2CAAAD,YAAAC,uBAAAD;;AADLpB;;;AAC8B,OAACsB,sDAAOH,uGAAuB,AAACL,eAAKf;;AADzE,GAEM,AAACgB,wBAAQhB;AAAG,OAACuB,sDAAOH,uGAAuBpB;;AAFjD,GAGM,cAAAkB,bAASlB;AAHf,0FAGmBA;;AAHnB,AAIY,OAACmB,uBAAU,CAAA,6EAAsCnB","names":["sicmutils.calculus.coordinate/coordinate-functions","coordinate-system","prototype","sicmutils.calculus.manifold/coordinate-prototype","sicmutils.structure/map-chain","coord","chain","_","point","sicmutils.calculus.manifold/point->coords","cljs.core.get_in","cljs.core/with-meta","sicmutils.calculus.coordinate/quotify-coordinate-prototype","p","and__4251__auto__","cljs.core/sequential?","G__87742","fexpr__87741","cljs.core/first","cljs.core.sequence","cljs.core/seq","cljs.core.concat","cljs.core/List","s","prefix","cljs.core._EQ_","cljs.core.map","q","cljs.core/rest","cljs.core/vector?","cljs.core.mapv","cljs.core/Symbol","sicmutils.util/illegal","sicmutils.calculus.coordinate/symbols-from-prototype","G__87746","fexpr__87745","cljs.core.mapcat"],"sourcesContent":["#_\"SPDX-License-Identifier: GPL-3.0\"\n\n(ns sicmutils.calculus.coordinate\n  (:require [sicmutils.calculus.form-field :as ff]\n            [sicmutils.calculus.manifold :as m]\n            [sicmutils.calculus.vector-field :as vf]\n            [sicmutils.structure :as s]\n            [sicmutils.util :as u]\n            [sicmutils.util.def :as ud]))\n\n(defn coordinate-functions\n  \"Returns a structure similar to the [[manifold/coordinate-prototype]] of\n  `coordinate-system`, where every entry is a function from manifold point =>\n  the associated component of the point in the coordinate representation\n  described by `coordinate-system`.\"\n  [coordinate-system]\n  (let [prototype (m/coordinate-prototype coordinate-system)]\n    (s/map-chain (fn [coord chain _]\n                   (-> (fn [point]\n                         (-> (m/point->coords coordinate-system point)\n                             (get-in chain)))\n                       (with-meta {:name coord})))\n                 prototype)))\n\n(defn quotify-coordinate-prototype\n  \"Scmutils wants to allow forms like this:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect ...)\n  ```\n\n   Note that `x`, `y` are unquoted. This function converts such an unquoted form\n  into a quoted one that could be evaluated to return an up-tuple of the\n  symbols:\n\n  ```clojure\n  (up 'x 'y)\n  ```\n\n  Such an object is useful for [[structure/mapr]].\"\n  [p]\n  (letfn [(q [p]\n            (cond (and (sequential? p) ('#{up down} (first p)))\n                  (let [s (first p)\n                        prefix (if (= s 'up)\n                                 `s/up\n                                 `s/down)]\n                    `(~prefix ~@(map q (rest p))))\n\n                  (vector? p) (mapv q p)\n                  (symbol? p) (list 'quote p)\n                  :else (u/illegal \"Invalid coordinate prototype\")))]\n    (q p)))\n\n(defn ^:no-doc symbols-from-prototype\n  \"Generates a list of symbols from the supplied argument prototype. The\n  prototype is allowed to be a vector, a list like `(up x y)` or a bare symbol.\n  Anything else causes an exception.\n\n  Nested structures are fine! The return value is a flat sequence.\"\n  [p]\n  (cond (and (sequential? p)\n             ('#{up down} (first p))) (mapcat symbols-from-prototype (rest p))\n        (vector? p) (mapcat symbols-from-prototype p)\n        (symbol? p) [p]\n        :else (u/illegal (str \"Invalid coordinate prototype: \" p))))\n\n(defmacro let-coordinates\n  \"similar to a `let` binding that holds pairs of\n\n  <coordinate-structure-prototype>, <coordinate-system>\n\n  And internally binds, for each pair: (take `[x y]` and `m/R2-rect` as\n  examples):\n\n  - The coordinate system symbol `R2-rect` to a new version of the coordinate\n    system with its `coordinate-prototype` replaced by the one you supplied.\n    That's `(up x y)` in this example.\n\n  - the entries `x` and `y` to coordinate functions, ie, functions from manifold\n    point to this particular coordinate\n\n  - `d:dx` and `d:dy` vector field procedures (I'm fuzzy here!)\n\n  - `dx` and `dy` 1-forms for each coordinate (fuzzy here too!)\n\n  Example:\n\n  ```clojure\n  (let-coordinates [[x y]    R2-rect\n                   [r theta] R2-polar]\n    ;; bindings:\n    ;; R2-rect, x, y, d:dx, d:dy, dx, dy\n    ;; R2-polar, r, theta, d:dr, d:dtheta, dr, dtheta\n    body...)\n  ```\"\n  [bindings & body]\n  (when-not (even? (count bindings))\n    (u/illegal \"let-coordinates requires an even number of bindings\"))\n  (let [pairs                         (partition 2 bindings)\n        prototypes                    (map first pairs)\n        c-systems                     (map second pairs)\n        system-names                  (map (comp symbol name) c-systems)\n        coordinate-names              (mapcat symbols-from-prototype prototypes)\n        coordinate-vector-field-names (map vf/coordinate-name->vf-name coordinate-names)\n        coordinate-form-field-names   (map ff/coordinate-name->ff-name coordinate-names)]\n    `(let [[~@system-names :as c-systems#]\n           (mapv m/with-coordinate-prototype\n                 ~(into [] c-systems)\n                 ~(mapv quotify-coordinate-prototype prototypes))\n\n           ~(into [] coordinate-names)\n           (flatten\n            (map coordinate-functions c-systems#))\n\n           ~(into [] coordinate-vector-field-names)\n           (flatten\n            (map vf/coordinate-system->vector-basis c-systems#))\n\n           ~(into [] coordinate-form-field-names)\n           (flatten\n            (map ff/coordinate-system->oneform-basis c-systems#))]\n       ~@body)))\n\n(defmacro using-coordinates\n  \"[[using-coordinates]] wraps [[let-coordinates]] and allows you to supply a\n  single coordinate prototype and a single coordinate system.\n  See [[let-coordinates]] for details about what symbols are bound inside the\n  body.\n\n  Example:\n\n  ```clojure\n  (using-coordinates (up x y) R2-rect\n                     body...)\n  ```\"\n  [coordinate-prototype coordinate-system & body]\n  `(let-coordinates [~coordinate-prototype ~coordinate-system]\n     ~@body))\n\n(defmacro define-coordinates\n  \"Give some `coordinate-system` like `R2-rect` and a `coordinate-prototype` like\n  `[x y]` or `(up x y), `binds the following definitions into the namespace\n  where [[define-coordinates]] is invoked:\n\n  - `R2-rect` binds to a new version of the coordinate system with its\n    `coordinate-prototype` replaced by the supplied prototype\n\n  - `x` and `y` bind to coordinate functions, ie, functions from manifold point\n  to that particular coordinate\n\n  - `d:dx` and `d:dy` bind to the corresponding vector field procedures\n\n  - `dx` and `dy` bind to 1-forms for each coordinate.\"\n  [coordinate-prototype coordinate-system]\n  (let [sys-name           (symbol (name coordinate-system))\n        coord-names        (symbols-from-prototype coordinate-prototype)\n        vector-field-names (map vf/coordinate-name->vf-name coord-names)\n        form-field-names   (map ff/coordinate-name->ff-name coord-names)\n        sys-sym            (gensym)\n        value-sym          (gensym)\n        bind               (ud/careful-def *ns*)]\n    `(let [~sys-sym (m/with-coordinate-prototype\n                      ~coordinate-system\n                      ~(quotify-coordinate-prototype coordinate-prototype))]\n       ~(bind sys-name sys-sym)\n       (let [~value-sym\n             (into [] (flatten\n                       [(coordinate-functions ~sys-sym)\n                        (vf/coordinate-system->vector-basis ~sys-sym)\n                        (ff/coordinate-system->oneform-basis ~sys-sym)]))]\n         ~@(map-indexed\n            (fn [i sym]\n              (bind sym `(nth ~value-sym ~i)))\n            (concat coord-names vector-field-names form-field-names))))))\n"]}