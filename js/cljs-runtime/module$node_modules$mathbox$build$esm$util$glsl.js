shadow$provide.module$node_modules$mathbox$build$esm$util$glsl=function(global,require,module,exports){function __range__(left,right,inclusive){const range=[],ascending=left<right;for(right=inclusive?ascending?right+1:right-1:right;ascending?left<right:left>right;ascending?left++:left--)range.push(left);return range}Object.defineProperty(exports,"__esModule",{value:!0});exports.constant=exports.identity=exports.invertSwizzleVec4=exports.swizzleVec4=exports.injectVec4=exports.truncateVec=exports.extendVec=
exports.binaryOperator=exports.sample2DArray=exports.mapByte2FloatOffset=exports.toType=void 0;const letters=["x","y","z","w"],index={0:-1,x:0,y:1,z:2,w:3},parseOrder=function(order){order===""+order&&(order=order.split(""));order===+order&&(order=[order]);return order},toType=function(type){type===+type&&(type="vec"+type);"vec1"===type&&(type="float");return type};exports.toType=toType;const toFloatString=function(value){value=""+value;if(0>value.indexOf("."))return value+".0"};exports.mapByte2FloatOffset=
function(stretch){null==stretch&&(stretch=4);stretch=toFloatString(stretch);return`\
vec4 float2ByteIndex(vec4 xyzw, out float channelIndex) {
  float relative = xyzw.w / ${stretch};
  float w = floor(relative);
  channelIndex = (relative - w) * ${stretch};
  return vec4(xyzw.xyz, w);
}\
`};exports.sample2DArray=function(textures){const divide=function(a,b){if(a===b)a=`\
return texture2D(dataTextures[${a}], uv);\
`;else{const mid=Math.ceil(a+(b-a)/2);a=`\
if (z < ${mid-.5}) {
  ${divide(a,mid-1)}
}
else {
  ${divide(mid,b)}
}\
`}return a.replace(/\n/g,"\n  ")},body=divide(0,textures-1);return`\
uniform sampler2D dataTextures[${textures}];

vec4 sample2DArray(vec2 uv, float z) {
  ${body}
}\
`};exports.binaryOperator=function(type,op,curry){type=toType(type);return null!=curry?`\
${type} binaryOperator(${type} a) {
  return a ${op} ${curry};
}\
`:`\
${type} binaryOperator(${type} a, ${type} b) {
  return a ${op} b;
}\
`};const extendVec=function(from,to,value){null==value&&(value=0);if(from>to)return truncateVec(from,to);var diff=to-from;from=toType(from);to=toType(to);value=toFloatString(value);diff=__range__(0,diff,!0).map(function(x){return x?value:"v"}).join(",");return`\
${to} extendVec(${from} v) { return ${to}(${diff}); }\
`};exports.extendVec=extendVec;const truncateVec=function(from,to){if(from<to)return extendVec(from,to);const swizzle="."+"xyzw".substr(0,to);from=toType(from);to=toType(to);return`\
${to} truncateVec(${from} v) { return v${swizzle}; }\
`};exports.truncateVec=truncateVec;exports.injectVec4=function(order){var swizzler=["0.0","0.0","0.0","0.0"];order=parseOrder(order);order=order.map(function(v){return v===""+v?index[v]:v});for(let i=0;i<order.length;i++)swizzler[order[i]]=["a","b","c","d"][i];swizzler=swizzler.slice(0,4).join(", ");return`\
vec4 inject(${["float a","float b","float c","float d"].slice(0,order.length)}) {
  return vec4(${swizzler});
}\
`};exports.swizzleVec4=function(order,size=null){const lookup=["0.0","xyzw.x","xyzw.y","xyzw.z","xyzw.w"];null==size&&(size=order.length);order=parseOrder(order);for(order=order.map(function(v){Array.from([0,1,2,3,4]).includes(+v)&&(v=+v);v===""+v&&(v=index[v]+1);return lookup[v]});order.length<size;)order.push("0.0");order=order.join(", ");return`\
vec${size} swizzle(vec4 xyzw) {
  return vec${size}(${order});
}\
`.replace(/vec1/g,"float")};exports.invertSwizzleVec4=function(order){const swizzler=["0.0","0.0","0.0","0.0"];order=parseOrder(order);order=order.map(function(v){return v===+v?letters[v-1]:v});for(let i=0;i<order.length;i++)swizzler[index[order[i]]]=`xyzw.${letters[i]}`;return`\
vec4 invertSwizzle(vec4 xyzw) {
  return vec4(${swizzler.join(", ")});
}\
`};exports.identity=function(type){let args=[].slice.call(arguments);return 1<args.length?(args=args.map((t,i)=>["inout",t,String.fromCharCode(97+i)].join(" ")),args=args.join(", "),`\
void identity(${args}) { }\
`):`\
${type} identity(${type} x) {
  return x;
}\
`};exports.constant=(type,value)=>`\
${type} constant() {
return ${value};
}\
`}
//# sourceMappingURL=module$node_modules$mathbox$build$esm$util$glsl.js.map
