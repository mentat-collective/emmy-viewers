{
"version":3,
"file":"module$node_modules$markdown_it$lib$rules_core$smartquotes.js",
"lineCount":7,
"mappings":"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",
"sources":["node_modules/markdown-it/lib/rules_core/smartquotes.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$markdown_it$lib$rules_core$smartquotes\"] = function(global,require,module,exports) {\n// Convert straight quotation marks to typographic ones\n//\n'use strict';\n\n\nvar isWhiteSpace   = require('../common/utils').isWhiteSpace;\nvar isPunctChar    = require('../common/utils').isPunctChar;\nvar isMdAsciiPunct = require('../common/utils').isMdAsciiPunct;\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar APOSTROPHE = '\\u2019'; /* \u2019 */\n\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction process_inlines(tokens, state) {\n  var i, token, text, t, pos, max, thisLevel, item, lastChar, nextChar,\n      isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace,\n      canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;\n\n  stack = [];\n\n  for (i = 0; i < tokens.length; i++) {\n    token = tokens[i];\n\n    thisLevel = tokens[i].level;\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break; }\n    }\n    stack.length = j + 1;\n\n    if (token.type !== 'text') { continue; }\n\n    text = token.content;\n    pos = 0;\n    max = text.length;\n\n    /*eslint no-labels:0,block-scoped-var:0*/\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      t = QUOTE_RE.exec(text);\n      if (!t) { break; }\n\n      canOpen = canClose = true;\n      pos = t.index + 1;\n      isSingle = (t[0] === \"'\");\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      lastChar = 0x20;\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      nextChar = 0x20;\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n\n      isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n\n      isLastWhiteSpace = isWhiteSpace(lastChar);\n      isNextWhiteSpace = isWhiteSpace(nextChar);\n\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          item = stack[j];\n          if (stack[j].level < thisLevel) { break; }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote);\n\n            pos += closeQuote.length - 1;\n            if (item.token === i) { pos += openQuote.length - 1; }\n\n            text = token.content;\n            max = text.length;\n\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\n\n\nmodule.exports = function smartquotes(state) {\n  /*eslint max-depth:0*/\n  var blkIdx;\n\n  if (!state.md.options.typographer) { return; }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","replaceAt","str","index","ch","substr","isWhiteSpace","isPunctChar","isMdAsciiPunct","QUOTE_TEST_RE","QUOTE_RE","module.exports","state","blkIdx","md","options","typographer","tokens","length","type","test","content","openQuote","j","i","children","stack","token","thisLevel","level","text","pos","max","lastIndex","t","exec","canOpen","canClose","isSingle","lastChar","charCodeAt","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","item","single","quotes","closeQuote","push","APOSTROPHE"]
}
