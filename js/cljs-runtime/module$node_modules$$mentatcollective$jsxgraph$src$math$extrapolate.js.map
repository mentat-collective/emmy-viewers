{
"version":3,
"file":"module$node_modules$$mentatcollective$jsxgraph$src$math$extrapolate.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/@mentatcollective/jsxgraph/src/math/extrapolate.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$mentatcollective$jsxgraph$src$math$extrapolate\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _math = _interopRequireDefault(require(\"./math\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n    Copyright 2008-2022\n        Matthias Ehmann,\n        Michael Gerhaeuser,\n        Carsten Miller,\n        Alfred Wassermann\n\n    This file is part of JSXGraph.\n\n    JSXGraph is free software dual licensed under the GNU LGPL or MIT License.\n\n    You can redistribute it and/or modify it under the terms of the\n\n      * GNU Lesser General Public License as published by\n        the Free Software Foundation, either version 3 of the License, or\n        (at your option) any later version\n      OR\n      * MIT License: https://github.com/jsxgraph/jsxgraph/blob/master/LICENSE.MIT\n\n    JSXGraph is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU Lesser General Public License for more details.\n\n    You should have received a copy of the GNU Lesser General Public License and\n    the MIT License along with JSXGraph. If not, see <http://www.gnu.org/licenses/>\n    and <http://opensource.org/licenses/MIT/>.\n */\n\n/*global JXG: true, define: true*/\n\n/*jslint nomen: true, plusplus: true*/\n\n/**\n * Functions for extrapolation of sequences. Used for finding limits of sequences which is used for curve plotting.\n * @name JXG.Math.Extrapolate\n * @exports Mat.Extrapolate as JXG.Math.Extrapolate\n * @namespace\n */\n_math.default.Extrapolate = {\n  upper: 15,\n  infty: 1e4,\n\n  /**\n   * Wynn's epsilon algorithm. Ported from the FORTRAN version in\n   * Ernst Joachim Weniger, \"Nonlinear sequence transformations for the acceleration of convergence\n   * and the summation of divergent series\", Computer Physics Reports Vol. 10, 189-371 (1989).\n   *\n   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n   * @param {Number} n index of s_n in the sequence\n   * @param {Array} e One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.\n   * @returns {Number} New estimate of the limit of the sequence.\n   *\n   * @memberof JXG.Math.Extrapolate\n   */\n  wynnEps: function (s_n, n, e) {\n    var HUGE = 1e20,\n        TINY = 1e-15,\n        f0 = 1,\n        // f0 may be changed to other values, see vanden Broeck, Schwartz (1979)\n    f,\n        j,\n        aux1,\n        aux2,\n        diff,\n        estlim;\n    e[n] = s_n;\n\n    if (n === 0) {\n      estlim = s_n;\n    } else {\n      aux2 = 0.0;\n\n      for (j = n; j > 0; j--) {\n        aux1 = aux2;\n        aux2 = e[j - 1];\n        diff = e[j] - aux2;\n\n        if (Math.abs(diff) <= TINY) {\n          e[j - 1] = HUGE;\n        } else {\n          f = (n - j + 1) % 2 === 1 ? f0 : 1;\n          e[j - 1] = aux1 * f + 1 / diff;\n        }\n      }\n\n      estlim = e[n % 2];\n    }\n\n    return estlim;\n  },\n  // wynnRho: function(s_n, n, e) {\n  //     var HUGE = 1.e+20,\n  //         TINY = 1.e-15,\n  //         j, f,\n  //         aux1, aux2, diff, estlim;\n  //     e[n] = s_n;\n  //     if (n === 0) {\n  //         estlim = s_n;\n  //     } else {\n  //         aux2 = 0.0;\n  //         for (j = n; j >= 1; j--) {\n  //             aux1 = aux2;\n  //             aux2 = e[j - 1];\n  //             diff = e[j] - aux2;\n  //             if (Math.abs(diff) <= TINY) {\n  //                 e[j - 1] = HUGE;\n  //             } else {\n  //                 f = ((n - j + 1) % 2 === 1) ? n - j + 1  : 1;\n  //                 e[j - 1] = aux1 + f / diff;\n  //             }\n  //         }\n  //         estlim = e[n % 2];\n  //     }\n  //     return estlim;\n  // },\n\n  /**\n   * Aitken transformation. Ported from the FORTRAN version in\n   * Ernst Joachim Weniger, \"Nonlinear sequence transformations for the acceleration of convergence\n   * and the summation of divergent series\", Computer Physics Reports Vol. 10, 189-371 (1989).\n   *\n   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n   * @param {Number} n index of s_n in the sequence\n   * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.\n   * @returns {Number} New estimate of the limit of the sequence.\n   *\n   * @memberof JXG.Math.Extrapolate\n   */\n  aitken: function (s_n, n, a) {\n    var estlim,\n        HUGE = 1e20,\n        TINY = 1e-15,\n        denom,\n        v,\n        lowmax,\n        j,\n        m;\n    a[n] = s_n;\n\n    if (n < 2) {\n      estlim = s_n;\n    } else {\n      lowmax = n / 2;\n\n      for (j = 1; j <= lowmax; j++) {\n        m = n - 2 * j;\n        denom = a[m + 2] - 2 * a[m + 1] + a[m];\n\n        if (Math.abs(denom) < TINY) {\n          a[m] = HUGE;\n        } else {\n          v = a[m] - a[m + 1];\n          a[m] -= v * v / denom;\n        }\n      }\n\n      estlim = a[n % 2];\n    }\n\n    return estlim;\n  },\n\n  /**\n   * Iterated Brezinski transformation. Ported from the FORTRAN version in\n   * Ernst Joachim Weniger, \"Nonlinear sequence transformations for the acceleration of convergence\n   * and the summation of divergent series\", Computer Physics Reports Vol. 10, 189-371 (1989).\n   *\n   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n   * @param {Number} n index of s_n in the sequence\n   * @param {Array} a One-dimensional array containing the extrapolation data. Has to be supplied by the calling routine.\n   * @returns {Number} New estimate of the limit of the sequence.\n   *\n   * @memberof JXG.Math.Extrapolate\n   */\n  brezinski: function (s_n, n, a) {\n    var estlim,\n        HUGE = 1e20,\n        TINY = 1e-15,\n        denom,\n        d0,\n        d1,\n        d2,\n        lowmax,\n        j,\n        m;\n    a[n] = s_n;\n\n    if (n < 3) {\n      estlim = s_n;\n    } else {\n      lowmax = n / 3;\n      m = n;\n\n      for (j = 1; j <= lowmax; j++) {\n        m -= 3;\n        d0 = a[m + 1] - a[m];\n        d1 = a[m + 2] - a[m + 1];\n        d2 = a[m + 3] - a[m + 2];\n        denom = d2 * (d1 - d0) - d0 * (d2 - d1);\n\n        if (Math.abs(denom) < TINY) {\n          a[m] = HUGE;\n        } else {\n          a[m] = a[m + 1] - d0 * d1 * (d2 - d1) / denom;\n        }\n      }\n\n      estlim = a[n % 3];\n    }\n\n    return estlim;\n  },\n\n  /**\n   * Extrapolated iteration to approximate the value f(x_0).\n   *\n   * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.\n   * @param {Number} h0 Initial (signed) distance from x0.\n   * @param {Function} f Function for which the limit at x0 is to be determined\n   * @param {String} method String to choose the method. Available values: \"wynnEps\", \"aitken\", \"brezinski\"\n   * @param {Number} step_type Approximation method. step_type = 0 uses the sequence x0 + h0/n; step_type = 1 uses the sequence x0 + h0 * 2^(-n)\n   *\n   * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.\n   * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).\n   *\n   * @memberof JXG.Math.Extrapolate\n   * @see JXG.Math.Extrapolate.limit\n   * @see JXG.Math.Extrapolate.wynnEps\n   * @see JXG.Math.Extrapolate.aitken\n   * @see JXG.Math.Extrapolate.brezinski\n   */\n  iteration: function (x0, h0, f, method, step_type) {\n    var n,\n        v,\n        w,\n        estlim = NaN,\n        diff,\n        r = 0.5,\n        E = [],\n        result = \"finite\",\n        h = h0;\n    step_type = step_type || 0;\n\n    for (n = 1; n <= this.upper; n++) {\n      h = step_type === 0 ? h0 / (n + 1) : h * r;\n      v = f(x0 + h, true);\n      w = this[method](v, n - 1, E); //console.log(n, x0 + h, v, w);\n\n      if (isNaN(w)) {\n        result = \"NaN\";\n        break;\n      }\n\n      if (v !== 0 && w / v > this.infty) {\n        estlim = w;\n        result = \"infinite\";\n        break;\n      }\n\n      diff = w - estlim;\n\n      if (Math.abs(diff) < 1e-7) {\n        break;\n      }\n\n      estlim = w;\n    }\n\n    return [estlim, result, 1 - (n - 1) / this.upper];\n  },\n\n  /**\n   * Levin transformation. See Numerical Recipes, ed. 3.\n   * Not yet ready for use.\n   *\n   * @param {Number} s_n next value of sequence, i.e. n-th element of sequence\n   * @param {Number} n index of s_n in the sequence\n   * @param {Array} numer One-dimensional array containing the extrapolation data for the numerator. Has to be supplied by the calling routine.\n   * @param {Array} denom One-dimensional array containing the extrapolation data for the denominator. Has to be supplied by the calling routine.\n   *\n   * @memberof JXG.Math.Extrapolate\n   */\n  levin: function (s_n, n, omega, beta, numer, denom) {\n    var HUGE = 1e20,\n        TINY = 1e-15,\n        j,\n        fact,\n        ratio,\n        term,\n        estlim;\n    term = 1.0 / (beta + n);\n    numer[n] = s_n / omega;\n    denom[n] = 1 / omega;\n\n    if (n > 0) {\n      numer[n - 1] = numer[n] - numer[n - 1];\n      denom[n - 1] = denom[n] - denom[n - 1];\n\n      if (n > 1) {\n        ratio = (beta + n - 1) * term;\n\n        for (j = 2; j <= n; j++) {\n          fact = (beta + n - j) * Math.pow(ratio, j - 2) * term;\n          numer[n - j] = numer[n - j + 1] - fact * numer[n - j];\n          denom[n - j] = denom[n - j + 1] - fact * denom[n - j];\n          term *= ratio;\n        }\n      }\n    }\n\n    if (Math.abs(denom[0]) < TINY) {\n      estlim = HUGE;\n    } else {\n      estlim = numer[0] / denom[0];\n    }\n\n    return estlim;\n  },\n  iteration_levin: function (x0, h0, f, step_type) {\n    var n,\n        v,\n        w,\n        estlim = NaN,\n        v_prev,\n        delta,\n        diff,\n        omega,\n        beta = 1,\n        r = 0.5,\n        numer = [],\n        denom = [],\n        result = \"finite\",\n        h = h0,\n        transform = \"u\";\n    step_type = step_type || 0;\n    v_prev = f(x0 + h0, true);\n\n    for (n = 1; n <= this.upper; n++) {\n      h = step_type === 0 ? h0 / (n + 1) : h * r;\n      v = f(x0 + h, true);\n      delta = v - v_prev;\n\n      if (Math.abs(delta) < 1) {\n        transform = \"u\";\n      } else {\n        transform = \"t\";\n      }\n\n      if (transform === \"u\") {\n        omega = (beta + n) * delta; // u transformation\n      } else {\n        omega = delta; // t transformation\n      }\n\n      v_prev = v;\n      w = this.levin(v, n - 1, omega, beta, numer, denom);\n      diff = w - estlim; // console.log(n, delta, transform, x0 + h, v, w, diff);\n\n      if (isNaN(w)) {\n        result = \"NaN\";\n        break;\n      }\n\n      if (v !== 0 && w / v > this.infty) {\n        estlim = w;\n        result = \"infinite\";\n        break;\n      }\n\n      if (Math.abs(diff) < 1e-7) {\n        break;\n      }\n\n      estlim = w;\n    }\n\n    return [estlim, result, 1 - (n - 1) / this.upper];\n  },\n\n  /**\n   *\n   * @param {Number} x0 Value for which the limit of f is to be determined. f(x0) may or may not exist.\n   * @param {Number} h0 Initial (signed) distance from x0.\n   * @param {Function} f Function for which the limit at x0 is to be determined\n   *\n   * @returns {Array} Array of length 3. Position 0: estimated value for f(x0), position 1: 'finite', 'infinite', or 'NaN'.\n   * Position 2: value between 0 and 1 judging the reliability of the result (1: high, 0: not successful).\n   * In case that the extrapolation fails, position 1 and 2 contain 'direct' and 0.\n   *\n   * @example\n   * var f1 = (x) => Math.log(x),\n   *     f2 = (x) => Math.tan(x - Math.PI * 0.5),\n   *     f3 = (x) => 4 / x;\n   *\n   * var x0 = 0.0000001;\n   * var h = 0.1;\n   * for (let f of [f1, f2, f3]) {\n   *     console.log(\"x0=\", x0, f.toString());\n   *     console.log(JXG.Math.Extrapolate.limit(x0, h, f));\n   *  }\n   *\n   * </pre><div id=\"JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab\" class=\"jxgbox\" style=\"width: 300px; height: 300px;\"></div>\n   * <script type=\"text/javascript\">\n   *     (function() {\n   *         var board = JXG.JSXGraph.initBoard('JXG5e8c6a7e-eeae-43fb-a669-26b5c9e40cab',\n   *             {boundingbox: [-8, 8, 8,-8], axis: true, showcopyright: false, shownavigation: false});\n   *     var f1 = (x) => Math.log(x),\n   *         f2 = (x) => Math.tan(x - Math.PI * 0.5),\n   *         f3 = (x) => 4 / x;\n   *\n   *     var x0 = 0.0000001;\n   *     var h = 0.1;\n   *     for (let f of [f1, f2, f3]) {\n   *         console.log(\"x0=\", x0, f.toString());\n   *         console.log(JXG.Math.Extrapolate.limit(x0, h, f));\n   *      }\n   *\n   *     })();\n   *\n   * \u003c/script><pre>\n   *\n   *\n   * @see JXG.Math.Extrapolate.iteration\n   * @memberof JXG.Math.Extrapolate\n   */\n  limit: function (x0, h0, f) {\n    return this.iteration_levin(x0, h0, f, 0); //return this.iteration(x0, h0, f, 'wynnEps', 1);\n    // var algs = ['wynnEps', 'levin'], //, 'wynnEps', 'levin', 'aitken', 'brezinski'],\n    //     le = algs.length,\n    //     i, t, res;\n    // for (i = 0; i < le; i++) {\n    //     for (t = 0; t < 1; t++) {\n    //         if (algs[i] === 'levin') {\n    //             res = this.iteration_levin(x0, h0, f, t);\n    //         } else {\n    //             res = this.iteration(x0, h0, f, algs[i], t);\n    //         }\n    //         if (res[2] > 0.6) {\n    //             return res;\n    //         }\n    //         console.log(algs[i], t, res)\n    //     }\n    // }\n    // return [f(x0 + Math.sign(h0) * Math.sqrt(Mat.eps)), 'direct', 0];\n  }\n};\nvar _default = _math.default.Extrapolate;\nexports.default = _default;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","default","_math","_interopRequireDefault","obj","__esModule","Extrapolate","upper","infty","wynnEps","s_n","n","e","estlim","aux2","j","aux1","diff","TINY","Math","abs","HUGE","f0","aitken","a","lowmax","m","denom","v","brezinski","d0","d1","d2","iteration","x0","h0","f","method","step_type","NaN","E","result","h","r","w","isNaN","levin","omega","beta","numer","term","ratio","fact","pow","iteration_levin","v_prev","delta","transform","limit"]
}
